<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="robots" content="noodp" />
    <title class="pjax-title">《C&#43;&#43;Primer》| 第十四章 重载运算与类型转换 - </title><meta name="Description" content=""><meta property="og:title" content="《C&#43;&#43;Primer》| 第十四章 重载运算与类型转换" />
<meta property="og:description" content="第14章 重载运算与类型转换14.1 基本概念重载的运算符是具有特殊名字的函数：它们的名字由关键字 operator 和其后要定义的运算符号共同组成。和其他函数一" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://blog.silasblog.top/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" /><meta property="og:image" content="https://blog.silasblog.top/logo.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-25T09:14:08+08:00" />
<meta property="article:modified_time" content="2022-04-25T10:55:21+08:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://blog.silasblog.top/logo.png"/>

<meta name="twitter:title" content="《C&#43;&#43;Primer》| 第十四章 重载运算与类型转换"/>
<meta name="twitter:description" content="第14章 重载运算与类型转换14.1 基本概念重载的运算符是具有特殊名字的函数：它们的名字由关键字 operator 和其后要定义的运算符号共同组成。和其他函数一"/>
<meta name="application-name" content="">
<meta name="apple-mobile-web-app-title" content="">

<meta name="theme-color" content="#f8f8f8"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="canonical" href="https://blog.silasblog.top/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" /><link rel="prev" href="https://blog.silasblog.top/133.%E5%85%8B%E9%9A%86%E5%9B%BE/" /><link rel="next" href="https://blog.silasblog.top/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" /><link rel="stylesheet" href="/lib/normalize/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="/lib/fontawesome-free/all.min.css">
        <noscript><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"></noscript><link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="/lib/animate/animate.min.css">
        <noscript><link rel="stylesheet" href="/lib/animate/animate.min.css"></noscript><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "《C++Primer》| 第十四章 重载运算与类型转换",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/blog.silasblog.top\/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2\/"
        },"genre": "posts","keywords": "C\u002b\u002b","wordcount":  6885 ,
        "url": "https:\/\/blog.silasblog.top\/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2\/","datePublished": "2022-04-25T09:14:08+08:00","dateModified": "2022-04-25T10:55:21+08:00","publisher": {
            "@type": "Organization",
            "name": ""},"author": {
                "@type": "Person",
                "name": "Silas"
            },"description": ""
    }
    </script></head>

<body header-desktop="normal" header-mobile="auto"><script type="text/javascript">
        function setTheme(theme) {document.body.setAttribute('theme', theme); document.documentElement.style.setProperty('color-scheme', theme === 'light' ? 'light' : 'dark');}
        function saveTheme(theme) {window.localStorage && localStorage.setItem('theme', theme);}
        function getMeta(metaName) {const metas = document.getElementsByTagName('meta'); for (let i = 0; i < metas.length; i++) if (metas[i].getAttribute('name') === metaName) return metas[i]; return '';}
        if (window.localStorage && localStorage.getItem('theme')) {let theme = localStorage.getItem('theme');theme === 'light' || theme === 'dark' || theme === 'black' ? setTheme(theme) : (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? setTheme('dark') : setTheme('light')); } else { if ('' === 'light' || '' === 'dark' || '' === 'black') setTheme(''), saveTheme(''); else saveTheme('auto'), window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? setTheme('dark') : setTheme('light');}
        let metaColors = {'light': '#f8f8f8','dark': '#252627','black': '#000000'}
        getMeta('theme-color').content = metaColors[document.body.getAttribute('theme')];
    </script>
    <div id="back-to-top"></div>
    <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title=""><span id="desktop-header-typeit" class="typeit"></span></a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 文章 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><a class="menu-item" href="/series/"> 系列 </a><a class="menu-item" href="/about/"> 关于 </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-desktop">
                        <a href="#" onclick="return false;" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="#" onclick="return false;" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </span><a href="#" onclick="return false;" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a></div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title=""><span id="mobile-header-typeit" class="typeit"></span></a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-mobile">
                        <a href="#" onclick="return false;" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="#" onclick="return false;" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </div>
                    <a href="#" onclick="return false;" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/posts/" title="">文章</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><a class="menu-item" href="/series/" title="">系列</a><a class="menu-item" href="/about/" title="">关于</a><a href="#" onclick="return false;" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
            <div class="container"><div class="toc" id="toc-auto">
        <h2 class="toc-title">目录</h2>
        <div class="toc-content" id="toc-content-auto"><nav id="TableOfContents">
  <ul>
    <li><a href="#141-基本概念">14.1 基本概念</a>
      <ul>
        <li>
          <ul>
            <li><a href="#重载运算符的几种调用形式">重载运算符的几种调用形式：</a></li>
            <li><a href="#某些运算符不应该被重载">某些运算符不应该被重载</a></li>
            <li><a href="#使用内置类型一致的含义">使用内置类型一致的含义</a></li>
            <li><a href="#选择作为成员或者非成员">选择作为成员或者非成员</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#142-输入输出运算符">14.2 输入输出运算符</a>
      <ul>
        <li><a href="#1421-重载输出运算符">14.2.1 重载输出运算符&laquo;</a>
          <ul>
            <li><a href="#输入输出运算符必须是非成员函数">输入输出运算符必须是非成员函数</a></li>
          </ul>
        </li>
        <li><a href="#1422-重载输入运算符">14.2.2 重载输入运算符&raquo;</a>
          <ul>
            <li><a href="#输入时的错误">输入时的错误</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#143-算术和关系运算符">14.3 算术和关系运算符</a>
      <ul>
        <li><a href="#1431-相等运算符">14.3.1 相等运算符</a></li>
        <li><a href="#1432-关系运算符">14.3.2 关系运算符</a></li>
      </ul>
    </li>
    <li><a href="#144-赋值运算符">14.4 赋值运算符</a>
      <ul>
        <li>
          <ul>
            <li><a href="#复合赋值运算符">复合赋值运算符</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#145-下标运算符">14.5 下标运算符</a></li>
    <li><a href="#146递增和递减运算符">14.6递增和递减运算符</a>
      <ul>
        <li>
          <ul>
            <li><a href="#定义前置递增递减运算符">定义前置递增/递减运算符</a></li>
            <li><a href="#区分前置和后置运算符">区分前置和后置运算符</a></li>
            <li><a href="#显示调用后置运算符">显示调用后置运算符</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#147-成员访问运算符">14.7 成员访问运算符</a>
      <ul>
        <li>
          <ul>
            <li><a href="#对箭头运算符返回值的限定">对箭头运算符返回值的限定</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#148-函数调用运算符">14.8 函数调用运算符</a>
      <ul>
        <li>
          <ul>
            <li><a href="#含有状态的函数对象类">含有状态的函数对象类</a></li>
          </ul>
        </li>
        <li><a href="#1481-lambda-是函数对象">14.8.1 lambda 是函数对象</a>
          <ul>
            <li><a href="#表示-lambda-及相应捕获行为的类">表示 lambda 及相应捕获行为的类</a></li>
          </ul>
        </li>
        <li><a href="#1482-标准库定义的函数对象">14.8.2 标准库定义的函数对象</a>
          <ul>
            <li><a href="#算法中使用标准库函数对象">算法中使用标准库函数对象</a></li>
          </ul>
        </li>
        <li><a href="#1483-可调用对象与-function">14.8.3 可调用对象与 function</a>
          <ul>
            <li><a href="#标准库-function-类型">标准库 function 类型</a></li>
            <li><a href="#重载的函数与-function">重载的函数与 function</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#149-重载类型转换和运算符">14.9 重载、类型转换和运算符</a></li>
  </ul>
</nav></div>
    </div><script>document.getElementsByTagName("main")[0].setAttribute("pageStyle", "wide")</script><script>document.getElementsByTagName("main")[0].setAttribute("autoTOC", "true")</script><article class="page single"><h1 class="single-title animate__animated animate__flipInX">《C&#43;&#43;Primer》| 第十四章 重载运算与类型转换</h1><div class="post-meta">
            <div class="post-meta-line">
                <span class="post-author"><i class="author fas fa-user-circle fa-fw"></i><a href="/" title="Author" rel=" author" class="author">Silas</a>
                </span>&nbsp;<span class="post-category">收录于 </span>&nbsp;<span class="post-category">类别 <a href="/categories/c++/"><i class="far fa-folder fa-fw"></i>C++</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2022-04-25">2022-04-25</time>&nbsp;<i class="far fa-edit fa-fw"></i>&nbsp;<time datetime="2022-04-25">2022-04-25</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 6885 字&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 14 分钟&nbsp;</div>
        </div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#141-基本概念">14.1 基本概念</a>
      <ul>
        <li>
          <ul>
            <li><a href="#重载运算符的几种调用形式">重载运算符的几种调用形式：</a></li>
            <li><a href="#某些运算符不应该被重载">某些运算符不应该被重载</a></li>
            <li><a href="#使用内置类型一致的含义">使用内置类型一致的含义</a></li>
            <li><a href="#选择作为成员或者非成员">选择作为成员或者非成员</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#142-输入输出运算符">14.2 输入输出运算符</a>
      <ul>
        <li><a href="#1421-重载输出运算符">14.2.1 重载输出运算符&laquo;</a>
          <ul>
            <li><a href="#输入输出运算符必须是非成员函数">输入输出运算符必须是非成员函数</a></li>
          </ul>
        </li>
        <li><a href="#1422-重载输入运算符">14.2.2 重载输入运算符&raquo;</a>
          <ul>
            <li><a href="#输入时的错误">输入时的错误</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#143-算术和关系运算符">14.3 算术和关系运算符</a>
      <ul>
        <li><a href="#1431-相等运算符">14.3.1 相等运算符</a></li>
        <li><a href="#1432-关系运算符">14.3.2 关系运算符</a></li>
      </ul>
    </li>
    <li><a href="#144-赋值运算符">14.4 赋值运算符</a>
      <ul>
        <li>
          <ul>
            <li><a href="#复合赋值运算符">复合赋值运算符</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#145-下标运算符">14.5 下标运算符</a></li>
    <li><a href="#146递增和递减运算符">14.6递增和递减运算符</a>
      <ul>
        <li>
          <ul>
            <li><a href="#定义前置递增递减运算符">定义前置递增/递减运算符</a></li>
            <li><a href="#区分前置和后置运算符">区分前置和后置运算符</a></li>
            <li><a href="#显示调用后置运算符">显示调用后置运算符</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#147-成员访问运算符">14.7 成员访问运算符</a>
      <ul>
        <li>
          <ul>
            <li><a href="#对箭头运算符返回值的限定">对箭头运算符返回值的限定</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#148-函数调用运算符">14.8 函数调用运算符</a>
      <ul>
        <li>
          <ul>
            <li><a href="#含有状态的函数对象类">含有状态的函数对象类</a></li>
          </ul>
        </li>
        <li><a href="#1481-lambda-是函数对象">14.8.1 lambda 是函数对象</a>
          <ul>
            <li><a href="#表示-lambda-及相应捕获行为的类">表示 lambda 及相应捕获行为的类</a></li>
          </ul>
        </li>
        <li><a href="#1482-标准库定义的函数对象">14.8.2 标准库定义的函数对象</a>
          <ul>
            <li><a href="#算法中使用标准库函数对象">算法中使用标准库函数对象</a></li>
          </ul>
        </li>
        <li><a href="#1483-可调用对象与-function">14.8.3 可调用对象与 function</a>
          <ul>
            <li><a href="#标准库-function-类型">标准库 function 类型</a></li>
            <li><a href="#重载的函数与-function">重载的函数与 function</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#149-重载类型转换和运算符">14.9 重载、类型转换和运算符</a></li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h1 id="第14章-重载运算与类型转换" class="headerLink">
    <a href="#%e7%ac%ac14%e7%ab%a0-%e9%87%8d%e8%bd%bd%e8%bf%90%e7%ae%97%e4%b8%8e%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2" class="header-mark"></a>第14章 重载运算与类型转换</h1><h2 id="141-基本概念" class="headerLink">
    <a href="#141-%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5" class="header-mark"></a>14.1 基本概念</h2><p>重载的运算符是具有特殊名字的函数：它们的名字由<strong>关键字 operator</strong> 和其后要定义的<strong>运算符号</strong>共同组成。和其他函数一样，重载的运算符也包含返回类型、参数列表以及函数体。</p>
<ul>
<li>重载运算符函数的参数数量与该作用的运算对象数量一样多，一元运算符有一个参数，二元运算符有两个参数；</li>
<li>二元运算符左侧运算对象传递给第一个参数，右侧对象传递给第二个对象</li>
<li>除了 operator() 外，其他重载运算符不能含有默认实参</li>
<li>如果一个重载运算符是类的成员函数时，this 会绑定到左侧运算对象，参数数量会比运算对象少一个</li>
</ul>
<p>重载运算符函数只能是一个类的成员，或者至少有一个类类型的参数，不能对内置类型定义重载运算符</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span><span class="c1">//错误，不能重定义int的运算符
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>以下是可以重载或者不能重载的运算符：
<img
        class="lazyload"
        data-src="https://silas-py-oss.oss-cn-chengdu.aliyuncs.com/img/20220425151917.png"
        data-srcset="https://silas-py-oss.oss-cn-chengdu.aliyuncs.com/img/20220425151917.png, https://silas-py-oss.oss-cn-chengdu.aliyuncs.com/img/20220425151917.png 1.5x, https://silas-py-oss.oss-cn-chengdu.aliyuncs.com/img/20220425151917.png 2x"
        data-sizes="auto"
        alt="https://silas-py-oss.oss-cn-chengdu.aliyuncs.com/img/20220425151917.png"
        title="https://silas-py-oss.oss-cn-chengdu.aliyuncs.com/img/20220425151917.png"></p>
<h4 id="重载运算符的几种调用形式" class="headerLink">
    <a href="#%e9%87%8d%e8%bd%bd%e8%bf%90%e7%ae%97%e7%ac%a6%e7%9a%84%e5%87%a0%e7%a7%8d%e8%b0%83%e7%94%a8%e5%bd%a2%e5%bc%8f" class="header-mark"></a>重载运算符的几种调用形式：</h4><ol>
<li>可以间接的用运算符调用重载的运算符函数</li>
<li>也可以像普通函数那样直接调用</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">//一个非成员运算符函数的等价调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">data1</span> <span class="o">+</span> <span class="n">data2</span><span class="p">;</span>           <span class="c1">//普通表达式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="n">data2</span><span class="p">);</span> <span class="c1">//等价的函数调用
</span></span></span></code></pre></td></tr></table>
</div>
</div><ol start="3">
<li>也可以像调用其他成员函数一样显示的调用成员运算符</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">data1</span> <span class="o">+=</span> <span class="n">data2</span><span class="p">;</span>         <span class="c1">//基于调用的表达式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">data1</span><span class="p">.</span><span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="n">data2</span><span class="p">);</span> <span class="c1">//对成员运算符函数的等价调用
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="某些运算符不应该被重载" class="headerLink">
    <a href="#%e6%9f%90%e4%ba%9b%e8%bf%90%e7%ae%97%e7%ac%a6%e4%b8%8d%e5%ba%94%e8%af%a5%e8%a2%ab%e9%87%8d%e8%bd%bd" class="header-mark"></a>某些运算符不应该被重载</h4><ul>
<li>
<p>某些运算符会指定运算对象的求值顺序，而关于这些运算对象求值顺序的规则无法应用到重载的运算符上</p>
</li>
<li>
<p>像逻辑与运算符、逻辑或运算符、逗号运算符的运算对象求值顺序无法保留下来，而 &amp;&amp; 和 || 短路求值属性也无法保留</p>
</li>
<li>
<p>对于逗号和取地址运算符，用于类类型对象时已经定义了特殊的含义，所以不应该被重载</p>
</li>
</ul>
<h4 id="使用内置类型一致的含义" class="headerLink">
    <a href="#%e4%bd%bf%e7%94%a8%e5%86%85%e7%bd%ae%e7%b1%bb%e5%9e%8b%e4%b8%80%e8%87%b4%e7%9a%84%e5%90%ab%e4%b9%89" class="header-mark"></a>使用内置类型一致的含义</h4><p>设计一个类时，要考虑这个类提供哪些操作，然后再考虑这些操作设为普通函数还是重载的运算符。如果某些类逻辑上和运算符相关，它们适合定义成重载的运算符</p>
<ul>
<li>如果类执行 IO 操作，定义移位运算符和内置类型的 IO 保存一致</li>
<li>类检查相等性操作，定义 <code>operator=</code>，同时也应该定义 <code>operator!=</code></li>
<li>如果类有比较操作，例如 <code>operator&lt;</code>，也该也定义其他关系的操作</li>
<li>返回类型通常情况下要和内置返回类型兼容：
<ul>
<li>逻辑和关系运算符应该返回 bool</li>
<li>算术运算符应该返回类类型的值</li>
<li>赋值和复合运算符应该返回左侧对象的引用</li>
</ul>
</li>
</ul>
<h4 id="选择作为成员或者非成员" class="headerLink">
    <a href="#%e9%80%89%e6%8b%a9%e4%bd%9c%e4%b8%ba%e6%88%90%e5%91%98%e6%88%96%e8%80%85%e9%9d%9e%e6%88%90%e5%91%98" class="header-mark"></a>选择作为成员或者非成员</h4><p>定义重载运算符时，首先要觉得声明为类的成员函数，还是一个普通的非成员函数，下面准则可以帮助判断：</p>
<ol>
<li>赋值（=），下标（[]），调用（()）和成员访问箭头（-&gt;）必须时成员</li>
<li>复合类型一般为成员，但非必须</li>
<li>改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减、解引用通常为成员</li>
<li>具有对称性的运算符可以转换任意一端的运算对象，如算术、相等性、关系和位运算，通常位普通的非成员函数</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="s">&#34;world&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">string</span> <span class="n">t</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="s">&#34;!&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">string</span> <span class="n">u</span> <span class="o">=</span>  <span class="s">&#34;hi &#34;</span> <span class="o">+</span> <span class="n">s</span><span class="p">;</span><span class="c1">//如果+是string成员函数，这里会报错
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>实际上，string 将 + 定义为了普通成员函数，<code>&quot;hi &quot; + s</code> 等价于 <code>operator+=(&quot;hi &quot;, s)</code>，就没有出现问题</p>
<h2 id="142-输入输出运算符" class="headerLink">
    <a href="#142-%e8%be%93%e5%85%a5%e8%be%93%e5%87%ba%e8%bf%90%e7%ae%97%e7%ac%a6" class="header-mark"></a>14.2 输入输出运算符</h2><h3 id="1421-重载输出运算符" class="headerLink">
    <a href="#1421-%e9%87%8d%e8%bd%bd%e8%be%93%e5%87%ba%e8%bf%90%e7%ae%97%e7%ac%a6" class="header-mark"></a>14.2.1 重载输出运算符&laquo;</h3><p>通常情况下，输出运算符第一个形参是一个非常量 ostream 对象的引用，非常量是因为像流写入内容会改变其状态，引用类型是因为无法直接复制一个 ostream 对象（注：拷贝构造函数为 delete）</p>
<p>第二个形参是一个常量的引用，这个常量是需要打印出来的类类型，引用为了避免复制，常量是因为打印不会改变对象的内容</p>
<p>举个例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">ostream</span> <span class="o">&amp;</span><span class="k">operator</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">Sales_data</span> <span class="o">&amp;</span><span class="n">item</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">item</span><span class="p">.</span><span class="n">isbn</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">item</span><span class="p">.</span><span class="n">units_sold</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span>
</span></span><span class="line"><span class="cl">	   <span class="o">&lt;&lt;</span> <span class="n">item</span><span class="p">.</span><span class="n">revenue</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">item</span><span class="p">.</span><span class="n">avg_price</span><span class="p">();</span><span class="c1">//末尾不需要再加换行符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">return</span> <span class="n">os</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>通常输出运算符主要负责打印对象内容而不是控制格式，所以一般不打印换行符</p>
</blockquote>
<h4 id="输入输出运算符必须是非成员函数" class="headerLink">
    <a href="#%e8%be%93%e5%85%a5%e8%be%93%e5%87%ba%e8%bf%90%e7%ae%97%e7%ac%a6%e5%bf%85%e9%a1%bb%e6%98%af%e9%9d%9e%e6%88%90%e5%91%98%e5%87%bd%e6%95%b0" class="header-mark"></a>输入输出运算符必须是非成员函数</h4><p>输入输出函数必须为非成员函数，不能是类成员函数，否则左侧运算对象将是类的一个对象</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">Sales_data</span> <span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">data</span> <span class="o">&lt;&lt;</span> <span class="n">cout</span><span class="p">;</span>     <span class="c1">//如果opeator&lt;&lt;是Sales_data的对象
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果输入输出运算符是Sales_data 的成员，它们也必须为 istream 或 ostream 的成员，当然我们不能为标准库定义成员</p>
<blockquote>
<p>注：其实这里感觉没看懂，如果像书上写的这样，data &laquo; cout 感觉是不是也可以输出？我自己也试了代码，确实可以输出，就是看着有点怪，要是深究起来，感觉书上写的话不够严谨</p>
</blockquote>
<h3 id="1422-重载输入运算符" class="headerLink">
    <a href="#1422-%e9%87%8d%e8%bd%bd%e8%be%93%e5%85%a5%e8%bf%90%e7%ae%97%e7%ac%a6" class="header-mark"></a>14.2.2 重载输入运算符&raquo;</h3><p>输入运算符第一个形参是读取流的引用，第二个形参是读入到对象的引用</p>
<p>例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">istream</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">istream</span> <span class="o">&amp;</span><span class="n">is</span><span class="p">,</span> <span class="n">Sales_data</span> <span class="o">&amp;</span><span class="n">item</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">double</span> <span class="n">price</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">is</span> <span class="o">&gt;&gt;</span> <span class="n">item</span><span class="p">.</span><span class="n">bookNo</span> <span class="o">&gt;&gt;</span> <span class="n">item</span><span class="p">.</span><span class="n">untis_sold</span> <span class="o">&gt;&gt;</span> <span class="n">price</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">is</span><span class="p">)</span> <span class="p">{</span><span class="c1">//检查是否输入成功
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">item</span><span class="p">.</span><span class="n">revenue</span> <span class="o">=</span> <span class="n">item</span><span class="p">.</span><span class="n">units_sold</span> <span class="o">*</span> <span class="n">price</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">item</span> <span class="o">=</span> <span class="n">Sales_data</span><span class="p">();</span><span class="c1">//输入失败，对象初始为默认情况
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">is</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="输入时的错误" class="headerLink">
    <a href="#%e8%be%93%e5%85%a5%e6%97%b6%e7%9a%84%e9%94%99%e8%af%af" class="header-mark"></a>输入时的错误</h4><p>执行输入运算符时可能发生以下错误：</p>
<ol>
<li>当流读取到错误类型的数据，后续操作都会失败</li>
<li>当读取操作未达到文件末尾或者遇到输入流其他错误时也会失败</li>
</ol>
<p>所以使用输入操作符时，需要判断是否有错误的情况发生，因为如果出现错误的情况可能发生在中间，这样的话前面的成员时正确的，而发生读取错误的地方后面的成员就和前面不匹配了</p>
<h2 id="143-算术和关系运算符" class="headerLink">
    <a href="#143-%e7%ae%97%e6%9c%af%e5%92%8c%e5%85%b3%e7%b3%bb%e8%bf%90%e7%ae%97%e7%ac%a6" class="header-mark"></a>14.3 算术和关系运算符</h2><p>通常情况下，算术和关系运算符定义为非成员函数允许左侧和右侧运算对象进行转换，形参都是常量的引用</p>
<p>算术运算符通常会计算两个对象并得到一个新值，这个值区别于任何一个运算对象，常常位于一个局部变量中，返回值应该为局部变量的副本作为结果，通常也会定义复合赋值运算符</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">Book</span>
</span></span><span class="line"><span class="cl"><span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">Book</span> <span class="o">&amp;</span><span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Book</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">Book</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">lhs</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">	<span class="n">sum</span> <span class="o">+=</span> <span class="n">rhs</span><span class="p">;</span>     <span class="c1">//复合赋值运算符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="1431-相等运算符" class="headerLink">
    <a href="#1431-%e7%9b%b8%e7%ad%89%e8%bf%90%e7%ae%97%e7%ac%a6" class="header-mark"></a>14.3.1 相等运算符</h3><p>一般情况下只有当两个对象每一个数据成员都相等时，才认为他们时相等的</p>
<p>下面是个具体例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">Book</span> <span class="o">&amp;</span><span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Book</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">lhs</span><span class="p">.</span><span class="n">price</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">.</span><span class="n">price</span> <span class="o">&amp;&amp;</span> <span class="n">lhs</span><span class="p">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">Book</span> <span class="o">&amp;</span><span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Book</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="n">lhs</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>设计相等运算符函数基本准则如下：</p>
<ol>
<li>设计一个类判断两个对象是否相等的操作时，通常定义为 operator== 而非其他的像（equl等等）普通的命名函数</li>
<li>如果类定义了 operator== ，则该运算符应该能判断一组给定对象是否含义重复数据</li>
<li>相等运算符应该具有传递性，如 a == b 和 b == c 都为真，那么 a == c 也为真</li>
<li>定义了 operator== 通常也要定义 operator!=</li>
<li>相等和不相等运算符，通常具体写一个即可，另一个进行调用即可</li>
</ol>
<h3 id="1432-关系运算符" class="headerLink">
    <a href="#1432-%e5%85%b3%e7%b3%bb%e8%bf%90%e7%ae%97%e7%ac%a6" class="header-mark"></a>14.3.2 关系运算符</h3><p>对于关联容器和一些算法会用到小于运算符，此时可以定义 operator&lt;</p>
<p>但是一般情况下，关系运算符可能没有那么有必要，比如说上面的 Book 类，如果说定义小于关系的，具体内容如何比较，是先根据书名然后根据价格进行比较？还是说仅仅根据书名比较</p>
<p>一般情况下，对于不相等的对象，一个对象应该小于另一个对象，这样的话，定义关系运算符的时候，逻辑上就不是很清楚了</p>
<blockquote>
<p>如果存在唯一一种逻辑可靠的 &lt; 定义，应该考虑定义 &lt; 运算符，但是如果类还包括 == ，仅当&lt; 的定义和 == 结果一致时才定义 &lt; 运算符</p>
</blockquote>
<h2 id="144-赋值运算符" class="headerLink">
    <a href="#144-%e8%b5%8b%e5%80%bc%e8%bf%90%e7%ae%97%e7%ac%a6" class="header-mark"></a>14.4 赋值运算符</h2><p>13章时已经介绍过拷贝赋值和移动赋值运算符，它们把一个对象赋值给另一个对象。我们还可以定义其他的赋值运算符，以使用别的类型作为右侧对象</p>
<h4 id="复合赋值运算符" class="headerLink">
    <a href="#%e5%a4%8d%e5%90%88%e8%b5%8b%e5%80%bc%e8%bf%90%e7%ae%97%e7%ac%a6" class="header-mark"></a>复合赋值运算符</h4><p>通常把复合赋值运算符等赋值运算符都定义在类的内部，复合赋值运算符也应该返回左侧对象的引用</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">Book</span> <span class="o">&amp;</span><span class="n">Book</span><span class="o">::</span><span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="k">const</span> <span class="n">Book</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">price</span> <span class="o">+=</span> <span class="n">rhs</span><span class="p">.</span><span class="n">price</span><span class="p">;</span><span class="c1">//这里因为自己写的例子，语义上可能有些问题
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="145-下标运算符" class="headerLink">
    <a href="#145-%e4%b8%8b%e6%a0%87%e8%bf%90%e7%ae%97%e7%ac%a6" class="header-mark"></a>14.5 下标运算符</h2><p>下标运算符通常在一些容器中，可以让我们像访问数组那样的形式进行访问，一般会定义为 operator[]</p>
<ul>
<li>下标运算符必须时成员函数</li>
<li>通常返回值为访问元素的引用，确保下标可以出现在赋值运算符任意一端</li>
<li>如果一个类包含下标运算符，通常会定义两个版本：
<ul>
<li>一个返回普通引用</li>
<li>另一个是类的常量成员并且返回常量引用</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">StrVec</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">n</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">		<span class="p">{</span><span class="k">return</span> <span class="n">elements</span><span class="p">[</span><span class="n">n</span><span class="p">];}</span>
</span></span><span class="line"><span class="cl">	<span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span><span class="p">)</span> <span class="k">const</span> 
</span></span><span class="line"><span class="cl">		<span class="p">{</span><span class="k">return</span> <span class="n">elements</span><span class="p">[</span><span class="n">n</span><span class="p">];}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">*</span><span class="n">elements</span><span class="p">;</span><span class="c1">//指向数组首元素的指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>当 StrVec 是非常量时，可以给元素赋值</li>
<li>当对常量对象取小标时，不能为其赋值</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">const</span> <span class="n">StrVec</span> <span class="n">cvec</span> <span class="o">=</span> <span class="n">svec</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">svec</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">svec</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">svec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#34;zero&#34;</span><span class="p">;</span><span class="c1">//正确：下标运算符返回string的引用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">cvec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#34;zip&#34;</span><span class="p">;</span> <span class="c1">//错误：cvec取下标返回的为常量引用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="146递增和递减运算符" class="headerLink">
    <a href="#146%e9%80%92%e5%a2%9e%e5%92%8c%e9%80%92%e5%87%8f%e8%bf%90%e7%ae%97%e7%ac%a6" class="header-mark"></a>14.6递增和递减运算符</h2><p>一般迭代器类会实现递增运算符（++）和递减运算符（&ndash;），使得迭代器可以在元素序列中进行移动，因为它们改变了操作对象的状态，通常设为成员函数</p>
<blockquote>
<p>定义递增和递减运算符的类要同时定义前置版本和后置版本，且都为类的成员函数</p>
</blockquote>
<h4 id="定义前置递增递减运算符" class="headerLink">
    <a href="#%e5%ae%9a%e4%b9%89%e5%89%8d%e7%bd%ae%e9%80%92%e5%a2%9e%e9%80%92%e5%87%8f%e8%bf%90%e7%ae%97%e7%ac%a6" class="header-mark"></a>定义前置递增/递减运算符</h4><p>==为了和内置版本保持一致，前置运算符应该返回递增或递减后对象的引用==</p>
<p>递增和递减运算符工作机理：</p>
<ul>
<li>首先调用check 函数检查是否有效</li>
<li>如果有效，接着检查给定索引值是否有效</li>
<li>check 函数没有发生异常，返回运算对象的引用
下面时具体例子：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">StrBlobPtr</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> <span class="c1">//递增和递减运算符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">StrBlobPtr</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">++</span><span class="p">();</span><span class="c1">//前置版本
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">StrBlobPtr</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">--</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//其他成员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">StrBlobPtr</span><span class="o">&amp;</span> <span class="n">StrBlobPtr</span><span class="o">::</span><span class="k">operator</span><span class="o">++</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">check</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="s">&#34;已经越界&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="o">++</span><span class="n">curr</span><span class="p">;</span>   <span class="c1">//curr向前移动一个元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">StrBlobPtr</span><span class="o">&amp;</span> <span class="n">StrBlobPtr</span><span class="o">::</span><span class="k">operator</span><span class="o">--</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="o">--</span><span class="n">curr</span><span class="p">;</span>   <span class="c1">//curr向后移动一个元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">check</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="s">&#34;已经越界&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="区分前置和后置运算符" class="headerLink">
    <a href="#%e5%8c%ba%e5%88%86%e5%89%8d%e7%bd%ae%e5%92%8c%e5%90%8e%e7%bd%ae%e8%bf%90%e7%ae%97%e7%ac%a6" class="header-mark"></a>区分前置和后置运算符</h4><p>因为前置和后置版本使用的是同一个符号，重载版本的名字也是相同的，运算对象的数量和类型也是相同的</p>
<p>所以为了解决这个问题，后置版本接受一个额外的但是不使用的 int 类型的参数，编译器会为这个形参提供一个值为 0 的实参</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">StrBlobPtr</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span> <span class="c1">//递增和递减运算符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">StrBlobPtr</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">++</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span><span class="c1">//后置版本
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">StrBlobPtr</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">--</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//其他成员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">StrBlobPtr</span> <span class="n">StrBlobPtr</span><span class="o">::</span><span class="k">operator</span><span class="o">++</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//这里无须检查有效性，调用前置版本的时候会检查
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">StrBlobPtr</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span><span class="c1">//记录当前的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="o">++*</span><span class="k">this</span><span class="p">;</span>       <span class="c1">//向前移动一个元素，前置++会检查有效性
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>    <span class="c1">//返回之前记录的状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">StrBlobPtr</span><span class="o">&amp;</span> <span class="n">StrBlobPtr</span><span class="o">::</span><span class="k">operator</span><span class="o">--</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//这里无须检查有效性，调用前置版本的时候会检查
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">StrBlobPtr</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span><span class="c1">//记录当前的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="o">--*</span><span class="k">this</span><span class="p">;</span>       <span class="c1">//向前移动一个元素，前置++会检查有效性
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>    <span class="c1">//返回之前记录的状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里主要需要理解内置类型前置版本和后置版本的区别（以int类型为例）</p>
<ul>
<li>++i 首先会对 i 的值进行递增，然后返回 i 的值</li>
<li>i++ 首先会返回 i 的值，然后再进行运算</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">sum</span> <span class="o">=</span> <span class="o">++</span><span class="n">i</span><span class="p">;</span> <span class="c1">//此时sum的值为2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">sum</span> <span class="o">=</span> <span class="n">i</span><span class="o">++</span><span class="p">;</span> <span class="c1">//此时sum的值为1
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="显示调用后置运算符" class="headerLink">
    <a href="#%e6%98%be%e7%a4%ba%e8%b0%83%e7%94%a8%e5%90%8e%e7%bd%ae%e8%bf%90%e7%ae%97%e7%ac%a6" class="header-mark"></a>显示调用后置运算符</h4><p>如果要显示调用运算符的话，像之前那样利用函数调用的形式进行调用，但是注意必须传入一个整型参数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">StrBlobPtr</span> <span class="nf">p</span><span class="p">(</span><span class="n">a1</span><span class="p">);</span> <span class="c1">//p指向a1的vector
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">p</span><span class="p">.</span><span class="k">operator</span><span class="o">++</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>  <span class="c1">//调用后置版本的operator++
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">p</span><span class="p">.</span><span class="k">operator</span><span class="o">++</span><span class="p">();</span>   <span class="c1">//调用前置版本的operator++
</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="147-成员访问运算符" class="headerLink">
    <a href="#147-%e6%88%90%e5%91%98%e8%ae%bf%e9%97%ae%e8%bf%90%e7%ae%97%e7%ac%a6" class="header-mark"></a>14.7 成员访问运算符</h2><p>迭代器和智能指针类中常常用到解引用运算符（*）和箭头运算符（-&gt;），例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">StrBlobPtr</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">check</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="s">&#34;dereference past end&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)[</span><span class="n">curr</span><span class="p">];</span> <span class="c1">//(*p)是对象所指的vector
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="o">&amp;</span> <span class="k">this</span><span class="o">-&gt;</span><span class="k">operator</span><span class="o">*</span><span class="p">();</span><span class="c1">//实际工作委托给解引用运算符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//其他成员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>解引用运算符首先检查curr是否在作用范围内，如果是返回curr所指元素的引用，箭头运算符返回解引用结果元素的地址</p>
<h4 id="对箭头运算符返回值的限定" class="headerLink">
    <a href="#%e5%af%b9%e7%ae%ad%e5%a4%b4%e8%bf%90%e7%ae%97%e7%ac%a6%e8%bf%94%e5%9b%9e%e5%80%bc%e7%9a%84%e9%99%90%e5%ae%9a" class="header-mark"></a>对箭头运算符返回值的限定</h4><p>形如point-&gt;mem 的表达式，point必须是指向类对象的指针或者是重载了 operator-&gt; 的类的对象</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="p">(</span><span class="o">*</span><span class="n">point</span><span class="p">).</span><span class="n">mem</span><span class="p">;</span>         <span class="c1">//point是一个内置指针类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">point</span><span class="p">.</span><span class="k">operator</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">mem</span><span class="p">;</span><span class="c1">//point是一个类的对象
</span></span></span></code></pre></td></tr></table>
</div>
</div><ol>
<li>如果 point 是指针，则会应用内置箭头运算符，等价于 <code>(*point).mem</code></li>
<li>如果 point 是一个定义了 operator-&gt;的类的一个对象，则使用 point.operator-&gt;() 的结果来获取 mem</li>
</ol>
<h2 id="148-函数调用运算符" class="headerLink">
    <a href="#148-%e5%87%bd%e6%95%b0%e8%b0%83%e7%94%a8%e8%bf%90%e7%ae%97%e7%ac%a6" class="header-mark"></a>14.8 函数调用运算符</h2><p>如果一个类重载了函数调用运算符（就是()），则可以像调用函数一样使用该类的对象，下面是一个例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">absInt</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="nf">operator</span><span class="p">()(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="o">-</span><span class="nl">val</span> <span class="p">:</span> <span class="n">val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">42</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">absInt</span> <span class="n">absObj</span><span class="p">;</span>     <span class="c1">//含有函数调用运算符的对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">ui</span> <span class="o">=</span> <span class="n">absObj</span><span class="p">(</span><span class="n">i</span><span class="p">);</span><span class="c1">//将i传递给absObj.operator()
</span></span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>函数调用运算符必须是成员函数，一个类可以定义多个不同版本的调用运算符</p>
</blockquote>
<p>如果类定义了调用运算符，则该类的对象称为<strong>函数对象</strong>，这些对象的行为像函数一样</p>
<h4 id="含有状态的函数对象类" class="headerLink">
    <a href="#%e5%90%ab%e6%9c%89%e7%8a%b6%e6%80%81%e7%9a%84%e5%87%bd%e6%95%b0%e5%af%b9%e8%b1%a1%e7%b1%bb" class="header-mark"></a>含有状态的函数对象类</h4><p>函数对象类除了 operator() 之外也可以包含其他成员，这些成员被用于定制调用运算符中的操作，下面是个例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">PrintString</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">PrintString</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">o</span> <span class="o">=</span> <span class="n">cout</span><span class="p">,</span> <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="sc">&#39; &#39;</span><span class="p">)</span> <span class="o">:</span> 
</span></span><span class="line"><span class="cl">		<span class="n">os</span><span class="p">(</span><span class="n">o</span><span class="p">),</span> <span class="n">sep</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="kt">void</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">)</span> <span class="k">const</span> 
</span></span><span class="line"><span class="cl">		<span class="p">{</span><span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="n">sep</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">;</span><span class="c1">//用于写入的目的流
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">char</span> <span class="n">step</span><span class="p">;</span>  <span class="c1">//用于将不同输出隔开的字符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">PrintString</span> <span class="n">printer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">printer</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">PrintString</span> <span class="nf">errors</span><span class="p">(</span><span class="n">cerr</span><span class="p">,</span> <span class="sc">&#39;\n&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">errors</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>函数对象常常作为泛型算法的实参，例如可以用for_each 算法和 PrintString 类来打印容器的内容：</p>
<p><code>for_each(vec.beign(), vec.end(), PrintString(cerr, '\n'));</code></p>
<p>for_each 第三个实参是类型 PrintString 的一个临时对象，我们用 cerr 和 换行符初始化了改对象，程序调用 for_each 时，会把 vec 每个元素打印到 cerr 中，元素之间以换行符分割</p>
<h3 id="1481-lambda-是函数对象" class="headerLink">
    <a href="#1481-lambda-%e6%98%af%e5%87%bd%e6%95%b0%e5%af%b9%e8%b1%a1" class="header-mark"></a>14.8.1 lambda 是函数对象</h3><p>使用 PrintString 对象作为 for_each 的实参，类似于使用 lambda 表达式，编译器会将 lambda 表达式 翻译成一个未命名类的未命名对象，举例如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">//根据单词长度进行排序，长度相同的会按照字典序排序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">stable_sort</span><span class="p">(</span><span class="n">word</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">word</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> 
</span></span><span class="line"><span class="cl">			<span class="p">[](</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="p">{</span> <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">size</span><span class="p">();});</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>上面 lambda 表达式类似下面的一个未命名对象</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">ShorterString</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s1</span><span class="p">,</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s2</span><span class="p">)</span> <span class="k">const</span> 
</span></span><span class="line"><span class="cl">	<span class="p">{</span> <span class="k">return</span> <span class="n">s1</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">s2</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">//替换上面的lambda表达式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">stable_sort</span><span class="p">(</span><span class="n">word</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">word</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">ShorterString</span><span class="p">());</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="表示-lambda-及相应捕获行为的类" class="headerLink">
    <a href="#%e8%a1%a8%e7%a4%ba-lambda-%e5%8f%8a%e7%9b%b8%e5%ba%94%e6%8d%95%e8%8e%b7%e8%a1%8c%e4%b8%ba%e7%9a%84%e7%b1%bb" class="header-mark"></a>表示 lambda 及相应捕获行为的类</h4><ul>
<li>使用一个 lambda 表达式通过引用捕获变量时，程序确保 lambda 执行时引用所引的对象确实存在，编译器可以直接引用而无须在 lambda 产生的类中将其存储为数据成员</li>
<li>使用值捕获的变量会拷贝到 lambda 表达式中，这种 lambda 表达式产生的类必须为每个值捕获的变量建立对应的数据成员，同时创建构造函数，用捕获的变量进行初始化</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">//获得第一个指向满足条件元素的迭代器，该元素满足size() &gt;= sz
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">wc</span> <span class="o">=</span> <span class="n">find_if</span><span class="p">(</span><span class="n">word</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">word</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> 
</span></span><span class="line"><span class="cl">				  <span class="p">[</span><span class="n">sz</span><span class="p">](</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">					  <span class="p">{</span> <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">sz</span><span class="p">;});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//上面的lambda表达式产生的类像下面这样
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">SizeComp</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">SizeComp</span><span class="p">(</span><span class="n">size_t</span> <span class="n">n</span><span class="p">)</span> <span class="o">:</span> <span class="n">sz</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="kt">bool</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">)</span> <span class="k">const</span> 
</span></span><span class="line"><span class="cl">		<span class="p">{</span> <span class="k">return</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">sz</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">size_t</span> <span class="n">sz</span><span class="p">;</span><span class="c1">//该数据成员对应通过值捕获的变量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//使用像上面的函数对象时，必须提供一个实参
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">wc</span> <span class="o">=</span> <span class="n">find_if</span><span class="p">(</span><span class="n">word</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">word</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">SizeCopm</span><span class="p">(</span><span class="n">sz</span><span class="p">));</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>lambda 表达式产生的类不含默认构造函数、赋值运算符和默认析构函数；它是否含有默认的拷贝/移动构造函数通常视捕获的数据成员类型而定</p>
<h3 id="1482-标准库定义的函数对象" class="headerLink">
    <a href="#1482-%e6%a0%87%e5%87%86%e5%ba%93%e5%ae%9a%e4%b9%89%e7%9a%84%e5%87%bd%e6%95%b0%e5%af%b9%e8%b1%a1" class="header-mark"></a>14.8.2 标准库定义的函数对象</h3><p>标准库定义了一组表示算术运算符、关系运算符和逻辑运算符的类，每个类分别定义了一个执行与类名对应的调用运算符。</p>
<p>如puls 类定义了一个函数调用运算符用于执行 + 操作，modulus类定义了一个调用运算符执行二元 % 的操作</p>
<p>这些类都是模板形式，可以指定具体的应用类型，即对应调用运算符的形参类型</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">plus</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">intAdd</span><span class="p">;</span>               <span class="c1">//执行int加法的函数对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">negate</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">intNegate</span><span class="p">;</span>          <span class="c1">//执行int取反的函数对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">intAdd</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>       <span class="c1">//sum = 30
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">sum</span> <span class="o">=</span> <span class="n">intNegate</span><span class="p">(</span><span class="n">intAdd</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">));</span><span class="c1">//sum = -30
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">sum</span> <span class="o">=</span> <span class="n">intAdd</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">intNegate</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span><span class="c1">//sum = 0
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>下面时标准库定义的函数对象：</p>
<table>
<thead>
<tr>
<th>算术</th>
<th>关系</th>
<th>逻辑</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>plus&lt;Type&gt;</code></td>
<td><code>equal_to&lt;Type&gt;</code></td>
<td><code>logical_and&lt;</code></td>
</tr>
<tr>
<td><code>minus&lt;Type</code></td>
<td><code>not_equal_to&lt;Type&gt;</code></td>
<td><code>logical_or&lt;Type&gt;</code></td>
</tr>
<tr>
<td><code>multiplies&lt;Type&gt;</code></td>
<td><code>greater&lt;Type&gt;</code></td>
<td><code>logical_not&lt;Type&gt;</code></td>
</tr>
<tr>
<td><code>divides&lt;Type&gt;</code></td>
<td><code>greater_equal&lt;Type&gt;</code></td>
<td></td>
</tr>
<tr>
<td><code>modulus&lt;Type&gt;</code></td>
<td><code>less&lt;Type&gt;</code></td>
<td></td>
</tr>
<tr>
<td><code>negate&lt;Type&gt;</code></td>
<td><code>less_equal&lt;Type&gt;</code></td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="算法中使用标准库函数对象" class="headerLink">
    <a href="#%e7%ae%97%e6%b3%95%e4%b8%ad%e4%bd%bf%e7%94%a8%e6%a0%87%e5%87%86%e5%ba%93%e5%87%bd%e6%95%b0%e5%af%b9%e8%b1%a1" class="header-mark"></a>算法中使用标准库函数对象</h4><p>默认情况下排序算法使用 operator&lt; 将序列按照升序进行排列，如果想执行降序的话，可以用 greater类型的对象
<code>sort(svec.begin(), sec.end(), greater&lt;string&gt;());</code></p>
<p>注意：标准库规定的函数对象对于指针同样适用，如果比较两个无关指针会产生未定义的行为，而我们如果想比较指针内存地址来 sort 指针的 vector。直接比较会产生未定义的行为，而标准库函数对象则可实现这个目的</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">*&gt;</span> <span class="n">nameTable</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">//错误：nameTable中指针彼此之间没有关系，所以 &lt; 将产生未定义行为
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">sort</span><span class="p">(</span><span class="n">nameTable</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">nameTable</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> 
</span></span><span class="line"><span class="cl">	 <span class="p">[](</span><span class="n">string</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="n">string</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">;});</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 正确：标准库规定指针的less是定义良好的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">sort</span><span class="p">(</span><span class="n">nameTable</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">nameTable</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">less</span><span class="o">&lt;</span><span class="n">string</span><span class="o">*&gt;</span><span class="p">());</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="1483-可调用对象与-function" class="headerLink">
    <a href="#1483-%e5%8f%af%e8%b0%83%e7%94%a8%e5%af%b9%e8%b1%a1%e4%b8%8e-function" class="header-mark"></a>14.8.3 可调用对象与 function</h3><p>C++中有几种可调用的对象：函数、函数指针、lambda 表达式、bind 创建的对象以及重载了函数调用运算符的类</p>
<p>这些不同类型的可调用对象可能共享一种<strong>调用形式</strong>，调用形式指明了返回类型以及实参类型，下面是个例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">//普通函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">//lambda 表达式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">mod</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i</span> <span class="o">%</span> <span class="n">j</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">//函数对象类
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">divide</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="nf">operator</span><span class="p">()(</span><span class="kt">int</span> <span class="n">denominator</span><span class="p">,</span> <span class="kt">int</span> <span class="n">divisor</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="n">denominator</span> <span class="o">/</span> <span class="n">divisor</span><span class="p">;</span>	
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>上面的几种可调用对象对参数执行了不同的算术运算，它们类型不相同，但是共享同一种调用形式 <code>int(int, int)</code></p>
<p>我们如果用这些可调用对象构建一个简单的计算器，可以定义一个<strong>函数表</strong>用于储存这些可调用对象的指针。</p>
<p>可以通过 map 来实现，用运算符符号的string对象作为关键字，实现运算符函数作为值</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">//构建运算符到函数指针的映射关系，函数接受两个int，返回一个int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">binops</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">//正确：add是一个指向正确类型的函数指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">binops</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span><span class="s">&#34;+&#34;</span><span class="p">,</span> <span class="n">add</span><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//错误：mod不是一个函数指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">binops</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span><span class="s">&#34;%&#34;</span><span class="p">,</span> <span class="n">mod</span><span class="p">});</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>上面的问题在于 mod 是一个 lambda 表达式，与 binops 的值类型不匹配</p>
<h4 id="标准库-function-类型" class="headerLink">
    <a href="#%e6%a0%87%e5%87%86%e5%ba%93-function-%e7%b1%bb%e5%9e%8b" class="header-mark"></a>标准库 function 类型</h4><p>标准库中一个新的类型 function 可以解决上述问题，下面是 function 定义的操作：</p>
<p><img
        class="lazyload"
        data-src="https://silas-py-oss.oss-cn-chengdu.aliyuncs.com/img/20220427101729.png"
        data-srcset="https://silas-py-oss.oss-cn-chengdu.aliyuncs.com/img/20220427101729.png, https://silas-py-oss.oss-cn-chengdu.aliyuncs.com/img/20220427101729.png 1.5x, https://silas-py-oss.oss-cn-chengdu.aliyuncs.com/img/20220427101729.png 2x"
        data-sizes="auto"
        alt="https://silas-py-oss.oss-cn-chengdu.aliyuncs.com/img/20220427101729.png"
        title="https://silas-py-oss.oss-cn-chengdu.aliyuncs.com/img/20220427101729.png"></p>
<p>function 是一个模板，创建一个具体 function 类型时需要指定 function 表示的对象的调用形式，如 <code>function&lt;int(int, int)&gt;</code> ，这里声明了一个 function 类型，它可以接受两个 int，返回一个 int 类型的可调用对象</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">f1</span> <span class="o">=</span> <span class="n">add</span><span class="p">;</span>     <span class="c1">//函数指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">f1</span> <span class="o">=</span> <span class="n">divide</span><span class="p">();</span><span class="c1">//函数对象类的对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">f1</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="c1">//lambda
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>							<span class="p">{</span> <span class="k">return</span> <span class="n">i</span> <span class="o">*</span> <span class="n">j</span><span class="p">;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">f1</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// 6
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">f2</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">f3</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// 8
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>使用这个 function 类型可以重新定义 map：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="o">&gt;&gt;</span> <span class="n">binops</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span><span class="s">&#34;+&#34;</span><span class="p">,</span> <span class="n">add</span><span class="p">},</span>                               <span class="c1">//函数指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">{</span><span class="s">&#34;-&#34;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">minus</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">()},</span>                 <span class="c1">//标准库定义函数对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">{</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="n">divide</span><span class="p">()},</span>                          <span class="c1">//用户定义函数对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">{</span><span class="s">&#34;*&#34;</span><span class="p">,</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i</span> <span class="o">*</span> <span class="n">j</span><span class="p">;</span> <span class="p">}},</span><span class="c1">//未命名lambda表达式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">{</span><span class="s">&#34;%&#34;</span><span class="p">,</span> <span class="n">mod</span><span class="p">}</span>                                <span class="c1">//命名的lambda
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>map 包含5 个元素，虽然可调用对象类型各不相同，但是仍可以存储在同一个 function&lt;int(int, int)&gt; 类型中，这时可以通过索引 map 得到function 对象的引用</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">binops</span><span class="p">[</span><span class="s">&#34;+&#34;</span><span class="p">](</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span><span class="c1">//add(10, 5);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">binops</span><span class="p">[</span><span class="s">&#34;-&#34;</span><span class="p">](</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span><span class="c1">//minus&lt;int&gt;(10, 5)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">binops</span><span class="p">[</span><span class="s">&#34;/&#34;</span><span class="p">](</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span><span class="c1">//divide对象调用运算符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">binops</span><span class="p">[</span><span class="s">&#34;*&#34;</span><span class="p">](</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span><span class="c1">//调用lambda函数对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">binops</span><span class="p">[</span><span class="s">&#34;%&#34;</span><span class="p">](</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span><span class="c1">//调用lambda函数对象
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="重载的函数与-function" class="headerLink">
    <a href="#%e9%87%8d%e8%bd%bd%e7%9a%84%e5%87%bd%e6%95%b0%e4%b8%8e-function" class="header-mark"></a>重载的函数与 function</h4><p>我们变不能将重载函数名字存入 function 类型的对象中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">Sales_data</span> <span class="nf">add</span><span class="p">(</span><span class="k">const</span> <span class="n">Sales_data</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Sales_data</span><span class="o">&amp;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="o">&gt;&gt;</span> <span class="n">binops</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">binops</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span><span class="s">&#34;+&#34;</span><span class="p">,</span> <span class="n">add</span><span class="p">});</span> <span class="c1">//错误：哪个add？
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>解决上述二义性问题，可以通过一个函数指针，以及 lambda 表达式进行区分</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fp</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="o">=</span> <span class="n">add</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">binops</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span><span class="s">&#34;+&#34;</span><span class="p">,</span> <span class="n">fp</span><span class="p">});</span><span class="c1">//正确：fp指向一个正确的add版本
</span></span></span><span class="line"><span class="cl"><span class="c1">//正确：使用lambda来指定我们希望使用的add版本
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">binops</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span><span class="s">&#34;+&#34;</span><span class="p">,</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="nf">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);}});</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="149-重载类型转换和运算符" class="headerLink">
    <a href="#149-%e9%87%8d%e8%bd%bd%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2%e5%92%8c%e8%bf%90%e7%ae%97%e7%ac%a6" class="header-mark"></a>14.9 重载、类型转换和运算符</h2></div>

        <div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2022-04-25</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"><span><a class="link-to-mardown" href=/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/index.md target="_blank" rel="noopener noreferrer">阅读原始文档</a>
                    </span></div>
            <div class="post-info-share">
                <span></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/c&#43;&#43;/">C&#43;&#43;</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/133.%E5%85%8B%E9%9A%86%E5%9B%BE/" class="prev" rel="prev" title="LC 133.克隆图"><i class="fas fa-angle-left fa-fw"></i>LC 133.克隆图</a>
            <a href="/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" class="next" rel="next" title="《C&#43;&#43;Primer》| 第十五章 面向对象程序设计">《C&#43;&#43;Primer》| 第十五章 面向对象程序设计<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
<div id="comments"><div id="utterances"></div><noscript>
                Please enable JavaScript to view the comments powered by <a href="https://utteranc.es/">Utterances</a>.
            </noscript></div></article></div>
        </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">
                    由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.97.3">Hugo</a> 强力驱动&nbsp;|&nbsp;主题 - <a href="https://github.com/HEIGE-PCloud/DoIt" target="_blank" rel="noopener noreffer" title="DoIt 0.2.13"><i class="far fa-edit fa-fw"></i> DoIt</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2022</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/" target="_blank" rel="noopener noreferrer">Silas</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
            <div class="footer-line"></div>
            <div class="footer-line">
            </div>
        </div></footer></div>

    <div id="fixed-buttons"><a href="#back-to-top" id="back-to-top-button" class="fixed-button" title="回到顶部">
            <i class="fas fa-arrow-up fa-fw"></i>
        </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
            <i class="fas fa-comment fa-fw"></i>
        </a>
    </div><div class="assets"><script type="text/javascript" src="/lib/autocomplete/autocomplete.min.js"></script><script type="text/javascript" src="/lib/fuse/fuse.min.js"></script><script type="text/javascript" src="/lib/lazysizes/lazysizes.min.js"></script><script type="text/javascript" src="/lib/tablesort/tablesort.min.js"></script><script type="text/javascript" src="/lib/topbar/topbar.min.js"></script><script type="text/javascript" src="/lib/pjax/pjax.min.js"></script><script type="text/javascript" src="/js/theme.min.js" defer></script></div>

<div class="pjax-assets"><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":20},"comment":{"utterances":{"darkTheme":"github-dark","issueTerm":"pathname","label":"","lightTheme":"github-light","repo":"ephmeral/hugoblogtalks"}},"data":{"desktop-header-typeit":"Ephmeral","mobile-header-typeit":"Ephmeral"},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"search":{"distance":100,"findAllMatches":false,"fuseIndexURL":"/index.json","highlightTag":"em","ignoreFieldNorm":false,"ignoreLocation":false,"isCaseSensitive":false,"location":0,"maxResultLength":10,"minMatchCharLength":2,"noResultsFound":"没有找到结果","snippetLength":50,"threshold":0.3,"type":"fuse","useExtendedSearch":false},"table":{"sort":true},"typeit":{"cursorChar":"|","cursorSpeed":1000,"data":{"desktop-header-typeit":["desktop-header-typeit"],"mobile-header-typeit":["mobile-header-typeit"]},"duration":-1,"speed":100}};</script><script type="text/javascript" src="/js/utterances.min.js" defer></script><script type="text/javascript" src="/lib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="/lib/typeit/typeit.min.js"></script><script type="text/javascript" src="/lib/katex/katex.min.js" defer></script><script type="text/javascript" src="/lib/katex/auto-render.min.js" defer></script><script type="text/javascript" src="/lib/katex/copy-tex.min.js" defer></script><script type="text/javascript" src="/lib/katex/mhchem.min.js" defer></script><script type="text/javascript" src="/js/katex.min.js" defer></script><link rel="stylesheet" href="/lib/katex/katex.min.css"><link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="/lib/katex/copy-tex.min.css">
        <noscript><link rel="stylesheet" href="/lib/katex/copy-tex.min.css"></noscript></div>
</body>

</html>
[{"categories":["C++"],"content":"16.1 定义模板如果希望定义两个函数，来比较两个值，对于不同类型，可以通过定义多个重载函数来实现这样的功能 //如果两个值相等，返回0，v1小于v2返回-1，v2小于v1返回1 int compare(const string \u0026v1, const string \u0026v2) { if (v1 \u003c v2) return -1; if (v2 \u003c v1) return 1; return 0; } int compare(const double \u0026v1, const double \u0026v2) { if (v1 \u003c v2) return -1; if (v2 \u003c v1) return 1; return 0; } 这两个函数几乎相同，唯一的区别是参数的类型，函数体完全一样 如果还需要定义其他类型的比较函数，显然这样定义比较麻烦，可以用到下面介绍的函数模板进行简化 ","date":"2022-05-07","objectID":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/:1:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十六章 模板与泛型编程","uri":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/#161-定义模板"},{"categories":["C++"],"content":"16.1.1 函数模板 通过定义一个函数模板，而不需要为每个类型都定义一个新函数； 一个函数模板就是一个公式，可以用来生成针对特定类型的函数版本 template\u003ctypename T\u003e int compare(const T \u0026v1, const T \u0026v2) { if (v1 \u003c v2) return -1; if (v2 \u003c v1) return 1; return 0; } 模板定义以关键字 template 开始，后跟一个模板参数列表，这是一个逗号分隔的一个或多个模板参数的列表，用（\u003c\u003e）包围起来 模板定义中，模板参数列表不能为空 模板参数列表类似函数参数列表，在调用时为函数提供实参来初始化形参；模板参数列表中的类型，只有当调用时，通过显式或隐式指定模板实参，将其绑定到模板参数上，根据具体使用情况来确定 实例化函数模板当调用一个函数模板时，编译器用函数实参来推断模板实参 cout \u003c\u003c compare(1, 0) \u003c\u003c endl; //T为int //实参类型为int, 编译器推断出模板实参为int，将其绑定到模板参数T 编译器用推断出来的模板参数来实例化一个特定版本的函数，对于上面的调用，会实例化出 int compare(const int\u0026, const int\u0026); 函数 同样对于下面的调用： vector\u003cint\u003e vec1{1, 2, 3}, vec2{5, 6, 7}; cout \u003c\u003c compare(vec1, vec2) \u003c\u003c endl; //实例化出 int compare(const vector\u003cint\u003e\u0026, const vector\u003cint\u003e\u0026) 编译器会实例化另一个 compare 版本，其中 T 被替换为 vector\u003cint\u003e int compare(const vector\u003cint\u003e\u0026v1, const vector\u003cint\u003e\u0026v2) { if (v1 \u003c v2) return -1; if (v2 \u003c v1) return 1; return 0; } 这些编译器生成的版本通常称为模板的==实例== 模板类型参数上面定义的 compare 函数有一个模板类型参数，一般可以将类型参数看作类型说明符，就像内置类型或类类型说明符一样使用 类型参数可以用来指定返回类型，函数参数类型，以及函数体内用于变量声明或类型转换 template \u003ctypename T\u003e T foo(T* p) { T tmp = *p; //tmp类型将时指针p指向的类型 //... return tmp; } 类型参数前必须使用关键字 class 或 typename //错误：U前面需要加上关键字class或typename template \u003ctypename T, U\u003e T calc(const T\u0026, const U\u0026); 这两个关键字含义相同，可以互换使用 非类型模板参数 一个非类型参数表示一个值而非一个类型，通过一个特定的类型名而非关键字 class 或 typename 来指定非类型参数 一个模板被实例化时，非类型参数被用户提供或编译器推断出的值所替代，这些值必须是常量表达式 例如：编写一个 compare 版本处理字符串字面常量，这种字面常量是 const char 数组，用于不能拷贝一个数组，所以将自己的参数定义为数组的引用，由于希望比较不同长度的字符串字面值常量，模板定义了两个非类型的参数 template \u003cunsigned N, unsigned M\u003e int compare(const (\u0026p1)[N], const (\u0026p2)[M]) { return strcmp(p1, p2); } 调用这个版本时： compare(\"hi\", \"mom\"); //编译器会用字面值常量的大小代替N，M //编译器会在末尾插入一个空字符作为终结符 //编译器会实例出下面版本 int compare(const char (\u0026p1)[3], const char (\u0026p2)[4]); 一个非类型参数可以是一个整型、一个指向对象或函数类型的指针或（左值）引用 绑定到非类型整型参数的实参必须是一个常量表达式 绑定到指针或引用必须具有静态生存期，不能用普通（非static）局部变量或动态对象作为指针引用的实参 指针参数也可以用 nullptr 或值为 0 的常量表达式来实例化 inline 和 constexpr 的函数模板inline 和 constexpr 说明符放在模板参数列表后面，返回类型之前 //正确：inline说明符在模板参数列表之后 template\u003ctypename T\u003e inline T min(const T\u0026, const T\u0026); //错误：inline位置不正确 inline template\u003ctypename T\u003e T min(const T\u0026, const T\u0026); 编写类型无关的代码编写泛型代码两个重要原则： 模板中的函数参数是 const 的引用 函数体中的条件判断仅用 \u003c 比较运算 使用 const 的引用，保证了函数可以用于不能拷贝的类型，设为引用处理大对象时，函数运行速度会更快 只使用 \u003c 运算符，降低了函数对要处理类型的要求，这些类型必须支持 \u003c，而不必同时支持 \u003e 如果需要类型无关和可移植性，可以使用 less 函数对象来定义 template \u003ctypename T\u003e int compare(const T \u0026v1, const T \u0026v2) { if (less\u003cT\u003e()(v1, v2)) return -1; if (less\u003cT\u003e()(v2, v1)) return 1; return 0; } 模板编译编译器遇见一个模板定义时，并不生成代码，只有当实例化出模板的一个特定版本时，编译器才会生成代码 模板为了生成一个实例化版本，需要函数模板或类模板成员函数的定义，与非模板代码不同，模板的头文件通常即包括声明也包括定义 大多数编译错误在实例化期间报告模板直到实例化才会生成代码，通常编译器在三个阶段报告错误： 编译模板本身，基本的语法错误（忘记分号，变量名拼错等） 编译器遇到模板使用时，函数模板会检查实参数目是否正确，参数类型是否匹配，类模板是否提供了正确数目的模板实参 模板实例化时，只有这个阶段才会发现类型相关的错误 例如：之前的 compare 函数，如果传入一个类类型 Sales_data data1, data2; cout \u003c\u003c compare(data1, data2) \u003c\u003c endl; //错误：Sales_data未定义\u003c 这样的错误只有等到实例化 compare 才会发现 ","date":"2022-05-07","objectID":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/:1:1","series":null,"tags":["C++"],"title":"《C++Primer》| 第十六章 模板与泛型编程","uri":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/#1611-函数模板"},{"categories":["C++"],"content":"16.1.1 函数模板 通过定义一个函数模板，而不需要为每个类型都定义一个新函数； 一个函数模板就是一个公式，可以用来生成针对特定类型的函数版本 templateint compare(const T \u0026v1, const T \u0026v2) { if (v1 ）包围起来 模板定义中，模板参数列表不能为空 模板参数列表类似函数参数列表，在调用时为函数提供实参来初始化形参；模板参数列表中的类型，只有当调用时，通过显式或隐式指定模板实参，将其绑定到模板参数上，根据具体使用情况来确定 实例化函数模板当调用一个函数模板时，编译器用函数实参来推断模板实参 cout vec1{1, 2, 3}, vec2{5, 6, 7}; cout \u0026, const vector\u0026) 编译器会实例化另一个 compare 版本，其中 T 被替换为 vector int compare(const vector\u0026v1, const vector\u0026v2) { if (v1 T foo(T* p) { T tmp = *p; //tmp类型将时指针p指向的类型 //... return tmp; } 类型参数前必须使用关键字 class 或 typename //错误：U前面需要加上关键字class或typename template T calc(const T\u0026, const U\u0026); 这两个关键字含义相同，可以互换使用 非类型模板参数 一个非类型参数表示一个值而非一个类型，通过一个特定的类型名而非关键字 class 或 typename 来指定非类型参数 一个模板被实例化时，非类型参数被用户提供或编译器推断出的值所替代，这些值必须是常量表达式 例如：编写一个 compare 版本处理字符串字面常量，这种字面常量是 const char 数组，用于不能拷贝一个数组，所以将自己的参数定义为数组的引用，由于希望比较不同长度的字符串字面值常量，模板定义了两个非类型的参数 template int compare(const (\u0026p1)[N], const (\u0026p2)[M]) { return strcmp(p1, p2); } 调用这个版本时： compare(\"hi\", \"mom\"); //编译器会用字面值常量的大小代替N，M //编译器会在末尾插入一个空字符作为终结符 //编译器会实例出下面版本 int compare(const char (\u0026p1)[3], const char (\u0026p2)[4]); 一个非类型参数可以是一个整型、一个指向对象或函数类型的指针或（左值）引用 绑定到非类型整型参数的实参必须是一个常量表达式 绑定到指针或引用必须具有静态生存期，不能用普通（非static）局部变量或动态对象作为指针引用的实参 指针参数也可以用 nullptr 或值为 0 的常量表达式来实例化 inline 和 constexpr 的函数模板inline 和 constexpr 说明符放在模板参数列表后面，返回类型之前 //正确：inline说明符在模板参数列表之后 templateinline T min(const T\u0026, const T\u0026); //错误：inline位置不正确 inline templateT min(const T\u0026, const T\u0026); 编写类型无关的代码编写泛型代码两个重要原则： 模板中的函数参数是 const 的引用 函数体中的条件判断仅用 如果需要类型无关和可移植性，可以使用 less 函数对象来定义 template int compare(const T \u0026v1, const T \u0026v2) { if (less()(v1, v2)) return -1; if (less()(v2, v1)) return 1; return 0; } 模板编译编译器遇见一个模板定义时，并不生成代码，只有当实例化出模板的一个特定版本时，编译器才会生成代码 模板为了生成一个实例化版本，需要函数模板或类模板成员函数的定义，与非模板代码不同，模板的头文件通常即包括声明也包括定义 大多数编译错误在实例化期间报告模板直到实例化才会生成代码，通常编译器在三个阶段报告错误： 编译模板本身，基本的语法错误（忘记分号，变量名拼错等） 编译器遇到模板使用时，函数模板会检查实参数目是否正确，参数类型是否匹配，类模板是否提供了正确数目的模板实参 模板实例化时，只有这个阶段才会发现类型相关的错误 例如：之前的 compare 函数，如果传入一个类类型 Sales_data data1, data2; cout ","date":"2022-05-07","objectID":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/:1:1","series":null,"tags":["C++"],"title":"《C++Primer》| 第十六章 模板与泛型编程","uri":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/#实例化函数模板"},{"categories":["C++"],"content":"16.1.1 函数模板 通过定义一个函数模板，而不需要为每个类型都定义一个新函数； 一个函数模板就是一个公式，可以用来生成针对特定类型的函数版本 templateint compare(const T \u0026v1, const T \u0026v2) { if (v1 ）包围起来 模板定义中，模板参数列表不能为空 模板参数列表类似函数参数列表，在调用时为函数提供实参来初始化形参；模板参数列表中的类型，只有当调用时，通过显式或隐式指定模板实参，将其绑定到模板参数上，根据具体使用情况来确定 实例化函数模板当调用一个函数模板时，编译器用函数实参来推断模板实参 cout vec1{1, 2, 3}, vec2{5, 6, 7}; cout \u0026, const vector\u0026) 编译器会实例化另一个 compare 版本，其中 T 被替换为 vector int compare(const vector\u0026v1, const vector\u0026v2) { if (v1 T foo(T* p) { T tmp = *p; //tmp类型将时指针p指向的类型 //... return tmp; } 类型参数前必须使用关键字 class 或 typename //错误：U前面需要加上关键字class或typename template T calc(const T\u0026, const U\u0026); 这两个关键字含义相同，可以互换使用 非类型模板参数 一个非类型参数表示一个值而非一个类型，通过一个特定的类型名而非关键字 class 或 typename 来指定非类型参数 一个模板被实例化时，非类型参数被用户提供或编译器推断出的值所替代，这些值必须是常量表达式 例如：编写一个 compare 版本处理字符串字面常量，这种字面常量是 const char 数组，用于不能拷贝一个数组，所以将自己的参数定义为数组的引用，由于希望比较不同长度的字符串字面值常量，模板定义了两个非类型的参数 template int compare(const (\u0026p1)[N], const (\u0026p2)[M]) { return strcmp(p1, p2); } 调用这个版本时： compare(\"hi\", \"mom\"); //编译器会用字面值常量的大小代替N，M //编译器会在末尾插入一个空字符作为终结符 //编译器会实例出下面版本 int compare(const char (\u0026p1)[3], const char (\u0026p2)[4]); 一个非类型参数可以是一个整型、一个指向对象或函数类型的指针或（左值）引用 绑定到非类型整型参数的实参必须是一个常量表达式 绑定到指针或引用必须具有静态生存期，不能用普通（非static）局部变量或动态对象作为指针引用的实参 指针参数也可以用 nullptr 或值为 0 的常量表达式来实例化 inline 和 constexpr 的函数模板inline 和 constexpr 说明符放在模板参数列表后面，返回类型之前 //正确：inline说明符在模板参数列表之后 templateinline T min(const T\u0026, const T\u0026); //错误：inline位置不正确 inline templateT min(const T\u0026, const T\u0026); 编写类型无关的代码编写泛型代码两个重要原则： 模板中的函数参数是 const 的引用 函数体中的条件判断仅用 如果需要类型无关和可移植性，可以使用 less 函数对象来定义 template int compare(const T \u0026v1, const T \u0026v2) { if (less()(v1, v2)) return -1; if (less()(v2, v1)) return 1; return 0; } 模板编译编译器遇见一个模板定义时，并不生成代码，只有当实例化出模板的一个特定版本时，编译器才会生成代码 模板为了生成一个实例化版本，需要函数模板或类模板成员函数的定义，与非模板代码不同，模板的头文件通常即包括声明也包括定义 大多数编译错误在实例化期间报告模板直到实例化才会生成代码，通常编译器在三个阶段报告错误： 编译模板本身，基本的语法错误（忘记分号，变量名拼错等） 编译器遇到模板使用时，函数模板会检查实参数目是否正确，参数类型是否匹配，类模板是否提供了正确数目的模板实参 模板实例化时，只有这个阶段才会发现类型相关的错误 例如：之前的 compare 函数，如果传入一个类类型 Sales_data data1, data2; cout ","date":"2022-05-07","objectID":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/:1:1","series":null,"tags":["C++"],"title":"《C++Primer》| 第十六章 模板与泛型编程","uri":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/#模板类型参数"},{"categories":["C++"],"content":"16.1.1 函数模板 通过定义一个函数模板，而不需要为每个类型都定义一个新函数； 一个函数模板就是一个公式，可以用来生成针对特定类型的函数版本 templateint compare(const T \u0026v1, const T \u0026v2) { if (v1 ）包围起来 模板定义中，模板参数列表不能为空 模板参数列表类似函数参数列表，在调用时为函数提供实参来初始化形参；模板参数列表中的类型，只有当调用时，通过显式或隐式指定模板实参，将其绑定到模板参数上，根据具体使用情况来确定 实例化函数模板当调用一个函数模板时，编译器用函数实参来推断模板实参 cout vec1{1, 2, 3}, vec2{5, 6, 7}; cout \u0026, const vector\u0026) 编译器会实例化另一个 compare 版本，其中 T 被替换为 vector int compare(const vector\u0026v1, const vector\u0026v2) { if (v1 T foo(T* p) { T tmp = *p; //tmp类型将时指针p指向的类型 //... return tmp; } 类型参数前必须使用关键字 class 或 typename //错误：U前面需要加上关键字class或typename template T calc(const T\u0026, const U\u0026); 这两个关键字含义相同，可以互换使用 非类型模板参数 一个非类型参数表示一个值而非一个类型，通过一个特定的类型名而非关键字 class 或 typename 来指定非类型参数 一个模板被实例化时，非类型参数被用户提供或编译器推断出的值所替代，这些值必须是常量表达式 例如：编写一个 compare 版本处理字符串字面常量，这种字面常量是 const char 数组，用于不能拷贝一个数组，所以将自己的参数定义为数组的引用，由于希望比较不同长度的字符串字面值常量，模板定义了两个非类型的参数 template int compare(const (\u0026p1)[N], const (\u0026p2)[M]) { return strcmp(p1, p2); } 调用这个版本时： compare(\"hi\", \"mom\"); //编译器会用字面值常量的大小代替N，M //编译器会在末尾插入一个空字符作为终结符 //编译器会实例出下面版本 int compare(const char (\u0026p1)[3], const char (\u0026p2)[4]); 一个非类型参数可以是一个整型、一个指向对象或函数类型的指针或（左值）引用 绑定到非类型整型参数的实参必须是一个常量表达式 绑定到指针或引用必须具有静态生存期，不能用普通（非static）局部变量或动态对象作为指针引用的实参 指针参数也可以用 nullptr 或值为 0 的常量表达式来实例化 inline 和 constexpr 的函数模板inline 和 constexpr 说明符放在模板参数列表后面，返回类型之前 //正确：inline说明符在模板参数列表之后 templateinline T min(const T\u0026, const T\u0026); //错误：inline位置不正确 inline templateT min(const T\u0026, const T\u0026); 编写类型无关的代码编写泛型代码两个重要原则： 模板中的函数参数是 const 的引用 函数体中的条件判断仅用 如果需要类型无关和可移植性，可以使用 less 函数对象来定义 template int compare(const T \u0026v1, const T \u0026v2) { if (less()(v1, v2)) return -1; if (less()(v2, v1)) return 1; return 0; } 模板编译编译器遇见一个模板定义时，并不生成代码，只有当实例化出模板的一个特定版本时，编译器才会生成代码 模板为了生成一个实例化版本，需要函数模板或类模板成员函数的定义，与非模板代码不同，模板的头文件通常即包括声明也包括定义 大多数编译错误在实例化期间报告模板直到实例化才会生成代码，通常编译器在三个阶段报告错误： 编译模板本身，基本的语法错误（忘记分号，变量名拼错等） 编译器遇到模板使用时，函数模板会检查实参数目是否正确，参数类型是否匹配，类模板是否提供了正确数目的模板实参 模板实例化时，只有这个阶段才会发现类型相关的错误 例如：之前的 compare 函数，如果传入一个类类型 Sales_data data1, data2; cout ","date":"2022-05-07","objectID":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/:1:1","series":null,"tags":["C++"],"title":"《C++Primer》| 第十六章 模板与泛型编程","uri":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/#非类型模板参数"},{"categories":["C++"],"content":"16.1.1 函数模板 通过定义一个函数模板，而不需要为每个类型都定义一个新函数； 一个函数模板就是一个公式，可以用来生成针对特定类型的函数版本 templateint compare(const T \u0026v1, const T \u0026v2) { if (v1 ）包围起来 模板定义中，模板参数列表不能为空 模板参数列表类似函数参数列表，在调用时为函数提供实参来初始化形参；模板参数列表中的类型，只有当调用时，通过显式或隐式指定模板实参，将其绑定到模板参数上，根据具体使用情况来确定 实例化函数模板当调用一个函数模板时，编译器用函数实参来推断模板实参 cout vec1{1, 2, 3}, vec2{5, 6, 7}; cout \u0026, const vector\u0026) 编译器会实例化另一个 compare 版本，其中 T 被替换为 vector int compare(const vector\u0026v1, const vector\u0026v2) { if (v1 T foo(T* p) { T tmp = *p; //tmp类型将时指针p指向的类型 //... return tmp; } 类型参数前必须使用关键字 class 或 typename //错误：U前面需要加上关键字class或typename template T calc(const T\u0026, const U\u0026); 这两个关键字含义相同，可以互换使用 非类型模板参数 一个非类型参数表示一个值而非一个类型，通过一个特定的类型名而非关键字 class 或 typename 来指定非类型参数 一个模板被实例化时，非类型参数被用户提供或编译器推断出的值所替代，这些值必须是常量表达式 例如：编写一个 compare 版本处理字符串字面常量，这种字面常量是 const char 数组，用于不能拷贝一个数组，所以将自己的参数定义为数组的引用，由于希望比较不同长度的字符串字面值常量，模板定义了两个非类型的参数 template int compare(const (\u0026p1)[N], const (\u0026p2)[M]) { return strcmp(p1, p2); } 调用这个版本时： compare(\"hi\", \"mom\"); //编译器会用字面值常量的大小代替N，M //编译器会在末尾插入一个空字符作为终结符 //编译器会实例出下面版本 int compare(const char (\u0026p1)[3], const char (\u0026p2)[4]); 一个非类型参数可以是一个整型、一个指向对象或函数类型的指针或（左值）引用 绑定到非类型整型参数的实参必须是一个常量表达式 绑定到指针或引用必须具有静态生存期，不能用普通（非static）局部变量或动态对象作为指针引用的实参 指针参数也可以用 nullptr 或值为 0 的常量表达式来实例化 inline 和 constexpr 的函数模板inline 和 constexpr 说明符放在模板参数列表后面，返回类型之前 //正确：inline说明符在模板参数列表之后 templateinline T min(const T\u0026, const T\u0026); //错误：inline位置不正确 inline templateT min(const T\u0026, const T\u0026); 编写类型无关的代码编写泛型代码两个重要原则： 模板中的函数参数是 const 的引用 函数体中的条件判断仅用 如果需要类型无关和可移植性，可以使用 less 函数对象来定义 template int compare(const T \u0026v1, const T \u0026v2) { if (less()(v1, v2)) return -1; if (less()(v2, v1)) return 1; return 0; } 模板编译编译器遇见一个模板定义时，并不生成代码，只有当实例化出模板的一个特定版本时，编译器才会生成代码 模板为了生成一个实例化版本，需要函数模板或类模板成员函数的定义，与非模板代码不同，模板的头文件通常即包括声明也包括定义 大多数编译错误在实例化期间报告模板直到实例化才会生成代码，通常编译器在三个阶段报告错误： 编译模板本身，基本的语法错误（忘记分号，变量名拼错等） 编译器遇到模板使用时，函数模板会检查实参数目是否正确，参数类型是否匹配，类模板是否提供了正确数目的模板实参 模板实例化时，只有这个阶段才会发现类型相关的错误 例如：之前的 compare 函数，如果传入一个类类型 Sales_data data1, data2; cout ","date":"2022-05-07","objectID":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/:1:1","series":null,"tags":["C++"],"title":"《C++Primer》| 第十六章 模板与泛型编程","uri":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/#inline-和-constexpr-的函数模板"},{"categories":["C++"],"content":"16.1.1 函数模板 通过定义一个函数模板，而不需要为每个类型都定义一个新函数； 一个函数模板就是一个公式，可以用来生成针对特定类型的函数版本 templateint compare(const T \u0026v1, const T \u0026v2) { if (v1 ）包围起来 模板定义中，模板参数列表不能为空 模板参数列表类似函数参数列表，在调用时为函数提供实参来初始化形参；模板参数列表中的类型，只有当调用时，通过显式或隐式指定模板实参，将其绑定到模板参数上，根据具体使用情况来确定 实例化函数模板当调用一个函数模板时，编译器用函数实参来推断模板实参 cout vec1{1, 2, 3}, vec2{5, 6, 7}; cout \u0026, const vector\u0026) 编译器会实例化另一个 compare 版本，其中 T 被替换为 vector int compare(const vector\u0026v1, const vector\u0026v2) { if (v1 T foo(T* p) { T tmp = *p; //tmp类型将时指针p指向的类型 //... return tmp; } 类型参数前必须使用关键字 class 或 typename //错误：U前面需要加上关键字class或typename template T calc(const T\u0026, const U\u0026); 这两个关键字含义相同，可以互换使用 非类型模板参数 一个非类型参数表示一个值而非一个类型，通过一个特定的类型名而非关键字 class 或 typename 来指定非类型参数 一个模板被实例化时，非类型参数被用户提供或编译器推断出的值所替代，这些值必须是常量表达式 例如：编写一个 compare 版本处理字符串字面常量，这种字面常量是 const char 数组，用于不能拷贝一个数组，所以将自己的参数定义为数组的引用，由于希望比较不同长度的字符串字面值常量，模板定义了两个非类型的参数 template int compare(const (\u0026p1)[N], const (\u0026p2)[M]) { return strcmp(p1, p2); } 调用这个版本时： compare(\"hi\", \"mom\"); //编译器会用字面值常量的大小代替N，M //编译器会在末尾插入一个空字符作为终结符 //编译器会实例出下面版本 int compare(const char (\u0026p1)[3], const char (\u0026p2)[4]); 一个非类型参数可以是一个整型、一个指向对象或函数类型的指针或（左值）引用 绑定到非类型整型参数的实参必须是一个常量表达式 绑定到指针或引用必须具有静态生存期，不能用普通（非static）局部变量或动态对象作为指针引用的实参 指针参数也可以用 nullptr 或值为 0 的常量表达式来实例化 inline 和 constexpr 的函数模板inline 和 constexpr 说明符放在模板参数列表后面，返回类型之前 //正确：inline说明符在模板参数列表之后 templateinline T min(const T\u0026, const T\u0026); //错误：inline位置不正确 inline templateT min(const T\u0026, const T\u0026); 编写类型无关的代码编写泛型代码两个重要原则： 模板中的函数参数是 const 的引用 函数体中的条件判断仅用 如果需要类型无关和可移植性，可以使用 less 函数对象来定义 template int compare(const T \u0026v1, const T \u0026v2) { if (less()(v1, v2)) return -1; if (less()(v2, v1)) return 1; return 0; } 模板编译编译器遇见一个模板定义时，并不生成代码，只有当实例化出模板的一个特定版本时，编译器才会生成代码 模板为了生成一个实例化版本，需要函数模板或类模板成员函数的定义，与非模板代码不同，模板的头文件通常即包括声明也包括定义 大多数编译错误在实例化期间报告模板直到实例化才会生成代码，通常编译器在三个阶段报告错误： 编译模板本身，基本的语法错误（忘记分号，变量名拼错等） 编译器遇到模板使用时，函数模板会检查实参数目是否正确，参数类型是否匹配，类模板是否提供了正确数目的模板实参 模板实例化时，只有这个阶段才会发现类型相关的错误 例如：之前的 compare 函数，如果传入一个类类型 Sales_data data1, data2; cout ","date":"2022-05-07","objectID":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/:1:1","series":null,"tags":["C++"],"title":"《C++Primer》| 第十六章 模板与泛型编程","uri":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/#编写类型无关的代码"},{"categories":["C++"],"content":"16.1.1 函数模板 通过定义一个函数模板，而不需要为每个类型都定义一个新函数； 一个函数模板就是一个公式，可以用来生成针对特定类型的函数版本 templateint compare(const T \u0026v1, const T \u0026v2) { if (v1 ）包围起来 模板定义中，模板参数列表不能为空 模板参数列表类似函数参数列表，在调用时为函数提供实参来初始化形参；模板参数列表中的类型，只有当调用时，通过显式或隐式指定模板实参，将其绑定到模板参数上，根据具体使用情况来确定 实例化函数模板当调用一个函数模板时，编译器用函数实参来推断模板实参 cout vec1{1, 2, 3}, vec2{5, 6, 7}; cout \u0026, const vector\u0026) 编译器会实例化另一个 compare 版本，其中 T 被替换为 vector int compare(const vector\u0026v1, const vector\u0026v2) { if (v1 T foo(T* p) { T tmp = *p; //tmp类型将时指针p指向的类型 //... return tmp; } 类型参数前必须使用关键字 class 或 typename //错误：U前面需要加上关键字class或typename template T calc(const T\u0026, const U\u0026); 这两个关键字含义相同，可以互换使用 非类型模板参数 一个非类型参数表示一个值而非一个类型，通过一个特定的类型名而非关键字 class 或 typename 来指定非类型参数 一个模板被实例化时，非类型参数被用户提供或编译器推断出的值所替代，这些值必须是常量表达式 例如：编写一个 compare 版本处理字符串字面常量，这种字面常量是 const char 数组，用于不能拷贝一个数组，所以将自己的参数定义为数组的引用，由于希望比较不同长度的字符串字面值常量，模板定义了两个非类型的参数 template int compare(const (\u0026p1)[N], const (\u0026p2)[M]) { return strcmp(p1, p2); } 调用这个版本时： compare(\"hi\", \"mom\"); //编译器会用字面值常量的大小代替N，M //编译器会在末尾插入一个空字符作为终结符 //编译器会实例出下面版本 int compare(const char (\u0026p1)[3], const char (\u0026p2)[4]); 一个非类型参数可以是一个整型、一个指向对象或函数类型的指针或（左值）引用 绑定到非类型整型参数的实参必须是一个常量表达式 绑定到指针或引用必须具有静态生存期，不能用普通（非static）局部变量或动态对象作为指针引用的实参 指针参数也可以用 nullptr 或值为 0 的常量表达式来实例化 inline 和 constexpr 的函数模板inline 和 constexpr 说明符放在模板参数列表后面，返回类型之前 //正确：inline说明符在模板参数列表之后 templateinline T min(const T\u0026, const T\u0026); //错误：inline位置不正确 inline templateT min(const T\u0026, const T\u0026); 编写类型无关的代码编写泛型代码两个重要原则： 模板中的函数参数是 const 的引用 函数体中的条件判断仅用 如果需要类型无关和可移植性，可以使用 less 函数对象来定义 template int compare(const T \u0026v1, const T \u0026v2) { if (less()(v1, v2)) return -1; if (less()(v2, v1)) return 1; return 0; } 模板编译编译器遇见一个模板定义时，并不生成代码，只有当实例化出模板的一个特定版本时，编译器才会生成代码 模板为了生成一个实例化版本，需要函数模板或类模板成员函数的定义，与非模板代码不同，模板的头文件通常即包括声明也包括定义 大多数编译错误在实例化期间报告模板直到实例化才会生成代码，通常编译器在三个阶段报告错误： 编译模板本身，基本的语法错误（忘记分号，变量名拼错等） 编译器遇到模板使用时，函数模板会检查实参数目是否正确，参数类型是否匹配，类模板是否提供了正确数目的模板实参 模板实例化时，只有这个阶段才会发现类型相关的错误 例如：之前的 compare 函数，如果传入一个类类型 Sales_data data1, data2; cout ","date":"2022-05-07","objectID":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/:1:1","series":null,"tags":["C++"],"title":"《C++Primer》| 第十六章 模板与泛型编程","uri":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/#模板编译"},{"categories":["C++"],"content":"16.1.1 函数模板 通过定义一个函数模板，而不需要为每个类型都定义一个新函数； 一个函数模板就是一个公式，可以用来生成针对特定类型的函数版本 templateint compare(const T \u0026v1, const T \u0026v2) { if (v1 ）包围起来 模板定义中，模板参数列表不能为空 模板参数列表类似函数参数列表，在调用时为函数提供实参来初始化形参；模板参数列表中的类型，只有当调用时，通过显式或隐式指定模板实参，将其绑定到模板参数上，根据具体使用情况来确定 实例化函数模板当调用一个函数模板时，编译器用函数实参来推断模板实参 cout vec1{1, 2, 3}, vec2{5, 6, 7}; cout \u0026, const vector\u0026) 编译器会实例化另一个 compare 版本，其中 T 被替换为 vector int compare(const vector\u0026v1, const vector\u0026v2) { if (v1 T foo(T* p) { T tmp = *p; //tmp类型将时指针p指向的类型 //... return tmp; } 类型参数前必须使用关键字 class 或 typename //错误：U前面需要加上关键字class或typename template T calc(const T\u0026, const U\u0026); 这两个关键字含义相同，可以互换使用 非类型模板参数 一个非类型参数表示一个值而非一个类型，通过一个特定的类型名而非关键字 class 或 typename 来指定非类型参数 一个模板被实例化时，非类型参数被用户提供或编译器推断出的值所替代，这些值必须是常量表达式 例如：编写一个 compare 版本处理字符串字面常量，这种字面常量是 const char 数组，用于不能拷贝一个数组，所以将自己的参数定义为数组的引用，由于希望比较不同长度的字符串字面值常量，模板定义了两个非类型的参数 template int compare(const (\u0026p1)[N], const (\u0026p2)[M]) { return strcmp(p1, p2); } 调用这个版本时： compare(\"hi\", \"mom\"); //编译器会用字面值常量的大小代替N，M //编译器会在末尾插入一个空字符作为终结符 //编译器会实例出下面版本 int compare(const char (\u0026p1)[3], const char (\u0026p2)[4]); 一个非类型参数可以是一个整型、一个指向对象或函数类型的指针或（左值）引用 绑定到非类型整型参数的实参必须是一个常量表达式 绑定到指针或引用必须具有静态生存期，不能用普通（非static）局部变量或动态对象作为指针引用的实参 指针参数也可以用 nullptr 或值为 0 的常量表达式来实例化 inline 和 constexpr 的函数模板inline 和 constexpr 说明符放在模板参数列表后面，返回类型之前 //正确：inline说明符在模板参数列表之后 templateinline T min(const T\u0026, const T\u0026); //错误：inline位置不正确 inline templateT min(const T\u0026, const T\u0026); 编写类型无关的代码编写泛型代码两个重要原则： 模板中的函数参数是 const 的引用 函数体中的条件判断仅用 如果需要类型无关和可移植性，可以使用 less 函数对象来定义 template int compare(const T \u0026v1, const T \u0026v2) { if (less()(v1, v2)) return -1; if (less()(v2, v1)) return 1; return 0; } 模板编译编译器遇见一个模板定义时，并不生成代码，只有当实例化出模板的一个特定版本时，编译器才会生成代码 模板为了生成一个实例化版本，需要函数模板或类模板成员函数的定义，与非模板代码不同，模板的头文件通常即包括声明也包括定义 大多数编译错误在实例化期间报告模板直到实例化才会生成代码，通常编译器在三个阶段报告错误： 编译模板本身，基本的语法错误（忘记分号，变量名拼错等） 编译器遇到模板使用时，函数模板会检查实参数目是否正确，参数类型是否匹配，类模板是否提供了正确数目的模板实参 模板实例化时，只有这个阶段才会发现类型相关的错误 例如：之前的 compare 函数，如果传入一个类类型 Sales_data data1, data2; cout ","date":"2022-05-07","objectID":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/:1:1","series":null,"tags":["C++"],"title":"《C++Primer》| 第十六章 模板与泛型编程","uri":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/#大多数编译错误在实例化期间报告"},{"categories":["C++"],"content":"16.1.2 类模板类模板用来生成类的蓝图，类模板必须提供额外的信息，来确定模板的参数类型，一般在模板名后尖括号中提供实参 定义类模板 template \u003ctypename T\u003e class Blob { public: typedef T value_type; typedef typename std::vector\u003cT\u003e::size_type size_type; //构造函数 Blob(); Blob(std::initializer_list\u003cT\u003e il); //Blob中元素数目 size_type size() const { return data-\u003esize(); } bool empty() const { return data-\u003eempty(); } void push_back(const T\u0026 t) { return data-\u003epush_back(t);} void pop_back(); //元素访问 T\u0026 back(); T\u0026 operator[](size_type i); private: std::shared_ptr\u003cstd::vector\u003cT\u003e\u003e data; //若data[i]无效，抛出msg void check(size_type i, const std::string \u0026msg) const; }； 实例化类模板使用一个类模板时，需要提供额外信息，这些额外信息是显示模板实参列表，它们被绑定到模板参数 //使用类模板，必须提供元素类型 Blob\u003cint\u003e ia; Blob\u003cint\u003e ia2 = {0, 1, 2, 3}; ia 和 ia2会实例化以下特定版本的 Blob\u003cint\u003e ` template \u003c\u003e class Blob\u003cint\u003e { typedef typename std::vector\u003cint\u003e::size_type size_type; Blob(); Blob(std::initializer_list\u003cint\u003e il); //... } 当编译器从 Blob 模板中实例化一个类时，它会重写 Blob 模板，将参数 T 的每个实例替换成给定的模板实参 一个类模板的每个实例都形成一个独立的类，类型 Blob\u003cstring\u003e 与其他任何 Blob类型都没有关系，也不会对任何其他 Blob 类型的成员具有特殊的访问权限 类模板的成员函数与其他类一样，既可以在类模板内部，也可以在外部定义其成员函数，且定义在类模板内的成员函数被隐式声明为内联函数 类模板的成员函数本身是一个普通函数 每个类模板的实例都有自己版本的成员函数 类模板的成员函数具有和模板相同的模板参数 定义在类模板之外的成员函数就必须以关键字 template 开始，后接参数列表 简单说就是在类模板内部定义成员函数，可以直接使用参数 T，而在类模板外部定义成员函数，前面需要加上 template 等 template \u003ctypename T\u003e ret-type Blob\u003cT\u003e::member-name(parm-list) 这里必须加上 template 这行 类模板成员函数实例化默认情况下，类模板的成员函数只有当程序使用它的时候才进行实例化 // 实例化Blob\u003cint\u003e和接受initializer_list\u003cint\u003e的构造函数 Blob\u003cint\u003e squares = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; for (size_t i = 0; i != squares.size(); ++i) { squares[i] = i * i; //实例化Blob\u003cint\u003e::operator[](size_t) } 如果一个成员函数没有被使用，则它不会被实例化 类代码内简化模板类名的使用在使用一个类模板类型时必须提供模板实参，但是在类模板自己的作用域中，可以直接使用模板名而不提供实参 template \u003ctypename T\u003e class BlobPtr { public: BlobPtr() : curr(0) {} //其他构造函数 T\u0026 operator*() const { auto p = check(curr, \"derederence past edn\"); return (*p)[curr]; } //递增和递减 BlobPtr\u0026 operator++(); //求值运算符 BlobPtr\u0026 operator--(); private: //其他成员 std::size_t curr; //数组中的位置 } 这里前置递增和递减成员返回的时 BlobPtr\u0026，而不是 BlobPtr\u003cT\u003e\u0026，在类模板作用域中，编译器处理模板自身引用会自动提供模板匹配的实参 类模板外使用类模板名在类模板外定义成员时，此时不在类的作用域，直到遇见类名菜进入类的作用域 //后置++版本 template \u003ctypename T\u003e BlobPtr\u003cT\u003e BlobPtr\u003cT\u003e::operator++(int) { BlobPtr ret = *this; ++*this; return ret; } 返回类型位于类的作用域之外，所以必须指出返回类型是一个实例化的 BlobPtr，在函数体内已经进入类的作用域，则定义 ret 时无须重复提供模板实参，如果不通过模板实参，编译器假定使用的类型与成员实例化所用类型一致，等价于：BlobPtr\u003cT\u003e ret = *this; 类模板和友元 一个类包含一个友元声明，类与友元各自是否是模板是互相无关的 如果一个模板包括一个非模板友元，则友元可以访问所以模板实例 如果友元自身也是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例 一对一友好关系类模板与另一个（类或函数）模板间友好关系的最常见的形式是建立对应实例及其友元间的友好关系。例如，我们的 Blob 类应该将 BlobPtr 类和一个模板版本的 Blob template \u003ctypename\u003e class BlobPtr; //需要提前声明 template \u003ctypename\u003e class Blob; template \u003ctypename T\u003e bool operator==(const Blob\u003cT\u003e\u0026, const Blob\u003cT\u003e\u0026); template \u003ctypename T\u003e class Blob { friend class BlobPtr\u003cT\u003e; friend bool operator==\u003cT\u003e (const Blob\u003cT\u003e\u0026, const Blob\u003cT\u003e\u0026); //其他成员 } 友元的声明用 Blob 的模板形参作为自己的模板实参，友好关系被限定在相同类型实例化的 Blob 和 BlobPtr 相等运算符之间 //BlobPtr\u003cchar\u003e和operator==\u003cchar\u003e都是本对象的友元 Blob\u003cchar\u003e ca; //BlobPtr\u003cint\u003e和operator==\u003cint\u003e都是本对象的友元 Blob\u003cint\u003e ia; 上面例子中，ca 对 ia 或其他实例没有特殊访问权限 通用和特定模板的友好关系一个类也可以将另一个模板的每个实例都声明为自己的友元，或者限定特定的实例为友元 template \u003ctypename T\u003e class Pal; class C { //C是普通非模板类 friend class Pal\u003cC\u003e;//C实例化Pal是C的友元 //Pal2的所有实例都是C的友元，这种情况无须前置声明 template \u003ctypename T\u003e friend class Pal2; }; template \u003ctypename T\u003e class C2 {//C2是个模板类 //C2每个实例将相同实例的Pal声明为友元 friend class Pal\u003cT\u003e; //Pal2所有实例都是C2每个实例的友元，不需要前置声明 template \u003ctypename X\u003e friend class Pal2; //Pal3是一个非模板类，它是C2所有实例的友元 friend class Pal3; }; 为了让所有实例都成为友元，友元声明中必须使用与类模板不同的模板参数 令模板自己的类型参数成为友元在C++11新标准中，可以将模板类型参数声明为友元 template \u003ctypename Type\u003e class Bar { friend Type; //访问权限授予实例化Bar的类型 //... } 此时，对于某个类型 Foo，Foo 将称为 Bar\u003cFoo\u003e 的友元，Sales_data 将成为 Bar\u003cSales_data\u003e 的友元 模板类型别名类模板一个实例定义了一个类类型，我们可以定义一个 typedef 来引用实例化的类： typedef Blob\u003cstring\u003e StrBlob; 由于模板不是一个类型，我们不能定义一个 typedef 引用一个模板，即不能定义一个 typedef 引用 Blob\u003cT\u003e 但是新标准允许为类模板定义一个类型别名： template\u003ctypename T\u003e using twin = pair\u003cT, T\u003e; twin\u003cstring\u003e authors; //authors是一个pair\u003cstring, strin\u003e 使用别名时，也需要像模板那样指出特定类型的 twin 使用一个模板类型别名时，可以固定一个或多个模板参数 template \u003ctypename T\u003e using partNo = pair\u003cT, unsigned\u003e; partNo\u003cstring\u003e books; /","date":"2022-05-07","objectID":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/:1:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十六章 模板与泛型编程","uri":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/#1612-类模板"},{"categories":["C++"],"content":"16.1.2 类模板类模板用来生成类的蓝图，类模板必须提供额外的信息，来确定模板的参数类型，一般在模板名后尖括号中提供实参 定义类模板 template class Blob { public: typedef T value_type; typedef typename std::vector::size_type size_type; //构造函数 Blob(); Blob(std::initializer_list il); //Blob中元素数目 size_type size() const { return data-size(); } bool empty() const { return data-empty(); } void push_back(const T\u0026 t) { return data-push_back(t);} void pop_back(); //元素访问 T\u0026 back(); T\u0026 operator[](size_type i); private: std::shared_ptr data; //若data[i]无效，抛出msg void check(size_type i, const std::string \u0026msg) const; }； 实例化类模板使用一个类模板时，需要提供额外信息，这些额外信息是显示模板实参列表，它们被绑定到模板参数 //使用类模板，必须提供元素类型 Blob ia; Blob ia2 = {0, 1, 2, 3}; ia 和 ia2会实例化以下特定版本的 Blob ` template class Blob { typedef typename std::vector::size_type size_type; Blob(); Blob(std::initializer_list il); //... } 当编译器从 Blob 模板中实例化一个类时，它会重写 Blob 模板，将参数 T 的每个实例替换成给定的模板实参 一个类模板的每个实例都形成一个独立的类，类型 Blob 与其他任何 Blob类型都没有关系，也不会对任何其他 Blob 类型的成员具有特殊的访问权限 类模板的成员函数与其他类一样，既可以在类模板内部，也可以在外部定义其成员函数，且定义在类模板内的成员函数被隐式声明为内联函数 类模板的成员函数本身是一个普通函数 每个类模板的实例都有自己版本的成员函数 类模板的成员函数具有和模板相同的模板参数 定义在类模板之外的成员函数就必须以关键字 template 开始，后接参数列表 简单说就是在类模板内部定义成员函数，可以直接使用参数 T，而在类模板外部定义成员函数，前面需要加上 template 等 template ret-type Blob::member-name(parm-list) 这里必须加上 template 这行 类模板成员函数实例化默认情况下，类模板的成员函数只有当程序使用它的时候才进行实例化 // 实例化Blob和接受initializer_list的构造函数 Blob squares = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; for (size_t i = 0; i != squares.size(); ++i) { squares[i] = i * i; //实例化Blob::operator[](size_t) } 如果一个成员函数没有被使用，则它不会被实例化 类代码内简化模板类名的使用在使用一个类模板类型时必须提供模板实参，但是在类模板自己的作用域中，可以直接使用模板名而不提供实参 template class BlobPtr { public: BlobPtr() : curr(0) {} //其他构造函数 T\u0026 operator*() const { auto p = check(curr, \"derederence past edn\"); return (*p)[curr]; } //递增和递减 BlobPtr\u0026 operator++(); //求值运算符 BlobPtr\u0026 operator--(); private: //其他成员 std::size_t curr; //数组中的位置 } 这里前置递增和递减成员返回的时 BlobPtr\u0026，而不是 BlobPtr\u0026，在类模板作用域中，编译器处理模板自身引用会自动提供模板匹配的实参 类模板外使用类模板名在类模板外定义成员时，此时不在类的作用域，直到遇见类名菜进入类的作用域 //后置++版本 template BlobPtr BlobPtr::operator++(int) { BlobPtr ret = *this; ++*this; return ret; } 返回类型位于类的作用域之外，所以必须指出返回类型是一个实例化的 BlobPtr，在函数体内已经进入类的作用域，则定义 ret 时无须重复提供模板实参，如果不通过模板实参，编译器假定使用的类型与成员实例化所用类型一致，等价于：BlobPtr ret = *this; 类模板和友元 一个类包含一个友元声明，类与友元各自是否是模板是互相无关的 如果一个模板包括一个非模板友元，则友元可以访问所以模板实例 如果友元自身也是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例 一对一友好关系类模板与另一个（类或函数）模板间友好关系的最常见的形式是建立对应实例及其友元间的友好关系。例如，我们的 Blob 类应该将 BlobPtr 类和一个模板版本的 Blob template class BlobPtr; //需要提前声明 template class Blob; template bool operator==(const Blob\u0026, const Blob\u0026); template class Blob { friend class BlobPtr; friend bool operator== (const Blob\u0026, const Blob\u0026); //其他成员 } 友元的声明用 Blob 的模板形参作为自己的模板实参，友好关系被限定在相同类型实例化的 Blob 和 BlobPtr 相等运算符之间 //BlobPtr和operator==都是本对象的友元 Blob ca; //BlobPtr和operator==都是本对象的友元 Blob ia; 上面例子中，ca 对 ia 或其他实例没有特殊访问权限 通用和特定模板的友好关系一个类也可以将另一个模板的每个实例都声明为自己的友元，或者限定特定的实例为友元 template class Pal; class C { //C是普通非模板类 friend class Pal;//C实例化Pal是C的友元 //Pal2的所有实例都是C的友元，这种情况无须前置声明 template friend class Pal2; }; template class C2 {//C2是个模板类 //C2每个实例将相同实例的Pal声明为友元 friend class Pal; //Pal2所有实例都是C2每个实例的友元，不需要前置声明 template friend class Pal2; //Pal3是一个非模板类，它是C2所有实例的友元 friend class Pal3; }; 为了让所有实例都成为友元，友元声明中必须使用与类模板不同的模板参数 令模板自己的类型参数成为友元在C++11新标准中，可以将模板类型参数声明为友元 template class Bar { friend Type; //访问权限授予实例化Bar的类型 //... } 此时，对于某个类型 Foo，Foo 将称为 Bar 的友元，Sales_data 将成为 Bar 的友元 模板类型别名类模板一个实例定义了一个类类型，我们可以定义一个 typedef 来引用实例化的类： typedef Blob StrBlob; 由于模板不是一个类型，我们不能定义一个 typedef 引用一个模板，即不能定义一个 typedef 引用 Blob 但是新标准允许为类模板定义一个类型别名： templateusing twin = pair; twin authors; //authors是一个pair使用别名时，也需要像模板那样指出特定类型的 twin 使用一个模板类型别名时，可以固定一个或多个模板参数 template using partNo = pair; partNo books; /","date":"2022-05-07","objectID":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/:1:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十六章 模板与泛型编程","uri":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/#定义类模板"},{"categories":["C++"],"content":"16.1.2 类模板类模板用来生成类的蓝图，类模板必须提供额外的信息，来确定模板的参数类型，一般在模板名后尖括号中提供实参 定义类模板 template class Blob { public: typedef T value_type; typedef typename std::vector::size_type size_type; //构造函数 Blob(); Blob(std::initializer_list il); //Blob中元素数目 size_type size() const { return data-size(); } bool empty() const { return data-empty(); } void push_back(const T\u0026 t) { return data-push_back(t);} void pop_back(); //元素访问 T\u0026 back(); T\u0026 operator[](size_type i); private: std::shared_ptr data; //若data[i]无效，抛出msg void check(size_type i, const std::string \u0026msg) const; }； 实例化类模板使用一个类模板时，需要提供额外信息，这些额外信息是显示模板实参列表，它们被绑定到模板参数 //使用类模板，必须提供元素类型 Blob ia; Blob ia2 = {0, 1, 2, 3}; ia 和 ia2会实例化以下特定版本的 Blob ` template class Blob { typedef typename std::vector::size_type size_type; Blob(); Blob(std::initializer_list il); //... } 当编译器从 Blob 模板中实例化一个类时，它会重写 Blob 模板，将参数 T 的每个实例替换成给定的模板实参 一个类模板的每个实例都形成一个独立的类，类型 Blob 与其他任何 Blob类型都没有关系，也不会对任何其他 Blob 类型的成员具有特殊的访问权限 类模板的成员函数与其他类一样，既可以在类模板内部，也可以在外部定义其成员函数，且定义在类模板内的成员函数被隐式声明为内联函数 类模板的成员函数本身是一个普通函数 每个类模板的实例都有自己版本的成员函数 类模板的成员函数具有和模板相同的模板参数 定义在类模板之外的成员函数就必须以关键字 template 开始，后接参数列表 简单说就是在类模板内部定义成员函数，可以直接使用参数 T，而在类模板外部定义成员函数，前面需要加上 template 等 template ret-type Blob::member-name(parm-list) 这里必须加上 template 这行 类模板成员函数实例化默认情况下，类模板的成员函数只有当程序使用它的时候才进行实例化 // 实例化Blob和接受initializer_list的构造函数 Blob squares = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; for (size_t i = 0; i != squares.size(); ++i) { squares[i] = i * i; //实例化Blob::operator[](size_t) } 如果一个成员函数没有被使用，则它不会被实例化 类代码内简化模板类名的使用在使用一个类模板类型时必须提供模板实参，但是在类模板自己的作用域中，可以直接使用模板名而不提供实参 template class BlobPtr { public: BlobPtr() : curr(0) {} //其他构造函数 T\u0026 operator*() const { auto p = check(curr, \"derederence past edn\"); return (*p)[curr]; } //递增和递减 BlobPtr\u0026 operator++(); //求值运算符 BlobPtr\u0026 operator--(); private: //其他成员 std::size_t curr; //数组中的位置 } 这里前置递增和递减成员返回的时 BlobPtr\u0026，而不是 BlobPtr\u0026，在类模板作用域中，编译器处理模板自身引用会自动提供模板匹配的实参 类模板外使用类模板名在类模板外定义成员时，此时不在类的作用域，直到遇见类名菜进入类的作用域 //后置++版本 template BlobPtr BlobPtr::operator++(int) { BlobPtr ret = *this; ++*this; return ret; } 返回类型位于类的作用域之外，所以必须指出返回类型是一个实例化的 BlobPtr，在函数体内已经进入类的作用域，则定义 ret 时无须重复提供模板实参，如果不通过模板实参，编译器假定使用的类型与成员实例化所用类型一致，等价于：BlobPtr ret = *this; 类模板和友元 一个类包含一个友元声明，类与友元各自是否是模板是互相无关的 如果一个模板包括一个非模板友元，则友元可以访问所以模板实例 如果友元自身也是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例 一对一友好关系类模板与另一个（类或函数）模板间友好关系的最常见的形式是建立对应实例及其友元间的友好关系。例如，我们的 Blob 类应该将 BlobPtr 类和一个模板版本的 Blob template class BlobPtr; //需要提前声明 template class Blob; template bool operator==(const Blob\u0026, const Blob\u0026); template class Blob { friend class BlobPtr; friend bool operator== (const Blob\u0026, const Blob\u0026); //其他成员 } 友元的声明用 Blob 的模板形参作为自己的模板实参，友好关系被限定在相同类型实例化的 Blob 和 BlobPtr 相等运算符之间 //BlobPtr和operator==都是本对象的友元 Blob ca; //BlobPtr和operator==都是本对象的友元 Blob ia; 上面例子中，ca 对 ia 或其他实例没有特殊访问权限 通用和特定模板的友好关系一个类也可以将另一个模板的每个实例都声明为自己的友元，或者限定特定的实例为友元 template class Pal; class C { //C是普通非模板类 friend class Pal;//C实例化Pal是C的友元 //Pal2的所有实例都是C的友元，这种情况无须前置声明 template friend class Pal2; }; template class C2 {//C2是个模板类 //C2每个实例将相同实例的Pal声明为友元 friend class Pal; //Pal2所有实例都是C2每个实例的友元，不需要前置声明 template friend class Pal2; //Pal3是一个非模板类，它是C2所有实例的友元 friend class Pal3; }; 为了让所有实例都成为友元，友元声明中必须使用与类模板不同的模板参数 令模板自己的类型参数成为友元在C++11新标准中，可以将模板类型参数声明为友元 template class Bar { friend Type; //访问权限授予实例化Bar的类型 //... } 此时，对于某个类型 Foo，Foo 将称为 Bar 的友元，Sales_data 将成为 Bar 的友元 模板类型别名类模板一个实例定义了一个类类型，我们可以定义一个 typedef 来引用实例化的类： typedef Blob StrBlob; 由于模板不是一个类型，我们不能定义一个 typedef 引用一个模板，即不能定义一个 typedef 引用 Blob 但是新标准允许为类模板定义一个类型别名： templateusing twin = pair; twin authors; //authors是一个pair使用别名时，也需要像模板那样指出特定类型的 twin 使用一个模板类型别名时，可以固定一个或多个模板参数 template using partNo = pair; partNo books; /","date":"2022-05-07","objectID":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/:1:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十六章 模板与泛型编程","uri":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/#实例化类模板"},{"categories":["C++"],"content":"16.1.2 类模板类模板用来生成类的蓝图，类模板必须提供额外的信息，来确定模板的参数类型，一般在模板名后尖括号中提供实参 定义类模板 template class Blob { public: typedef T value_type; typedef typename std::vector::size_type size_type; //构造函数 Blob(); Blob(std::initializer_list il); //Blob中元素数目 size_type size() const { return data-size(); } bool empty() const { return data-empty(); } void push_back(const T\u0026 t) { return data-push_back(t);} void pop_back(); //元素访问 T\u0026 back(); T\u0026 operator[](size_type i); private: std::shared_ptr data; //若data[i]无效，抛出msg void check(size_type i, const std::string \u0026msg) const; }； 实例化类模板使用一个类模板时，需要提供额外信息，这些额外信息是显示模板实参列表，它们被绑定到模板参数 //使用类模板，必须提供元素类型 Blob ia; Blob ia2 = {0, 1, 2, 3}; ia 和 ia2会实例化以下特定版本的 Blob ` template class Blob { typedef typename std::vector::size_type size_type; Blob(); Blob(std::initializer_list il); //... } 当编译器从 Blob 模板中实例化一个类时，它会重写 Blob 模板，将参数 T 的每个实例替换成给定的模板实参 一个类模板的每个实例都形成一个独立的类，类型 Blob 与其他任何 Blob类型都没有关系，也不会对任何其他 Blob 类型的成员具有特殊的访问权限 类模板的成员函数与其他类一样，既可以在类模板内部，也可以在外部定义其成员函数，且定义在类模板内的成员函数被隐式声明为内联函数 类模板的成员函数本身是一个普通函数 每个类模板的实例都有自己版本的成员函数 类模板的成员函数具有和模板相同的模板参数 定义在类模板之外的成员函数就必须以关键字 template 开始，后接参数列表 简单说就是在类模板内部定义成员函数，可以直接使用参数 T，而在类模板外部定义成员函数，前面需要加上 template 等 template ret-type Blob::member-name(parm-list) 这里必须加上 template 这行 类模板成员函数实例化默认情况下，类模板的成员函数只有当程序使用它的时候才进行实例化 // 实例化Blob和接受initializer_list的构造函数 Blob squares = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; for (size_t i = 0; i != squares.size(); ++i) { squares[i] = i * i; //实例化Blob::operator[](size_t) } 如果一个成员函数没有被使用，则它不会被实例化 类代码内简化模板类名的使用在使用一个类模板类型时必须提供模板实参，但是在类模板自己的作用域中，可以直接使用模板名而不提供实参 template class BlobPtr { public: BlobPtr() : curr(0) {} //其他构造函数 T\u0026 operator*() const { auto p = check(curr, \"derederence past edn\"); return (*p)[curr]; } //递增和递减 BlobPtr\u0026 operator++(); //求值运算符 BlobPtr\u0026 operator--(); private: //其他成员 std::size_t curr; //数组中的位置 } 这里前置递增和递减成员返回的时 BlobPtr\u0026，而不是 BlobPtr\u0026，在类模板作用域中，编译器处理模板自身引用会自动提供模板匹配的实参 类模板外使用类模板名在类模板外定义成员时，此时不在类的作用域，直到遇见类名菜进入类的作用域 //后置++版本 template BlobPtr BlobPtr::operator++(int) { BlobPtr ret = *this; ++*this; return ret; } 返回类型位于类的作用域之外，所以必须指出返回类型是一个实例化的 BlobPtr，在函数体内已经进入类的作用域，则定义 ret 时无须重复提供模板实参，如果不通过模板实参，编译器假定使用的类型与成员实例化所用类型一致，等价于：BlobPtr ret = *this; 类模板和友元 一个类包含一个友元声明，类与友元各自是否是模板是互相无关的 如果一个模板包括一个非模板友元，则友元可以访问所以模板实例 如果友元自身也是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例 一对一友好关系类模板与另一个（类或函数）模板间友好关系的最常见的形式是建立对应实例及其友元间的友好关系。例如，我们的 Blob 类应该将 BlobPtr 类和一个模板版本的 Blob template class BlobPtr; //需要提前声明 template class Blob; template bool operator==(const Blob\u0026, const Blob\u0026); template class Blob { friend class BlobPtr; friend bool operator== (const Blob\u0026, const Blob\u0026); //其他成员 } 友元的声明用 Blob 的模板形参作为自己的模板实参，友好关系被限定在相同类型实例化的 Blob 和 BlobPtr 相等运算符之间 //BlobPtr和operator==都是本对象的友元 Blob ca; //BlobPtr和operator==都是本对象的友元 Blob ia; 上面例子中，ca 对 ia 或其他实例没有特殊访问权限 通用和特定模板的友好关系一个类也可以将另一个模板的每个实例都声明为自己的友元，或者限定特定的实例为友元 template class Pal; class C { //C是普通非模板类 friend class Pal;//C实例化Pal是C的友元 //Pal2的所有实例都是C的友元，这种情况无须前置声明 template friend class Pal2; }; template class C2 {//C2是个模板类 //C2每个实例将相同实例的Pal声明为友元 friend class Pal; //Pal2所有实例都是C2每个实例的友元，不需要前置声明 template friend class Pal2; //Pal3是一个非模板类，它是C2所有实例的友元 friend class Pal3; }; 为了让所有实例都成为友元，友元声明中必须使用与类模板不同的模板参数 令模板自己的类型参数成为友元在C++11新标准中，可以将模板类型参数声明为友元 template class Bar { friend Type; //访问权限授予实例化Bar的类型 //... } 此时，对于某个类型 Foo，Foo 将称为 Bar 的友元，Sales_data 将成为 Bar 的友元 模板类型别名类模板一个实例定义了一个类类型，我们可以定义一个 typedef 来引用实例化的类： typedef Blob StrBlob; 由于模板不是一个类型，我们不能定义一个 typedef 引用一个模板，即不能定义一个 typedef 引用 Blob 但是新标准允许为类模板定义一个类型别名： templateusing twin = pair; twin authors; //authors是一个pair使用别名时，也需要像模板那样指出特定类型的 twin 使用一个模板类型别名时，可以固定一个或多个模板参数 template using partNo = pair; partNo books; /","date":"2022-05-07","objectID":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/:1:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十六章 模板与泛型编程","uri":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/#类模板的成员函数"},{"categories":["C++"],"content":"16.1.2 类模板类模板用来生成类的蓝图，类模板必须提供额外的信息，来确定模板的参数类型，一般在模板名后尖括号中提供实参 定义类模板 template class Blob { public: typedef T value_type; typedef typename std::vector::size_type size_type; //构造函数 Blob(); Blob(std::initializer_list il); //Blob中元素数目 size_type size() const { return data-size(); } bool empty() const { return data-empty(); } void push_back(const T\u0026 t) { return data-push_back(t);} void pop_back(); //元素访问 T\u0026 back(); T\u0026 operator[](size_type i); private: std::shared_ptr data; //若data[i]无效，抛出msg void check(size_type i, const std::string \u0026msg) const; }； 实例化类模板使用一个类模板时，需要提供额外信息，这些额外信息是显示模板实参列表，它们被绑定到模板参数 //使用类模板，必须提供元素类型 Blob ia; Blob ia2 = {0, 1, 2, 3}; ia 和 ia2会实例化以下特定版本的 Blob ` template class Blob { typedef typename std::vector::size_type size_type; Blob(); Blob(std::initializer_list il); //... } 当编译器从 Blob 模板中实例化一个类时，它会重写 Blob 模板，将参数 T 的每个实例替换成给定的模板实参 一个类模板的每个实例都形成一个独立的类，类型 Blob 与其他任何 Blob类型都没有关系，也不会对任何其他 Blob 类型的成员具有特殊的访问权限 类模板的成员函数与其他类一样，既可以在类模板内部，也可以在外部定义其成员函数，且定义在类模板内的成员函数被隐式声明为内联函数 类模板的成员函数本身是一个普通函数 每个类模板的实例都有自己版本的成员函数 类模板的成员函数具有和模板相同的模板参数 定义在类模板之外的成员函数就必须以关键字 template 开始，后接参数列表 简单说就是在类模板内部定义成员函数，可以直接使用参数 T，而在类模板外部定义成员函数，前面需要加上 template 等 template ret-type Blob::member-name(parm-list) 这里必须加上 template 这行 类模板成员函数实例化默认情况下，类模板的成员函数只有当程序使用它的时候才进行实例化 // 实例化Blob和接受initializer_list的构造函数 Blob squares = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; for (size_t i = 0; i != squares.size(); ++i) { squares[i] = i * i; //实例化Blob::operator[](size_t) } 如果一个成员函数没有被使用，则它不会被实例化 类代码内简化模板类名的使用在使用一个类模板类型时必须提供模板实参，但是在类模板自己的作用域中，可以直接使用模板名而不提供实参 template class BlobPtr { public: BlobPtr() : curr(0) {} //其他构造函数 T\u0026 operator*() const { auto p = check(curr, \"derederence past edn\"); return (*p)[curr]; } //递增和递减 BlobPtr\u0026 operator++(); //求值运算符 BlobPtr\u0026 operator--(); private: //其他成员 std::size_t curr; //数组中的位置 } 这里前置递增和递减成员返回的时 BlobPtr\u0026，而不是 BlobPtr\u0026，在类模板作用域中，编译器处理模板自身引用会自动提供模板匹配的实参 类模板外使用类模板名在类模板外定义成员时，此时不在类的作用域，直到遇见类名菜进入类的作用域 //后置++版本 template BlobPtr BlobPtr::operator++(int) { BlobPtr ret = *this; ++*this; return ret; } 返回类型位于类的作用域之外，所以必须指出返回类型是一个实例化的 BlobPtr，在函数体内已经进入类的作用域，则定义 ret 时无须重复提供模板实参，如果不通过模板实参，编译器假定使用的类型与成员实例化所用类型一致，等价于：BlobPtr ret = *this; 类模板和友元 一个类包含一个友元声明，类与友元各自是否是模板是互相无关的 如果一个模板包括一个非模板友元，则友元可以访问所以模板实例 如果友元自身也是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例 一对一友好关系类模板与另一个（类或函数）模板间友好关系的最常见的形式是建立对应实例及其友元间的友好关系。例如，我们的 Blob 类应该将 BlobPtr 类和一个模板版本的 Blob template class BlobPtr; //需要提前声明 template class Blob; template bool operator==(const Blob\u0026, const Blob\u0026); template class Blob { friend class BlobPtr; friend bool operator== (const Blob\u0026, const Blob\u0026); //其他成员 } 友元的声明用 Blob 的模板形参作为自己的模板实参，友好关系被限定在相同类型实例化的 Blob 和 BlobPtr 相等运算符之间 //BlobPtr和operator==都是本对象的友元 Blob ca; //BlobPtr和operator==都是本对象的友元 Blob ia; 上面例子中，ca 对 ia 或其他实例没有特殊访问权限 通用和特定模板的友好关系一个类也可以将另一个模板的每个实例都声明为自己的友元，或者限定特定的实例为友元 template class Pal; class C { //C是普通非模板类 friend class Pal;//C实例化Pal是C的友元 //Pal2的所有实例都是C的友元，这种情况无须前置声明 template friend class Pal2; }; template class C2 {//C2是个模板类 //C2每个实例将相同实例的Pal声明为友元 friend class Pal; //Pal2所有实例都是C2每个实例的友元，不需要前置声明 template friend class Pal2; //Pal3是一个非模板类，它是C2所有实例的友元 friend class Pal3; }; 为了让所有实例都成为友元，友元声明中必须使用与类模板不同的模板参数 令模板自己的类型参数成为友元在C++11新标准中，可以将模板类型参数声明为友元 template class Bar { friend Type; //访问权限授予实例化Bar的类型 //... } 此时，对于某个类型 Foo，Foo 将称为 Bar 的友元，Sales_data 将成为 Bar 的友元 模板类型别名类模板一个实例定义了一个类类型，我们可以定义一个 typedef 来引用实例化的类： typedef Blob StrBlob; 由于模板不是一个类型，我们不能定义一个 typedef 引用一个模板，即不能定义一个 typedef 引用 Blob 但是新标准允许为类模板定义一个类型别名： templateusing twin = pair; twin authors; //authors是一个pair使用别名时，也需要像模板那样指出特定类型的 twin 使用一个模板类型别名时，可以固定一个或多个模板参数 template using partNo = pair; partNo books; /","date":"2022-05-07","objectID":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/:1:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十六章 模板与泛型编程","uri":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/#类模板成员函数实例化"},{"categories":["C++"],"content":"16.1.2 类模板类模板用来生成类的蓝图，类模板必须提供额外的信息，来确定模板的参数类型，一般在模板名后尖括号中提供实参 定义类模板 template class Blob { public: typedef T value_type; typedef typename std::vector::size_type size_type; //构造函数 Blob(); Blob(std::initializer_list il); //Blob中元素数目 size_type size() const { return data-size(); } bool empty() const { return data-empty(); } void push_back(const T\u0026 t) { return data-push_back(t);} void pop_back(); //元素访问 T\u0026 back(); T\u0026 operator[](size_type i); private: std::shared_ptr data; //若data[i]无效，抛出msg void check(size_type i, const std::string \u0026msg) const; }； 实例化类模板使用一个类模板时，需要提供额外信息，这些额外信息是显示模板实参列表，它们被绑定到模板参数 //使用类模板，必须提供元素类型 Blob ia; Blob ia2 = {0, 1, 2, 3}; ia 和 ia2会实例化以下特定版本的 Blob ` template class Blob { typedef typename std::vector::size_type size_type; Blob(); Blob(std::initializer_list il); //... } 当编译器从 Blob 模板中实例化一个类时，它会重写 Blob 模板，将参数 T 的每个实例替换成给定的模板实参 一个类模板的每个实例都形成一个独立的类，类型 Blob 与其他任何 Blob类型都没有关系，也不会对任何其他 Blob 类型的成员具有特殊的访问权限 类模板的成员函数与其他类一样，既可以在类模板内部，也可以在外部定义其成员函数，且定义在类模板内的成员函数被隐式声明为内联函数 类模板的成员函数本身是一个普通函数 每个类模板的实例都有自己版本的成员函数 类模板的成员函数具有和模板相同的模板参数 定义在类模板之外的成员函数就必须以关键字 template 开始，后接参数列表 简单说就是在类模板内部定义成员函数，可以直接使用参数 T，而在类模板外部定义成员函数，前面需要加上 template 等 template ret-type Blob::member-name(parm-list) 这里必须加上 template 这行 类模板成员函数实例化默认情况下，类模板的成员函数只有当程序使用它的时候才进行实例化 // 实例化Blob和接受initializer_list的构造函数 Blob squares = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; for (size_t i = 0; i != squares.size(); ++i) { squares[i] = i * i; //实例化Blob::operator[](size_t) } 如果一个成员函数没有被使用，则它不会被实例化 类代码内简化模板类名的使用在使用一个类模板类型时必须提供模板实参，但是在类模板自己的作用域中，可以直接使用模板名而不提供实参 template class BlobPtr { public: BlobPtr() : curr(0) {} //其他构造函数 T\u0026 operator*() const { auto p = check(curr, \"derederence past edn\"); return (*p)[curr]; } //递增和递减 BlobPtr\u0026 operator++(); //求值运算符 BlobPtr\u0026 operator--(); private: //其他成员 std::size_t curr; //数组中的位置 } 这里前置递增和递减成员返回的时 BlobPtr\u0026，而不是 BlobPtr\u0026，在类模板作用域中，编译器处理模板自身引用会自动提供模板匹配的实参 类模板外使用类模板名在类模板外定义成员时，此时不在类的作用域，直到遇见类名菜进入类的作用域 //后置++版本 template BlobPtr BlobPtr::operator++(int) { BlobPtr ret = *this; ++*this; return ret; } 返回类型位于类的作用域之外，所以必须指出返回类型是一个实例化的 BlobPtr，在函数体内已经进入类的作用域，则定义 ret 时无须重复提供模板实参，如果不通过模板实参，编译器假定使用的类型与成员实例化所用类型一致，等价于：BlobPtr ret = *this; 类模板和友元 一个类包含一个友元声明，类与友元各自是否是模板是互相无关的 如果一个模板包括一个非模板友元，则友元可以访问所以模板实例 如果友元自身也是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例 一对一友好关系类模板与另一个（类或函数）模板间友好关系的最常见的形式是建立对应实例及其友元间的友好关系。例如，我们的 Blob 类应该将 BlobPtr 类和一个模板版本的 Blob template class BlobPtr; //需要提前声明 template class Blob; template bool operator==(const Blob\u0026, const Blob\u0026); template class Blob { friend class BlobPtr; friend bool operator== (const Blob\u0026, const Blob\u0026); //其他成员 } 友元的声明用 Blob 的模板形参作为自己的模板实参，友好关系被限定在相同类型实例化的 Blob 和 BlobPtr 相等运算符之间 //BlobPtr和operator==都是本对象的友元 Blob ca; //BlobPtr和operator==都是本对象的友元 Blob ia; 上面例子中，ca 对 ia 或其他实例没有特殊访问权限 通用和特定模板的友好关系一个类也可以将另一个模板的每个实例都声明为自己的友元，或者限定特定的实例为友元 template class Pal; class C { //C是普通非模板类 friend class Pal;//C实例化Pal是C的友元 //Pal2的所有实例都是C的友元，这种情况无须前置声明 template friend class Pal2; }; template class C2 {//C2是个模板类 //C2每个实例将相同实例的Pal声明为友元 friend class Pal; //Pal2所有实例都是C2每个实例的友元，不需要前置声明 template friend class Pal2; //Pal3是一个非模板类，它是C2所有实例的友元 friend class Pal3; }; 为了让所有实例都成为友元，友元声明中必须使用与类模板不同的模板参数 令模板自己的类型参数成为友元在C++11新标准中，可以将模板类型参数声明为友元 template class Bar { friend Type; //访问权限授予实例化Bar的类型 //... } 此时，对于某个类型 Foo，Foo 将称为 Bar 的友元，Sales_data 将成为 Bar 的友元 模板类型别名类模板一个实例定义了一个类类型，我们可以定义一个 typedef 来引用实例化的类： typedef Blob StrBlob; 由于模板不是一个类型，我们不能定义一个 typedef 引用一个模板，即不能定义一个 typedef 引用 Blob 但是新标准允许为类模板定义一个类型别名： templateusing twin = pair; twin authors; //authors是一个pair使用别名时，也需要像模板那样指出特定类型的 twin 使用一个模板类型别名时，可以固定一个或多个模板参数 template using partNo = pair; partNo books; /","date":"2022-05-07","objectID":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/:1:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十六章 模板与泛型编程","uri":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/#类代码内简化模板类名的使用"},{"categories":["C++"],"content":"16.1.2 类模板类模板用来生成类的蓝图，类模板必须提供额外的信息，来确定模板的参数类型，一般在模板名后尖括号中提供实参 定义类模板 template class Blob { public: typedef T value_type; typedef typename std::vector::size_type size_type; //构造函数 Blob(); Blob(std::initializer_list il); //Blob中元素数目 size_type size() const { return data-size(); } bool empty() const { return data-empty(); } void push_back(const T\u0026 t) { return data-push_back(t);} void pop_back(); //元素访问 T\u0026 back(); T\u0026 operator[](size_type i); private: std::shared_ptr data; //若data[i]无效，抛出msg void check(size_type i, const std::string \u0026msg) const; }； 实例化类模板使用一个类模板时，需要提供额外信息，这些额外信息是显示模板实参列表，它们被绑定到模板参数 //使用类模板，必须提供元素类型 Blob ia; Blob ia2 = {0, 1, 2, 3}; ia 和 ia2会实例化以下特定版本的 Blob ` template class Blob { typedef typename std::vector::size_type size_type; Blob(); Blob(std::initializer_list il); //... } 当编译器从 Blob 模板中实例化一个类时，它会重写 Blob 模板，将参数 T 的每个实例替换成给定的模板实参 一个类模板的每个实例都形成一个独立的类，类型 Blob 与其他任何 Blob类型都没有关系，也不会对任何其他 Blob 类型的成员具有特殊的访问权限 类模板的成员函数与其他类一样，既可以在类模板内部，也可以在外部定义其成员函数，且定义在类模板内的成员函数被隐式声明为内联函数 类模板的成员函数本身是一个普通函数 每个类模板的实例都有自己版本的成员函数 类模板的成员函数具有和模板相同的模板参数 定义在类模板之外的成员函数就必须以关键字 template 开始，后接参数列表 简单说就是在类模板内部定义成员函数，可以直接使用参数 T，而在类模板外部定义成员函数，前面需要加上 template 等 template ret-type Blob::member-name(parm-list) 这里必须加上 template 这行 类模板成员函数实例化默认情况下，类模板的成员函数只有当程序使用它的时候才进行实例化 // 实例化Blob和接受initializer_list的构造函数 Blob squares = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; for (size_t i = 0; i != squares.size(); ++i) { squares[i] = i * i; //实例化Blob::operator[](size_t) } 如果一个成员函数没有被使用，则它不会被实例化 类代码内简化模板类名的使用在使用一个类模板类型时必须提供模板实参，但是在类模板自己的作用域中，可以直接使用模板名而不提供实参 template class BlobPtr { public: BlobPtr() : curr(0) {} //其他构造函数 T\u0026 operator*() const { auto p = check(curr, \"derederence past edn\"); return (*p)[curr]; } //递增和递减 BlobPtr\u0026 operator++(); //求值运算符 BlobPtr\u0026 operator--(); private: //其他成员 std::size_t curr; //数组中的位置 } 这里前置递增和递减成员返回的时 BlobPtr\u0026，而不是 BlobPtr\u0026，在类模板作用域中，编译器处理模板自身引用会自动提供模板匹配的实参 类模板外使用类模板名在类模板外定义成员时，此时不在类的作用域，直到遇见类名菜进入类的作用域 //后置++版本 template BlobPtr BlobPtr::operator++(int) { BlobPtr ret = *this; ++*this; return ret; } 返回类型位于类的作用域之外，所以必须指出返回类型是一个实例化的 BlobPtr，在函数体内已经进入类的作用域，则定义 ret 时无须重复提供模板实参，如果不通过模板实参，编译器假定使用的类型与成员实例化所用类型一致，等价于：BlobPtr ret = *this; 类模板和友元 一个类包含一个友元声明，类与友元各自是否是模板是互相无关的 如果一个模板包括一个非模板友元，则友元可以访问所以模板实例 如果友元自身也是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例 一对一友好关系类模板与另一个（类或函数）模板间友好关系的最常见的形式是建立对应实例及其友元间的友好关系。例如，我们的 Blob 类应该将 BlobPtr 类和一个模板版本的 Blob template class BlobPtr; //需要提前声明 template class Blob; template bool operator==(const Blob\u0026, const Blob\u0026); template class Blob { friend class BlobPtr; friend bool operator== (const Blob\u0026, const Blob\u0026); //其他成员 } 友元的声明用 Blob 的模板形参作为自己的模板实参，友好关系被限定在相同类型实例化的 Blob 和 BlobPtr 相等运算符之间 //BlobPtr和operator==都是本对象的友元 Blob ca; //BlobPtr和operator==都是本对象的友元 Blob ia; 上面例子中，ca 对 ia 或其他实例没有特殊访问权限 通用和特定模板的友好关系一个类也可以将另一个模板的每个实例都声明为自己的友元，或者限定特定的实例为友元 template class Pal; class C { //C是普通非模板类 friend class Pal;//C实例化Pal是C的友元 //Pal2的所有实例都是C的友元，这种情况无须前置声明 template friend class Pal2; }; template class C2 {//C2是个模板类 //C2每个实例将相同实例的Pal声明为友元 friend class Pal; //Pal2所有实例都是C2每个实例的友元，不需要前置声明 template friend class Pal2; //Pal3是一个非模板类，它是C2所有实例的友元 friend class Pal3; }; 为了让所有实例都成为友元，友元声明中必须使用与类模板不同的模板参数 令模板自己的类型参数成为友元在C++11新标准中，可以将模板类型参数声明为友元 template class Bar { friend Type; //访问权限授予实例化Bar的类型 //... } 此时，对于某个类型 Foo，Foo 将称为 Bar 的友元，Sales_data 将成为 Bar 的友元 模板类型别名类模板一个实例定义了一个类类型，我们可以定义一个 typedef 来引用实例化的类： typedef Blob StrBlob; 由于模板不是一个类型，我们不能定义一个 typedef 引用一个模板，即不能定义一个 typedef 引用 Blob 但是新标准允许为类模板定义一个类型别名： templateusing twin = pair; twin authors; //authors是一个pair使用别名时，也需要像模板那样指出特定类型的 twin 使用一个模板类型别名时，可以固定一个或多个模板参数 template using partNo = pair; partNo books; /","date":"2022-05-07","objectID":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/:1:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十六章 模板与泛型编程","uri":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/#类模板外使用类模板名"},{"categories":["C++"],"content":"16.1.2 类模板类模板用来生成类的蓝图，类模板必须提供额外的信息，来确定模板的参数类型，一般在模板名后尖括号中提供实参 定义类模板 template class Blob { public: typedef T value_type; typedef typename std::vector::size_type size_type; //构造函数 Blob(); Blob(std::initializer_list il); //Blob中元素数目 size_type size() const { return data-size(); } bool empty() const { return data-empty(); } void push_back(const T\u0026 t) { return data-push_back(t);} void pop_back(); //元素访问 T\u0026 back(); T\u0026 operator[](size_type i); private: std::shared_ptr data; //若data[i]无效，抛出msg void check(size_type i, const std::string \u0026msg) const; }； 实例化类模板使用一个类模板时，需要提供额外信息，这些额外信息是显示模板实参列表，它们被绑定到模板参数 //使用类模板，必须提供元素类型 Blob ia; Blob ia2 = {0, 1, 2, 3}; ia 和 ia2会实例化以下特定版本的 Blob ` template class Blob { typedef typename std::vector::size_type size_type; Blob(); Blob(std::initializer_list il); //... } 当编译器从 Blob 模板中实例化一个类时，它会重写 Blob 模板，将参数 T 的每个实例替换成给定的模板实参 一个类模板的每个实例都形成一个独立的类，类型 Blob 与其他任何 Blob类型都没有关系，也不会对任何其他 Blob 类型的成员具有特殊的访问权限 类模板的成员函数与其他类一样，既可以在类模板内部，也可以在外部定义其成员函数，且定义在类模板内的成员函数被隐式声明为内联函数 类模板的成员函数本身是一个普通函数 每个类模板的实例都有自己版本的成员函数 类模板的成员函数具有和模板相同的模板参数 定义在类模板之外的成员函数就必须以关键字 template 开始，后接参数列表 简单说就是在类模板内部定义成员函数，可以直接使用参数 T，而在类模板外部定义成员函数，前面需要加上 template 等 template ret-type Blob::member-name(parm-list) 这里必须加上 template 这行 类模板成员函数实例化默认情况下，类模板的成员函数只有当程序使用它的时候才进行实例化 // 实例化Blob和接受initializer_list的构造函数 Blob squares = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; for (size_t i = 0; i != squares.size(); ++i) { squares[i] = i * i; //实例化Blob::operator[](size_t) } 如果一个成员函数没有被使用，则它不会被实例化 类代码内简化模板类名的使用在使用一个类模板类型时必须提供模板实参，但是在类模板自己的作用域中，可以直接使用模板名而不提供实参 template class BlobPtr { public: BlobPtr() : curr(0) {} //其他构造函数 T\u0026 operator*() const { auto p = check(curr, \"derederence past edn\"); return (*p)[curr]; } //递增和递减 BlobPtr\u0026 operator++(); //求值运算符 BlobPtr\u0026 operator--(); private: //其他成员 std::size_t curr; //数组中的位置 } 这里前置递增和递减成员返回的时 BlobPtr\u0026，而不是 BlobPtr\u0026，在类模板作用域中，编译器处理模板自身引用会自动提供模板匹配的实参 类模板外使用类模板名在类模板外定义成员时，此时不在类的作用域，直到遇见类名菜进入类的作用域 //后置++版本 template BlobPtr BlobPtr::operator++(int) { BlobPtr ret = *this; ++*this; return ret; } 返回类型位于类的作用域之外，所以必须指出返回类型是一个实例化的 BlobPtr，在函数体内已经进入类的作用域，则定义 ret 时无须重复提供模板实参，如果不通过模板实参，编译器假定使用的类型与成员实例化所用类型一致，等价于：BlobPtr ret = *this; 类模板和友元 一个类包含一个友元声明，类与友元各自是否是模板是互相无关的 如果一个模板包括一个非模板友元，则友元可以访问所以模板实例 如果友元自身也是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例 一对一友好关系类模板与另一个（类或函数）模板间友好关系的最常见的形式是建立对应实例及其友元间的友好关系。例如，我们的 Blob 类应该将 BlobPtr 类和一个模板版本的 Blob template class BlobPtr; //需要提前声明 template class Blob; template bool operator==(const Blob\u0026, const Blob\u0026); template class Blob { friend class BlobPtr; friend bool operator== (const Blob\u0026, const Blob\u0026); //其他成员 } 友元的声明用 Blob 的模板形参作为自己的模板实参，友好关系被限定在相同类型实例化的 Blob 和 BlobPtr 相等运算符之间 //BlobPtr和operator==都是本对象的友元 Blob ca; //BlobPtr和operator==都是本对象的友元 Blob ia; 上面例子中，ca 对 ia 或其他实例没有特殊访问权限 通用和特定模板的友好关系一个类也可以将另一个模板的每个实例都声明为自己的友元，或者限定特定的实例为友元 template class Pal; class C { //C是普通非模板类 friend class Pal;//C实例化Pal是C的友元 //Pal2的所有实例都是C的友元，这种情况无须前置声明 template friend class Pal2; }; template class C2 {//C2是个模板类 //C2每个实例将相同实例的Pal声明为友元 friend class Pal; //Pal2所有实例都是C2每个实例的友元，不需要前置声明 template friend class Pal2; //Pal3是一个非模板类，它是C2所有实例的友元 friend class Pal3; }; 为了让所有实例都成为友元，友元声明中必须使用与类模板不同的模板参数 令模板自己的类型参数成为友元在C++11新标准中，可以将模板类型参数声明为友元 template class Bar { friend Type; //访问权限授予实例化Bar的类型 //... } 此时，对于某个类型 Foo，Foo 将称为 Bar 的友元，Sales_data 将成为 Bar 的友元 模板类型别名类模板一个实例定义了一个类类型，我们可以定义一个 typedef 来引用实例化的类： typedef Blob StrBlob; 由于模板不是一个类型，我们不能定义一个 typedef 引用一个模板，即不能定义一个 typedef 引用 Blob 但是新标准允许为类模板定义一个类型别名： templateusing twin = pair; twin authors; //authors是一个pair使用别名时，也需要像模板那样指出特定类型的 twin 使用一个模板类型别名时，可以固定一个或多个模板参数 template using partNo = pair; partNo books; /","date":"2022-05-07","objectID":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/:1:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十六章 模板与泛型编程","uri":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/#类模板和友元"},{"categories":["C++"],"content":"16.1.2 类模板类模板用来生成类的蓝图，类模板必须提供额外的信息，来确定模板的参数类型，一般在模板名后尖括号中提供实参 定义类模板 template class Blob { public: typedef T value_type; typedef typename std::vector::size_type size_type; //构造函数 Blob(); Blob(std::initializer_list il); //Blob中元素数目 size_type size() const { return data-size(); } bool empty() const { return data-empty(); } void push_back(const T\u0026 t) { return data-push_back(t);} void pop_back(); //元素访问 T\u0026 back(); T\u0026 operator[](size_type i); private: std::shared_ptr data; //若data[i]无效，抛出msg void check(size_type i, const std::string \u0026msg) const; }； 实例化类模板使用一个类模板时，需要提供额外信息，这些额外信息是显示模板实参列表，它们被绑定到模板参数 //使用类模板，必须提供元素类型 Blob ia; Blob ia2 = {0, 1, 2, 3}; ia 和 ia2会实例化以下特定版本的 Blob ` template class Blob { typedef typename std::vector::size_type size_type; Blob(); Blob(std::initializer_list il); //... } 当编译器从 Blob 模板中实例化一个类时，它会重写 Blob 模板，将参数 T 的每个实例替换成给定的模板实参 一个类模板的每个实例都形成一个独立的类，类型 Blob 与其他任何 Blob类型都没有关系，也不会对任何其他 Blob 类型的成员具有特殊的访问权限 类模板的成员函数与其他类一样，既可以在类模板内部，也可以在外部定义其成员函数，且定义在类模板内的成员函数被隐式声明为内联函数 类模板的成员函数本身是一个普通函数 每个类模板的实例都有自己版本的成员函数 类模板的成员函数具有和模板相同的模板参数 定义在类模板之外的成员函数就必须以关键字 template 开始，后接参数列表 简单说就是在类模板内部定义成员函数，可以直接使用参数 T，而在类模板外部定义成员函数，前面需要加上 template 等 template ret-type Blob::member-name(parm-list) 这里必须加上 template 这行 类模板成员函数实例化默认情况下，类模板的成员函数只有当程序使用它的时候才进行实例化 // 实例化Blob和接受initializer_list的构造函数 Blob squares = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; for (size_t i = 0; i != squares.size(); ++i) { squares[i] = i * i; //实例化Blob::operator[](size_t) } 如果一个成员函数没有被使用，则它不会被实例化 类代码内简化模板类名的使用在使用一个类模板类型时必须提供模板实参，但是在类模板自己的作用域中，可以直接使用模板名而不提供实参 template class BlobPtr { public: BlobPtr() : curr(0) {} //其他构造函数 T\u0026 operator*() const { auto p = check(curr, \"derederence past edn\"); return (*p)[curr]; } //递增和递减 BlobPtr\u0026 operator++(); //求值运算符 BlobPtr\u0026 operator--(); private: //其他成员 std::size_t curr; //数组中的位置 } 这里前置递增和递减成员返回的时 BlobPtr\u0026，而不是 BlobPtr\u0026，在类模板作用域中，编译器处理模板自身引用会自动提供模板匹配的实参 类模板外使用类模板名在类模板外定义成员时，此时不在类的作用域，直到遇见类名菜进入类的作用域 //后置++版本 template BlobPtr BlobPtr::operator++(int) { BlobPtr ret = *this; ++*this; return ret; } 返回类型位于类的作用域之外，所以必须指出返回类型是一个实例化的 BlobPtr，在函数体内已经进入类的作用域，则定义 ret 时无须重复提供模板实参，如果不通过模板实参，编译器假定使用的类型与成员实例化所用类型一致，等价于：BlobPtr ret = *this; 类模板和友元 一个类包含一个友元声明，类与友元各自是否是模板是互相无关的 如果一个模板包括一个非模板友元，则友元可以访问所以模板实例 如果友元自身也是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例 一对一友好关系类模板与另一个（类或函数）模板间友好关系的最常见的形式是建立对应实例及其友元间的友好关系。例如，我们的 Blob 类应该将 BlobPtr 类和一个模板版本的 Blob template class BlobPtr; //需要提前声明 template class Blob; template bool operator==(const Blob\u0026, const Blob\u0026); template class Blob { friend class BlobPtr; friend bool operator== (const Blob\u0026, const Blob\u0026); //其他成员 } 友元的声明用 Blob 的模板形参作为自己的模板实参，友好关系被限定在相同类型实例化的 Blob 和 BlobPtr 相等运算符之间 //BlobPtr和operator==都是本对象的友元 Blob ca; //BlobPtr和operator==都是本对象的友元 Blob ia; 上面例子中，ca 对 ia 或其他实例没有特殊访问权限 通用和特定模板的友好关系一个类也可以将另一个模板的每个实例都声明为自己的友元，或者限定特定的实例为友元 template class Pal; class C { //C是普通非模板类 friend class Pal;//C实例化Pal是C的友元 //Pal2的所有实例都是C的友元，这种情况无须前置声明 template friend class Pal2; }; template class C2 {//C2是个模板类 //C2每个实例将相同实例的Pal声明为友元 friend class Pal; //Pal2所有实例都是C2每个实例的友元，不需要前置声明 template friend class Pal2; //Pal3是一个非模板类，它是C2所有实例的友元 friend class Pal3; }; 为了让所有实例都成为友元，友元声明中必须使用与类模板不同的模板参数 令模板自己的类型参数成为友元在C++11新标准中，可以将模板类型参数声明为友元 template class Bar { friend Type; //访问权限授予实例化Bar的类型 //... } 此时，对于某个类型 Foo，Foo 将称为 Bar 的友元，Sales_data 将成为 Bar 的友元 模板类型别名类模板一个实例定义了一个类类型，我们可以定义一个 typedef 来引用实例化的类： typedef Blob StrBlob; 由于模板不是一个类型，我们不能定义一个 typedef 引用一个模板，即不能定义一个 typedef 引用 Blob 但是新标准允许为类模板定义一个类型别名： templateusing twin = pair; twin authors; //authors是一个pair使用别名时，也需要像模板那样指出特定类型的 twin 使用一个模板类型别名时，可以固定一个或多个模板参数 template using partNo = pair; partNo books; /","date":"2022-05-07","objectID":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/:1:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十六章 模板与泛型编程","uri":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/#一对一友好关系"},{"categories":["C++"],"content":"16.1.2 类模板类模板用来生成类的蓝图，类模板必须提供额外的信息，来确定模板的参数类型，一般在模板名后尖括号中提供实参 定义类模板 template class Blob { public: typedef T value_type; typedef typename std::vector::size_type size_type; //构造函数 Blob(); Blob(std::initializer_list il); //Blob中元素数目 size_type size() const { return data-size(); } bool empty() const { return data-empty(); } void push_back(const T\u0026 t) { return data-push_back(t);} void pop_back(); //元素访问 T\u0026 back(); T\u0026 operator[](size_type i); private: std::shared_ptr data; //若data[i]无效，抛出msg void check(size_type i, const std::string \u0026msg) const; }； 实例化类模板使用一个类模板时，需要提供额外信息，这些额外信息是显示模板实参列表，它们被绑定到模板参数 //使用类模板，必须提供元素类型 Blob ia; Blob ia2 = {0, 1, 2, 3}; ia 和 ia2会实例化以下特定版本的 Blob ` template class Blob { typedef typename std::vector::size_type size_type; Blob(); Blob(std::initializer_list il); //... } 当编译器从 Blob 模板中实例化一个类时，它会重写 Blob 模板，将参数 T 的每个实例替换成给定的模板实参 一个类模板的每个实例都形成一个独立的类，类型 Blob 与其他任何 Blob类型都没有关系，也不会对任何其他 Blob 类型的成员具有特殊的访问权限 类模板的成员函数与其他类一样，既可以在类模板内部，也可以在外部定义其成员函数，且定义在类模板内的成员函数被隐式声明为内联函数 类模板的成员函数本身是一个普通函数 每个类模板的实例都有自己版本的成员函数 类模板的成员函数具有和模板相同的模板参数 定义在类模板之外的成员函数就必须以关键字 template 开始，后接参数列表 简单说就是在类模板内部定义成员函数，可以直接使用参数 T，而在类模板外部定义成员函数，前面需要加上 template 等 template ret-type Blob::member-name(parm-list) 这里必须加上 template 这行 类模板成员函数实例化默认情况下，类模板的成员函数只有当程序使用它的时候才进行实例化 // 实例化Blob和接受initializer_list的构造函数 Blob squares = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; for (size_t i = 0; i != squares.size(); ++i) { squares[i] = i * i; //实例化Blob::operator[](size_t) } 如果一个成员函数没有被使用，则它不会被实例化 类代码内简化模板类名的使用在使用一个类模板类型时必须提供模板实参，但是在类模板自己的作用域中，可以直接使用模板名而不提供实参 template class BlobPtr { public: BlobPtr() : curr(0) {} //其他构造函数 T\u0026 operator*() const { auto p = check(curr, \"derederence past edn\"); return (*p)[curr]; } //递增和递减 BlobPtr\u0026 operator++(); //求值运算符 BlobPtr\u0026 operator--(); private: //其他成员 std::size_t curr; //数组中的位置 } 这里前置递增和递减成员返回的时 BlobPtr\u0026，而不是 BlobPtr\u0026，在类模板作用域中，编译器处理模板自身引用会自动提供模板匹配的实参 类模板外使用类模板名在类模板外定义成员时，此时不在类的作用域，直到遇见类名菜进入类的作用域 //后置++版本 template BlobPtr BlobPtr::operator++(int) { BlobPtr ret = *this; ++*this; return ret; } 返回类型位于类的作用域之外，所以必须指出返回类型是一个实例化的 BlobPtr，在函数体内已经进入类的作用域，则定义 ret 时无须重复提供模板实参，如果不通过模板实参，编译器假定使用的类型与成员实例化所用类型一致，等价于：BlobPtr ret = *this; 类模板和友元 一个类包含一个友元声明，类与友元各自是否是模板是互相无关的 如果一个模板包括一个非模板友元，则友元可以访问所以模板实例 如果友元自身也是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例 一对一友好关系类模板与另一个（类或函数）模板间友好关系的最常见的形式是建立对应实例及其友元间的友好关系。例如，我们的 Blob 类应该将 BlobPtr 类和一个模板版本的 Blob template class BlobPtr; //需要提前声明 template class Blob; template bool operator==(const Blob\u0026, const Blob\u0026); template class Blob { friend class BlobPtr; friend bool operator== (const Blob\u0026, const Blob\u0026); //其他成员 } 友元的声明用 Blob 的模板形参作为自己的模板实参，友好关系被限定在相同类型实例化的 Blob 和 BlobPtr 相等运算符之间 //BlobPtr和operator==都是本对象的友元 Blob ca; //BlobPtr和operator==都是本对象的友元 Blob ia; 上面例子中，ca 对 ia 或其他实例没有特殊访问权限 通用和特定模板的友好关系一个类也可以将另一个模板的每个实例都声明为自己的友元，或者限定特定的实例为友元 template class Pal; class C { //C是普通非模板类 friend class Pal;//C实例化Pal是C的友元 //Pal2的所有实例都是C的友元，这种情况无须前置声明 template friend class Pal2; }; template class C2 {//C2是个模板类 //C2每个实例将相同实例的Pal声明为友元 friend class Pal; //Pal2所有实例都是C2每个实例的友元，不需要前置声明 template friend class Pal2; //Pal3是一个非模板类，它是C2所有实例的友元 friend class Pal3; }; 为了让所有实例都成为友元，友元声明中必须使用与类模板不同的模板参数 令模板自己的类型参数成为友元在C++11新标准中，可以将模板类型参数声明为友元 template class Bar { friend Type; //访问权限授予实例化Bar的类型 //... } 此时，对于某个类型 Foo，Foo 将称为 Bar 的友元，Sales_data 将成为 Bar 的友元 模板类型别名类模板一个实例定义了一个类类型，我们可以定义一个 typedef 来引用实例化的类： typedef Blob StrBlob; 由于模板不是一个类型，我们不能定义一个 typedef 引用一个模板，即不能定义一个 typedef 引用 Blob 但是新标准允许为类模板定义一个类型别名： templateusing twin = pair; twin authors; //authors是一个pair使用别名时，也需要像模板那样指出特定类型的 twin 使用一个模板类型别名时，可以固定一个或多个模板参数 template using partNo = pair; partNo books; /","date":"2022-05-07","objectID":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/:1:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十六章 模板与泛型编程","uri":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/#通用和特定模板的友好关系"},{"categories":["C++"],"content":"16.1.2 类模板类模板用来生成类的蓝图，类模板必须提供额外的信息，来确定模板的参数类型，一般在模板名后尖括号中提供实参 定义类模板 template class Blob { public: typedef T value_type; typedef typename std::vector::size_type size_type; //构造函数 Blob(); Blob(std::initializer_list il); //Blob中元素数目 size_type size() const { return data-size(); } bool empty() const { return data-empty(); } void push_back(const T\u0026 t) { return data-push_back(t);} void pop_back(); //元素访问 T\u0026 back(); T\u0026 operator[](size_type i); private: std::shared_ptr data; //若data[i]无效，抛出msg void check(size_type i, const std::string \u0026msg) const; }； 实例化类模板使用一个类模板时，需要提供额外信息，这些额外信息是显示模板实参列表，它们被绑定到模板参数 //使用类模板，必须提供元素类型 Blob ia; Blob ia2 = {0, 1, 2, 3}; ia 和 ia2会实例化以下特定版本的 Blob ` template class Blob { typedef typename std::vector::size_type size_type; Blob(); Blob(std::initializer_list il); //... } 当编译器从 Blob 模板中实例化一个类时，它会重写 Blob 模板，将参数 T 的每个实例替换成给定的模板实参 一个类模板的每个实例都形成一个独立的类，类型 Blob 与其他任何 Blob类型都没有关系，也不会对任何其他 Blob 类型的成员具有特殊的访问权限 类模板的成员函数与其他类一样，既可以在类模板内部，也可以在外部定义其成员函数，且定义在类模板内的成员函数被隐式声明为内联函数 类模板的成员函数本身是一个普通函数 每个类模板的实例都有自己版本的成员函数 类模板的成员函数具有和模板相同的模板参数 定义在类模板之外的成员函数就必须以关键字 template 开始，后接参数列表 简单说就是在类模板内部定义成员函数，可以直接使用参数 T，而在类模板外部定义成员函数，前面需要加上 template 等 template ret-type Blob::member-name(parm-list) 这里必须加上 template 这行 类模板成员函数实例化默认情况下，类模板的成员函数只有当程序使用它的时候才进行实例化 // 实例化Blob和接受initializer_list的构造函数 Blob squares = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; for (size_t i = 0; i != squares.size(); ++i) { squares[i] = i * i; //实例化Blob::operator[](size_t) } 如果一个成员函数没有被使用，则它不会被实例化 类代码内简化模板类名的使用在使用一个类模板类型时必须提供模板实参，但是在类模板自己的作用域中，可以直接使用模板名而不提供实参 template class BlobPtr { public: BlobPtr() : curr(0) {} //其他构造函数 T\u0026 operator*() const { auto p = check(curr, \"derederence past edn\"); return (*p)[curr]; } //递增和递减 BlobPtr\u0026 operator++(); //求值运算符 BlobPtr\u0026 operator--(); private: //其他成员 std::size_t curr; //数组中的位置 } 这里前置递增和递减成员返回的时 BlobPtr\u0026，而不是 BlobPtr\u0026，在类模板作用域中，编译器处理模板自身引用会自动提供模板匹配的实参 类模板外使用类模板名在类模板外定义成员时，此时不在类的作用域，直到遇见类名菜进入类的作用域 //后置++版本 template BlobPtr BlobPtr::operator++(int) { BlobPtr ret = *this; ++*this; return ret; } 返回类型位于类的作用域之外，所以必须指出返回类型是一个实例化的 BlobPtr，在函数体内已经进入类的作用域，则定义 ret 时无须重复提供模板实参，如果不通过模板实参，编译器假定使用的类型与成员实例化所用类型一致，等价于：BlobPtr ret = *this; 类模板和友元 一个类包含一个友元声明，类与友元各自是否是模板是互相无关的 如果一个模板包括一个非模板友元，则友元可以访问所以模板实例 如果友元自身也是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例 一对一友好关系类模板与另一个（类或函数）模板间友好关系的最常见的形式是建立对应实例及其友元间的友好关系。例如，我们的 Blob 类应该将 BlobPtr 类和一个模板版本的 Blob template class BlobPtr; //需要提前声明 template class Blob; template bool operator==(const Blob\u0026, const Blob\u0026); template class Blob { friend class BlobPtr; friend bool operator== (const Blob\u0026, const Blob\u0026); //其他成员 } 友元的声明用 Blob 的模板形参作为自己的模板实参，友好关系被限定在相同类型实例化的 Blob 和 BlobPtr 相等运算符之间 //BlobPtr和operator==都是本对象的友元 Blob ca; //BlobPtr和operator==都是本对象的友元 Blob ia; 上面例子中，ca 对 ia 或其他实例没有特殊访问权限 通用和特定模板的友好关系一个类也可以将另一个模板的每个实例都声明为自己的友元，或者限定特定的实例为友元 template class Pal; class C { //C是普通非模板类 friend class Pal;//C实例化Pal是C的友元 //Pal2的所有实例都是C的友元，这种情况无须前置声明 template friend class Pal2; }; template class C2 {//C2是个模板类 //C2每个实例将相同实例的Pal声明为友元 friend class Pal; //Pal2所有实例都是C2每个实例的友元，不需要前置声明 template friend class Pal2; //Pal3是一个非模板类，它是C2所有实例的友元 friend class Pal3; }; 为了让所有实例都成为友元，友元声明中必须使用与类模板不同的模板参数 令模板自己的类型参数成为友元在C++11新标准中，可以将模板类型参数声明为友元 template class Bar { friend Type; //访问权限授予实例化Bar的类型 //... } 此时，对于某个类型 Foo，Foo 将称为 Bar 的友元，Sales_data 将成为 Bar 的友元 模板类型别名类模板一个实例定义了一个类类型，我们可以定义一个 typedef 来引用实例化的类： typedef Blob StrBlob; 由于模板不是一个类型，我们不能定义一个 typedef 引用一个模板，即不能定义一个 typedef 引用 Blob 但是新标准允许为类模板定义一个类型别名： templateusing twin = pair; twin authors; //authors是一个pair使用别名时，也需要像模板那样指出特定类型的 twin 使用一个模板类型别名时，可以固定一个或多个模板参数 template using partNo = pair; partNo books; /","date":"2022-05-07","objectID":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/:1:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十六章 模板与泛型编程","uri":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/#令模板自己的类型参数成为友元"},{"categories":["C++"],"content":"16.1.2 类模板类模板用来生成类的蓝图，类模板必须提供额外的信息，来确定模板的参数类型，一般在模板名后尖括号中提供实参 定义类模板 template class Blob { public: typedef T value_type; typedef typename std::vector::size_type size_type; //构造函数 Blob(); Blob(std::initializer_list il); //Blob中元素数目 size_type size() const { return data-size(); } bool empty() const { return data-empty(); } void push_back(const T\u0026 t) { return data-push_back(t);} void pop_back(); //元素访问 T\u0026 back(); T\u0026 operator[](size_type i); private: std::shared_ptr data; //若data[i]无效，抛出msg void check(size_type i, const std::string \u0026msg) const; }； 实例化类模板使用一个类模板时，需要提供额外信息，这些额外信息是显示模板实参列表，它们被绑定到模板参数 //使用类模板，必须提供元素类型 Blob ia; Blob ia2 = {0, 1, 2, 3}; ia 和 ia2会实例化以下特定版本的 Blob ` template class Blob { typedef typename std::vector::size_type size_type; Blob(); Blob(std::initializer_list il); //... } 当编译器从 Blob 模板中实例化一个类时，它会重写 Blob 模板，将参数 T 的每个实例替换成给定的模板实参 一个类模板的每个实例都形成一个独立的类，类型 Blob 与其他任何 Blob类型都没有关系，也不会对任何其他 Blob 类型的成员具有特殊的访问权限 类模板的成员函数与其他类一样，既可以在类模板内部，也可以在外部定义其成员函数，且定义在类模板内的成员函数被隐式声明为内联函数 类模板的成员函数本身是一个普通函数 每个类模板的实例都有自己版本的成员函数 类模板的成员函数具有和模板相同的模板参数 定义在类模板之外的成员函数就必须以关键字 template 开始，后接参数列表 简单说就是在类模板内部定义成员函数，可以直接使用参数 T，而在类模板外部定义成员函数，前面需要加上 template 等 template ret-type Blob::member-name(parm-list) 这里必须加上 template 这行 类模板成员函数实例化默认情况下，类模板的成员函数只有当程序使用它的时候才进行实例化 // 实例化Blob和接受initializer_list的构造函数 Blob squares = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; for (size_t i = 0; i != squares.size(); ++i) { squares[i] = i * i; //实例化Blob::operator[](size_t) } 如果一个成员函数没有被使用，则它不会被实例化 类代码内简化模板类名的使用在使用一个类模板类型时必须提供模板实参，但是在类模板自己的作用域中，可以直接使用模板名而不提供实参 template class BlobPtr { public: BlobPtr() : curr(0) {} //其他构造函数 T\u0026 operator*() const { auto p = check(curr, \"derederence past edn\"); return (*p)[curr]; } //递增和递减 BlobPtr\u0026 operator++(); //求值运算符 BlobPtr\u0026 operator--(); private: //其他成员 std::size_t curr; //数组中的位置 } 这里前置递增和递减成员返回的时 BlobPtr\u0026，而不是 BlobPtr\u0026，在类模板作用域中，编译器处理模板自身引用会自动提供模板匹配的实参 类模板外使用类模板名在类模板外定义成员时，此时不在类的作用域，直到遇见类名菜进入类的作用域 //后置++版本 template BlobPtr BlobPtr::operator++(int) { BlobPtr ret = *this; ++*this; return ret; } 返回类型位于类的作用域之外，所以必须指出返回类型是一个实例化的 BlobPtr，在函数体内已经进入类的作用域，则定义 ret 时无须重复提供模板实参，如果不通过模板实参，编译器假定使用的类型与成员实例化所用类型一致，等价于：BlobPtr ret = *this; 类模板和友元 一个类包含一个友元声明，类与友元各自是否是模板是互相无关的 如果一个模板包括一个非模板友元，则友元可以访问所以模板实例 如果友元自身也是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例 一对一友好关系类模板与另一个（类或函数）模板间友好关系的最常见的形式是建立对应实例及其友元间的友好关系。例如，我们的 Blob 类应该将 BlobPtr 类和一个模板版本的 Blob template class BlobPtr; //需要提前声明 template class Blob; template bool operator==(const Blob\u0026, const Blob\u0026); template class Blob { friend class BlobPtr; friend bool operator== (const Blob\u0026, const Blob\u0026); //其他成员 } 友元的声明用 Blob 的模板形参作为自己的模板实参，友好关系被限定在相同类型实例化的 Blob 和 BlobPtr 相等运算符之间 //BlobPtr和operator==都是本对象的友元 Blob ca; //BlobPtr和operator==都是本对象的友元 Blob ia; 上面例子中，ca 对 ia 或其他实例没有特殊访问权限 通用和特定模板的友好关系一个类也可以将另一个模板的每个实例都声明为自己的友元，或者限定特定的实例为友元 template class Pal; class C { //C是普通非模板类 friend class Pal;//C实例化Pal是C的友元 //Pal2的所有实例都是C的友元，这种情况无须前置声明 template friend class Pal2; }; template class C2 {//C2是个模板类 //C2每个实例将相同实例的Pal声明为友元 friend class Pal; //Pal2所有实例都是C2每个实例的友元，不需要前置声明 template friend class Pal2; //Pal3是一个非模板类，它是C2所有实例的友元 friend class Pal3; }; 为了让所有实例都成为友元，友元声明中必须使用与类模板不同的模板参数 令模板自己的类型参数成为友元在C++11新标准中，可以将模板类型参数声明为友元 template class Bar { friend Type; //访问权限授予实例化Bar的类型 //... } 此时，对于某个类型 Foo，Foo 将称为 Bar 的友元，Sales_data 将成为 Bar 的友元 模板类型别名类模板一个实例定义了一个类类型，我们可以定义一个 typedef 来引用实例化的类： typedef Blob StrBlob; 由于模板不是一个类型，我们不能定义一个 typedef 引用一个模板，即不能定义一个 typedef 引用 Blob 但是新标准允许为类模板定义一个类型别名： templateusing twin = pair; twin authors; //authors是一个pair使用别名时，也需要像模板那样指出特定类型的 twin 使用一个模板类型别名时，可以固定一个或多个模板参数 template using partNo = pair; partNo books; /","date":"2022-05-07","objectID":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/:1:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十六章 模板与泛型编程","uri":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/#模板类型别名"},{"categories":["C++"],"content":"16.1.2 类模板类模板用来生成类的蓝图，类模板必须提供额外的信息，来确定模板的参数类型，一般在模板名后尖括号中提供实参 定义类模板 template class Blob { public: typedef T value_type; typedef typename std::vector::size_type size_type; //构造函数 Blob(); Blob(std::initializer_list il); //Blob中元素数目 size_type size() const { return data-size(); } bool empty() const { return data-empty(); } void push_back(const T\u0026 t) { return data-push_back(t);} void pop_back(); //元素访问 T\u0026 back(); T\u0026 operator[](size_type i); private: std::shared_ptr data; //若data[i]无效，抛出msg void check(size_type i, const std::string \u0026msg) const; }； 实例化类模板使用一个类模板时，需要提供额外信息，这些额外信息是显示模板实参列表，它们被绑定到模板参数 //使用类模板，必须提供元素类型 Blob ia; Blob ia2 = {0, 1, 2, 3}; ia 和 ia2会实例化以下特定版本的 Blob ` template class Blob { typedef typename std::vector::size_type size_type; Blob(); Blob(std::initializer_list il); //... } 当编译器从 Blob 模板中实例化一个类时，它会重写 Blob 模板，将参数 T 的每个实例替换成给定的模板实参 一个类模板的每个实例都形成一个独立的类，类型 Blob 与其他任何 Blob类型都没有关系，也不会对任何其他 Blob 类型的成员具有特殊的访问权限 类模板的成员函数与其他类一样，既可以在类模板内部，也可以在外部定义其成员函数，且定义在类模板内的成员函数被隐式声明为内联函数 类模板的成员函数本身是一个普通函数 每个类模板的实例都有自己版本的成员函数 类模板的成员函数具有和模板相同的模板参数 定义在类模板之外的成员函数就必须以关键字 template 开始，后接参数列表 简单说就是在类模板内部定义成员函数，可以直接使用参数 T，而在类模板外部定义成员函数，前面需要加上 template 等 template ret-type Blob::member-name(parm-list) 这里必须加上 template 这行 类模板成员函数实例化默认情况下，类模板的成员函数只有当程序使用它的时候才进行实例化 // 实例化Blob和接受initializer_list的构造函数 Blob squares = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; for (size_t i = 0; i != squares.size(); ++i) { squares[i] = i * i; //实例化Blob::operator[](size_t) } 如果一个成员函数没有被使用，则它不会被实例化 类代码内简化模板类名的使用在使用一个类模板类型时必须提供模板实参，但是在类模板自己的作用域中，可以直接使用模板名而不提供实参 template class BlobPtr { public: BlobPtr() : curr(0) {} //其他构造函数 T\u0026 operator*() const { auto p = check(curr, \"derederence past edn\"); return (*p)[curr]; } //递增和递减 BlobPtr\u0026 operator++(); //求值运算符 BlobPtr\u0026 operator--(); private: //其他成员 std::size_t curr; //数组中的位置 } 这里前置递增和递减成员返回的时 BlobPtr\u0026，而不是 BlobPtr\u0026，在类模板作用域中，编译器处理模板自身引用会自动提供模板匹配的实参 类模板外使用类模板名在类模板外定义成员时，此时不在类的作用域，直到遇见类名菜进入类的作用域 //后置++版本 template BlobPtr BlobPtr::operator++(int) { BlobPtr ret = *this; ++*this; return ret; } 返回类型位于类的作用域之外，所以必须指出返回类型是一个实例化的 BlobPtr，在函数体内已经进入类的作用域，则定义 ret 时无须重复提供模板实参，如果不通过模板实参，编译器假定使用的类型与成员实例化所用类型一致，等价于：BlobPtr ret = *this; 类模板和友元 一个类包含一个友元声明，类与友元各自是否是模板是互相无关的 如果一个模板包括一个非模板友元，则友元可以访问所以模板实例 如果友元自身也是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例 一对一友好关系类模板与另一个（类或函数）模板间友好关系的最常见的形式是建立对应实例及其友元间的友好关系。例如，我们的 Blob 类应该将 BlobPtr 类和一个模板版本的 Blob template class BlobPtr; //需要提前声明 template class Blob; template bool operator==(const Blob\u0026, const Blob\u0026); template class Blob { friend class BlobPtr; friend bool operator== (const Blob\u0026, const Blob\u0026); //其他成员 } 友元的声明用 Blob 的模板形参作为自己的模板实参，友好关系被限定在相同类型实例化的 Blob 和 BlobPtr 相等运算符之间 //BlobPtr和operator==都是本对象的友元 Blob ca; //BlobPtr和operator==都是本对象的友元 Blob ia; 上面例子中，ca 对 ia 或其他实例没有特殊访问权限 通用和特定模板的友好关系一个类也可以将另一个模板的每个实例都声明为自己的友元，或者限定特定的实例为友元 template class Pal; class C { //C是普通非模板类 friend class Pal;//C实例化Pal是C的友元 //Pal2的所有实例都是C的友元，这种情况无须前置声明 template friend class Pal2; }; template class C2 {//C2是个模板类 //C2每个实例将相同实例的Pal声明为友元 friend class Pal; //Pal2所有实例都是C2每个实例的友元，不需要前置声明 template friend class Pal2; //Pal3是一个非模板类，它是C2所有实例的友元 friend class Pal3; }; 为了让所有实例都成为友元，友元声明中必须使用与类模板不同的模板参数 令模板自己的类型参数成为友元在C++11新标准中，可以将模板类型参数声明为友元 template class Bar { friend Type; //访问权限授予实例化Bar的类型 //... } 此时，对于某个类型 Foo，Foo 将称为 Bar 的友元，Sales_data 将成为 Bar 的友元 模板类型别名类模板一个实例定义了一个类类型，我们可以定义一个 typedef 来引用实例化的类： typedef Blob StrBlob; 由于模板不是一个类型，我们不能定义一个 typedef 引用一个模板，即不能定义一个 typedef 引用 Blob 但是新标准允许为类模板定义一个类型别名： templateusing twin = pair; twin authors; //authors是一个pair使用别名时，也需要像模板那样指出特定类型的 twin 使用一个模板类型别名时，可以固定一个或多个模板参数 template using partNo = pair; partNo books; /","date":"2022-05-07","objectID":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/:1:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十六章 模板与泛型编程","uri":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/#类模板的static成员"},{"categories":["C++"],"content":"15.1 OOP：概述面向对象程序设计：核心思想是数据抽象、继承和动态绑定 数据抽象：类的接口与实现进行分离 继承：定义相似的类型并对相似关系建模 动态绑定：一定程度上忽略相似类型的区别，用统一的方式使用它们的对象 继承通过继承联系在一起的类构成一种层次关系，这种层次关系的根部有一个基类，其他类直接或间接由基类继承而来，继承得到的类称为派生类，继承的关系满足 is a ，即派生类本身也是一种基类的类型 对于基类中的某些函数，如果派生类需要自定义适合自身的版本，可以在基类中将这些函数声明为虚函数，派生类必须在内部对所有的虚函数重新声明 动态绑定使用动态绑定，可以用同一段代码处理基类和派生类的对象 比如说定义一个函数参入的形参是基类类型，然后打印处基类的成员，此时如果传入一个派生类也同样可以打印派生类的成员，这时调用的函数会根据实际传入的类型进行调用 动态绑定过程是在函数运行时由实参决定，有时也可以称为运行时绑定 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:1:0","series":null,"tags":["C++"],"title":"《C++Primer》第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#151-oop概述"},{"categories":["C++"],"content":"15.1 OOP：概述面向对象程序设计：核心思想是数据抽象、继承和动态绑定 数据抽象：类的接口与实现进行分离 继承：定义相似的类型并对相似关系建模 动态绑定：一定程度上忽略相似类型的区别，用统一的方式使用它们的对象 继承通过继承联系在一起的类构成一种层次关系，这种层次关系的根部有一个基类，其他类直接或间接由基类继承而来，继承得到的类称为派生类，继承的关系满足 is a ，即派生类本身也是一种基类的类型 对于基类中的某些函数，如果派生类需要自定义适合自身的版本，可以在基类中将这些函数声明为虚函数，派生类必须在内部对所有的虚函数重新声明 动态绑定使用动态绑定，可以用同一段代码处理基类和派生类的对象 比如说定义一个函数参入的形参是基类类型，然后打印处基类的成员，此时如果传入一个派生类也同样可以打印派生类的成员，这时调用的函数会根据实际传入的类型进行调用 动态绑定过程是在函数运行时由实参决定，有时也可以称为运行时绑定 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:1:0","series":null,"tags":["C++"],"title":"《C++Primer》第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#继承"},{"categories":["C++"],"content":"15.1 OOP：概述面向对象程序设计：核心思想是数据抽象、继承和动态绑定 数据抽象：类的接口与实现进行分离 继承：定义相似的类型并对相似关系建模 动态绑定：一定程度上忽略相似类型的区别，用统一的方式使用它们的对象 继承通过继承联系在一起的类构成一种层次关系，这种层次关系的根部有一个基类，其他类直接或间接由基类继承而来，继承得到的类称为派生类，继承的关系满足 is a ，即派生类本身也是一种基类的类型 对于基类中的某些函数，如果派生类需要自定义适合自身的版本，可以在基类中将这些函数声明为虚函数，派生类必须在内部对所有的虚函数重新声明 动态绑定使用动态绑定，可以用同一段代码处理基类和派生类的对象 比如说定义一个函数参入的形参是基类类型，然后打印处基类的成员，此时如果传入一个派生类也同样可以打印派生类的成员，这时调用的函数会根据实际传入的类型进行调用 动态绑定过程是在函数运行时由实参决定，有时也可以称为运行时绑定 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:1:0","series":null,"tags":["C++"],"title":"《C++Primer》第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#动态绑定"},{"categories":["C++"],"content":"15.2 定义基类和派生类","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:0","series":null,"tags":["C++"],"title":"《C++Primer》第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#152-定义基类和派生类"},{"categories":["C++"],"content":"15.2.1 定义基类首先定义 Quote 类： class Quote { public: Quote() = default;//默认构造函数 Quote(const std::string \u0026book, double sales_price) : bookNo(book), price(sales_price) {} std::string isbn() const { return bookNo; } //返回给定数量书籍的销售总额 //派生类负责改写并使用不同的折算算法 virtual double net_price(std::size_t n) const { return n * price; } virtual ~Quote() = default;//对析构函数进行动态绑定 private: std::string bookNo; //书籍ISBN号 protected: double price = 0.0; //普通状态下不打折的价格 } 基类通常定义一个虚析构函数，即使不执行任何操作 成员函数和继承派生类可以继承基类的成员，遇见 net_price 这种与类型相关的操作，派生类需要对这些操作提供自己新定义以覆盖从基类继承而来的定义 通常将基类希望派生类进行覆盖的函数定义为虚函数，当使用指针或者引用调用虚函数时，该调用将被动态绑定 访问控制和继承 派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权访问从基类继承而来的成员 派生类可以访问公有成员，但是不能访问私有成员 如果希望基类的派生类有权访问该成员，同时禁止其他用户访问，可以定义为受保护的（protected） ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:1","series":null,"tags":["C++"],"title":"《C++Primer》第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#1521-定义基类"},{"categories":["C++"],"content":"15.2.1 定义基类首先定义 Quote 类： class Quote { public: Quote() = default;//默认构造函数 Quote(const std::string \u0026book, double sales_price) : bookNo(book), price(sales_price) {} std::string isbn() const { return bookNo; } //返回给定数量书籍的销售总额 //派生类负责改写并使用不同的折算算法 virtual double net_price(std::size_t n) const { return n * price; } virtual ~Quote() = default;//对析构函数进行动态绑定 private: std::string bookNo; //书籍ISBN号 protected: double price = 0.0; //普通状态下不打折的价格 } 基类通常定义一个虚析构函数，即使不执行任何操作 成员函数和继承派生类可以继承基类的成员，遇见 net_price 这种与类型相关的操作，派生类需要对这些操作提供自己新定义以覆盖从基类继承而来的定义 通常将基类希望派生类进行覆盖的函数定义为虚函数，当使用指针或者引用调用虚函数时，该调用将被动态绑定 访问控制和继承 派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权访问从基类继承而来的成员 派生类可以访问公有成员，但是不能访问私有成员 如果希望基类的派生类有权访问该成员，同时禁止其他用户访问，可以定义为受保护的（protected） ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:1","series":null,"tags":["C++"],"title":"《C++Primer》第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#成员函数和继承"},{"categories":["C++"],"content":"15.2.1 定义基类首先定义 Quote 类： class Quote { public: Quote() = default;//默认构造函数 Quote(const std::string \u0026book, double sales_price) : bookNo(book), price(sales_price) {} std::string isbn() const { return bookNo; } //返回给定数量书籍的销售总额 //派生类负责改写并使用不同的折算算法 virtual double net_price(std::size_t n) const { return n * price; } virtual ~Quote() = default;//对析构函数进行动态绑定 private: std::string bookNo; //书籍ISBN号 protected: double price = 0.0; //普通状态下不打折的价格 } 基类通常定义一个虚析构函数，即使不执行任何操作 成员函数和继承派生类可以继承基类的成员，遇见 net_price 这种与类型相关的操作，派生类需要对这些操作提供自己新定义以覆盖从基类继承而来的定义 通常将基类希望派生类进行覆盖的函数定义为虚函数，当使用指针或者引用调用虚函数时，该调用将被动态绑定 访问控制和继承 派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权访问从基类继承而来的成员 派生类可以访问公有成员，但是不能访问私有成员 如果希望基类的派生类有权访问该成员，同时禁止其他用户访问，可以定义为受保护的（protected） ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:1","series":null,"tags":["C++"],"title":"《C++Primer》第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#访问控制和继承"},{"categories":["C++"],"content":"15.2.2 定义派生类派生类必须通过类派生列表来指明它是从哪个基类继承而来的，类派生列表形式是：首先一个冒号，后面紧跟以逗号分隔的基类列表，每个基类前面可以有以下三种访问说明符之一：public、protected和private 定义 Bulk_quote 类 class Bulk_quote : public Quote { //Bulk_quote继承自Quote public: Bulk_quote() = default; Bulk_quote(const std::string\u0026, double, std::size_t, double); //覆盖基类的函数版本以实现基于大量购买的折扣政策 double net_price(std::size_t) const override; private: std::size_t min_qty = 0;//适用折扣政策的最低购买量 double discount = 0.0; //以小数表示折扣额 } Bulk_quote 类从基类 Quote 继承了 isbn 函数和 bookNo、price等数据成员，此外还定义了 net_price 的新版本，同时增加了两个新的数据成员 派生类中的虚函数派生类如果没有覆盖基类的虚函数，则派生类会直接继承基类中的版本 C++11新标准允许派生类显示注明它使用某个成员函数覆盖了它继承的虚函数，具体做法是在函数定义后面加个关键字 override 派生类对象即派生类向基类的类型转换派生类对象含有基类对应的成员部分，我们可以将派生类对象当成基类对象来使用，也能将基类指针或引用绑定到派生类对象的基类部分上 Quote item; //基类对象 Bulk_quote bulk; //派生类对象 Quote *p = \u0026item;//p指向Quote对象 p = \u0026bulk; //p指向bulk的Quote部分 Quote \u0026r = bulk; //r绑定到bulk的Quote部分 这种转换称为派生类到基类的类型转换 派生类构造函数派生类对象中含有从基类继承的成员，但是派生类不能直接初始化这些成员，派生类必须使用基类的构造函数来初始化它的基类部分 派生类在初始化成员时，可以通过构造函数初始化列表将实参传给基类构造函数，如下： //Bulk_quote的构造函数 Bulk_quote(const std::string \u0026book, double p, std::size_t qyt, double disc) : Quote(book, p), min_qty(qty), discount(disc) {} 派生类首先初始化基类部分，然后按照声明顺序初始化派生类的成员 派生类使用基类的成员派生类可以访问基类的公用成员和受保护的成员，例如： //如果达到购买书籍某个最低限度值，就可以享受折扣价格 double Bulk_quote::net_price(size_t cnt) const { if (cnt \u003e= min_qty) return cnt * (1 - discount) * price; else return cnt * price; } 继承与静态成员如果基类定义了一个静态成员，则整个继承体系中只存在该成员的唯一定义，不能派生出来多个各类，每一个静态成员只存在唯一的实例 静态成员遵循通用的访问控制规则，如果基类中定义为 private 的，派生类无权进行访问；如果静态成员可访问，既可以通过基类使用它，也可以通过派生类使用 class Base { public: static void statemen(); }; class Derived : public Base { void f(const Derived\u0026); }; void Derived::f(const Derived \u0026derived_obj) { Base::statemem(); //通过基类访问 Derived::statemem(); //通过派生类访问 derived_obj.statemem(); //通过基类对象访问 statemem(); //通过this对象访问 } 派生类的声明派生类声明和其他类差别不大，声明中包含类名但是不包含它的派生列表： class Bulk_quote : public Quote;//错误，派生列表不能出现在这 class Bulk_quote; //正确：声明派生类的正确方式 被用作基类的类如果想用某个类作为基类，则这个类必须已经定义而非仅仅声明： class Quote;//声明但未定义 //错误：Quote必须被定义 class Bulk_quote : public Quote {...}; 一个类不可以派生它本身 防止继承的发生如果不希望某一个类派生出其他类，或者不考虑将它作为一个基类，C++11新标准提供了一种防止继承发生的方法，即在类名后面跟一个关键字 final： class NoDrived final { /***/ }; class Bad : Noderived { /***/ }; //错误：NoDrived是final的 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:2","series":null,"tags":["C++"],"title":"《C++Primer》第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#1522-定义派生类"},{"categories":["C++"],"content":"15.2.2 定义派生类派生类必须通过类派生列表来指明它是从哪个基类继承而来的，类派生列表形式是：首先一个冒号，后面紧跟以逗号分隔的基类列表，每个基类前面可以有以下三种访问说明符之一：public、protected和private 定义 Bulk_quote 类 class Bulk_quote : public Quote { //Bulk_quote继承自Quote public: Bulk_quote() = default; Bulk_quote(const std::string\u0026, double, std::size_t, double); //覆盖基类的函数版本以实现基于大量购买的折扣政策 double net_price(std::size_t) const override; private: std::size_t min_qty = 0;//适用折扣政策的最低购买量 double discount = 0.0; //以小数表示折扣额 } Bulk_quote 类从基类 Quote 继承了 isbn 函数和 bookNo、price等数据成员，此外还定义了 net_price 的新版本，同时增加了两个新的数据成员 派生类中的虚函数派生类如果没有覆盖基类的虚函数，则派生类会直接继承基类中的版本 C++11新标准允许派生类显示注明它使用某个成员函数覆盖了它继承的虚函数，具体做法是在函数定义后面加个关键字 override 派生类对象即派生类向基类的类型转换派生类对象含有基类对应的成员部分，我们可以将派生类对象当成基类对象来使用，也能将基类指针或引用绑定到派生类对象的基类部分上 Quote item; //基类对象 Bulk_quote bulk; //派生类对象 Quote *p = \u0026item;//p指向Quote对象 p = \u0026bulk; //p指向bulk的Quote部分 Quote \u0026r = bulk; //r绑定到bulk的Quote部分 这种转换称为派生类到基类的类型转换 派生类构造函数派生类对象中含有从基类继承的成员，但是派生类不能直接初始化这些成员，派生类必须使用基类的构造函数来初始化它的基类部分 派生类在初始化成员时，可以通过构造函数初始化列表将实参传给基类构造函数，如下： //Bulk_quote的构造函数 Bulk_quote(const std::string \u0026book, double p, std::size_t qyt, double disc) : Quote(book, p), min_qty(qty), discount(disc) {} 派生类首先初始化基类部分，然后按照声明顺序初始化派生类的成员 派生类使用基类的成员派生类可以访问基类的公用成员和受保护的成员，例如： //如果达到购买书籍某个最低限度值，就可以享受折扣价格 double Bulk_quote::net_price(size_t cnt) const { if (cnt = min_qty) return cnt * (1 - discount) * price; else return cnt * price; } 继承与静态成员如果基类定义了一个静态成员，则整个继承体系中只存在该成员的唯一定义，不能派生出来多个各类，每一个静态成员只存在唯一的实例 静态成员遵循通用的访问控制规则，如果基类中定义为 private 的，派生类无权进行访问；如果静态成员可访问，既可以通过基类使用它，也可以通过派生类使用 class Base { public: static void statemen(); }; class Derived : public Base { void f(const Derived\u0026); }; void Derived::f(const Derived \u0026derived_obj) { Base::statemem(); //通过基类访问 Derived::statemem(); //通过派生类访问 derived_obj.statemem(); //通过基类对象访问 statemem(); //通过this对象访问 } 派生类的声明派生类声明和其他类差别不大，声明中包含类名但是不包含它的派生列表： class Bulk_quote : public Quote;//错误，派生列表不能出现在这 class Bulk_quote; //正确：声明派生类的正确方式 被用作基类的类如果想用某个类作为基类，则这个类必须已经定义而非仅仅声明： class Quote;//声明但未定义 //错误：Quote必须被定义 class Bulk_quote : public Quote {...}; 一个类不可以派生它本身 防止继承的发生如果不希望某一个类派生出其他类，或者不考虑将它作为一个基类，C++11新标准提供了一种防止继承发生的方法，即在类名后面跟一个关键字 final： class NoDrived final { /***/ }; class Bad : Noderived { /***/ }; //错误：NoDrived是final的 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:2","series":null,"tags":["C++"],"title":"《C++Primer》第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#派生类中的虚函数"},{"categories":["C++"],"content":"15.2.2 定义派生类派生类必须通过类派生列表来指明它是从哪个基类继承而来的，类派生列表形式是：首先一个冒号，后面紧跟以逗号分隔的基类列表，每个基类前面可以有以下三种访问说明符之一：public、protected和private 定义 Bulk_quote 类 class Bulk_quote : public Quote { //Bulk_quote继承自Quote public: Bulk_quote() = default; Bulk_quote(const std::string\u0026, double, std::size_t, double); //覆盖基类的函数版本以实现基于大量购买的折扣政策 double net_price(std::size_t) const override; private: std::size_t min_qty = 0;//适用折扣政策的最低购买量 double discount = 0.0; //以小数表示折扣额 } Bulk_quote 类从基类 Quote 继承了 isbn 函数和 bookNo、price等数据成员，此外还定义了 net_price 的新版本，同时增加了两个新的数据成员 派生类中的虚函数派生类如果没有覆盖基类的虚函数，则派生类会直接继承基类中的版本 C++11新标准允许派生类显示注明它使用某个成员函数覆盖了它继承的虚函数，具体做法是在函数定义后面加个关键字 override 派生类对象即派生类向基类的类型转换派生类对象含有基类对应的成员部分，我们可以将派生类对象当成基类对象来使用，也能将基类指针或引用绑定到派生类对象的基类部分上 Quote item; //基类对象 Bulk_quote bulk; //派生类对象 Quote *p = \u0026item;//p指向Quote对象 p = \u0026bulk; //p指向bulk的Quote部分 Quote \u0026r = bulk; //r绑定到bulk的Quote部分 这种转换称为派生类到基类的类型转换 派生类构造函数派生类对象中含有从基类继承的成员，但是派生类不能直接初始化这些成员，派生类必须使用基类的构造函数来初始化它的基类部分 派生类在初始化成员时，可以通过构造函数初始化列表将实参传给基类构造函数，如下： //Bulk_quote的构造函数 Bulk_quote(const std::string \u0026book, double p, std::size_t qyt, double disc) : Quote(book, p), min_qty(qty), discount(disc) {} 派生类首先初始化基类部分，然后按照声明顺序初始化派生类的成员 派生类使用基类的成员派生类可以访问基类的公用成员和受保护的成员，例如： //如果达到购买书籍某个最低限度值，就可以享受折扣价格 double Bulk_quote::net_price(size_t cnt) const { if (cnt = min_qty) return cnt * (1 - discount) * price; else return cnt * price; } 继承与静态成员如果基类定义了一个静态成员，则整个继承体系中只存在该成员的唯一定义，不能派生出来多个各类，每一个静态成员只存在唯一的实例 静态成员遵循通用的访问控制规则，如果基类中定义为 private 的，派生类无权进行访问；如果静态成员可访问，既可以通过基类使用它，也可以通过派生类使用 class Base { public: static void statemen(); }; class Derived : public Base { void f(const Derived\u0026); }; void Derived::f(const Derived \u0026derived_obj) { Base::statemem(); //通过基类访问 Derived::statemem(); //通过派生类访问 derived_obj.statemem(); //通过基类对象访问 statemem(); //通过this对象访问 } 派生类的声明派生类声明和其他类差别不大，声明中包含类名但是不包含它的派生列表： class Bulk_quote : public Quote;//错误，派生列表不能出现在这 class Bulk_quote; //正确：声明派生类的正确方式 被用作基类的类如果想用某个类作为基类，则这个类必须已经定义而非仅仅声明： class Quote;//声明但未定义 //错误：Quote必须被定义 class Bulk_quote : public Quote {...}; 一个类不可以派生它本身 防止继承的发生如果不希望某一个类派生出其他类，或者不考虑将它作为一个基类，C++11新标准提供了一种防止继承发生的方法，即在类名后面跟一个关键字 final： class NoDrived final { /***/ }; class Bad : Noderived { /***/ }; //错误：NoDrived是final的 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:2","series":null,"tags":["C++"],"title":"《C++Primer》第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#派生类对象即派生类向基类的类型转换"},{"categories":["C++"],"content":"15.2.2 定义派生类派生类必须通过类派生列表来指明它是从哪个基类继承而来的，类派生列表形式是：首先一个冒号，后面紧跟以逗号分隔的基类列表，每个基类前面可以有以下三种访问说明符之一：public、protected和private 定义 Bulk_quote 类 class Bulk_quote : public Quote { //Bulk_quote继承自Quote public: Bulk_quote() = default; Bulk_quote(const std::string\u0026, double, std::size_t, double); //覆盖基类的函数版本以实现基于大量购买的折扣政策 double net_price(std::size_t) const override; private: std::size_t min_qty = 0;//适用折扣政策的最低购买量 double discount = 0.0; //以小数表示折扣额 } Bulk_quote 类从基类 Quote 继承了 isbn 函数和 bookNo、price等数据成员，此外还定义了 net_price 的新版本，同时增加了两个新的数据成员 派生类中的虚函数派生类如果没有覆盖基类的虚函数，则派生类会直接继承基类中的版本 C++11新标准允许派生类显示注明它使用某个成员函数覆盖了它继承的虚函数，具体做法是在函数定义后面加个关键字 override 派生类对象即派生类向基类的类型转换派生类对象含有基类对应的成员部分，我们可以将派生类对象当成基类对象来使用，也能将基类指针或引用绑定到派生类对象的基类部分上 Quote item; //基类对象 Bulk_quote bulk; //派生类对象 Quote *p = \u0026item;//p指向Quote对象 p = \u0026bulk; //p指向bulk的Quote部分 Quote \u0026r = bulk; //r绑定到bulk的Quote部分 这种转换称为派生类到基类的类型转换 派生类构造函数派生类对象中含有从基类继承的成员，但是派生类不能直接初始化这些成员，派生类必须使用基类的构造函数来初始化它的基类部分 派生类在初始化成员时，可以通过构造函数初始化列表将实参传给基类构造函数，如下： //Bulk_quote的构造函数 Bulk_quote(const std::string \u0026book, double p, std::size_t qyt, double disc) : Quote(book, p), min_qty(qty), discount(disc) {} 派生类首先初始化基类部分，然后按照声明顺序初始化派生类的成员 派生类使用基类的成员派生类可以访问基类的公用成员和受保护的成员，例如： //如果达到购买书籍某个最低限度值，就可以享受折扣价格 double Bulk_quote::net_price(size_t cnt) const { if (cnt = min_qty) return cnt * (1 - discount) * price; else return cnt * price; } 继承与静态成员如果基类定义了一个静态成员，则整个继承体系中只存在该成员的唯一定义，不能派生出来多个各类，每一个静态成员只存在唯一的实例 静态成员遵循通用的访问控制规则，如果基类中定义为 private 的，派生类无权进行访问；如果静态成员可访问，既可以通过基类使用它，也可以通过派生类使用 class Base { public: static void statemen(); }; class Derived : public Base { void f(const Derived\u0026); }; void Derived::f(const Derived \u0026derived_obj) { Base::statemem(); //通过基类访问 Derived::statemem(); //通过派生类访问 derived_obj.statemem(); //通过基类对象访问 statemem(); //通过this对象访问 } 派生类的声明派生类声明和其他类差别不大，声明中包含类名但是不包含它的派生列表： class Bulk_quote : public Quote;//错误，派生列表不能出现在这 class Bulk_quote; //正确：声明派生类的正确方式 被用作基类的类如果想用某个类作为基类，则这个类必须已经定义而非仅仅声明： class Quote;//声明但未定义 //错误：Quote必须被定义 class Bulk_quote : public Quote {...}; 一个类不可以派生它本身 防止继承的发生如果不希望某一个类派生出其他类，或者不考虑将它作为一个基类，C++11新标准提供了一种防止继承发生的方法，即在类名后面跟一个关键字 final： class NoDrived final { /***/ }; class Bad : Noderived { /***/ }; //错误：NoDrived是final的 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:2","series":null,"tags":["C++"],"title":"《C++Primer》第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#派生类构造函数"},{"categories":["C++"],"content":"15.2.2 定义派生类派生类必须通过类派生列表来指明它是从哪个基类继承而来的，类派生列表形式是：首先一个冒号，后面紧跟以逗号分隔的基类列表，每个基类前面可以有以下三种访问说明符之一：public、protected和private 定义 Bulk_quote 类 class Bulk_quote : public Quote { //Bulk_quote继承自Quote public: Bulk_quote() = default; Bulk_quote(const std::string\u0026, double, std::size_t, double); //覆盖基类的函数版本以实现基于大量购买的折扣政策 double net_price(std::size_t) const override; private: std::size_t min_qty = 0;//适用折扣政策的最低购买量 double discount = 0.0; //以小数表示折扣额 } Bulk_quote 类从基类 Quote 继承了 isbn 函数和 bookNo、price等数据成员，此外还定义了 net_price 的新版本，同时增加了两个新的数据成员 派生类中的虚函数派生类如果没有覆盖基类的虚函数，则派生类会直接继承基类中的版本 C++11新标准允许派生类显示注明它使用某个成员函数覆盖了它继承的虚函数，具体做法是在函数定义后面加个关键字 override 派生类对象即派生类向基类的类型转换派生类对象含有基类对应的成员部分，我们可以将派生类对象当成基类对象来使用，也能将基类指针或引用绑定到派生类对象的基类部分上 Quote item; //基类对象 Bulk_quote bulk; //派生类对象 Quote *p = \u0026item;//p指向Quote对象 p = \u0026bulk; //p指向bulk的Quote部分 Quote \u0026r = bulk; //r绑定到bulk的Quote部分 这种转换称为派生类到基类的类型转换 派生类构造函数派生类对象中含有从基类继承的成员，但是派生类不能直接初始化这些成员，派生类必须使用基类的构造函数来初始化它的基类部分 派生类在初始化成员时，可以通过构造函数初始化列表将实参传给基类构造函数，如下： //Bulk_quote的构造函数 Bulk_quote(const std::string \u0026book, double p, std::size_t qyt, double disc) : Quote(book, p), min_qty(qty), discount(disc) {} 派生类首先初始化基类部分，然后按照声明顺序初始化派生类的成员 派生类使用基类的成员派生类可以访问基类的公用成员和受保护的成员，例如： //如果达到购买书籍某个最低限度值，就可以享受折扣价格 double Bulk_quote::net_price(size_t cnt) const { if (cnt = min_qty) return cnt * (1 - discount) * price; else return cnt * price; } 继承与静态成员如果基类定义了一个静态成员，则整个继承体系中只存在该成员的唯一定义，不能派生出来多个各类，每一个静态成员只存在唯一的实例 静态成员遵循通用的访问控制规则，如果基类中定义为 private 的，派生类无权进行访问；如果静态成员可访问，既可以通过基类使用它，也可以通过派生类使用 class Base { public: static void statemen(); }; class Derived : public Base { void f(const Derived\u0026); }; void Derived::f(const Derived \u0026derived_obj) { Base::statemem(); //通过基类访问 Derived::statemem(); //通过派生类访问 derived_obj.statemem(); //通过基类对象访问 statemem(); //通过this对象访问 } 派生类的声明派生类声明和其他类差别不大，声明中包含类名但是不包含它的派生列表： class Bulk_quote : public Quote;//错误，派生列表不能出现在这 class Bulk_quote; //正确：声明派生类的正确方式 被用作基类的类如果想用某个类作为基类，则这个类必须已经定义而非仅仅声明： class Quote;//声明但未定义 //错误：Quote必须被定义 class Bulk_quote : public Quote {...}; 一个类不可以派生它本身 防止继承的发生如果不希望某一个类派生出其他类，或者不考虑将它作为一个基类，C++11新标准提供了一种防止继承发生的方法，即在类名后面跟一个关键字 final： class NoDrived final { /***/ }; class Bad : Noderived { /***/ }; //错误：NoDrived是final的 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:2","series":null,"tags":["C++"],"title":"《C++Primer》第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#派生类使用基类的成员"},{"categories":["C++"],"content":"15.2.2 定义派生类派生类必须通过类派生列表来指明它是从哪个基类继承而来的，类派生列表形式是：首先一个冒号，后面紧跟以逗号分隔的基类列表，每个基类前面可以有以下三种访问说明符之一：public、protected和private 定义 Bulk_quote 类 class Bulk_quote : public Quote { //Bulk_quote继承自Quote public: Bulk_quote() = default; Bulk_quote(const std::string\u0026, double, std::size_t, double); //覆盖基类的函数版本以实现基于大量购买的折扣政策 double net_price(std::size_t) const override; private: std::size_t min_qty = 0;//适用折扣政策的最低购买量 double discount = 0.0; //以小数表示折扣额 } Bulk_quote 类从基类 Quote 继承了 isbn 函数和 bookNo、price等数据成员，此外还定义了 net_price 的新版本，同时增加了两个新的数据成员 派生类中的虚函数派生类如果没有覆盖基类的虚函数，则派生类会直接继承基类中的版本 C++11新标准允许派生类显示注明它使用某个成员函数覆盖了它继承的虚函数，具体做法是在函数定义后面加个关键字 override 派生类对象即派生类向基类的类型转换派生类对象含有基类对应的成员部分，我们可以将派生类对象当成基类对象来使用，也能将基类指针或引用绑定到派生类对象的基类部分上 Quote item; //基类对象 Bulk_quote bulk; //派生类对象 Quote *p = \u0026item;//p指向Quote对象 p = \u0026bulk; //p指向bulk的Quote部分 Quote \u0026r = bulk; //r绑定到bulk的Quote部分 这种转换称为派生类到基类的类型转换 派生类构造函数派生类对象中含有从基类继承的成员，但是派生类不能直接初始化这些成员，派生类必须使用基类的构造函数来初始化它的基类部分 派生类在初始化成员时，可以通过构造函数初始化列表将实参传给基类构造函数，如下： //Bulk_quote的构造函数 Bulk_quote(const std::string \u0026book, double p, std::size_t qyt, double disc) : Quote(book, p), min_qty(qty), discount(disc) {} 派生类首先初始化基类部分，然后按照声明顺序初始化派生类的成员 派生类使用基类的成员派生类可以访问基类的公用成员和受保护的成员，例如： //如果达到购买书籍某个最低限度值，就可以享受折扣价格 double Bulk_quote::net_price(size_t cnt) const { if (cnt = min_qty) return cnt * (1 - discount) * price; else return cnt * price; } 继承与静态成员如果基类定义了一个静态成员，则整个继承体系中只存在该成员的唯一定义，不能派生出来多个各类，每一个静态成员只存在唯一的实例 静态成员遵循通用的访问控制规则，如果基类中定义为 private 的，派生类无权进行访问；如果静态成员可访问，既可以通过基类使用它，也可以通过派生类使用 class Base { public: static void statemen(); }; class Derived : public Base { void f(const Derived\u0026); }; void Derived::f(const Derived \u0026derived_obj) { Base::statemem(); //通过基类访问 Derived::statemem(); //通过派生类访问 derived_obj.statemem(); //通过基类对象访问 statemem(); //通过this对象访问 } 派生类的声明派生类声明和其他类差别不大，声明中包含类名但是不包含它的派生列表： class Bulk_quote : public Quote;//错误，派生列表不能出现在这 class Bulk_quote; //正确：声明派生类的正确方式 被用作基类的类如果想用某个类作为基类，则这个类必须已经定义而非仅仅声明： class Quote;//声明但未定义 //错误：Quote必须被定义 class Bulk_quote : public Quote {...}; 一个类不可以派生它本身 防止继承的发生如果不希望某一个类派生出其他类，或者不考虑将它作为一个基类，C++11新标准提供了一种防止继承发生的方法，即在类名后面跟一个关键字 final： class NoDrived final { /***/ }; class Bad : Noderived { /***/ }; //错误：NoDrived是final的 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:2","series":null,"tags":["C++"],"title":"《C++Primer》第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#继承与静态成员"},{"categories":["C++"],"content":"15.2.2 定义派生类派生类必须通过类派生列表来指明它是从哪个基类继承而来的，类派生列表形式是：首先一个冒号，后面紧跟以逗号分隔的基类列表，每个基类前面可以有以下三种访问说明符之一：public、protected和private 定义 Bulk_quote 类 class Bulk_quote : public Quote { //Bulk_quote继承自Quote public: Bulk_quote() = default; Bulk_quote(const std::string\u0026, double, std::size_t, double); //覆盖基类的函数版本以实现基于大量购买的折扣政策 double net_price(std::size_t) const override; private: std::size_t min_qty = 0;//适用折扣政策的最低购买量 double discount = 0.0; //以小数表示折扣额 } Bulk_quote 类从基类 Quote 继承了 isbn 函数和 bookNo、price等数据成员，此外还定义了 net_price 的新版本，同时增加了两个新的数据成员 派生类中的虚函数派生类如果没有覆盖基类的虚函数，则派生类会直接继承基类中的版本 C++11新标准允许派生类显示注明它使用某个成员函数覆盖了它继承的虚函数，具体做法是在函数定义后面加个关键字 override 派生类对象即派生类向基类的类型转换派生类对象含有基类对应的成员部分，我们可以将派生类对象当成基类对象来使用，也能将基类指针或引用绑定到派生类对象的基类部分上 Quote item; //基类对象 Bulk_quote bulk; //派生类对象 Quote *p = \u0026item;//p指向Quote对象 p = \u0026bulk; //p指向bulk的Quote部分 Quote \u0026r = bulk; //r绑定到bulk的Quote部分 这种转换称为派生类到基类的类型转换 派生类构造函数派生类对象中含有从基类继承的成员，但是派生类不能直接初始化这些成员，派生类必须使用基类的构造函数来初始化它的基类部分 派生类在初始化成员时，可以通过构造函数初始化列表将实参传给基类构造函数，如下： //Bulk_quote的构造函数 Bulk_quote(const std::string \u0026book, double p, std::size_t qyt, double disc) : Quote(book, p), min_qty(qty), discount(disc) {} 派生类首先初始化基类部分，然后按照声明顺序初始化派生类的成员 派生类使用基类的成员派生类可以访问基类的公用成员和受保护的成员，例如： //如果达到购买书籍某个最低限度值，就可以享受折扣价格 double Bulk_quote::net_price(size_t cnt) const { if (cnt = min_qty) return cnt * (1 - discount) * price; else return cnt * price; } 继承与静态成员如果基类定义了一个静态成员，则整个继承体系中只存在该成员的唯一定义，不能派生出来多个各类，每一个静态成员只存在唯一的实例 静态成员遵循通用的访问控制规则，如果基类中定义为 private 的，派生类无权进行访问；如果静态成员可访问，既可以通过基类使用它，也可以通过派生类使用 class Base { public: static void statemen(); }; class Derived : public Base { void f(const Derived\u0026); }; void Derived::f(const Derived \u0026derived_obj) { Base::statemem(); //通过基类访问 Derived::statemem(); //通过派生类访问 derived_obj.statemem(); //通过基类对象访问 statemem(); //通过this对象访问 } 派生类的声明派生类声明和其他类差别不大，声明中包含类名但是不包含它的派生列表： class Bulk_quote : public Quote;//错误，派生列表不能出现在这 class Bulk_quote; //正确：声明派生类的正确方式 被用作基类的类如果想用某个类作为基类，则这个类必须已经定义而非仅仅声明： class Quote;//声明但未定义 //错误：Quote必须被定义 class Bulk_quote : public Quote {...}; 一个类不可以派生它本身 防止继承的发生如果不希望某一个类派生出其他类，或者不考虑将它作为一个基类，C++11新标准提供了一种防止继承发生的方法，即在类名后面跟一个关键字 final： class NoDrived final { /***/ }; class Bad : Noderived { /***/ }; //错误：NoDrived是final的 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:2","series":null,"tags":["C++"],"title":"《C++Primer》第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#派生类的声明"},{"categories":["C++"],"content":"15.2.2 定义派生类派生类必须通过类派生列表来指明它是从哪个基类继承而来的，类派生列表形式是：首先一个冒号，后面紧跟以逗号分隔的基类列表，每个基类前面可以有以下三种访问说明符之一：public、protected和private 定义 Bulk_quote 类 class Bulk_quote : public Quote { //Bulk_quote继承自Quote public: Bulk_quote() = default; Bulk_quote(const std::string\u0026, double, std::size_t, double); //覆盖基类的函数版本以实现基于大量购买的折扣政策 double net_price(std::size_t) const override; private: std::size_t min_qty = 0;//适用折扣政策的最低购买量 double discount = 0.0; //以小数表示折扣额 } Bulk_quote 类从基类 Quote 继承了 isbn 函数和 bookNo、price等数据成员，此外还定义了 net_price 的新版本，同时增加了两个新的数据成员 派生类中的虚函数派生类如果没有覆盖基类的虚函数，则派生类会直接继承基类中的版本 C++11新标准允许派生类显示注明它使用某个成员函数覆盖了它继承的虚函数，具体做法是在函数定义后面加个关键字 override 派生类对象即派生类向基类的类型转换派生类对象含有基类对应的成员部分，我们可以将派生类对象当成基类对象来使用，也能将基类指针或引用绑定到派生类对象的基类部分上 Quote item; //基类对象 Bulk_quote bulk; //派生类对象 Quote *p = \u0026item;//p指向Quote对象 p = \u0026bulk; //p指向bulk的Quote部分 Quote \u0026r = bulk; //r绑定到bulk的Quote部分 这种转换称为派生类到基类的类型转换 派生类构造函数派生类对象中含有从基类继承的成员，但是派生类不能直接初始化这些成员，派生类必须使用基类的构造函数来初始化它的基类部分 派生类在初始化成员时，可以通过构造函数初始化列表将实参传给基类构造函数，如下： //Bulk_quote的构造函数 Bulk_quote(const std::string \u0026book, double p, std::size_t qyt, double disc) : Quote(book, p), min_qty(qty), discount(disc) {} 派生类首先初始化基类部分，然后按照声明顺序初始化派生类的成员 派生类使用基类的成员派生类可以访问基类的公用成员和受保护的成员，例如： //如果达到购买书籍某个最低限度值，就可以享受折扣价格 double Bulk_quote::net_price(size_t cnt) const { if (cnt = min_qty) return cnt * (1 - discount) * price; else return cnt * price; } 继承与静态成员如果基类定义了一个静态成员，则整个继承体系中只存在该成员的唯一定义，不能派生出来多个各类，每一个静态成员只存在唯一的实例 静态成员遵循通用的访问控制规则，如果基类中定义为 private 的，派生类无权进行访问；如果静态成员可访问，既可以通过基类使用它，也可以通过派生类使用 class Base { public: static void statemen(); }; class Derived : public Base { void f(const Derived\u0026); }; void Derived::f(const Derived \u0026derived_obj) { Base::statemem(); //通过基类访问 Derived::statemem(); //通过派生类访问 derived_obj.statemem(); //通过基类对象访问 statemem(); //通过this对象访问 } 派生类的声明派生类声明和其他类差别不大，声明中包含类名但是不包含它的派生列表： class Bulk_quote : public Quote;//错误，派生列表不能出现在这 class Bulk_quote; //正确：声明派生类的正确方式 被用作基类的类如果想用某个类作为基类，则这个类必须已经定义而非仅仅声明： class Quote;//声明但未定义 //错误：Quote必须被定义 class Bulk_quote : public Quote {...}; 一个类不可以派生它本身 防止继承的发生如果不希望某一个类派生出其他类，或者不考虑将它作为一个基类，C++11新标准提供了一种防止继承发生的方法，即在类名后面跟一个关键字 final： class NoDrived final { /***/ }; class Bad : Noderived { /***/ }; //错误：NoDrived是final的 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:2","series":null,"tags":["C++"],"title":"《C++Primer》第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#被用作基类的类"},{"categories":["C++"],"content":"15.2.2 定义派生类派生类必须通过类派生列表来指明它是从哪个基类继承而来的，类派生列表形式是：首先一个冒号，后面紧跟以逗号分隔的基类列表，每个基类前面可以有以下三种访问说明符之一：public、protected和private 定义 Bulk_quote 类 class Bulk_quote : public Quote { //Bulk_quote继承自Quote public: Bulk_quote() = default; Bulk_quote(const std::string\u0026, double, std::size_t, double); //覆盖基类的函数版本以实现基于大量购买的折扣政策 double net_price(std::size_t) const override; private: std::size_t min_qty = 0;//适用折扣政策的最低购买量 double discount = 0.0; //以小数表示折扣额 } Bulk_quote 类从基类 Quote 继承了 isbn 函数和 bookNo、price等数据成员，此外还定义了 net_price 的新版本，同时增加了两个新的数据成员 派生类中的虚函数派生类如果没有覆盖基类的虚函数，则派生类会直接继承基类中的版本 C++11新标准允许派生类显示注明它使用某个成员函数覆盖了它继承的虚函数，具体做法是在函数定义后面加个关键字 override 派生类对象即派生类向基类的类型转换派生类对象含有基类对应的成员部分，我们可以将派生类对象当成基类对象来使用，也能将基类指针或引用绑定到派生类对象的基类部分上 Quote item; //基类对象 Bulk_quote bulk; //派生类对象 Quote *p = \u0026item;//p指向Quote对象 p = \u0026bulk; //p指向bulk的Quote部分 Quote \u0026r = bulk; //r绑定到bulk的Quote部分 这种转换称为派生类到基类的类型转换 派生类构造函数派生类对象中含有从基类继承的成员，但是派生类不能直接初始化这些成员，派生类必须使用基类的构造函数来初始化它的基类部分 派生类在初始化成员时，可以通过构造函数初始化列表将实参传给基类构造函数，如下： //Bulk_quote的构造函数 Bulk_quote(const std::string \u0026book, double p, std::size_t qyt, double disc) : Quote(book, p), min_qty(qty), discount(disc) {} 派生类首先初始化基类部分，然后按照声明顺序初始化派生类的成员 派生类使用基类的成员派生类可以访问基类的公用成员和受保护的成员，例如： //如果达到购买书籍某个最低限度值，就可以享受折扣价格 double Bulk_quote::net_price(size_t cnt) const { if (cnt = min_qty) return cnt * (1 - discount) * price; else return cnt * price; } 继承与静态成员如果基类定义了一个静态成员，则整个继承体系中只存在该成员的唯一定义，不能派生出来多个各类，每一个静态成员只存在唯一的实例 静态成员遵循通用的访问控制规则，如果基类中定义为 private 的，派生类无权进行访问；如果静态成员可访问，既可以通过基类使用它，也可以通过派生类使用 class Base { public: static void statemen(); }; class Derived : public Base { void f(const Derived\u0026); }; void Derived::f(const Derived \u0026derived_obj) { Base::statemem(); //通过基类访问 Derived::statemem(); //通过派生类访问 derived_obj.statemem(); //通过基类对象访问 statemem(); //通过this对象访问 } 派生类的声明派生类声明和其他类差别不大，声明中包含类名但是不包含它的派生列表： class Bulk_quote : public Quote;//错误，派生列表不能出现在这 class Bulk_quote; //正确：声明派生类的正确方式 被用作基类的类如果想用某个类作为基类，则这个类必须已经定义而非仅仅声明： class Quote;//声明但未定义 //错误：Quote必须被定义 class Bulk_quote : public Quote {...}; 一个类不可以派生它本身 防止继承的发生如果不希望某一个类派生出其他类，或者不考虑将它作为一个基类，C++11新标准提供了一种防止继承发生的方法，即在类名后面跟一个关键字 final： class NoDrived final { /***/ }; class Bad : Noderived { /***/ }; //错误：NoDrived是final的 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:2","series":null,"tags":["C++"],"title":"《C++Primer》第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#防止继承的发生"},{"categories":["C++"],"content":"15.2.3 类型转换与继承我们可以将基类的指针或引用绑定到派生类对象上，例如：可以用 Quote\u0026 指向一个 Bulk_quote 对象 ==当使用基类的引用（或指针）时，我们并不清楚该引用（指针）所绑定对象的真实类型==，可能该对象时基类的对象，也可能时派生类的对象 智能指针类也支持派生类向基类的类型转换 静态类型和动态类型 使用存在继承关系的类型时，需要区分一个变量或者表达式的静态类型和动态类型 静态类型编译时总是已知的，它是变量声明时的类型或者表达式生成的类型 动态类型则是变量或表达式表示内存中的对象的类型，运行时才可以确定 如果表达式既不是引用也不是指针，则它的动态类型和静态类型永远一致 不存在基类向派生类的隐式转换 派生类可以向基类转换是因为派生类中含有基类的成员，基类的引用或指针可以绑定到该基类部分上 而基类对象中可能存在派生类对象中的成员，也可能不存在，所以不能从基类向派生类自动类型转换 Quote base; Bulk_quote* bulkPtr = \u0026base; //错误：基类不能转换为派生类 Bulk_quote\u0026 bulkRef = base; //错误：基类不能转换为派生类 ==即使一个基类指针或者引用类型绑定在派生类对象上，我们也不能执行从基类向派生类的转换== Bulk_quote bulk; Quote *itemPtr = \u0026bulk; //正确：动态类型是Bulk_quote Bulk_quote *bulkPtr = itemPtr; //错误：不能将基类转换为派生类 编译器在编译时候无法确定上述转换过程在运行时是否安全，编译器只能检查静态类型来判断是否合法 对象之间不存在类型转换派生类向基类的自动类型转换只能对指针和引用有效，在派生类和基类类型之间不存在这样的转换。 当对基类进行初始化或者拷贝赋值时，如果传入的是派生类的对象，通常只会将派生类中含有基类的部分进行拷贝复制，而派生类多的部分会被忽略 Bulk_quote bulk; //派生类对象 Quote item(bulk); //使用Quote::Quote(const Quote\u0026)构造函数 item = bulk; //调用Quote::operator=(const Quote\u0026) 当构造 item 时，只会处理 Quote 类中的 bookNo 和 price 两个部分，同时忽略了 bulk 中其他成员 当使用一个派生类对象为基类对象初始化或赋值时，只有派生类对象中基类部分会被拷贝、移动或赋值，它的派生类部分会被忽略 问：给出静态类型和动态类型的定义 静态类型在编译时就己经确定了，它是变量声明时的类型或表达式生成的类型； 而动态类型则是变量或表达式表示的内存中的对象的类型，动态类型直到运行时才能知道； 如果一个变量非指针也非引用，则它的静态类型和动态类型永远一致。但基类的指针或引用的动态类型可能与其动态类型不一致 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:3","series":null,"tags":["C++"],"title":"《C++Primer》第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#1523-类型转换与继承"},{"categories":["C++"],"content":"15.2.3 类型转换与继承我们可以将基类的指针或引用绑定到派生类对象上，例如：可以用 Quote\u0026 指向一个 Bulk_quote 对象 ==当使用基类的引用（或指针）时，我们并不清楚该引用（指针）所绑定对象的真实类型==，可能该对象时基类的对象，也可能时派生类的对象 智能指针类也支持派生类向基类的类型转换 静态类型和动态类型 使用存在继承关系的类型时，需要区分一个变量或者表达式的静态类型和动态类型 静态类型编译时总是已知的，它是变量声明时的类型或者表达式生成的类型 动态类型则是变量或表达式表示内存中的对象的类型，运行时才可以确定 如果表达式既不是引用也不是指针，则它的动态类型和静态类型永远一致 不存在基类向派生类的隐式转换 派生类可以向基类转换是因为派生类中含有基类的成员，基类的引用或指针可以绑定到该基类部分上 而基类对象中可能存在派生类对象中的成员，也可能不存在，所以不能从基类向派生类自动类型转换 Quote base; Bulk_quote* bulkPtr = \u0026base; //错误：基类不能转换为派生类 Bulk_quote\u0026 bulkRef = base; //错误：基类不能转换为派生类 ==即使一个基类指针或者引用类型绑定在派生类对象上，我们也不能执行从基类向派生类的转换== Bulk_quote bulk; Quote *itemPtr = \u0026bulk; //正确：动态类型是Bulk_quote Bulk_quote *bulkPtr = itemPtr; //错误：不能将基类转换为派生类 编译器在编译时候无法确定上述转换过程在运行时是否安全，编译器只能检查静态类型来判断是否合法 对象之间不存在类型转换派生类向基类的自动类型转换只能对指针和引用有效，在派生类和基类类型之间不存在这样的转换。 当对基类进行初始化或者拷贝赋值时，如果传入的是派生类的对象，通常只会将派生类中含有基类的部分进行拷贝复制，而派生类多的部分会被忽略 Bulk_quote bulk; //派生类对象 Quote item(bulk); //使用Quote::Quote(const Quote\u0026)构造函数 item = bulk; //调用Quote::operator=(const Quote\u0026) 当构造 item 时，只会处理 Quote 类中的 bookNo 和 price 两个部分，同时忽略了 bulk 中其他成员 当使用一个派生类对象为基类对象初始化或赋值时，只有派生类对象中基类部分会被拷贝、移动或赋值，它的派生类部分会被忽略 问：给出静态类型和动态类型的定义 静态类型在编译时就己经确定了，它是变量声明时的类型或表达式生成的类型； 而动态类型则是变量或表达式表示的内存中的对象的类型，动态类型直到运行时才能知道； 如果一个变量非指针也非引用，则它的静态类型和动态类型永远一致。但基类的指针或引用的动态类型可能与其动态类型不一致 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:3","series":null,"tags":["C++"],"title":"《C++Primer》第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#静态类型和动态类型"},{"categories":["C++"],"content":"15.2.3 类型转换与继承我们可以将基类的指针或引用绑定到派生类对象上，例如：可以用 Quote\u0026 指向一个 Bulk_quote 对象 ==当使用基类的引用（或指针）时，我们并不清楚该引用（指针）所绑定对象的真实类型==，可能该对象时基类的对象，也可能时派生类的对象 智能指针类也支持派生类向基类的类型转换 静态类型和动态类型 使用存在继承关系的类型时，需要区分一个变量或者表达式的静态类型和动态类型 静态类型编译时总是已知的，它是变量声明时的类型或者表达式生成的类型 动态类型则是变量或表达式表示内存中的对象的类型，运行时才可以确定 如果表达式既不是引用也不是指针，则它的动态类型和静态类型永远一致 不存在基类向派生类的隐式转换 派生类可以向基类转换是因为派生类中含有基类的成员，基类的引用或指针可以绑定到该基类部分上 而基类对象中可能存在派生类对象中的成员，也可能不存在，所以不能从基类向派生类自动类型转换 Quote base; Bulk_quote* bulkPtr = \u0026base; //错误：基类不能转换为派生类 Bulk_quote\u0026 bulkRef = base; //错误：基类不能转换为派生类 ==即使一个基类指针或者引用类型绑定在派生类对象上，我们也不能执行从基类向派生类的转换== Bulk_quote bulk; Quote *itemPtr = \u0026bulk; //正确：动态类型是Bulk_quote Bulk_quote *bulkPtr = itemPtr; //错误：不能将基类转换为派生类 编译器在编译时候无法确定上述转换过程在运行时是否安全，编译器只能检查静态类型来判断是否合法 对象之间不存在类型转换派生类向基类的自动类型转换只能对指针和引用有效，在派生类和基类类型之间不存在这样的转换。 当对基类进行初始化或者拷贝赋值时，如果传入的是派生类的对象，通常只会将派生类中含有基类的部分进行拷贝复制，而派生类多的部分会被忽略 Bulk_quote bulk; //派生类对象 Quote item(bulk); //使用Quote::Quote(const Quote\u0026)构造函数 item = bulk; //调用Quote::operator=(const Quote\u0026) 当构造 item 时，只会处理 Quote 类中的 bookNo 和 price 两个部分，同时忽略了 bulk 中其他成员 当使用一个派生类对象为基类对象初始化或赋值时，只有派生类对象中基类部分会被拷贝、移动或赋值，它的派生类部分会被忽略 问：给出静态类型和动态类型的定义 静态类型在编译时就己经确定了，它是变量声明时的类型或表达式生成的类型； 而动态类型则是变量或表达式表示的内存中的对象的类型，动态类型直到运行时才能知道； 如果一个变量非指针也非引用，则它的静态类型和动态类型永远一致。但基类的指针或引用的动态类型可能与其动态类型不一致 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:3","series":null,"tags":["C++"],"title":"《C++Primer》第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#不存在基类向派生类的隐式转换"},{"categories":["C++"],"content":"15.2.3 类型转换与继承我们可以将基类的指针或引用绑定到派生类对象上，例如：可以用 Quote\u0026 指向一个 Bulk_quote 对象 ==当使用基类的引用（或指针）时，我们并不清楚该引用（指针）所绑定对象的真实类型==，可能该对象时基类的对象，也可能时派生类的对象 智能指针类也支持派生类向基类的类型转换 静态类型和动态类型 使用存在继承关系的类型时，需要区分一个变量或者表达式的静态类型和动态类型 静态类型编译时总是已知的，它是变量声明时的类型或者表达式生成的类型 动态类型则是变量或表达式表示内存中的对象的类型，运行时才可以确定 如果表达式既不是引用也不是指针，则它的动态类型和静态类型永远一致 不存在基类向派生类的隐式转换 派生类可以向基类转换是因为派生类中含有基类的成员，基类的引用或指针可以绑定到该基类部分上 而基类对象中可能存在派生类对象中的成员，也可能不存在，所以不能从基类向派生类自动类型转换 Quote base; Bulk_quote* bulkPtr = \u0026base; //错误：基类不能转换为派生类 Bulk_quote\u0026 bulkRef = base; //错误：基类不能转换为派生类 ==即使一个基类指针或者引用类型绑定在派生类对象上，我们也不能执行从基类向派生类的转换== Bulk_quote bulk; Quote *itemPtr = \u0026bulk; //正确：动态类型是Bulk_quote Bulk_quote *bulkPtr = itemPtr; //错误：不能将基类转换为派生类 编译器在编译时候无法确定上述转换过程在运行时是否安全，编译器只能检查静态类型来判断是否合法 对象之间不存在类型转换派生类向基类的自动类型转换只能对指针和引用有效，在派生类和基类类型之间不存在这样的转换。 当对基类进行初始化或者拷贝赋值时，如果传入的是派生类的对象，通常只会将派生类中含有基类的部分进行拷贝复制，而派生类多的部分会被忽略 Bulk_quote bulk; //派生类对象 Quote item(bulk); //使用Quote::Quote(const Quote\u0026)构造函数 item = bulk; //调用Quote::operator=(const Quote\u0026) 当构造 item 时，只会处理 Quote 类中的 bookNo 和 price 两个部分，同时忽略了 bulk 中其他成员 当使用一个派生类对象为基类对象初始化或赋值时，只有派生类对象中基类部分会被拷贝、移动或赋值，它的派生类部分会被忽略 问：给出静态类型和动态类型的定义 静态类型在编译时就己经确定了，它是变量声明时的类型或表达式生成的类型； 而动态类型则是变量或表达式表示的内存中的对象的类型，动态类型直到运行时才能知道； 如果一个变量非指针也非引用，则它的静态类型和动态类型永远一致。但基类的指针或引用的动态类型可能与其动态类型不一致 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:3","series":null,"tags":["C++"],"title":"《C++Primer》第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#对象之间不存在类型转换"},{"categories":["C++"],"content":"15.3 虚函数我们使用基类的引用或指针调用一个虚函数的成员函数时，会执行动态绑定，直到运行时我们才能知道到底调用了哪个版本的虚函数，所以所有的虚函数都必须被定义 虚函数的调用可能在运行时才被解析下面是个例子： Quote base(\"0-201-824-1\", 50); print_total(cout, base, 10); //Quote::net_price Bulk_quote derived(\"021-82470-1\", 50); print_total(cout, derived, 10); //Bulk_quote::net_price 第一次调用 print_total 时，base 绑定到 Quote 上，运行的是 Quote 定义的版本 第二次调用时，derived 绑定的 Bulk_quote 版本上，调用的会是 Bulk_quote 定义的版本 动态绑定只有当通过引用或指针调用虚函数时才会发生 base = derived; //把derived中Quote部分拷贝给base base.net_price(20); //调用Quote::net_price 使用普通类型（非指针非引用）的表达式调用虚函数时，在编译阶段就已经确定下来调用的版本了 派生类中的虚函数 派生类如果覆盖继承而来的虚函数，它的形参类型和返回类型必须和基类函数一致 当派生类返回类型是指针或引用时，返回类型存在例外，如果 D 由 B 派生而来，则派生类的返回类型可以时 B* ，而基类返回类型为 D* final 和 override 说明符派生类如果定义了一个函数和虚函数名字相同但是形参列表不同，编译器会认为这个函数和原有函数相互独立，这样的话就不符合我们的想法，派生类没有覆盖基类中的虚函数。或者是在派生类定义函数时因为疏忽打错了函数名，也会出现上述情况 C++11新标准提供 override 关键字来说明派生类中的虚函数，这样使得程序员意图更清晰同时编译器也可以发现错误 struct B { virtual void f1(int) const; virtual void f2(); void f3(); }; struct D1 : B { void f1(int) const override; //正确：f1与基类f1匹配 void f2(int) override; //错误：形参不匹配 void f3() override; //错误：f3不是虚函数 void f4() override; //错误：基类没有名为f4函数 } 如果我们使用 final 关键字，则之后尝试覆盖该函数操作都会失败 struct D2 : B { //从B继承f2()和f3()，覆盖f1(int) void f1(int) const final;//不允许后续其他类覆盖f1(int) }; struct D3 : D2 { void f2(); //正确：覆盖从基类B间接继承来的f2() void f1(int) const; //错误：D2将f1声明为final } final 和 override 说明符出现在形参列表（包括任何const和引用修饰符）以及尾置返回类型之后 虚函数和默认实参虚函数也可以像其他函数一样拥有默认实参，基类和派生类定义的默认实参最好相同 回避虚函数的机制如果希望对虚函数的调用不要进行动态绑定，而是强迫执行虚函数的特定版本，可以使用作用域运算符实现这一目的 double undiscounted = basePtr-\u003eQuote::net_price(42); 通常情况下，只有成员函数（或友元）中代码才需要使用作用域运算符回避虚函数机制 通常当一个派生类的虚函数想调用基类中虚函数版本时，需要回避虚函数的机制 如果派生类虚函数中没有使用作用域运算符，运行时被解析成调用自身版本，导致无限循环 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:3:0","series":null,"tags":["C++"],"title":"《C++Primer》第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#153-虚函数"},{"categories":["C++"],"content":"15.3 虚函数我们使用基类的引用或指针调用一个虚函数的成员函数时，会执行动态绑定，直到运行时我们才能知道到底调用了哪个版本的虚函数，所以所有的虚函数都必须被定义 虚函数的调用可能在运行时才被解析下面是个例子： Quote base(\"0-201-824-1\", 50); print_total(cout, base, 10); //Quote::net_price Bulk_quote derived(\"021-82470-1\", 50); print_total(cout, derived, 10); //Bulk_quote::net_price 第一次调用 print_total 时，base 绑定到 Quote 上，运行的是 Quote 定义的版本 第二次调用时，derived 绑定的 Bulk_quote 版本上，调用的会是 Bulk_quote 定义的版本 动态绑定只有当通过引用或指针调用虚函数时才会发生 base = derived; //把derived中Quote部分拷贝给base base.net_price(20); //调用Quote::net_price 使用普通类型（非指针非引用）的表达式调用虚函数时，在编译阶段就已经确定下来调用的版本了 派生类中的虚函数 派生类如果覆盖继承而来的虚函数，它的形参类型和返回类型必须和基类函数一致 当派生类返回类型是指针或引用时，返回类型存在例外，如果 D 由 B 派生而来，则派生类的返回类型可以时 B* ，而基类返回类型为 D* final 和 override 说明符派生类如果定义了一个函数和虚函数名字相同但是形参列表不同，编译器会认为这个函数和原有函数相互独立，这样的话就不符合我们的想法，派生类没有覆盖基类中的虚函数。或者是在派生类定义函数时因为疏忽打错了函数名，也会出现上述情况 C++11新标准提供 override 关键字来说明派生类中的虚函数，这样使得程序员意图更清晰同时编译器也可以发现错误 struct B { virtual void f1(int) const; virtual void f2(); void f3(); }; struct D1 : B { void f1(int) const override; //正确：f1与基类f1匹配 void f2(int) override; //错误：形参不匹配 void f3() override; //错误：f3不是虚函数 void f4() override; //错误：基类没有名为f4函数 } 如果我们使用 final 关键字，则之后尝试覆盖该函数操作都会失败 struct D2 : B { //从B继承f2()和f3()，覆盖f1(int) void f1(int) const final;//不允许后续其他类覆盖f1(int) }; struct D3 : D2 { void f2(); //正确：覆盖从基类B间接继承来的f2() void f1(int) const; //错误：D2将f1声明为final } final 和 override 说明符出现在形参列表（包括任何const和引用修饰符）以及尾置返回类型之后 虚函数和默认实参虚函数也可以像其他函数一样拥有默认实参，基类和派生类定义的默认实参最好相同 回避虚函数的机制如果希望对虚函数的调用不要进行动态绑定，而是强迫执行虚函数的特定版本，可以使用作用域运算符实现这一目的 double undiscounted = basePtr-Quote::net_price(42); 通常情况下，只有成员函数（或友元）中代码才需要使用作用域运算符回避虚函数机制 通常当一个派生类的虚函数想调用基类中虚函数版本时，需要回避虚函数的机制 如果派生类虚函数中没有使用作用域运算符，运行时被解析成调用自身版本，导致无限循环 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:3:0","series":null,"tags":["C++"],"title":"《C++Primer》第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#虚函数的调用可能在运行时才被解析"},{"categories":["C++"],"content":"15.3 虚函数我们使用基类的引用或指针调用一个虚函数的成员函数时，会执行动态绑定，直到运行时我们才能知道到底调用了哪个版本的虚函数，所以所有的虚函数都必须被定义 虚函数的调用可能在运行时才被解析下面是个例子： Quote base(\"0-201-824-1\", 50); print_total(cout, base, 10); //Quote::net_price Bulk_quote derived(\"021-82470-1\", 50); print_total(cout, derived, 10); //Bulk_quote::net_price 第一次调用 print_total 时，base 绑定到 Quote 上，运行的是 Quote 定义的版本 第二次调用时，derived 绑定的 Bulk_quote 版本上，调用的会是 Bulk_quote 定义的版本 动态绑定只有当通过引用或指针调用虚函数时才会发生 base = derived; //把derived中Quote部分拷贝给base base.net_price(20); //调用Quote::net_price 使用普通类型（非指针非引用）的表达式调用虚函数时，在编译阶段就已经确定下来调用的版本了 派生类中的虚函数 派生类如果覆盖继承而来的虚函数，它的形参类型和返回类型必须和基类函数一致 当派生类返回类型是指针或引用时，返回类型存在例外，如果 D 由 B 派生而来，则派生类的返回类型可以时 B* ，而基类返回类型为 D* final 和 override 说明符派生类如果定义了一个函数和虚函数名字相同但是形参列表不同，编译器会认为这个函数和原有函数相互独立，这样的话就不符合我们的想法，派生类没有覆盖基类中的虚函数。或者是在派生类定义函数时因为疏忽打错了函数名，也会出现上述情况 C++11新标准提供 override 关键字来说明派生类中的虚函数，这样使得程序员意图更清晰同时编译器也可以发现错误 struct B { virtual void f1(int) const; virtual void f2(); void f3(); }; struct D1 : B { void f1(int) const override; //正确：f1与基类f1匹配 void f2(int) override; //错误：形参不匹配 void f3() override; //错误：f3不是虚函数 void f4() override; //错误：基类没有名为f4函数 } 如果我们使用 final 关键字，则之后尝试覆盖该函数操作都会失败 struct D2 : B { //从B继承f2()和f3()，覆盖f1(int) void f1(int) const final;//不允许后续其他类覆盖f1(int) }; struct D3 : D2 { void f2(); //正确：覆盖从基类B间接继承来的f2() void f1(int) const; //错误：D2将f1声明为final } final 和 override 说明符出现在形参列表（包括任何const和引用修饰符）以及尾置返回类型之后 虚函数和默认实参虚函数也可以像其他函数一样拥有默认实参，基类和派生类定义的默认实参最好相同 回避虚函数的机制如果希望对虚函数的调用不要进行动态绑定，而是强迫执行虚函数的特定版本，可以使用作用域运算符实现这一目的 double undiscounted = basePtr-Quote::net_price(42); 通常情况下，只有成员函数（或友元）中代码才需要使用作用域运算符回避虚函数机制 通常当一个派生类的虚函数想调用基类中虚函数版本时，需要回避虚函数的机制 如果派生类虚函数中没有使用作用域运算符，运行时被解析成调用自身版本，导致无限循环 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:3:0","series":null,"tags":["C++"],"title":"《C++Primer》第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#派生类中的虚函数-1"},{"categories":["C++"],"content":"15.3 虚函数我们使用基类的引用或指针调用一个虚函数的成员函数时，会执行动态绑定，直到运行时我们才能知道到底调用了哪个版本的虚函数，所以所有的虚函数都必须被定义 虚函数的调用可能在运行时才被解析下面是个例子： Quote base(\"0-201-824-1\", 50); print_total(cout, base, 10); //Quote::net_price Bulk_quote derived(\"021-82470-1\", 50); print_total(cout, derived, 10); //Bulk_quote::net_price 第一次调用 print_total 时，base 绑定到 Quote 上，运行的是 Quote 定义的版本 第二次调用时，derived 绑定的 Bulk_quote 版本上，调用的会是 Bulk_quote 定义的版本 动态绑定只有当通过引用或指针调用虚函数时才会发生 base = derived; //把derived中Quote部分拷贝给base base.net_price(20); //调用Quote::net_price 使用普通类型（非指针非引用）的表达式调用虚函数时，在编译阶段就已经确定下来调用的版本了 派生类中的虚函数 派生类如果覆盖继承而来的虚函数，它的形参类型和返回类型必须和基类函数一致 当派生类返回类型是指针或引用时，返回类型存在例外，如果 D 由 B 派生而来，则派生类的返回类型可以时 B* ，而基类返回类型为 D* final 和 override 说明符派生类如果定义了一个函数和虚函数名字相同但是形参列表不同，编译器会认为这个函数和原有函数相互独立，这样的话就不符合我们的想法，派生类没有覆盖基类中的虚函数。或者是在派生类定义函数时因为疏忽打错了函数名，也会出现上述情况 C++11新标准提供 override 关键字来说明派生类中的虚函数，这样使得程序员意图更清晰同时编译器也可以发现错误 struct B { virtual void f1(int) const; virtual void f2(); void f3(); }; struct D1 : B { void f1(int) const override; //正确：f1与基类f1匹配 void f2(int) override; //错误：形参不匹配 void f3() override; //错误：f3不是虚函数 void f4() override; //错误：基类没有名为f4函数 } 如果我们使用 final 关键字，则之后尝试覆盖该函数操作都会失败 struct D2 : B { //从B继承f2()和f3()，覆盖f1(int) void f1(int) const final;//不允许后续其他类覆盖f1(int) }; struct D3 : D2 { void f2(); //正确：覆盖从基类B间接继承来的f2() void f1(int) const; //错误：D2将f1声明为final } final 和 override 说明符出现在形参列表（包括任何const和引用修饰符）以及尾置返回类型之后 虚函数和默认实参虚函数也可以像其他函数一样拥有默认实参，基类和派生类定义的默认实参最好相同 回避虚函数的机制如果希望对虚函数的调用不要进行动态绑定，而是强迫执行虚函数的特定版本，可以使用作用域运算符实现这一目的 double undiscounted = basePtr-Quote::net_price(42); 通常情况下，只有成员函数（或友元）中代码才需要使用作用域运算符回避虚函数机制 通常当一个派生类的虚函数想调用基类中虚函数版本时，需要回避虚函数的机制 如果派生类虚函数中没有使用作用域运算符，运行时被解析成调用自身版本，导致无限循环 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:3:0","series":null,"tags":["C++"],"title":"《C++Primer》第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#final-和-override-说明符"},{"categories":["C++"],"content":"15.3 虚函数我们使用基类的引用或指针调用一个虚函数的成员函数时，会执行动态绑定，直到运行时我们才能知道到底调用了哪个版本的虚函数，所以所有的虚函数都必须被定义 虚函数的调用可能在运行时才被解析下面是个例子： Quote base(\"0-201-824-1\", 50); print_total(cout, base, 10); //Quote::net_price Bulk_quote derived(\"021-82470-1\", 50); print_total(cout, derived, 10); //Bulk_quote::net_price 第一次调用 print_total 时，base 绑定到 Quote 上，运行的是 Quote 定义的版本 第二次调用时，derived 绑定的 Bulk_quote 版本上，调用的会是 Bulk_quote 定义的版本 动态绑定只有当通过引用或指针调用虚函数时才会发生 base = derived; //把derived中Quote部分拷贝给base base.net_price(20); //调用Quote::net_price 使用普通类型（非指针非引用）的表达式调用虚函数时，在编译阶段就已经确定下来调用的版本了 派生类中的虚函数 派生类如果覆盖继承而来的虚函数，它的形参类型和返回类型必须和基类函数一致 当派生类返回类型是指针或引用时，返回类型存在例外，如果 D 由 B 派生而来，则派生类的返回类型可以时 B* ，而基类返回类型为 D* final 和 override 说明符派生类如果定义了一个函数和虚函数名字相同但是形参列表不同，编译器会认为这个函数和原有函数相互独立，这样的话就不符合我们的想法，派生类没有覆盖基类中的虚函数。或者是在派生类定义函数时因为疏忽打错了函数名，也会出现上述情况 C++11新标准提供 override 关键字来说明派生类中的虚函数，这样使得程序员意图更清晰同时编译器也可以发现错误 struct B { virtual void f1(int) const; virtual void f2(); void f3(); }; struct D1 : B { void f1(int) const override; //正确：f1与基类f1匹配 void f2(int) override; //错误：形参不匹配 void f3() override; //错误：f3不是虚函数 void f4() override; //错误：基类没有名为f4函数 } 如果我们使用 final 关键字，则之后尝试覆盖该函数操作都会失败 struct D2 : B { //从B继承f2()和f3()，覆盖f1(int) void f1(int) const final;//不允许后续其他类覆盖f1(int) }; struct D3 : D2 { void f2(); //正确：覆盖从基类B间接继承来的f2() void f1(int) const; //错误：D2将f1声明为final } final 和 override 说明符出现在形参列表（包括任何const和引用修饰符）以及尾置返回类型之后 虚函数和默认实参虚函数也可以像其他函数一样拥有默认实参，基类和派生类定义的默认实参最好相同 回避虚函数的机制如果希望对虚函数的调用不要进行动态绑定，而是强迫执行虚函数的特定版本，可以使用作用域运算符实现这一目的 double undiscounted = basePtr-Quote::net_price(42); 通常情况下，只有成员函数（或友元）中代码才需要使用作用域运算符回避虚函数机制 通常当一个派生类的虚函数想调用基类中虚函数版本时，需要回避虚函数的机制 如果派生类虚函数中没有使用作用域运算符，运行时被解析成调用自身版本，导致无限循环 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:3:0","series":null,"tags":["C++"],"title":"《C++Primer》第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#虚函数和默认实参"},{"categories":["C++"],"content":"15.3 虚函数我们使用基类的引用或指针调用一个虚函数的成员函数时，会执行动态绑定，直到运行时我们才能知道到底调用了哪个版本的虚函数，所以所有的虚函数都必须被定义 虚函数的调用可能在运行时才被解析下面是个例子： Quote base(\"0-201-824-1\", 50); print_total(cout, base, 10); //Quote::net_price Bulk_quote derived(\"021-82470-1\", 50); print_total(cout, derived, 10); //Bulk_quote::net_price 第一次调用 print_total 时，base 绑定到 Quote 上，运行的是 Quote 定义的版本 第二次调用时，derived 绑定的 Bulk_quote 版本上，调用的会是 Bulk_quote 定义的版本 动态绑定只有当通过引用或指针调用虚函数时才会发生 base = derived; //把derived中Quote部分拷贝给base base.net_price(20); //调用Quote::net_price 使用普通类型（非指针非引用）的表达式调用虚函数时，在编译阶段就已经确定下来调用的版本了 派生类中的虚函数 派生类如果覆盖继承而来的虚函数，它的形参类型和返回类型必须和基类函数一致 当派生类返回类型是指针或引用时，返回类型存在例外，如果 D 由 B 派生而来，则派生类的返回类型可以时 B* ，而基类返回类型为 D* final 和 override 说明符派生类如果定义了一个函数和虚函数名字相同但是形参列表不同，编译器会认为这个函数和原有函数相互独立，这样的话就不符合我们的想法，派生类没有覆盖基类中的虚函数。或者是在派生类定义函数时因为疏忽打错了函数名，也会出现上述情况 C++11新标准提供 override 关键字来说明派生类中的虚函数，这样使得程序员意图更清晰同时编译器也可以发现错误 struct B { virtual void f1(int) const; virtual void f2(); void f3(); }; struct D1 : B { void f1(int) const override; //正确：f1与基类f1匹配 void f2(int) override; //错误：形参不匹配 void f3() override; //错误：f3不是虚函数 void f4() override; //错误：基类没有名为f4函数 } 如果我们使用 final 关键字，则之后尝试覆盖该函数操作都会失败 struct D2 : B { //从B继承f2()和f3()，覆盖f1(int) void f1(int) const final;//不允许后续其他类覆盖f1(int) }; struct D3 : D2 { void f2(); //正确：覆盖从基类B间接继承来的f2() void f1(int) const; //错误：D2将f1声明为final } final 和 override 说明符出现在形参列表（包括任何const和引用修饰符）以及尾置返回类型之后 虚函数和默认实参虚函数也可以像其他函数一样拥有默认实参，基类和派生类定义的默认实参最好相同 回避虚函数的机制如果希望对虚函数的调用不要进行动态绑定，而是强迫执行虚函数的特定版本，可以使用作用域运算符实现这一目的 double undiscounted = basePtr-Quote::net_price(42); 通常情况下，只有成员函数（或友元）中代码才需要使用作用域运算符回避虚函数机制 通常当一个派生类的虚函数想调用基类中虚函数版本时，需要回避虚函数的机制 如果派生类虚函数中没有使用作用域运算符，运行时被解析成调用自身版本，导致无限循环 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:3:0","series":null,"tags":["C++"],"title":"《C++Primer》第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#回避虚函数的机制"},{"categories":["C++"],"content":"15.4 抽象基类纯虚函数我们如果将虚函数定义为纯虚函数，含有该函数的类是抽象基类，抽象基类负责定义接口，而后续其他类可以覆盖该接口 我们在函数体的位置（即分号前面）书写 =0 就可以将一个虚函数说明为纯虚函数 class Disc_quote : public Quote { public: Disc_quote() = default; Disc_quote(const std::string\u0026 book, double price, std::size_t qty, double price) : Quote(book, price), quantity(qty), discount(dis) {} double net_price(std::size_t) const = 0; protected: std::size_t quantity = 0; double discount = 0.0; } 纯虚函数无须定义，我们也可以为其定义，但函数体必须写在类的外部，即我们不能在类的内部为一个 =0 的函数提供函数体 我们不能直接创建一个抽象基类的对象 派生类构造函数只初始化它的直接基类下面重新实现 Bulk_quote class Bulk_quote : public Disc_quote { public: Bulk_quote() = default; Bulk_quote(const std::string\u0026 book, double price, std::size_t qty, double price) : Disc_quote(book, price, qty, disc) {} double net_price(std::size_t) const override; }; 每个类各自控制其对象的初始化过程，即使 Bulk_quote 中没有任何数据成员，也需要提供一个构造函数，初始化它的直接基类，也就是 Disc_quote ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:4:0","series":null,"tags":["C++"],"title":"《C++Primer》第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#154-抽象基类"},{"categories":["C++"],"content":"15.4 抽象基类纯虚函数我们如果将虚函数定义为纯虚函数，含有该函数的类是抽象基类，抽象基类负责定义接口，而后续其他类可以覆盖该接口 我们在函数体的位置（即分号前面）书写 =0 就可以将一个虚函数说明为纯虚函数 class Disc_quote : public Quote { public: Disc_quote() = default; Disc_quote(const std::string\u0026 book, double price, std::size_t qty, double price) : Quote(book, price), quantity(qty), discount(dis) {} double net_price(std::size_t) const = 0; protected: std::size_t quantity = 0; double discount = 0.0; } 纯虚函数无须定义，我们也可以为其定义，但函数体必须写在类的外部，即我们不能在类的内部为一个 =0 的函数提供函数体 我们不能直接创建一个抽象基类的对象 派生类构造函数只初始化它的直接基类下面重新实现 Bulk_quote class Bulk_quote : public Disc_quote { public: Bulk_quote() = default; Bulk_quote(const std::string\u0026 book, double price, std::size_t qty, double price) : Disc_quote(book, price, qty, disc) {} double net_price(std::size_t) const override; }; 每个类各自控制其对象的初始化过程，即使 Bulk_quote 中没有任何数据成员，也需要提供一个构造函数，初始化它的直接基类，也就是 Disc_quote ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:4:0","series":null,"tags":["C++"],"title":"《C++Primer》第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#纯虚函数"},{"categories":["C++"],"content":"15.4 抽象基类纯虚函数我们如果将虚函数定义为纯虚函数，含有该函数的类是抽象基类，抽象基类负责定义接口，而后续其他类可以覆盖该接口 我们在函数体的位置（即分号前面）书写 =0 就可以将一个虚函数说明为纯虚函数 class Disc_quote : public Quote { public: Disc_quote() = default; Disc_quote(const std::string\u0026 book, double price, std::size_t qty, double price) : Quote(book, price), quantity(qty), discount(dis) {} double net_price(std::size_t) const = 0; protected: std::size_t quantity = 0; double discount = 0.0; } 纯虚函数无须定义，我们也可以为其定义，但函数体必须写在类的外部，即我们不能在类的内部为一个 =0 的函数提供函数体 我们不能直接创建一个抽象基类的对象 派生类构造函数只初始化它的直接基类下面重新实现 Bulk_quote class Bulk_quote : public Disc_quote { public: Bulk_quote() = default; Bulk_quote(const std::string\u0026 book, double price, std::size_t qty, double price) : Disc_quote(book, price, qty, disc) {} double net_price(std::size_t) const override; }; 每个类各自控制其对象的初始化过程，即使 Bulk_quote 中没有任何数据成员，也需要提供一个构造函数，初始化它的直接基类，也就是 Disc_quote ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:4:0","series":null,"tags":["C++"],"title":"《C++Primer》第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#派生类构造函数只初始化它的直接基类"},{"categories":["C++"],"content":"15.5 访问控制与继承每个类分别控制自己成员初始化过程，每个类还控制着其成员对于派生类来说是否可访问 受保护的成员protected 关键字可以控制那些它希望与派生类分享但是不想和其他公共访问使用的成员 和私有成员类似，受保护的成员对于类的用户是不可访问的 和公有成员类型，受保护的成员对于派生类和友元是可访问的 派生类的成员或友元只能通过派生类对象来访问基类中受保护的成员 派生类对于基类对象中受保护成员没有任何访问权限 class Base { protected: int prot_mem; }; class Sneaky : public Base { friend void clobber(Sneaky\u0026);//能访问Sneaky::prot_mem friend void clobber(Base\u0026*); //不能访问Base::prot_mem int j; //默认为private }; //正确：可以访问Sneaky对象的private和protected成员 void clobber(Sneaky \u0026s) { s.j = s.prot_mem = 0; } //错误：不能访问Base中的protected成员 void clobber(Base \u0026b) { b.prot_mem = 0; } 上面的最后一条的含义是一个派生类成员和友元只能访问派生类继承过来属于基类那部分的受保护成员（这些成员，派生类自己本身也有，成员和友元可以访问自己本身的受保护的成员），而不能直接访问基类对象中的受保护成员 公共、私有和受保护继承类对继承而来的成员的访问权限受到两个因素影响：一是基类在该成员的访问说明符，二是派生类的派生列表中的访问说明符 class Base { public: void pub_mem(); protected: int prot_mem; private: char priv_mem; }; struct Pub_Derv : public Base { //正确：派生类能访问protected成员 int f() { return prot_mem; } //错误：派生类不能访问private成员 char g() { return priv_mem; } }; struct Priv_Derv : private Base { //private不影响派生类访问权限 int f1() const { return prot_mem; } }; 派生类访问说明符对于派生类的成员能否访问直接基类的成员没有什么影响，如上 Pub_Derv 和 Priv_Derv 都可以访问基类 Base 中的 prot_mem 派生类访问说明符是控制派生类用户（包括派生类的派生类）对于基类成员的访问权限，相当于将基类成员定义为相应的访问说明符 Pub_Derv d1; Priv_Derv d2; d1.pub_mem(); //正确：pub_mem在派生类中是public的 d2.pub_mem(); //错误：pub_mem在派生类中是protected的 此时在 Priv_Derv 中基类的成员被定义为 private 的了，这样它创建的对象就不可以直接访问 派生类向基类转换的可访问性派生类向基类的转换是否可访问由使用该转换的代码决定，同时派牛类的派生访问说明符也会有影响。假定D 继承自B :· 只有当 D 公有地继承 B 时，用户代码才能使用派生类向基类的转换；如果 D 继承 B 的方式是受保护的或者私有的，则用户代码不能使用该转换。 不论 D 以什么方式继承B , D 的成员函数和友元都能使用派生类向基类的转换： 派生类向其直接基类的类型转换对千派牛类的成员和友元来说水远是可访问的。 如果 D 继承 B 的方式是公有的或者受保护的，则 D 的派生类的成员和友元可以使用 D 向 B 的类型转换； 反之，如果 D 继承 B 的方式是私有的，则不能使用。 友元和继承友元关系不能传递，也不能继承，基类的友元在访问派生类成员时不具有特殊性 class Base { friend class Pal; protected: int prot_mem; }; class Sneaky : public Base { friend void clobber(Sneaky\u0026);//能访问Sneaky::prot_mem friend void clobber(Base\u0026*); //不能访问Base::prot_mem int j; //默认为private }; class Pal { public: int f(Base b) { return b.prot_mem; } //正确：Pal是Base友元 int f(Sneaky s) { return s.j; } //错误：Pal不是Sneaky友元 int f3(Sneaky s) { return s.prot_mem; }//正确：Pal是Base友元 } f3 访问了派生类中基类部分的成员，Pal 是基类的友元，Pal 能够访问 Base 对象的成员 友元只对做出声明的类有效，而友元的基类或派生类不具有特殊访问能力 class D2 : public Pal { public: int mem(Base b) { return b.prot_mem; } //错误友元不能继承 } 改变个别成员的可访问性如果需要改变派生类继承的某个名字的访问性，可以使用 using 声明达到这个目的 class Base { public: std::size_t size() cont { return n; } protected: std::size_t n; }; class Dervied : private Base { public: using Base::size; protected: using Base::n; }; Derived 为私有继承，继承的size 和 n 默认情况下是 Derived 的私有成员，使用 using 声明语句，可以改变这个成员的可访问性，此时的 Derived 用户都可以使用 size，而只有 Derived 的派生类才可以使用 n using 声明控制的访问权限仅由声明语句前面的访问说明符决定 默认的继承保护级别默认情况下，class 关键字的派生类是私有继承的，struct 关键字的派生类是公有继承的 class Base { /**/ }; struct D1 : Base { /**/ }; //默认public继承 class D2 : Base { /**/ }; //默认private继承 struct 和 class 关键字唯一区别就是默认成员访问说明符默认派生访问说明符的区别 一个私有派生的类最好显示的声明 private，不要仅仅依赖默认设置 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:5:0","series":null,"tags":["C++"],"title":"《C++Primer》第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#155-访问控制与继承"},{"categories":["C++"],"content":"15.5 访问控制与继承每个类分别控制自己成员初始化过程，每个类还控制着其成员对于派生类来说是否可访问 受保护的成员protected 关键字可以控制那些它希望与派生类分享但是不想和其他公共访问使用的成员 和私有成员类似，受保护的成员对于类的用户是不可访问的 和公有成员类型，受保护的成员对于派生类和友元是可访问的 派生类的成员或友元只能通过派生类对象来访问基类中受保护的成员 派生类对于基类对象中受保护成员没有任何访问权限 class Base { protected: int prot_mem; }; class Sneaky : public Base { friend void clobber(Sneaky\u0026);//能访问Sneaky::prot_mem friend void clobber(Base\u0026*); //不能访问Base::prot_mem int j; //默认为private }; //正确：可以访问Sneaky对象的private和protected成员 void clobber(Sneaky \u0026s) { s.j = s.prot_mem = 0; } //错误：不能访问Base中的protected成员 void clobber(Base \u0026b) { b.prot_mem = 0; } 上面的最后一条的含义是一个派生类成员和友元只能访问派生类继承过来属于基类那部分的受保护成员（这些成员，派生类自己本身也有，成员和友元可以访问自己本身的受保护的成员），而不能直接访问基类对象中的受保护成员 公共、私有和受保护继承类对继承而来的成员的访问权限受到两个因素影响：一是基类在该成员的访问说明符，二是派生类的派生列表中的访问说明符 class Base { public: void pub_mem(); protected: int prot_mem; private: char priv_mem; }; struct Pub_Derv : public Base { //正确：派生类能访问protected成员 int f() { return prot_mem; } //错误：派生类不能访问private成员 char g() { return priv_mem; } }; struct Priv_Derv : private Base { //private不影响派生类访问权限 int f1() const { return prot_mem; } }; 派生类访问说明符对于派生类的成员能否访问直接基类的成员没有什么影响，如上 Pub_Derv 和 Priv_Derv 都可以访问基类 Base 中的 prot_mem 派生类访问说明符是控制派生类用户（包括派生类的派生类）对于基类成员的访问权限，相当于将基类成员定义为相应的访问说明符 Pub_Derv d1; Priv_Derv d2; d1.pub_mem(); //正确：pub_mem在派生类中是public的 d2.pub_mem(); //错误：pub_mem在派生类中是protected的 此时在 Priv_Derv 中基类的成员被定义为 private 的了，这样它创建的对象就不可以直接访问 派生类向基类转换的可访问性派生类向基类的转换是否可访问由使用该转换的代码决定，同时派牛类的派生访问说明符也会有影响。假定D 继承自B :· 只有当 D 公有地继承 B 时，用户代码才能使用派生类向基类的转换；如果 D 继承 B 的方式是受保护的或者私有的，则用户代码不能使用该转换。 不论 D 以什么方式继承B , D 的成员函数和友元都能使用派生类向基类的转换： 派生类向其直接基类的类型转换对千派牛类的成员和友元来说水远是可访问的。 如果 D 继承 B 的方式是公有的或者受保护的，则 D 的派生类的成员和友元可以使用 D 向 B 的类型转换； 反之，如果 D 继承 B 的方式是私有的，则不能使用。 友元和继承友元关系不能传递，也不能继承，基类的友元在访问派生类成员时不具有特殊性 class Base { friend class Pal; protected: int prot_mem; }; class Sneaky : public Base { friend void clobber(Sneaky\u0026);//能访问Sneaky::prot_mem friend void clobber(Base\u0026*); //不能访问Base::prot_mem int j; //默认为private }; class Pal { public: int f(Base b) { return b.prot_mem; } //正确：Pal是Base友元 int f(Sneaky s) { return s.j; } //错误：Pal不是Sneaky友元 int f3(Sneaky s) { return s.prot_mem; }//正确：Pal是Base友元 } f3 访问了派生类中基类部分的成员，Pal 是基类的友元，Pal 能够访问 Base 对象的成员 友元只对做出声明的类有效，而友元的基类或派生类不具有特殊访问能力 class D2 : public Pal { public: int mem(Base b) { return b.prot_mem; } //错误友元不能继承 } 改变个别成员的可访问性如果需要改变派生类继承的某个名字的访问性，可以使用 using 声明达到这个目的 class Base { public: std::size_t size() cont { return n; } protected: std::size_t n; }; class Dervied : private Base { public: using Base::size; protected: using Base::n; }; Derived 为私有继承，继承的size 和 n 默认情况下是 Derived 的私有成员，使用 using 声明语句，可以改变这个成员的可访问性，此时的 Derived 用户都可以使用 size，而只有 Derived 的派生类才可以使用 n using 声明控制的访问权限仅由声明语句前面的访问说明符决定 默认的继承保护级别默认情况下，class 关键字的派生类是私有继承的，struct 关键字的派生类是公有继承的 class Base { /**/ }; struct D1 : Base { /**/ }; //默认public继承 class D2 : Base { /**/ }; //默认private继承 struct 和 class 关键字唯一区别就是默认成员访问说明符默认派生访问说明符的区别 一个私有派生的类最好显示的声明 private，不要仅仅依赖默认设置 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:5:0","series":null,"tags":["C++"],"title":"《C++Primer》第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#受保护的成员"},{"categories":["C++"],"content":"15.5 访问控制与继承每个类分别控制自己成员初始化过程，每个类还控制着其成员对于派生类来说是否可访问 受保护的成员protected 关键字可以控制那些它希望与派生类分享但是不想和其他公共访问使用的成员 和私有成员类似，受保护的成员对于类的用户是不可访问的 和公有成员类型，受保护的成员对于派生类和友元是可访问的 派生类的成员或友元只能通过派生类对象来访问基类中受保护的成员 派生类对于基类对象中受保护成员没有任何访问权限 class Base { protected: int prot_mem; }; class Sneaky : public Base { friend void clobber(Sneaky\u0026);//能访问Sneaky::prot_mem friend void clobber(Base\u0026*); //不能访问Base::prot_mem int j; //默认为private }; //正确：可以访问Sneaky对象的private和protected成员 void clobber(Sneaky \u0026s) { s.j = s.prot_mem = 0; } //错误：不能访问Base中的protected成员 void clobber(Base \u0026b) { b.prot_mem = 0; } 上面的最后一条的含义是一个派生类成员和友元只能访问派生类继承过来属于基类那部分的受保护成员（这些成员，派生类自己本身也有，成员和友元可以访问自己本身的受保护的成员），而不能直接访问基类对象中的受保护成员 公共、私有和受保护继承类对继承而来的成员的访问权限受到两个因素影响：一是基类在该成员的访问说明符，二是派生类的派生列表中的访问说明符 class Base { public: void pub_mem(); protected: int prot_mem; private: char priv_mem; }; struct Pub_Derv : public Base { //正确：派生类能访问protected成员 int f() { return prot_mem; } //错误：派生类不能访问private成员 char g() { return priv_mem; } }; struct Priv_Derv : private Base { //private不影响派生类访问权限 int f1() const { return prot_mem; } }; 派生类访问说明符对于派生类的成员能否访问直接基类的成员没有什么影响，如上 Pub_Derv 和 Priv_Derv 都可以访问基类 Base 中的 prot_mem 派生类访问说明符是控制派生类用户（包括派生类的派生类）对于基类成员的访问权限，相当于将基类成员定义为相应的访问说明符 Pub_Derv d1; Priv_Derv d2; d1.pub_mem(); //正确：pub_mem在派生类中是public的 d2.pub_mem(); //错误：pub_mem在派生类中是protected的 此时在 Priv_Derv 中基类的成员被定义为 private 的了，这样它创建的对象就不可以直接访问 派生类向基类转换的可访问性派生类向基类的转换是否可访问由使用该转换的代码决定，同时派牛类的派生访问说明符也会有影响。假定D 继承自B :· 只有当 D 公有地继承 B 时，用户代码才能使用派生类向基类的转换；如果 D 继承 B 的方式是受保护的或者私有的，则用户代码不能使用该转换。 不论 D 以什么方式继承B , D 的成员函数和友元都能使用派生类向基类的转换： 派生类向其直接基类的类型转换对千派牛类的成员和友元来说水远是可访问的。 如果 D 继承 B 的方式是公有的或者受保护的，则 D 的派生类的成员和友元可以使用 D 向 B 的类型转换； 反之，如果 D 继承 B 的方式是私有的，则不能使用。 友元和继承友元关系不能传递，也不能继承，基类的友元在访问派生类成员时不具有特殊性 class Base { friend class Pal; protected: int prot_mem; }; class Sneaky : public Base { friend void clobber(Sneaky\u0026);//能访问Sneaky::prot_mem friend void clobber(Base\u0026*); //不能访问Base::prot_mem int j; //默认为private }; class Pal { public: int f(Base b) { return b.prot_mem; } //正确：Pal是Base友元 int f(Sneaky s) { return s.j; } //错误：Pal不是Sneaky友元 int f3(Sneaky s) { return s.prot_mem; }//正确：Pal是Base友元 } f3 访问了派生类中基类部分的成员，Pal 是基类的友元，Pal 能够访问 Base 对象的成员 友元只对做出声明的类有效，而友元的基类或派生类不具有特殊访问能力 class D2 : public Pal { public: int mem(Base b) { return b.prot_mem; } //错误友元不能继承 } 改变个别成员的可访问性如果需要改变派生类继承的某个名字的访问性，可以使用 using 声明达到这个目的 class Base { public: std::size_t size() cont { return n; } protected: std::size_t n; }; class Dervied : private Base { public: using Base::size; protected: using Base::n; }; Derived 为私有继承，继承的size 和 n 默认情况下是 Derived 的私有成员，使用 using 声明语句，可以改变这个成员的可访问性，此时的 Derived 用户都可以使用 size，而只有 Derived 的派生类才可以使用 n using 声明控制的访问权限仅由声明语句前面的访问说明符决定 默认的继承保护级别默认情况下，class 关键字的派生类是私有继承的，struct 关键字的派生类是公有继承的 class Base { /**/ }; struct D1 : Base { /**/ }; //默认public继承 class D2 : Base { /**/ }; //默认private继承 struct 和 class 关键字唯一区别就是默认成员访问说明符默认派生访问说明符的区别 一个私有派生的类最好显示的声明 private，不要仅仅依赖默认设置 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:5:0","series":null,"tags":["C++"],"title":"《C++Primer》第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#公共私有和受保护继承"},{"categories":["C++"],"content":"15.5 访问控制与继承每个类分别控制自己成员初始化过程，每个类还控制着其成员对于派生类来说是否可访问 受保护的成员protected 关键字可以控制那些它希望与派生类分享但是不想和其他公共访问使用的成员 和私有成员类似，受保护的成员对于类的用户是不可访问的 和公有成员类型，受保护的成员对于派生类和友元是可访问的 派生类的成员或友元只能通过派生类对象来访问基类中受保护的成员 派生类对于基类对象中受保护成员没有任何访问权限 class Base { protected: int prot_mem; }; class Sneaky : public Base { friend void clobber(Sneaky\u0026);//能访问Sneaky::prot_mem friend void clobber(Base\u0026*); //不能访问Base::prot_mem int j; //默认为private }; //正确：可以访问Sneaky对象的private和protected成员 void clobber(Sneaky \u0026s) { s.j = s.prot_mem = 0; } //错误：不能访问Base中的protected成员 void clobber(Base \u0026b) { b.prot_mem = 0; } 上面的最后一条的含义是一个派生类成员和友元只能访问派生类继承过来属于基类那部分的受保护成员（这些成员，派生类自己本身也有，成员和友元可以访问自己本身的受保护的成员），而不能直接访问基类对象中的受保护成员 公共、私有和受保护继承类对继承而来的成员的访问权限受到两个因素影响：一是基类在该成员的访问说明符，二是派生类的派生列表中的访问说明符 class Base { public: void pub_mem(); protected: int prot_mem; private: char priv_mem; }; struct Pub_Derv : public Base { //正确：派生类能访问protected成员 int f() { return prot_mem; } //错误：派生类不能访问private成员 char g() { return priv_mem; } }; struct Priv_Derv : private Base { //private不影响派生类访问权限 int f1() const { return prot_mem; } }; 派生类访问说明符对于派生类的成员能否访问直接基类的成员没有什么影响，如上 Pub_Derv 和 Priv_Derv 都可以访问基类 Base 中的 prot_mem 派生类访问说明符是控制派生类用户（包括派生类的派生类）对于基类成员的访问权限，相当于将基类成员定义为相应的访问说明符 Pub_Derv d1; Priv_Derv d2; d1.pub_mem(); //正确：pub_mem在派生类中是public的 d2.pub_mem(); //错误：pub_mem在派生类中是protected的 此时在 Priv_Derv 中基类的成员被定义为 private 的了，这样它创建的对象就不可以直接访问 派生类向基类转换的可访问性派生类向基类的转换是否可访问由使用该转换的代码决定，同时派牛类的派生访问说明符也会有影响。假定D 继承自B :· 只有当 D 公有地继承 B 时，用户代码才能使用派生类向基类的转换；如果 D 继承 B 的方式是受保护的或者私有的，则用户代码不能使用该转换。 不论 D 以什么方式继承B , D 的成员函数和友元都能使用派生类向基类的转换： 派生类向其直接基类的类型转换对千派牛类的成员和友元来说水远是可访问的。 如果 D 继承 B 的方式是公有的或者受保护的，则 D 的派生类的成员和友元可以使用 D 向 B 的类型转换； 反之，如果 D 继承 B 的方式是私有的，则不能使用。 友元和继承友元关系不能传递，也不能继承，基类的友元在访问派生类成员时不具有特殊性 class Base { friend class Pal; protected: int prot_mem; }; class Sneaky : public Base { friend void clobber(Sneaky\u0026);//能访问Sneaky::prot_mem friend void clobber(Base\u0026*); //不能访问Base::prot_mem int j; //默认为private }; class Pal { public: int f(Base b) { return b.prot_mem; } //正确：Pal是Base友元 int f(Sneaky s) { return s.j; } //错误：Pal不是Sneaky友元 int f3(Sneaky s) { return s.prot_mem; }//正确：Pal是Base友元 } f3 访问了派生类中基类部分的成员，Pal 是基类的友元，Pal 能够访问 Base 对象的成员 友元只对做出声明的类有效，而友元的基类或派生类不具有特殊访问能力 class D2 : public Pal { public: int mem(Base b) { return b.prot_mem; } //错误友元不能继承 } 改变个别成员的可访问性如果需要改变派生类继承的某个名字的访问性，可以使用 using 声明达到这个目的 class Base { public: std::size_t size() cont { return n; } protected: std::size_t n; }; class Dervied : private Base { public: using Base::size; protected: using Base::n; }; Derived 为私有继承，继承的size 和 n 默认情况下是 Derived 的私有成员，使用 using 声明语句，可以改变这个成员的可访问性，此时的 Derived 用户都可以使用 size，而只有 Derived 的派生类才可以使用 n using 声明控制的访问权限仅由声明语句前面的访问说明符决定 默认的继承保护级别默认情况下，class 关键字的派生类是私有继承的，struct 关键字的派生类是公有继承的 class Base { /**/ }; struct D1 : Base { /**/ }; //默认public继承 class D2 : Base { /**/ }; //默认private继承 struct 和 class 关键字唯一区别就是默认成员访问说明符默认派生访问说明符的区别 一个私有派生的类最好显示的声明 private，不要仅仅依赖默认设置 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:5:0","series":null,"tags":["C++"],"title":"《C++Primer》第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#派生类向基类转换的可访问性"},{"categories":["C++"],"content":"15.5 访问控制与继承每个类分别控制自己成员初始化过程，每个类还控制着其成员对于派生类来说是否可访问 受保护的成员protected 关键字可以控制那些它希望与派生类分享但是不想和其他公共访问使用的成员 和私有成员类似，受保护的成员对于类的用户是不可访问的 和公有成员类型，受保护的成员对于派生类和友元是可访问的 派生类的成员或友元只能通过派生类对象来访问基类中受保护的成员 派生类对于基类对象中受保护成员没有任何访问权限 class Base { protected: int prot_mem; }; class Sneaky : public Base { friend void clobber(Sneaky\u0026);//能访问Sneaky::prot_mem friend void clobber(Base\u0026*); //不能访问Base::prot_mem int j; //默认为private }; //正确：可以访问Sneaky对象的private和protected成员 void clobber(Sneaky \u0026s) { s.j = s.prot_mem = 0; } //错误：不能访问Base中的protected成员 void clobber(Base \u0026b) { b.prot_mem = 0; } 上面的最后一条的含义是一个派生类成员和友元只能访问派生类继承过来属于基类那部分的受保护成员（这些成员，派生类自己本身也有，成员和友元可以访问自己本身的受保护的成员），而不能直接访问基类对象中的受保护成员 公共、私有和受保护继承类对继承而来的成员的访问权限受到两个因素影响：一是基类在该成员的访问说明符，二是派生类的派生列表中的访问说明符 class Base { public: void pub_mem(); protected: int prot_mem; private: char priv_mem; }; struct Pub_Derv : public Base { //正确：派生类能访问protected成员 int f() { return prot_mem; } //错误：派生类不能访问private成员 char g() { return priv_mem; } }; struct Priv_Derv : private Base { //private不影响派生类访问权限 int f1() const { return prot_mem; } }; 派生类访问说明符对于派生类的成员能否访问直接基类的成员没有什么影响，如上 Pub_Derv 和 Priv_Derv 都可以访问基类 Base 中的 prot_mem 派生类访问说明符是控制派生类用户（包括派生类的派生类）对于基类成员的访问权限，相当于将基类成员定义为相应的访问说明符 Pub_Derv d1; Priv_Derv d2; d1.pub_mem(); //正确：pub_mem在派生类中是public的 d2.pub_mem(); //错误：pub_mem在派生类中是protected的 此时在 Priv_Derv 中基类的成员被定义为 private 的了，这样它创建的对象就不可以直接访问 派生类向基类转换的可访问性派生类向基类的转换是否可访问由使用该转换的代码决定，同时派牛类的派生访问说明符也会有影响。假定D 继承自B :· 只有当 D 公有地继承 B 时，用户代码才能使用派生类向基类的转换；如果 D 继承 B 的方式是受保护的或者私有的，则用户代码不能使用该转换。 不论 D 以什么方式继承B , D 的成员函数和友元都能使用派生类向基类的转换： 派生类向其直接基类的类型转换对千派牛类的成员和友元来说水远是可访问的。 如果 D 继承 B 的方式是公有的或者受保护的，则 D 的派生类的成员和友元可以使用 D 向 B 的类型转换； 反之，如果 D 继承 B 的方式是私有的，则不能使用。 友元和继承友元关系不能传递，也不能继承，基类的友元在访问派生类成员时不具有特殊性 class Base { friend class Pal; protected: int prot_mem; }; class Sneaky : public Base { friend void clobber(Sneaky\u0026);//能访问Sneaky::prot_mem friend void clobber(Base\u0026*); //不能访问Base::prot_mem int j; //默认为private }; class Pal { public: int f(Base b) { return b.prot_mem; } //正确：Pal是Base友元 int f(Sneaky s) { return s.j; } //错误：Pal不是Sneaky友元 int f3(Sneaky s) { return s.prot_mem; }//正确：Pal是Base友元 } f3 访问了派生类中基类部分的成员，Pal 是基类的友元，Pal 能够访问 Base 对象的成员 友元只对做出声明的类有效，而友元的基类或派生类不具有特殊访问能力 class D2 : public Pal { public: int mem(Base b) { return b.prot_mem; } //错误友元不能继承 } 改变个别成员的可访问性如果需要改变派生类继承的某个名字的访问性，可以使用 using 声明达到这个目的 class Base { public: std::size_t size() cont { return n; } protected: std::size_t n; }; class Dervied : private Base { public: using Base::size; protected: using Base::n; }; Derived 为私有继承，继承的size 和 n 默认情况下是 Derived 的私有成员，使用 using 声明语句，可以改变这个成员的可访问性，此时的 Derived 用户都可以使用 size，而只有 Derived 的派生类才可以使用 n using 声明控制的访问权限仅由声明语句前面的访问说明符决定 默认的继承保护级别默认情况下，class 关键字的派生类是私有继承的，struct 关键字的派生类是公有继承的 class Base { /**/ }; struct D1 : Base { /**/ }; //默认public继承 class D2 : Base { /**/ }; //默认private继承 struct 和 class 关键字唯一区别就是默认成员访问说明符默认派生访问说明符的区别 一个私有派生的类最好显示的声明 private，不要仅仅依赖默认设置 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:5:0","series":null,"tags":["C++"],"title":"《C++Primer》第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#友元和继承"},{"categories":["C++"],"content":"15.5 访问控制与继承每个类分别控制自己成员初始化过程，每个类还控制着其成员对于派生类来说是否可访问 受保护的成员protected 关键字可以控制那些它希望与派生类分享但是不想和其他公共访问使用的成员 和私有成员类似，受保护的成员对于类的用户是不可访问的 和公有成员类型，受保护的成员对于派生类和友元是可访问的 派生类的成员或友元只能通过派生类对象来访问基类中受保护的成员 派生类对于基类对象中受保护成员没有任何访问权限 class Base { protected: int prot_mem; }; class Sneaky : public Base { friend void clobber(Sneaky\u0026);//能访问Sneaky::prot_mem friend void clobber(Base\u0026*); //不能访问Base::prot_mem int j; //默认为private }; //正确：可以访问Sneaky对象的private和protected成员 void clobber(Sneaky \u0026s) { s.j = s.prot_mem = 0; } //错误：不能访问Base中的protected成员 void clobber(Base \u0026b) { b.prot_mem = 0; } 上面的最后一条的含义是一个派生类成员和友元只能访问派生类继承过来属于基类那部分的受保护成员（这些成员，派生类自己本身也有，成员和友元可以访问自己本身的受保护的成员），而不能直接访问基类对象中的受保护成员 公共、私有和受保护继承类对继承而来的成员的访问权限受到两个因素影响：一是基类在该成员的访问说明符，二是派生类的派生列表中的访问说明符 class Base { public: void pub_mem(); protected: int prot_mem; private: char priv_mem; }; struct Pub_Derv : public Base { //正确：派生类能访问protected成员 int f() { return prot_mem; } //错误：派生类不能访问private成员 char g() { return priv_mem; } }; struct Priv_Derv : private Base { //private不影响派生类访问权限 int f1() const { return prot_mem; } }; 派生类访问说明符对于派生类的成员能否访问直接基类的成员没有什么影响，如上 Pub_Derv 和 Priv_Derv 都可以访问基类 Base 中的 prot_mem 派生类访问说明符是控制派生类用户（包括派生类的派生类）对于基类成员的访问权限，相当于将基类成员定义为相应的访问说明符 Pub_Derv d1; Priv_Derv d2; d1.pub_mem(); //正确：pub_mem在派生类中是public的 d2.pub_mem(); //错误：pub_mem在派生类中是protected的 此时在 Priv_Derv 中基类的成员被定义为 private 的了，这样它创建的对象就不可以直接访问 派生类向基类转换的可访问性派生类向基类的转换是否可访问由使用该转换的代码决定，同时派牛类的派生访问说明符也会有影响。假定D 继承自B :· 只有当 D 公有地继承 B 时，用户代码才能使用派生类向基类的转换；如果 D 继承 B 的方式是受保护的或者私有的，则用户代码不能使用该转换。 不论 D 以什么方式继承B , D 的成员函数和友元都能使用派生类向基类的转换： 派生类向其直接基类的类型转换对千派牛类的成员和友元来说水远是可访问的。 如果 D 继承 B 的方式是公有的或者受保护的，则 D 的派生类的成员和友元可以使用 D 向 B 的类型转换； 反之，如果 D 继承 B 的方式是私有的，则不能使用。 友元和继承友元关系不能传递，也不能继承，基类的友元在访问派生类成员时不具有特殊性 class Base { friend class Pal; protected: int prot_mem; }; class Sneaky : public Base { friend void clobber(Sneaky\u0026);//能访问Sneaky::prot_mem friend void clobber(Base\u0026*); //不能访问Base::prot_mem int j; //默认为private }; class Pal { public: int f(Base b) { return b.prot_mem; } //正确：Pal是Base友元 int f(Sneaky s) { return s.j; } //错误：Pal不是Sneaky友元 int f3(Sneaky s) { return s.prot_mem; }//正确：Pal是Base友元 } f3 访问了派生类中基类部分的成员，Pal 是基类的友元，Pal 能够访问 Base 对象的成员 友元只对做出声明的类有效，而友元的基类或派生类不具有特殊访问能力 class D2 : public Pal { public: int mem(Base b) { return b.prot_mem; } //错误友元不能继承 } 改变个别成员的可访问性如果需要改变派生类继承的某个名字的访问性，可以使用 using 声明达到这个目的 class Base { public: std::size_t size() cont { return n; } protected: std::size_t n; }; class Dervied : private Base { public: using Base::size; protected: using Base::n; }; Derived 为私有继承，继承的size 和 n 默认情况下是 Derived 的私有成员，使用 using 声明语句，可以改变这个成员的可访问性，此时的 Derived 用户都可以使用 size，而只有 Derived 的派生类才可以使用 n using 声明控制的访问权限仅由声明语句前面的访问说明符决定 默认的继承保护级别默认情况下，class 关键字的派生类是私有继承的，struct 关键字的派生类是公有继承的 class Base { /**/ }; struct D1 : Base { /**/ }; //默认public继承 class D2 : Base { /**/ }; //默认private继承 struct 和 class 关键字唯一区别就是默认成员访问说明符默认派生访问说明符的区别 一个私有派生的类最好显示的声明 private，不要仅仅依赖默认设置 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:5:0","series":null,"tags":["C++"],"title":"《C++Primer》第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#改变个别成员的可访问性"},{"categories":["C++"],"content":"15.5 访问控制与继承每个类分别控制自己成员初始化过程，每个类还控制着其成员对于派生类来说是否可访问 受保护的成员protected 关键字可以控制那些它希望与派生类分享但是不想和其他公共访问使用的成员 和私有成员类似，受保护的成员对于类的用户是不可访问的 和公有成员类型，受保护的成员对于派生类和友元是可访问的 派生类的成员或友元只能通过派生类对象来访问基类中受保护的成员 派生类对于基类对象中受保护成员没有任何访问权限 class Base { protected: int prot_mem; }; class Sneaky : public Base { friend void clobber(Sneaky\u0026);//能访问Sneaky::prot_mem friend void clobber(Base\u0026*); //不能访问Base::prot_mem int j; //默认为private }; //正确：可以访问Sneaky对象的private和protected成员 void clobber(Sneaky \u0026s) { s.j = s.prot_mem = 0; } //错误：不能访问Base中的protected成员 void clobber(Base \u0026b) { b.prot_mem = 0; } 上面的最后一条的含义是一个派生类成员和友元只能访问派生类继承过来属于基类那部分的受保护成员（这些成员，派生类自己本身也有，成员和友元可以访问自己本身的受保护的成员），而不能直接访问基类对象中的受保护成员 公共、私有和受保护继承类对继承而来的成员的访问权限受到两个因素影响：一是基类在该成员的访问说明符，二是派生类的派生列表中的访问说明符 class Base { public: void pub_mem(); protected: int prot_mem; private: char priv_mem; }; struct Pub_Derv : public Base { //正确：派生类能访问protected成员 int f() { return prot_mem; } //错误：派生类不能访问private成员 char g() { return priv_mem; } }; struct Priv_Derv : private Base { //private不影响派生类访问权限 int f1() const { return prot_mem; } }; 派生类访问说明符对于派生类的成员能否访问直接基类的成员没有什么影响，如上 Pub_Derv 和 Priv_Derv 都可以访问基类 Base 中的 prot_mem 派生类访问说明符是控制派生类用户（包括派生类的派生类）对于基类成员的访问权限，相当于将基类成员定义为相应的访问说明符 Pub_Derv d1; Priv_Derv d2; d1.pub_mem(); //正确：pub_mem在派生类中是public的 d2.pub_mem(); //错误：pub_mem在派生类中是protected的 此时在 Priv_Derv 中基类的成员被定义为 private 的了，这样它创建的对象就不可以直接访问 派生类向基类转换的可访问性派生类向基类的转换是否可访问由使用该转换的代码决定，同时派牛类的派生访问说明符也会有影响。假定D 继承自B :· 只有当 D 公有地继承 B 时，用户代码才能使用派生类向基类的转换；如果 D 继承 B 的方式是受保护的或者私有的，则用户代码不能使用该转换。 不论 D 以什么方式继承B , D 的成员函数和友元都能使用派生类向基类的转换： 派生类向其直接基类的类型转换对千派牛类的成员和友元来说水远是可访问的。 如果 D 继承 B 的方式是公有的或者受保护的，则 D 的派生类的成员和友元可以使用 D 向 B 的类型转换； 反之，如果 D 继承 B 的方式是私有的，则不能使用。 友元和继承友元关系不能传递，也不能继承，基类的友元在访问派生类成员时不具有特殊性 class Base { friend class Pal; protected: int prot_mem; }; class Sneaky : public Base { friend void clobber(Sneaky\u0026);//能访问Sneaky::prot_mem friend void clobber(Base\u0026*); //不能访问Base::prot_mem int j; //默认为private }; class Pal { public: int f(Base b) { return b.prot_mem; } //正确：Pal是Base友元 int f(Sneaky s) { return s.j; } //错误：Pal不是Sneaky友元 int f3(Sneaky s) { return s.prot_mem; }//正确：Pal是Base友元 } f3 访问了派生类中基类部分的成员，Pal 是基类的友元，Pal 能够访问 Base 对象的成员 友元只对做出声明的类有效，而友元的基类或派生类不具有特殊访问能力 class D2 : public Pal { public: int mem(Base b) { return b.prot_mem; } //错误友元不能继承 } 改变个别成员的可访问性如果需要改变派生类继承的某个名字的访问性，可以使用 using 声明达到这个目的 class Base { public: std::size_t size() cont { return n; } protected: std::size_t n; }; class Dervied : private Base { public: using Base::size; protected: using Base::n; }; Derived 为私有继承，继承的size 和 n 默认情况下是 Derived 的私有成员，使用 using 声明语句，可以改变这个成员的可访问性，此时的 Derived 用户都可以使用 size，而只有 Derived 的派生类才可以使用 n using 声明控制的访问权限仅由声明语句前面的访问说明符决定 默认的继承保护级别默认情况下，class 关键字的派生类是私有继承的，struct 关键字的派生类是公有继承的 class Base { /**/ }; struct D1 : Base { /**/ }; //默认public继承 class D2 : Base { /**/ }; //默认private继承 struct 和 class 关键字唯一区别就是默认成员访问说明符默认派生访问说明符的区别 一个私有派生的类最好显示的声明 private，不要仅仅依赖默认设置 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:5:0","series":null,"tags":["C++"],"title":"《C++Primer》第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#默认的继承保护级别"},{"categories":["C++"],"content":"15.6 继承中的类作用域每个类定义自己的作用域，在这个作用域类定义类的成员 存在继承关系时，派生类的作用域嵌套在基类作用域之内，当一个名字在派生类的作用域无法解析，编译器会继续在外层的基类作用域中寻找改名字的含义 Bulk_quote bulk; cout \u003c\u003c bulk.isbn(); 名字 isbn 解析过程如下： 我们通过 Bulk_quote 对象调用 isbn 的，首先在 Bulk_quote 中查找，没有找到 isbn Bulk_quote 由 Disc_quote 派生而来，记下来在 Disc_quote 中查找，仍然找不到 Disc_quote 由 Quote 派生而来，接着在 Quote 中查找，此时找到了 isbn，最终被解析为 Quote 中的 isbn 在编译时进行名字查找一个对象、引用或指针的静态类型决定了对象哪些成员是可见的，静态类型和动态类型可能不一样，但是能使用哪些成员依然由静态类型决定 我们在 Disc_quote 中添加一个新成员 class Disc_quote : public Quote { public: std::pair\u003csize_t, double\u003e discount_policy() const { return {quantity, discount}; } //其他成员与前面一致 } 我们只能通过 Disc_quote 及派生类对象、引用或指针使用 discount_policy Bulk_quote bulk; Bulk_quote *bulkPtr = \u0026bulk; Quote *itemPtr = \u0026bulk; bulkPtr-\u003ediscount_policy();//正确：bulkPtr类型为Bulk_quote* itemPtr-\u003ediscount_policy();//错误：itemPtr类型为Quote* 名字冲突与继承和其他作用域一样，派生类也能重用定义在基类中的名字，此时定义在内层作用域（即派生类）的名字将隐藏定义在外层作用域（即基类）的名字 可以通过作用域运算符来使用一个被隐藏的基类成员 名字查找先于类型检查声明在内层作用域的函数并不会重载声明在外层作用域的函数，定义在派生类中的函数也不会重载基类中的成员 如果派生类和基类某个成员同名，派生类将在其作用域内隐藏该基类成员，即使形参列表不一样，基类成员仍然会被隐藏 struct Base { int memfcn(); }; struct Derived : Base { int memfcn(int);//隐藏基类的memfcn }; Derived d; Base b; b.memfcn(); //调用 Base::memfcn d.memfcn(10); //调用 Derived::memfcn d.memfcn(); //错误：基类memfcn被隐藏了 d.Base::memfcn(); //正确：调用Base::memfcn 虚函数和作用域15.3说到基类和派生类的虚函数必须有相同的形参列表，如果基类和派生类虚函数接受实参不一样，无法通过基类的引用或指针调用派生类的虚函数 class Base { public: virtual int fcn(); }; class D1 : public Base { public: //隐藏了基类的fcn，这个fcn不是虚函数 //D1继承了Base::fcn()定义 int fcn(int); virtual void f2(); }； class D2 : public D1 { public: int fcn(int);//非虚函数，隐藏了D1::fcn(int) int fcn(); //覆盖了Base的虚函数fcn void f2(); //覆盖了D1虚函数f2 } 下面是使用几种函数的方法 Base bobj; D1 d1obj; D2 d2obj; Base *bp1 = \u0026bobj, *bp2 = \u0026d1obj, *bp3 = \u0026d2obj; bp1-\u003efcn(); //虚调用，运行时调用Base::fcn bp2-\u003efcn(); //虚调用，运行时调用Base::fcn bp3-\u003efcn(); //需调用，运行时调用D2::fcn D1 *d1p = \u0026d1obj; D2 *d2p = \u0026d2obj; bp2-\u003ef2(); //错误：Base没有名为f2成员 d1p-\u003ef2(); //虚调用，运行时调用D1::f2() d2p-\u003ef2(); //虚调用，运行时调用D2::f2() Base *p1 = \u0026d2obj; D1 *p2 = \u0026d2obj; D2 *p3 = \u0026d2obj; p1-\u003efcn(42); //错误，Base中没有fcn(int)函数 p2-\u003efcn(42); //静态绑定，调用D1::fcn(int) p3-\u003efcn(42); //静态绑定，调用D2::fcn(int) 覆盖重载的函数成员函数无论是否为虚函数都能被重载，如果派生类希望所有的重载版本对于它都是可见的，那么它就需要覆盖所有的版本，或者一个都不覆盖 如果只需要覆盖其中一些函数，但是不得不自己重新定义覆盖基类的每一个版本，否则未重新定义的函数会被隐藏 通过使用 using 声明，就无须覆盖所有版本。using 声明语句指定一个名字而不指定形参列表，所有一条基类成员函数的 using 声明语句就可以把该函数所有重载实例添加到派生类作用域中。此时派生类只需要定义特有的函数就行了 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:6:0","series":null,"tags":["C++"],"title":"《C++Primer》第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#156-继承中的类作用域"},{"categories":["C++"],"content":"15.6 继承中的类作用域每个类定义自己的作用域，在这个作用域类定义类的成员 存在继承关系时，派生类的作用域嵌套在基类作用域之内，当一个名字在派生类的作用域无法解析，编译器会继续在外层的基类作用域中寻找改名字的含义 Bulk_quote bulk; cout discount_policy() const { return {quantity, discount}; } //其他成员与前面一致 } 我们只能通过 Disc_quote 及派生类对象、引用或指针使用 discount_policy Bulk_quote bulk; Bulk_quote *bulkPtr = \u0026bulk; Quote *itemPtr = \u0026bulk; bulkPtr-discount_policy();//正确：bulkPtr类型为Bulk_quote* itemPtr-discount_policy();//错误：itemPtr类型为Quote* 名字冲突与继承和其他作用域一样，派生类也能重用定义在基类中的名字，此时定义在内层作用域（即派生类）的名字将隐藏定义在外层作用域（即基类）的名字 可以通过作用域运算符来使用一个被隐藏的基类成员 名字查找先于类型检查声明在内层作用域的函数并不会重载声明在外层作用域的函数，定义在派生类中的函数也不会重载基类中的成员 如果派生类和基类某个成员同名，派生类将在其作用域内隐藏该基类成员，即使形参列表不一样，基类成员仍然会被隐藏 struct Base { int memfcn(); }; struct Derived : Base { int memfcn(int);//隐藏基类的memfcn }; Derived d; Base b; b.memfcn(); //调用 Base::memfcn d.memfcn(10); //调用 Derived::memfcn d.memfcn(); //错误：基类memfcn被隐藏了 d.Base::memfcn(); //正确：调用Base::memfcn 虚函数和作用域15.3说到基类和派生类的虚函数必须有相同的形参列表，如果基类和派生类虚函数接受实参不一样，无法通过基类的引用或指针调用派生类的虚函数 class Base { public: virtual int fcn(); }; class D1 : public Base { public: //隐藏了基类的fcn，这个fcn不是虚函数 //D1继承了Base::fcn()定义 int fcn(int); virtual void f2(); }； class D2 : public D1 { public: int fcn(int);//非虚函数，隐藏了D1::fcn(int) int fcn(); //覆盖了Base的虚函数fcn void f2(); //覆盖了D1虚函数f2 } 下面是使用几种函数的方法 Base bobj; D1 d1obj; D2 d2obj; Base *bp1 = \u0026bobj, *bp2 = \u0026d1obj, *bp3 = \u0026d2obj; bp1-fcn(); //虚调用，运行时调用Base::fcn bp2-fcn(); //虚调用，运行时调用Base::fcn bp3-fcn(); //需调用，运行时调用D2::fcn D1 *d1p = \u0026d1obj; D2 *d2p = \u0026d2obj; bp2-f2(); //错误：Base没有名为f2成员 d1p-f2(); //虚调用，运行时调用D1::f2() d2p-f2(); //虚调用，运行时调用D2::f2() Base *p1 = \u0026d2obj; D1 *p2 = \u0026d2obj; D2 *p3 = \u0026d2obj; p1-fcn(42); //错误，Base中没有fcn(int)函数 p2-fcn(42); //静态绑定，调用D1::fcn(int) p3-fcn(42); //静态绑定，调用D2::fcn(int) 覆盖重载的函数成员函数无论是否为虚函数都能被重载，如果派生类希望所有的重载版本对于它都是可见的，那么它就需要覆盖所有的版本，或者一个都不覆盖 如果只需要覆盖其中一些函数，但是不得不自己重新定义覆盖基类的每一个版本，否则未重新定义的函数会被隐藏 通过使用 using 声明，就无须覆盖所有版本。using 声明语句指定一个名字而不指定形参列表，所有一条基类成员函数的 using 声明语句就可以把该函数所有重载实例添加到派生类作用域中。此时派生类只需要定义特有的函数就行了 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:6:0","series":null,"tags":["C++"],"title":"《C++Primer》第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#在编译时进行名字查找"},{"categories":["C++"],"content":"15.6 继承中的类作用域每个类定义自己的作用域，在这个作用域类定义类的成员 存在继承关系时，派生类的作用域嵌套在基类作用域之内，当一个名字在派生类的作用域无法解析，编译器会继续在外层的基类作用域中寻找改名字的含义 Bulk_quote bulk; cout discount_policy() const { return {quantity, discount}; } //其他成员与前面一致 } 我们只能通过 Disc_quote 及派生类对象、引用或指针使用 discount_policy Bulk_quote bulk; Bulk_quote *bulkPtr = \u0026bulk; Quote *itemPtr = \u0026bulk; bulkPtr-discount_policy();//正确：bulkPtr类型为Bulk_quote* itemPtr-discount_policy();//错误：itemPtr类型为Quote* 名字冲突与继承和其他作用域一样，派生类也能重用定义在基类中的名字，此时定义在内层作用域（即派生类）的名字将隐藏定义在外层作用域（即基类）的名字 可以通过作用域运算符来使用一个被隐藏的基类成员 名字查找先于类型检查声明在内层作用域的函数并不会重载声明在外层作用域的函数，定义在派生类中的函数也不会重载基类中的成员 如果派生类和基类某个成员同名，派生类将在其作用域内隐藏该基类成员，即使形参列表不一样，基类成员仍然会被隐藏 struct Base { int memfcn(); }; struct Derived : Base { int memfcn(int);//隐藏基类的memfcn }; Derived d; Base b; b.memfcn(); //调用 Base::memfcn d.memfcn(10); //调用 Derived::memfcn d.memfcn(); //错误：基类memfcn被隐藏了 d.Base::memfcn(); //正确：调用Base::memfcn 虚函数和作用域15.3说到基类和派生类的虚函数必须有相同的形参列表，如果基类和派生类虚函数接受实参不一样，无法通过基类的引用或指针调用派生类的虚函数 class Base { public: virtual int fcn(); }; class D1 : public Base { public: //隐藏了基类的fcn，这个fcn不是虚函数 //D1继承了Base::fcn()定义 int fcn(int); virtual void f2(); }； class D2 : public D1 { public: int fcn(int);//非虚函数，隐藏了D1::fcn(int) int fcn(); //覆盖了Base的虚函数fcn void f2(); //覆盖了D1虚函数f2 } 下面是使用几种函数的方法 Base bobj; D1 d1obj; D2 d2obj; Base *bp1 = \u0026bobj, *bp2 = \u0026d1obj, *bp3 = \u0026d2obj; bp1-fcn(); //虚调用，运行时调用Base::fcn bp2-fcn(); //虚调用，运行时调用Base::fcn bp3-fcn(); //需调用，运行时调用D2::fcn D1 *d1p = \u0026d1obj; D2 *d2p = \u0026d2obj; bp2-f2(); //错误：Base没有名为f2成员 d1p-f2(); //虚调用，运行时调用D1::f2() d2p-f2(); //虚调用，运行时调用D2::f2() Base *p1 = \u0026d2obj; D1 *p2 = \u0026d2obj; D2 *p3 = \u0026d2obj; p1-fcn(42); //错误，Base中没有fcn(int)函数 p2-fcn(42); //静态绑定，调用D1::fcn(int) p3-fcn(42); //静态绑定，调用D2::fcn(int) 覆盖重载的函数成员函数无论是否为虚函数都能被重载，如果派生类希望所有的重载版本对于它都是可见的，那么它就需要覆盖所有的版本，或者一个都不覆盖 如果只需要覆盖其中一些函数，但是不得不自己重新定义覆盖基类的每一个版本，否则未重新定义的函数会被隐藏 通过使用 using 声明，就无须覆盖所有版本。using 声明语句指定一个名字而不指定形参列表，所有一条基类成员函数的 using 声明语句就可以把该函数所有重载实例添加到派生类作用域中。此时派生类只需要定义特有的函数就行了 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:6:0","series":null,"tags":["C++"],"title":"《C++Primer》第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#名字冲突与继承"},{"categories":["C++"],"content":"15.6 继承中的类作用域每个类定义自己的作用域，在这个作用域类定义类的成员 存在继承关系时，派生类的作用域嵌套在基类作用域之内，当一个名字在派生类的作用域无法解析，编译器会继续在外层的基类作用域中寻找改名字的含义 Bulk_quote bulk; cout discount_policy() const { return {quantity, discount}; } //其他成员与前面一致 } 我们只能通过 Disc_quote 及派生类对象、引用或指针使用 discount_policy Bulk_quote bulk; Bulk_quote *bulkPtr = \u0026bulk; Quote *itemPtr = \u0026bulk; bulkPtr-discount_policy();//正确：bulkPtr类型为Bulk_quote* itemPtr-discount_policy();//错误：itemPtr类型为Quote* 名字冲突与继承和其他作用域一样，派生类也能重用定义在基类中的名字，此时定义在内层作用域（即派生类）的名字将隐藏定义在外层作用域（即基类）的名字 可以通过作用域运算符来使用一个被隐藏的基类成员 名字查找先于类型检查声明在内层作用域的函数并不会重载声明在外层作用域的函数，定义在派生类中的函数也不会重载基类中的成员 如果派生类和基类某个成员同名，派生类将在其作用域内隐藏该基类成员，即使形参列表不一样，基类成员仍然会被隐藏 struct Base { int memfcn(); }; struct Derived : Base { int memfcn(int);//隐藏基类的memfcn }; Derived d; Base b; b.memfcn(); //调用 Base::memfcn d.memfcn(10); //调用 Derived::memfcn d.memfcn(); //错误：基类memfcn被隐藏了 d.Base::memfcn(); //正确：调用Base::memfcn 虚函数和作用域15.3说到基类和派生类的虚函数必须有相同的形参列表，如果基类和派生类虚函数接受实参不一样，无法通过基类的引用或指针调用派生类的虚函数 class Base { public: virtual int fcn(); }; class D1 : public Base { public: //隐藏了基类的fcn，这个fcn不是虚函数 //D1继承了Base::fcn()定义 int fcn(int); virtual void f2(); }； class D2 : public D1 { public: int fcn(int);//非虚函数，隐藏了D1::fcn(int) int fcn(); //覆盖了Base的虚函数fcn void f2(); //覆盖了D1虚函数f2 } 下面是使用几种函数的方法 Base bobj; D1 d1obj; D2 d2obj; Base *bp1 = \u0026bobj, *bp2 = \u0026d1obj, *bp3 = \u0026d2obj; bp1-fcn(); //虚调用，运行时调用Base::fcn bp2-fcn(); //虚调用，运行时调用Base::fcn bp3-fcn(); //需调用，运行时调用D2::fcn D1 *d1p = \u0026d1obj; D2 *d2p = \u0026d2obj; bp2-f2(); //错误：Base没有名为f2成员 d1p-f2(); //虚调用，运行时调用D1::f2() d2p-f2(); //虚调用，运行时调用D2::f2() Base *p1 = \u0026d2obj; D1 *p2 = \u0026d2obj; D2 *p3 = \u0026d2obj; p1-fcn(42); //错误，Base中没有fcn(int)函数 p2-fcn(42); //静态绑定，调用D1::fcn(int) p3-fcn(42); //静态绑定，调用D2::fcn(int) 覆盖重载的函数成员函数无论是否为虚函数都能被重载，如果派生类希望所有的重载版本对于它都是可见的，那么它就需要覆盖所有的版本，或者一个都不覆盖 如果只需要覆盖其中一些函数，但是不得不自己重新定义覆盖基类的每一个版本，否则未重新定义的函数会被隐藏 通过使用 using 声明，就无须覆盖所有版本。using 声明语句指定一个名字而不指定形参列表，所有一条基类成员函数的 using 声明语句就可以把该函数所有重载实例添加到派生类作用域中。此时派生类只需要定义特有的函数就行了 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:6:0","series":null,"tags":["C++"],"title":"《C++Primer》第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#名字查找先于类型检查"},{"categories":["C++"],"content":"15.6 继承中的类作用域每个类定义自己的作用域，在这个作用域类定义类的成员 存在继承关系时，派生类的作用域嵌套在基类作用域之内，当一个名字在派生类的作用域无法解析，编译器会继续在外层的基类作用域中寻找改名字的含义 Bulk_quote bulk; cout discount_policy() const { return {quantity, discount}; } //其他成员与前面一致 } 我们只能通过 Disc_quote 及派生类对象、引用或指针使用 discount_policy Bulk_quote bulk; Bulk_quote *bulkPtr = \u0026bulk; Quote *itemPtr = \u0026bulk; bulkPtr-discount_policy();//正确：bulkPtr类型为Bulk_quote* itemPtr-discount_policy();//错误：itemPtr类型为Quote* 名字冲突与继承和其他作用域一样，派生类也能重用定义在基类中的名字，此时定义在内层作用域（即派生类）的名字将隐藏定义在外层作用域（即基类）的名字 可以通过作用域运算符来使用一个被隐藏的基类成员 名字查找先于类型检查声明在内层作用域的函数并不会重载声明在外层作用域的函数，定义在派生类中的函数也不会重载基类中的成员 如果派生类和基类某个成员同名，派生类将在其作用域内隐藏该基类成员，即使形参列表不一样，基类成员仍然会被隐藏 struct Base { int memfcn(); }; struct Derived : Base { int memfcn(int);//隐藏基类的memfcn }; Derived d; Base b; b.memfcn(); //调用 Base::memfcn d.memfcn(10); //调用 Derived::memfcn d.memfcn(); //错误：基类memfcn被隐藏了 d.Base::memfcn(); //正确：调用Base::memfcn 虚函数和作用域15.3说到基类和派生类的虚函数必须有相同的形参列表，如果基类和派生类虚函数接受实参不一样，无法通过基类的引用或指针调用派生类的虚函数 class Base { public: virtual int fcn(); }; class D1 : public Base { public: //隐藏了基类的fcn，这个fcn不是虚函数 //D1继承了Base::fcn()定义 int fcn(int); virtual void f2(); }； class D2 : public D1 { public: int fcn(int);//非虚函数，隐藏了D1::fcn(int) int fcn(); //覆盖了Base的虚函数fcn void f2(); //覆盖了D1虚函数f2 } 下面是使用几种函数的方法 Base bobj; D1 d1obj; D2 d2obj; Base *bp1 = \u0026bobj, *bp2 = \u0026d1obj, *bp3 = \u0026d2obj; bp1-fcn(); //虚调用，运行时调用Base::fcn bp2-fcn(); //虚调用，运行时调用Base::fcn bp3-fcn(); //需调用，运行时调用D2::fcn D1 *d1p = \u0026d1obj; D2 *d2p = \u0026d2obj; bp2-f2(); //错误：Base没有名为f2成员 d1p-f2(); //虚调用，运行时调用D1::f2() d2p-f2(); //虚调用，运行时调用D2::f2() Base *p1 = \u0026d2obj; D1 *p2 = \u0026d2obj; D2 *p3 = \u0026d2obj; p1-fcn(42); //错误，Base中没有fcn(int)函数 p2-fcn(42); //静态绑定，调用D1::fcn(int) p3-fcn(42); //静态绑定，调用D2::fcn(int) 覆盖重载的函数成员函数无论是否为虚函数都能被重载，如果派生类希望所有的重载版本对于它都是可见的，那么它就需要覆盖所有的版本，或者一个都不覆盖 如果只需要覆盖其中一些函数，但是不得不自己重新定义覆盖基类的每一个版本，否则未重新定义的函数会被隐藏 通过使用 using 声明，就无须覆盖所有版本。using 声明语句指定一个名字而不指定形参列表，所有一条基类成员函数的 using 声明语句就可以把该函数所有重载实例添加到派生类作用域中。此时派生类只需要定义特有的函数就行了 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:6:0","series":null,"tags":["C++"],"title":"《C++Primer》第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#虚函数和作用域"},{"categories":["C++"],"content":"15.6 继承中的类作用域每个类定义自己的作用域，在这个作用域类定义类的成员 存在继承关系时，派生类的作用域嵌套在基类作用域之内，当一个名字在派生类的作用域无法解析，编译器会继续在外层的基类作用域中寻找改名字的含义 Bulk_quote bulk; cout discount_policy() const { return {quantity, discount}; } //其他成员与前面一致 } 我们只能通过 Disc_quote 及派生类对象、引用或指针使用 discount_policy Bulk_quote bulk; Bulk_quote *bulkPtr = \u0026bulk; Quote *itemPtr = \u0026bulk; bulkPtr-discount_policy();//正确：bulkPtr类型为Bulk_quote* itemPtr-discount_policy();//错误：itemPtr类型为Quote* 名字冲突与继承和其他作用域一样，派生类也能重用定义在基类中的名字，此时定义在内层作用域（即派生类）的名字将隐藏定义在外层作用域（即基类）的名字 可以通过作用域运算符来使用一个被隐藏的基类成员 名字查找先于类型检查声明在内层作用域的函数并不会重载声明在外层作用域的函数，定义在派生类中的函数也不会重载基类中的成员 如果派生类和基类某个成员同名，派生类将在其作用域内隐藏该基类成员，即使形参列表不一样，基类成员仍然会被隐藏 struct Base { int memfcn(); }; struct Derived : Base { int memfcn(int);//隐藏基类的memfcn }; Derived d; Base b; b.memfcn(); //调用 Base::memfcn d.memfcn(10); //调用 Derived::memfcn d.memfcn(); //错误：基类memfcn被隐藏了 d.Base::memfcn(); //正确：调用Base::memfcn 虚函数和作用域15.3说到基类和派生类的虚函数必须有相同的形参列表，如果基类和派生类虚函数接受实参不一样，无法通过基类的引用或指针调用派生类的虚函数 class Base { public: virtual int fcn(); }; class D1 : public Base { public: //隐藏了基类的fcn，这个fcn不是虚函数 //D1继承了Base::fcn()定义 int fcn(int); virtual void f2(); }； class D2 : public D1 { public: int fcn(int);//非虚函数，隐藏了D1::fcn(int) int fcn(); //覆盖了Base的虚函数fcn void f2(); //覆盖了D1虚函数f2 } 下面是使用几种函数的方法 Base bobj; D1 d1obj; D2 d2obj; Base *bp1 = \u0026bobj, *bp2 = \u0026d1obj, *bp3 = \u0026d2obj; bp1-fcn(); //虚调用，运行时调用Base::fcn bp2-fcn(); //虚调用，运行时调用Base::fcn bp3-fcn(); //需调用，运行时调用D2::fcn D1 *d1p = \u0026d1obj; D2 *d2p = \u0026d2obj; bp2-f2(); //错误：Base没有名为f2成员 d1p-f2(); //虚调用，运行时调用D1::f2() d2p-f2(); //虚调用，运行时调用D2::f2() Base *p1 = \u0026d2obj; D1 *p2 = \u0026d2obj; D2 *p3 = \u0026d2obj; p1-fcn(42); //错误，Base中没有fcn(int)函数 p2-fcn(42); //静态绑定，调用D1::fcn(int) p3-fcn(42); //静态绑定，调用D2::fcn(int) 覆盖重载的函数成员函数无论是否为虚函数都能被重载，如果派生类希望所有的重载版本对于它都是可见的，那么它就需要覆盖所有的版本，或者一个都不覆盖 如果只需要覆盖其中一些函数，但是不得不自己重新定义覆盖基类的每一个版本，否则未重新定义的函数会被隐藏 通过使用 using 声明，就无须覆盖所有版本。using 声明语句指定一个名字而不指定形参列表，所有一条基类成员函数的 using 声明语句就可以把该函数所有重载实例添加到派生类作用域中。此时派生类只需要定义特有的函数就行了 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:6:0","series":null,"tags":["C++"],"title":"《C++Primer》第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#覆盖重载的函数"},{"categories":["C++"],"content":"15.7 构造函数与拷贝控制","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:7:0","series":null,"tags":["C++"],"title":"《C++Primer》第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#157-构造函数与拷贝控制"},{"categories":["C++"],"content":"15.7.1 虚析构函数当我们 delete 一个动态分配的对象指针时，将执行析构函数，如果指向继承体系中的某个类型，则有可能出现指针的静态类型与被删除对象动态类型不符合的情况，这样的话编译器必须确保执行正确的析构函数 通过将基类中的析构函数定义为虚函数来确保执行正确的析构函数版本 class Quote { public: //如果我们删除指向派生类对象的基类指针，需要虚析构函数 virtual ~Quote() = default; //动态绑定析构函数 } 析构函数的虚属性也会继承，基类的析构函数为虚函数就可以确保 delete 基类指针时能够调用正确的析构函数版本 Quote *itemPtr = new Quote; //静态类型与动态类型一致 delete itemPtr; //调用Quote的析构函数 itemPtr = new Bulk_Quote; //静态类型与动态类型一致 delete itemPtr; //调用Bulk_quote析构函数 如果基类的析构函数不是虚函数，则 delete 一个指向派生类对象的基类函数将产生未定义的行为 虚函数将阻止合成移动操作如果一个类定义了一个析构函数，即使通过=default 的形式使用了合成版本，编译器也不会为这个类合成移动操作 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:7:1","series":null,"tags":["C++"],"title":"《C++Primer》第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#1571-虚析构函数"},{"categories":["C++"],"content":"15.7.1 虚析构函数当我们 delete 一个动态分配的对象指针时，将执行析构函数，如果指向继承体系中的某个类型，则有可能出现指针的静态类型与被删除对象动态类型不符合的情况，这样的话编译器必须确保执行正确的析构函数 通过将基类中的析构函数定义为虚函数来确保执行正确的析构函数版本 class Quote { public: //如果我们删除指向派生类对象的基类指针，需要虚析构函数 virtual ~Quote() = default; //动态绑定析构函数 } 析构函数的虚属性也会继承，基类的析构函数为虚函数就可以确保 delete 基类指针时能够调用正确的析构函数版本 Quote *itemPtr = new Quote; //静态类型与动态类型一致 delete itemPtr; //调用Quote的析构函数 itemPtr = new Bulk_Quote; //静态类型与动态类型一致 delete itemPtr; //调用Bulk_quote析构函数 如果基类的析构函数不是虚函数，则 delete 一个指向派生类对象的基类函数将产生未定义的行为 虚函数将阻止合成移动操作如果一个类定义了一个析构函数，即使通过=default 的形式使用了合成版本，编译器也不会为这个类合成移动操作 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:7:1","series":null,"tags":["C++"],"title":"《C++Primer》第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#虚函数将阻止合成移动操作"},{"categories":["C++"],"content":"15.7.2 合成拷贝控制与继承基类和派生类的合成拷贝控制成员的行为与其他合成的构造函数、赋值运算符或析构函数类似，它们对类本身成员依次进行初始化、赋值和销毁操作，此外还负责对直接基类部分进行初始化、赋值、销毁的操作 这里需要注意的就是顺序问题： 对于构造函数，派生类使用合成的构造函数时，会自动先调用直接基类的构造函数，然后再初始化自己的成员，直接基类又会进一步调用基类的构造函数 构造函数整体的表现为，先初始化基类成员-\u003e初始化直接基类-\u003e派生类 对于析构函数，合成的析构函数体是空的，隐式的析构部分负责销毁类的成员，对于派生类的析构函数来说，除了销毁自己的成员外，还负责销毁派生类的直接基类，依次进行 整体表现为，先调用派生类析构函数-\u003e直接基类析构函数-\u003e基类析构函数 派生类中删除的拷贝控制和基类的关系 如果基类拷贝控制成员是被删除的或者不可访问，派生类中对于的成员也是被删除的 如果基类中有一个不可访问或删除的析构函数，派生类中合成的默认和拷贝构造函数是删除的，因为编译器无法销毁派生类对象中基类部分 class B { public: B() {} B(const B\u0026) = delete; //其他成员，无移动构造函数 }; class D : public B { //没有声明任何构造函数 }; D d; //正确：D合成默认构造函数使用B默认构造函数 D d2(d); //错误：D合成拷贝构造函数是删除的 D d3(std::move(d)); //错误：隐式使用D被删除的拷贝构造函数 如果基类中没有默认、拷贝或移动构造函数，一般情况下派生类也不会定义相应的操作 移动操作和继承大多数基类会定义一个虚析构函数，默认情况下，基类不含有合成的移动操作，派生类也没有 如果需要移动操作，首先应该在基类中进行定义，可以使用合成的版本，但是要显示的定义，一旦定义移动操作，还有同时定义拷贝操作（3/5准则） class Quote { public: Quote() = default; Quote(const Quote\u0026) = default; Quote(Quote\u0026\u0026) = default; Quote\u0026 operator=(const Quote\u0026) = default; Quote\u0026 operator=(Quote\u0026\u0026) = default; virtual ~Quote() = default; }; ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:8:0","series":null,"tags":["C++"],"title":"《C++Primer》第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#1572-合成拷贝控制与继承"},{"categories":["C++"],"content":"15.7.2 合成拷贝控制与继承基类和派生类的合成拷贝控制成员的行为与其他合成的构造函数、赋值运算符或析构函数类似，它们对类本身成员依次进行初始化、赋值和销毁操作，此外还负责对直接基类部分进行初始化、赋值、销毁的操作 这里需要注意的就是顺序问题： 对于构造函数，派生类使用合成的构造函数时，会自动先调用直接基类的构造函数，然后再初始化自己的成员，直接基类又会进一步调用基类的构造函数 构造函数整体的表现为，先初始化基类成员-初始化直接基类-派生类 对于析构函数，合成的析构函数体是空的，隐式的析构部分负责销毁类的成员，对于派生类的析构函数来说，除了销毁自己的成员外，还负责销毁派生类的直接基类，依次进行 整体表现为，先调用派生类析构函数-直接基类析构函数-基类析构函数 派生类中删除的拷贝控制和基类的关系 如果基类拷贝控制成员是被删除的或者不可访问，派生类中对于的成员也是被删除的 如果基类中有一个不可访问或删除的析构函数，派生类中合成的默认和拷贝构造函数是删除的，因为编译器无法销毁派生类对象中基类部分 class B { public: B() {} B(const B\u0026) = delete; //其他成员，无移动构造函数 }; class D : public B { //没有声明任何构造函数 }; D d; //正确：D合成默认构造函数使用B默认构造函数 D d2(d); //错误：D合成拷贝构造函数是删除的 D d3(std::move(d)); //错误：隐式使用D被删除的拷贝构造函数 如果基类中没有默认、拷贝或移动构造函数，一般情况下派生类也不会定义相应的操作 移动操作和继承大多数基类会定义一个虚析构函数，默认情况下，基类不含有合成的移动操作，派生类也没有 如果需要移动操作，首先应该在基类中进行定义，可以使用合成的版本，但是要显示的定义，一旦定义移动操作，还有同时定义拷贝操作（3/5准则） class Quote { public: Quote() = default; Quote(const Quote\u0026) = default; Quote(Quote\u0026\u0026) = default; Quote\u0026 operator=(const Quote\u0026) = default; Quote\u0026 operator=(Quote\u0026\u0026) = default; virtual ~Quote() = default; }; ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:8:0","series":null,"tags":["C++"],"title":"《C++Primer》第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#派生类中删除的拷贝控制和基类的关系"},{"categories":["C++"],"content":"15.7.2 合成拷贝控制与继承基类和派生类的合成拷贝控制成员的行为与其他合成的构造函数、赋值运算符或析构函数类似，它们对类本身成员依次进行初始化、赋值和销毁操作，此外还负责对直接基类部分进行初始化、赋值、销毁的操作 这里需要注意的就是顺序问题： 对于构造函数，派生类使用合成的构造函数时，会自动先调用直接基类的构造函数，然后再初始化自己的成员，直接基类又会进一步调用基类的构造函数 构造函数整体的表现为，先初始化基类成员-初始化直接基类-派生类 对于析构函数，合成的析构函数体是空的，隐式的析构部分负责销毁类的成员，对于派生类的析构函数来说，除了销毁自己的成员外，还负责销毁派生类的直接基类，依次进行 整体表现为，先调用派生类析构函数-直接基类析构函数-基类析构函数 派生类中删除的拷贝控制和基类的关系 如果基类拷贝控制成员是被删除的或者不可访问，派生类中对于的成员也是被删除的 如果基类中有一个不可访问或删除的析构函数，派生类中合成的默认和拷贝构造函数是删除的，因为编译器无法销毁派生类对象中基类部分 class B { public: B() {} B(const B\u0026) = delete; //其他成员，无移动构造函数 }; class D : public B { //没有声明任何构造函数 }; D d; //正确：D合成默认构造函数使用B默认构造函数 D d2(d); //错误：D合成拷贝构造函数是删除的 D d3(std::move(d)); //错误：隐式使用D被删除的拷贝构造函数 如果基类中没有默认、拷贝或移动构造函数，一般情况下派生类也不会定义相应的操作 移动操作和继承大多数基类会定义一个虚析构函数，默认情况下，基类不含有合成的移动操作，派生类也没有 如果需要移动操作，首先应该在基类中进行定义，可以使用合成的版本，但是要显示的定义，一旦定义移动操作，还有同时定义拷贝操作（3/5准则） class Quote { public: Quote() = default; Quote(const Quote\u0026) = default; Quote(Quote\u0026\u0026) = default; Quote\u0026 operator=(const Quote\u0026) = default; Quote\u0026 operator=(Quote\u0026\u0026) = default; virtual ~Quote() = default; }; ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:8:0","series":null,"tags":["C++"],"title":"《C++Primer》第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#移动操作和继承"},{"categories":["C++"],"content":"15.7.3 派生类的拷贝控制成员 派生类构造函数初始化阶段不仅需要初始化派生类自己的成员，还负责初始化派生类对象中基类部分 派生类的拷贝、移动构造函数、赋值运算符也类似，拷贝移动赋值派生类成员的同时，也要对基类部分进行相同的操作 而析构函数只负责销毁派生类自己分配的资源，派生类中基类部分是自动销毁的 定义派生类的拷贝或移动构造函数 class Base { /***/ }; class D : public Base { public: D(const D\u0026 d) : Base(d) //拷贝基类成员 /*D的成员初始值*/ {/**/} D(D\u0026\u0026 d) : Base(std::move(d)) //移动基类成员 /*D的成员初始值*/ {/**/} }; 初始值 Base(d) 将一个 D 对象传递给基类构造函数，值得注意的是，这里传给基类拷贝构造函数是一个 D 对象，它会自动匹配 Base 中的拷贝构造函数 如果没有提供基类初始值的话，基类部分被默认初始化，而不是从其他对象拷贝而来 //D这个拷贝构造函数很可能是不正确的定义 //基类部分被默认初始化，而非拷贝 D(const D\u0026 d) /*成员初始值，但是没有提供基类初始值*/ {/**/} 派生类赋值运算符和拷贝移动构造函数一样，赋值运算符也必须显示为基类部分进行赋值 D \u0026D::operator=(const D \u0026rhs) { Base::operator=(rhs); //D的其他成员赋值 //酌情使用自赋值和释放已有资源 return *this; } 派生类析构函数派生类析构函数只负责销毁派生类自己分配的资源 class D : public B { public: //Base::~Base()被自动执行 ~D() { /*销毁D分配的资源*/} } 构造函数和析构函数中调用虚函数书上这里写的有点绕，我的理解就是： 在基类的构造或析构函数中调用虚函数时，执行的版本时基类的虚函数版本 在派生类的构造或析构函数中调用虚函数时，执行的是派生类的虚函数版本 我自己也写了下面的代码进行了测试，确实是这样： #include \u003ciostream\u003eusing namespace std; class Base { public: Base() { cout \u003c\u003c \"Base default constructor\" \u003c\u003c endl; } Base(int n) : num(n) { cout \u003c\u003c \"Base constructor\" \u003c\u003c endl; print_num(); } virtual void print_num() { cout \u003c\u003c \"this is a base virtual, num = \"; cout \u003c\u003c num \u003c\u003c endl; } ~Base() { cout \u003c\u003c \"this is a Base destructor\" \u003c\u003c endl; print_num(); } protected: int num; }; class Derived : public Base { public: Derived(int n) :Base(n) { print_num(); cnt = n / 2; } void print_num() override { cout \u003c\u003c \"this is a derived virtual, num = \" \u003c\u003c num \u003c\u003c endl; cout \u003c\u003c \"cnt is \" \u003c\u003c cnt \u003c\u003c endl; } ~Derived() { cout \u003c\u003c \"this is a Derived destructor\" \u003c\u003c endl; print_num(); } private: int cnt; }; int main() { Derived *p = new Derived(10); cout \u003c\u003c \"===========\" \u003c\u003c endl; delete p; return 0; } /*打印结果，先执行了构造函数的调用，然后是析构函数的调用 silas@Silas-PC:~/cpp$ g++ construct_virtual.cpp \u0026\u0026 ./a.out Base constructor this is a base virtual, num = 10 this is a derived virtual, num = 10 cnt is 0 =========== this is a Derived destructor this is a derived virtual, num = 10 cnt is 5 this is a Base destructor this is a base virtual, num = 10 */ ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:8:1","series":null,"tags":["C++"],"title":"《C++Primer》第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#1573-派生类的拷贝控制成员"},{"categories":["C++"],"content":"15.7.3 派生类的拷贝控制成员 派生类构造函数初始化阶段不仅需要初始化派生类自己的成员，还负责初始化派生类对象中基类部分 派生类的拷贝、移动构造函数、赋值运算符也类似，拷贝移动赋值派生类成员的同时，也要对基类部分进行相同的操作 而析构函数只负责销毁派生类自己分配的资源，派生类中基类部分是自动销毁的 定义派生类的拷贝或移动构造函数 class Base { /***/ }; class D : public Base { public: D(const D\u0026 d) : Base(d) //拷贝基类成员 /*D的成员初始值*/ {/**/} D(D\u0026\u0026 d) : Base(std::move(d)) //移动基类成员 /*D的成员初始值*/ {/**/} }; 初始值 Base(d) 将一个 D 对象传递给基类构造函数，值得注意的是，这里传给基类拷贝构造函数是一个 D 对象，它会自动匹配 Base 中的拷贝构造函数 如果没有提供基类初始值的话，基类部分被默认初始化，而不是从其他对象拷贝而来 //D这个拷贝构造函数很可能是不正确的定义 //基类部分被默认初始化，而非拷贝 D(const D\u0026 d) /*成员初始值，但是没有提供基类初始值*/ {/**/} 派生类赋值运算符和拷贝移动构造函数一样，赋值运算符也必须显示为基类部分进行赋值 D \u0026D::operator=(const D \u0026rhs) { Base::operator=(rhs); //D的其他成员赋值 //酌情使用自赋值和释放已有资源 return *this; } 派生类析构函数派生类析构函数只负责销毁派生类自己分配的资源 class D : public B { public: //Base::~Base()被自动执行 ~D() { /*销毁D分配的资源*/} } 构造函数和析构函数中调用虚函数书上这里写的有点绕，我的理解就是： 在基类的构造或析构函数中调用虚函数时，执行的版本时基类的虚函数版本 在派生类的构造或析构函数中调用虚函数时，执行的是派生类的虚函数版本 我自己也写了下面的代码进行了测试，确实是这样： #include using namespace std; class Base { public: Base() { cout ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:8:1","series":null,"tags":["C++"],"title":"《C++Primer》第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#定义派生类的拷贝或移动构造函数"},{"categories":["C++"],"content":"15.7.3 派生类的拷贝控制成员 派生类构造函数初始化阶段不仅需要初始化派生类自己的成员，还负责初始化派生类对象中基类部分 派生类的拷贝、移动构造函数、赋值运算符也类似，拷贝移动赋值派生类成员的同时，也要对基类部分进行相同的操作 而析构函数只负责销毁派生类自己分配的资源，派生类中基类部分是自动销毁的 定义派生类的拷贝或移动构造函数 class Base { /***/ }; class D : public Base { public: D(const D\u0026 d) : Base(d) //拷贝基类成员 /*D的成员初始值*/ {/**/} D(D\u0026\u0026 d) : Base(std::move(d)) //移动基类成员 /*D的成员初始值*/ {/**/} }; 初始值 Base(d) 将一个 D 对象传递给基类构造函数，值得注意的是，这里传给基类拷贝构造函数是一个 D 对象，它会自动匹配 Base 中的拷贝构造函数 如果没有提供基类初始值的话，基类部分被默认初始化，而不是从其他对象拷贝而来 //D这个拷贝构造函数很可能是不正确的定义 //基类部分被默认初始化，而非拷贝 D(const D\u0026 d) /*成员初始值，但是没有提供基类初始值*/ {/**/} 派生类赋值运算符和拷贝移动构造函数一样，赋值运算符也必须显示为基类部分进行赋值 D \u0026D::operator=(const D \u0026rhs) { Base::operator=(rhs); //D的其他成员赋值 //酌情使用自赋值和释放已有资源 return *this; } 派生类析构函数派生类析构函数只负责销毁派生类自己分配的资源 class D : public B { public: //Base::~Base()被自动执行 ~D() { /*销毁D分配的资源*/} } 构造函数和析构函数中调用虚函数书上这里写的有点绕，我的理解就是： 在基类的构造或析构函数中调用虚函数时，执行的版本时基类的虚函数版本 在派生类的构造或析构函数中调用虚函数时，执行的是派生类的虚函数版本 我自己也写了下面的代码进行了测试，确实是这样： #include using namespace std; class Base { public: Base() { cout ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:8:1","series":null,"tags":["C++"],"title":"《C++Primer》第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#派生类赋值运算符"},{"categories":["C++"],"content":"15.7.3 派生类的拷贝控制成员 派生类构造函数初始化阶段不仅需要初始化派生类自己的成员，还负责初始化派生类对象中基类部分 派生类的拷贝、移动构造函数、赋值运算符也类似，拷贝移动赋值派生类成员的同时，也要对基类部分进行相同的操作 而析构函数只负责销毁派生类自己分配的资源，派生类中基类部分是自动销毁的 定义派生类的拷贝或移动构造函数 class Base { /***/ }; class D : public Base { public: D(const D\u0026 d) : Base(d) //拷贝基类成员 /*D的成员初始值*/ {/**/} D(D\u0026\u0026 d) : Base(std::move(d)) //移动基类成员 /*D的成员初始值*/ {/**/} }; 初始值 Base(d) 将一个 D 对象传递给基类构造函数，值得注意的是，这里传给基类拷贝构造函数是一个 D 对象，它会自动匹配 Base 中的拷贝构造函数 如果没有提供基类初始值的话，基类部分被默认初始化，而不是从其他对象拷贝而来 //D这个拷贝构造函数很可能是不正确的定义 //基类部分被默认初始化，而非拷贝 D(const D\u0026 d) /*成员初始值，但是没有提供基类初始值*/ {/**/} 派生类赋值运算符和拷贝移动构造函数一样，赋值运算符也必须显示为基类部分进行赋值 D \u0026D::operator=(const D \u0026rhs) { Base::operator=(rhs); //D的其他成员赋值 //酌情使用自赋值和释放已有资源 return *this; } 派生类析构函数派生类析构函数只负责销毁派生类自己分配的资源 class D : public B { public: //Base::~Base()被自动执行 ~D() { /*销毁D分配的资源*/} } 构造函数和析构函数中调用虚函数书上这里写的有点绕，我的理解就是： 在基类的构造或析构函数中调用虚函数时，执行的版本时基类的虚函数版本 在派生类的构造或析构函数中调用虚函数时，执行的是派生类的虚函数版本 我自己也写了下面的代码进行了测试，确实是这样： #include using namespace std; class Base { public: Base() { cout ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:8:1","series":null,"tags":["C++"],"title":"《C++Primer》第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#派生类析构函数"},{"categories":["C++"],"content":"15.7.3 派生类的拷贝控制成员 派生类构造函数初始化阶段不仅需要初始化派生类自己的成员，还负责初始化派生类对象中基类部分 派生类的拷贝、移动构造函数、赋值运算符也类似，拷贝移动赋值派生类成员的同时，也要对基类部分进行相同的操作 而析构函数只负责销毁派生类自己分配的资源，派生类中基类部分是自动销毁的 定义派生类的拷贝或移动构造函数 class Base { /***/ }; class D : public Base { public: D(const D\u0026 d) : Base(d) //拷贝基类成员 /*D的成员初始值*/ {/**/} D(D\u0026\u0026 d) : Base(std::move(d)) //移动基类成员 /*D的成员初始值*/ {/**/} }; 初始值 Base(d) 将一个 D 对象传递给基类构造函数，值得注意的是，这里传给基类拷贝构造函数是一个 D 对象，它会自动匹配 Base 中的拷贝构造函数 如果没有提供基类初始值的话，基类部分被默认初始化，而不是从其他对象拷贝而来 //D这个拷贝构造函数很可能是不正确的定义 //基类部分被默认初始化，而非拷贝 D(const D\u0026 d) /*成员初始值，但是没有提供基类初始值*/ {/**/} 派生类赋值运算符和拷贝移动构造函数一样，赋值运算符也必须显示为基类部分进行赋值 D \u0026D::operator=(const D \u0026rhs) { Base::operator=(rhs); //D的其他成员赋值 //酌情使用自赋值和释放已有资源 return *this; } 派生类析构函数派生类析构函数只负责销毁派生类自己分配的资源 class D : public B { public: //Base::~Base()被自动执行 ~D() { /*销毁D分配的资源*/} } 构造函数和析构函数中调用虚函数书上这里写的有点绕，我的理解就是： 在基类的构造或析构函数中调用虚函数时，执行的版本时基类的虚函数版本 在派生类的构造或析构函数中调用虚函数时，执行的是派生类的虚函数版本 我自己也写了下面的代码进行了测试，确实是这样： #include using namespace std; class Base { public: Base() { cout ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:8:1","series":null,"tags":["C++"],"title":"《C++Primer》第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#构造函数和析构函数中调用虚函数"},{"categories":["C++"],"content":"15.7.4 继承的构造函数C++11新标准下，派生类可以重用直接基类定义的构造函数，一个类只负责初始化它的直接基类，也只继承直接基类的构造函数。 类不能继承默认、拷贝和移动构造函数，如果派生类没有直接定义这些构造函数，编译器将为派生类合成它们 派生类继承基类构造函数的方式是提供一条注明了直接基类名的 using 声明语句 class Bulk_quote : public Disc_quote { public: using Disc_quote::Disc_quote;//继承了Disc_quote构造函数 double net_price(std::size_t) const; }; using 声明语句作用在构造函数时，将令编译器产生代码，对于基类的每个构造函数，在派生类都会生成一个与之对应的构造函数，形如：derived(parms) : base(args) {} 在上面Bulk_quote 中，继承的构造函数等价于： Bulk_quote(const std::string \u0026book, double price, std::size_t qty, double disc) : Disc_quote(book, price, qty, disc) {} 如果派生类有自己的成员，这些成员将会被默认初始化 继承的构造函数特点 和普通成员 using 声明不一样，using 不会改变构造函数的访问级别，如，基类的私有构造函数在派生类中还是一个私有的构造函数 using 声明不能指定 explicit 或 constexpr，基类构造函数是 explicit 或 constexpr，派生类也是如此 基类构造函数中的默认实参不会被继承，派生类会获得多个继承的构造函数，其中每个构造函数分别省略掉一个含义默认实参的形参 如果派生类定义的构造函数和基类构造函数有相同形参列表，这些构造函数不会被继承 默认、 拷贝和移动构造函数不会被继承，这些按照正常合成规则被合成 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:8:2","series":null,"tags":["C++"],"title":"《C++Primer》第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#1574-继承的构造函数"},{"categories":["C++"],"content":"15.7.4 继承的构造函数C++11新标准下，派生类可以重用直接基类定义的构造函数，一个类只负责初始化它的直接基类，也只继承直接基类的构造函数。 类不能继承默认、拷贝和移动构造函数，如果派生类没有直接定义这些构造函数，编译器将为派生类合成它们 派生类继承基类构造函数的方式是提供一条注明了直接基类名的 using 声明语句 class Bulk_quote : public Disc_quote { public: using Disc_quote::Disc_quote;//继承了Disc_quote构造函数 double net_price(std::size_t) const; }; using 声明语句作用在构造函数时，将令编译器产生代码，对于基类的每个构造函数，在派生类都会生成一个与之对应的构造函数，形如：derived(parms) : base(args) {} 在上面Bulk_quote 中，继承的构造函数等价于： Bulk_quote(const std::string \u0026book, double price, std::size_t qty, double disc) : Disc_quote(book, price, qty, disc) {} 如果派生类有自己的成员，这些成员将会被默认初始化 继承的构造函数特点 和普通成员 using 声明不一样，using 不会改变构造函数的访问级别，如，基类的私有构造函数在派生类中还是一个私有的构造函数 using 声明不能指定 explicit 或 constexpr，基类构造函数是 explicit 或 constexpr，派生类也是如此 基类构造函数中的默认实参不会被继承，派生类会获得多个继承的构造函数，其中每个构造函数分别省略掉一个含义默认实参的形参 如果派生类定义的构造函数和基类构造函数有相同形参列表，这些构造函数不会被继承 默认、 拷贝和移动构造函数不会被继承，这些按照正常合成规则被合成 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:8:2","series":null,"tags":["C++"],"title":"《C++Primer》第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#继承的构造函数特点"},{"categories":["C++"],"content":"第14章 重载运算与类型转换","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:0:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#第14章-重载运算与类型转换"},{"categories":["C++"],"content":"14.1 基本概念重载的运算符是具有特殊名字的函数：它们的名字由关键字 operator 和其后要定义的运算符号共同组成。和其他函数一样，重载的运算符也包含返回类型、参数列表以及函数体。 重载运算符函数的参数数量与该作用的运算对象数量一样多，一元运算符有一个参数，二元运算符有两个参数； 二元运算符左侧运算对象传递给第一个参数，右侧对象传递给第二个对象 除了 operator() 外，其他重载运算符不能含有默认实参 如果一个重载运算符是类的成员函数时，this 会绑定到左侧运算对象，参数数量会比运算对象少一个 重载运算符函数只能是一个类的成员，或者至少有一个类类型的参数，不能对内置类型定义重载运算符 int operator+(int, int);//错误，不能重定义int的运算符 以下是可以重载或者不能重载的运算符： 重载运算符的几种调用形式： 可以间接的用运算符调用重载的运算符函数 也可以像普通函数那样直接调用 //一个非成员运算符函数的等价调用 data1 + data2; //普通表达式 operator+(data1, data2); //等价的函数调用 也可以像调用其他成员函数一样显示的调用成员运算符 data1 += data2; //基于调用的表达式 data1.operator+=(data2); //对成员运算符函数的等价调用 某些运算符不应该被重载 某些运算符会指定运算对象的求值顺序，而关于这些运算对象求值顺序的规则无法应用到重载的运算符上 像逻辑与运算符、逻辑或运算符、逗号运算符的运算对象求值顺序无法保留下来，而 \u0026\u0026 和 || 短路求值属性也无法保留 对于逗号和取地址运算符，用于类类型对象时已经定义了特殊的含义，所以不应该被重载 使用内置类型一致的含义设计一个类时，要考虑这个类提供哪些操作，然后再考虑这些操作设为普通函数还是重载的运算符。如果某些类逻辑上和运算符相关，它们适合定义成重载的运算符 如果类执行 IO 操作，定义移位运算符和内置类型的 IO 保存一致 类检查相等性操作，定义 operator=，同时也应该定义 operator!= 如果类有比较操作，例如 operator\u003c，也该也定义其他关系的操作 返回类型通常情况下要和内置返回类型兼容： 逻辑和关系运算符应该返回 bool 算术运算符应该返回类类型的值 赋值和复合运算符应该返回左侧对象的引用 选择作为成员或者非成员定义重载运算符时，首先要觉得声明为类的成员函数，还是一个普通的非成员函数，下面准则可以帮助判断： 赋值（=），下标（[]），调用（()）和成员访问箭头（-\u003e）必须时成员 复合类型一般为成员，但非必须 改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减、解引用通常为成员 具有对称性的运算符可以转换任意一端的运算对象，如算术、相等性、关系和位运算，通常位普通的非成员函数 string s = \"world\"; string t = s + \"!\"; string u = \"hi \" + s;//如果+是string成员函数，这里会报错 实际上，string 将 + 定义为了普通成员函数，\"hi \" + s 等价于 operator+=(\"hi \", s)，就没有出现问题 ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:1:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#141-基本概念"},{"categories":["C++"],"content":"14.1 基本概念重载的运算符是具有特殊名字的函数：它们的名字由关键字 operator 和其后要定义的运算符号共同组成。和其他函数一样，重载的运算符也包含返回类型、参数列表以及函数体。 重载运算符函数的参数数量与该作用的运算对象数量一样多，一元运算符有一个参数，二元运算符有两个参数； 二元运算符左侧运算对象传递给第一个参数，右侧对象传递给第二个对象 除了 operator() 外，其他重载运算符不能含有默认实参 如果一个重载运算符是类的成员函数时，this 会绑定到左侧运算对象，参数数量会比运算对象少一个 重载运算符函数只能是一个类的成员，或者至少有一个类类型的参数，不能对内置类型定义重载运算符 int operator+(int, int);//错误，不能重定义int的运算符 以下是可以重载或者不能重载的运算符： 重载运算符的几种调用形式： 可以间接的用运算符调用重载的运算符函数 也可以像普通函数那样直接调用 //一个非成员运算符函数的等价调用 data1 + data2; //普通表达式 operator+(data1, data2); //等价的函数调用 也可以像调用其他成员函数一样显示的调用成员运算符 data1 += data2; //基于调用的表达式 data1.operator+=(data2); //对成员运算符函数的等价调用 某些运算符不应该被重载 某些运算符会指定运算对象的求值顺序，而关于这些运算对象求值顺序的规则无法应用到重载的运算符上 像逻辑与运算符、逻辑或运算符、逗号运算符的运算对象求值顺序无法保留下来，而 \u0026\u0026 和 || 短路求值属性也无法保留 对于逗号和取地址运算符，用于类类型对象时已经定义了特殊的含义，所以不应该被重载 使用内置类型一致的含义设计一个类时，要考虑这个类提供哪些操作，然后再考虑这些操作设为普通函数还是重载的运算符。如果某些类逻辑上和运算符相关，它们适合定义成重载的运算符 如果类执行 IO 操作，定义移位运算符和内置类型的 IO 保存一致 类检查相等性操作，定义 operator=，同时也应该定义 operator!= 如果类有比较操作，例如 operator）必须时成员 复合类型一般为成员，但非必须 改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减、解引用通常为成员 具有对称性的运算符可以转换任意一端的运算对象，如算术、相等性、关系和位运算，通常位普通的非成员函数 string s = \"world\"; string t = s + \"!\"; string u = \"hi \" + s;//如果+是string成员函数，这里会报错 实际上，string 将 + 定义为了普通成员函数，\"hi \" + s 等价于 operator+=(\"hi \", s)，就没有出现问题 ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:1:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#重载运算符的几种调用形式"},{"categories":["C++"],"content":"14.1 基本概念重载的运算符是具有特殊名字的函数：它们的名字由关键字 operator 和其后要定义的运算符号共同组成。和其他函数一样，重载的运算符也包含返回类型、参数列表以及函数体。 重载运算符函数的参数数量与该作用的运算对象数量一样多，一元运算符有一个参数，二元运算符有两个参数； 二元运算符左侧运算对象传递给第一个参数，右侧对象传递给第二个对象 除了 operator() 外，其他重载运算符不能含有默认实参 如果一个重载运算符是类的成员函数时，this 会绑定到左侧运算对象，参数数量会比运算对象少一个 重载运算符函数只能是一个类的成员，或者至少有一个类类型的参数，不能对内置类型定义重载运算符 int operator+(int, int);//错误，不能重定义int的运算符 以下是可以重载或者不能重载的运算符： 重载运算符的几种调用形式： 可以间接的用运算符调用重载的运算符函数 也可以像普通函数那样直接调用 //一个非成员运算符函数的等价调用 data1 + data2; //普通表达式 operator+(data1, data2); //等价的函数调用 也可以像调用其他成员函数一样显示的调用成员运算符 data1 += data2; //基于调用的表达式 data1.operator+=(data2); //对成员运算符函数的等价调用 某些运算符不应该被重载 某些运算符会指定运算对象的求值顺序，而关于这些运算对象求值顺序的规则无法应用到重载的运算符上 像逻辑与运算符、逻辑或运算符、逗号运算符的运算对象求值顺序无法保留下来，而 \u0026\u0026 和 || 短路求值属性也无法保留 对于逗号和取地址运算符，用于类类型对象时已经定义了特殊的含义，所以不应该被重载 使用内置类型一致的含义设计一个类时，要考虑这个类提供哪些操作，然后再考虑这些操作设为普通函数还是重载的运算符。如果某些类逻辑上和运算符相关，它们适合定义成重载的运算符 如果类执行 IO 操作，定义移位运算符和内置类型的 IO 保存一致 类检查相等性操作，定义 operator=，同时也应该定义 operator!= 如果类有比较操作，例如 operator）必须时成员 复合类型一般为成员，但非必须 改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减、解引用通常为成员 具有对称性的运算符可以转换任意一端的运算对象，如算术、相等性、关系和位运算，通常位普通的非成员函数 string s = \"world\"; string t = s + \"!\"; string u = \"hi \" + s;//如果+是string成员函数，这里会报错 实际上，string 将 + 定义为了普通成员函数，\"hi \" + s 等价于 operator+=(\"hi \", s)，就没有出现问题 ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:1:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#某些运算符不应该被重载"},{"categories":["C++"],"content":"14.1 基本概念重载的运算符是具有特殊名字的函数：它们的名字由关键字 operator 和其后要定义的运算符号共同组成。和其他函数一样，重载的运算符也包含返回类型、参数列表以及函数体。 重载运算符函数的参数数量与该作用的运算对象数量一样多，一元运算符有一个参数，二元运算符有两个参数； 二元运算符左侧运算对象传递给第一个参数，右侧对象传递给第二个对象 除了 operator() 外，其他重载运算符不能含有默认实参 如果一个重载运算符是类的成员函数时，this 会绑定到左侧运算对象，参数数量会比运算对象少一个 重载运算符函数只能是一个类的成员，或者至少有一个类类型的参数，不能对内置类型定义重载运算符 int operator+(int, int);//错误，不能重定义int的运算符 以下是可以重载或者不能重载的运算符： 重载运算符的几种调用形式： 可以间接的用运算符调用重载的运算符函数 也可以像普通函数那样直接调用 //一个非成员运算符函数的等价调用 data1 + data2; //普通表达式 operator+(data1, data2); //等价的函数调用 也可以像调用其他成员函数一样显示的调用成员运算符 data1 += data2; //基于调用的表达式 data1.operator+=(data2); //对成员运算符函数的等价调用 某些运算符不应该被重载 某些运算符会指定运算对象的求值顺序，而关于这些运算对象求值顺序的规则无法应用到重载的运算符上 像逻辑与运算符、逻辑或运算符、逗号运算符的运算对象求值顺序无法保留下来，而 \u0026\u0026 和 || 短路求值属性也无法保留 对于逗号和取地址运算符，用于类类型对象时已经定义了特殊的含义，所以不应该被重载 使用内置类型一致的含义设计一个类时，要考虑这个类提供哪些操作，然后再考虑这些操作设为普通函数还是重载的运算符。如果某些类逻辑上和运算符相关，它们适合定义成重载的运算符 如果类执行 IO 操作，定义移位运算符和内置类型的 IO 保存一致 类检查相等性操作，定义 operator=，同时也应该定义 operator!= 如果类有比较操作，例如 operator）必须时成员 复合类型一般为成员，但非必须 改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减、解引用通常为成员 具有对称性的运算符可以转换任意一端的运算对象，如算术、相等性、关系和位运算，通常位普通的非成员函数 string s = \"world\"; string t = s + \"!\"; string u = \"hi \" + s;//如果+是string成员函数，这里会报错 实际上，string 将 + 定义为了普通成员函数，\"hi \" + s 等价于 operator+=(\"hi \", s)，就没有出现问题 ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:1:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#使用内置类型一致的含义"},{"categories":["C++"],"content":"14.1 基本概念重载的运算符是具有特殊名字的函数：它们的名字由关键字 operator 和其后要定义的运算符号共同组成。和其他函数一样，重载的运算符也包含返回类型、参数列表以及函数体。 重载运算符函数的参数数量与该作用的运算对象数量一样多，一元运算符有一个参数，二元运算符有两个参数； 二元运算符左侧运算对象传递给第一个参数，右侧对象传递给第二个对象 除了 operator() 外，其他重载运算符不能含有默认实参 如果一个重载运算符是类的成员函数时，this 会绑定到左侧运算对象，参数数量会比运算对象少一个 重载运算符函数只能是一个类的成员，或者至少有一个类类型的参数，不能对内置类型定义重载运算符 int operator+(int, int);//错误，不能重定义int的运算符 以下是可以重载或者不能重载的运算符： 重载运算符的几种调用形式： 可以间接的用运算符调用重载的运算符函数 也可以像普通函数那样直接调用 //一个非成员运算符函数的等价调用 data1 + data2; //普通表达式 operator+(data1, data2); //等价的函数调用 也可以像调用其他成员函数一样显示的调用成员运算符 data1 += data2; //基于调用的表达式 data1.operator+=(data2); //对成员运算符函数的等价调用 某些运算符不应该被重载 某些运算符会指定运算对象的求值顺序，而关于这些运算对象求值顺序的规则无法应用到重载的运算符上 像逻辑与运算符、逻辑或运算符、逗号运算符的运算对象求值顺序无法保留下来，而 \u0026\u0026 和 || 短路求值属性也无法保留 对于逗号和取地址运算符，用于类类型对象时已经定义了特殊的含义，所以不应该被重载 使用内置类型一致的含义设计一个类时，要考虑这个类提供哪些操作，然后再考虑这些操作设为普通函数还是重载的运算符。如果某些类逻辑上和运算符相关，它们适合定义成重载的运算符 如果类执行 IO 操作，定义移位运算符和内置类型的 IO 保存一致 类检查相等性操作，定义 operator=，同时也应该定义 operator!= 如果类有比较操作，例如 operator）必须时成员 复合类型一般为成员，但非必须 改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减、解引用通常为成员 具有对称性的运算符可以转换任意一端的运算对象，如算术、相等性、关系和位运算，通常位普通的非成员函数 string s = \"world\"; string t = s + \"!\"; string u = \"hi \" + s;//如果+是string成员函数，这里会报错 实际上，string 将 + 定义为了普通成员函数，\"hi \" + s 等价于 operator+=(\"hi \", s)，就没有出现问题 ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:1:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#选择作为成员或者非成员"},{"categories":["C++"],"content":"14.2 输入输出运算符","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:2:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#142-输入输出运算符"},{"categories":["C++"],"content":"14.2.1 重载输出运算符«通常情况下，输出运算符第一个形参是一个非常量 ostream 对象的引用，非常量是因为像流写入内容会改变其状态，引用类型是因为无法直接复制一个 ostream 对象（注：拷贝构造函数为 delete） 第二个形参是一个常量的引用，这个常量是需要打印出来的类类型，引用为了避免复制，常量是因为打印不会改变对象的内容 举个例子： ostream \u0026operator(ostream \u0026os, const \u0026Sales_data \u0026item) { os \u003c\u003c item.isbn() \u003c\u003c \" \" \u003c\u003c item.units_sold \u003c\u003c \" \" \u003c\u003c item.revenue \u003c\u003c \" \" \u003c\u003c item.avg_price();//末尾不需要再加换行符 return os; } 通常输出运算符主要负责打印对象内容而不是控制格式，所以一般不打印换行符 输入输出运算符必须是非成员函数输入输出函数必须为非成员函数，不能是类成员函数，否则左侧运算对象将是类的一个对象 Sales_data data; data \u003c\u003c cout; //如果opeator\u003c\u003c是Sales_data的对象 如果输入输出运算符是Sales_data 的成员，它们也必须为 istream 或 ostream 的成员，当然我们不能为标准库定义成员 注：其实这里感觉没看懂，如果像书上写的这样，data « cout 感觉是不是也可以输出？我自己也试了代码，确实可以输出，就是看着有点怪，要是深究起来，感觉书上写的话不够严谨 ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:2:1","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#1421-重载输出运算符"},{"categories":["C++"],"content":"14.2.1 重载输出运算符«通常情况下，输出运算符第一个形参是一个非常量 ostream 对象的引用，非常量是因为像流写入内容会改变其状态，引用类型是因为无法直接复制一个 ostream 对象（注：拷贝构造函数为 delete） 第二个形参是一个常量的引用，这个常量是需要打印出来的类类型，引用为了避免复制，常量是因为打印不会改变对象的内容 举个例子： ostream \u0026operator(ostream \u0026os, const \u0026Sales_data \u0026item) { os ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:2:1","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#输入输出运算符必须是非成员函数"},{"categories":["C++"],"content":"14.2.2 重载输入运算符»输入运算符第一个形参是读取流的引用，第二个形参是读入到对象的引用 例如： istream \u0026operator\u003e\u003e(istream \u0026is, Sales_data \u0026item) { double price; is \u003e\u003e item.bookNo \u003e\u003e item.untis_sold \u003e\u003e price; if (is) {//检查是否输入成功 item.revenue = item.units_sold * price; } else { item = Sales_data();//输入失败，对象初始为默认情况 } return is; } 输入时的错误执行输入运算符时可能发生以下错误： 当流读取到错误类型的数据，后续操作都会失败 当读取操作未达到文件末尾或者遇到输入流其他错误时也会失败 所以使用输入操作符时，需要判断是否有错误的情况发生，因为如果出现错误的情况可能发生在中间，这样的话前面的成员时正确的，而发生读取错误的地方后面的成员就和前面不匹配了 ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:2:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#1422-重载输入运算符"},{"categories":["C++"],"content":"14.2.2 重载输入运算符»输入运算符第一个形参是读取流的引用，第二个形参是读入到对象的引用 例如： istream \u0026operator(istream \u0026is, Sales_data \u0026item) { double price; is item.bookNo item.untis_sold price; if (is) {//检查是否输入成功 item.revenue = item.units_sold * price; } else { item = Sales_data();//输入失败，对象初始为默认情况 } return is; } 输入时的错误执行输入运算符时可能发生以下错误： 当流读取到错误类型的数据，后续操作都会失败 当读取操作未达到文件末尾或者遇到输入流其他错误时也会失败 所以使用输入操作符时，需要判断是否有错误的情况发生，因为如果出现错误的情况可能发生在中间，这样的话前面的成员时正确的，而发生读取错误的地方后面的成员就和前面不匹配了 ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:2:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#输入时的错误"},{"categories":["C++"],"content":"14.3 算术和关系运算符通常情况下，算术和关系运算符定义为非成员函数允许左侧和右侧运算对象进行转换，形参都是常量的引用 算术运算符通常会计算两个对象并得到一个新值，这个值区别于任何一个运算对象，常常位于一个局部变量中，返回值应该为局部变量的副本作为结果，通常也会定义复合赋值运算符 Book operator+(const Book \u0026lhs, const Book \u0026rhs) { Book sum = lhs; sum += rhs; //复合赋值运算符 return sum; } ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:3:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#143-算术和关系运算符"},{"categories":["C++"],"content":"14.3.1 相等运算符一般情况下只有当两个对象每一个数据成员都相等时，才认为他们时相等的 下面是个具体例子： bool operator==(const Book \u0026lhs, const Book \u0026rhs) { return lhs.price == rhs.price \u0026\u0026 lhs.name == rhs.name; } bool operator!=(const Book \u0026lhs, const Book \u0026rhs) { return !(lhs == rhs); } 设计相等运算符函数基本准则如下： 设计一个类判断两个对象是否相等的操作时，通常定义为 operator== 而非其他的像（equl等等）普通的命名函数 如果类定义了 operator== ，则该运算符应该能判断一组给定对象是否含义重复数据 相等运算符应该具有传递性，如 a == b 和 b == c 都为真，那么 a == c 也为真 定义了 operator== 通常也要定义 operator!= 相等和不相等运算符，通常具体写一个即可，另一个进行调用即可 ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:3:1","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#1431-相等运算符"},{"categories":["C++"],"content":"14.3.2 关系运算符对于关联容器和一些算法会用到小于运算符，此时可以定义 operator\u003c 但是一般情况下，关系运算符可能没有那么有必要，比如说上面的 Book 类，如果说定义小于关系的，具体内容如何比较，是先根据书名然后根据价格进行比较？还是说仅仅根据书名比较 一般情况下，对于不相等的对象，一个对象应该小于另一个对象，这样的话，定义关系运算符的时候，逻辑上就不是很清楚了 如果存在唯一一种逻辑可靠的 \u003c 定义，应该考虑定义 \u003c 运算符，但是如果类还包括 == ，仅当\u003c 的定义和 == 结果一致时才定义 \u003c 运算符 ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:3:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#1432-关系运算符"},{"categories":["C++"],"content":"14.4 赋值运算符13章时已经介绍过拷贝赋值和移动赋值运算符，它们把一个对象赋值给另一个对象。我们还可以定义其他的赋值运算符，以使用别的类型作为右侧对象 复合赋值运算符通常把复合赋值运算符等赋值运算符都定义在类的内部，复合赋值运算符也应该返回左侧对象的引用 Book \u0026Book::operator+=(const Book \u0026rhs) { price += rhs.price;//这里因为自己写的例子，语义上可能有些问题 return *this; } ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:4:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#144-赋值运算符"},{"categories":["C++"],"content":"14.4 赋值运算符13章时已经介绍过拷贝赋值和移动赋值运算符，它们把一个对象赋值给另一个对象。我们还可以定义其他的赋值运算符，以使用别的类型作为右侧对象 复合赋值运算符通常把复合赋值运算符等赋值运算符都定义在类的内部，复合赋值运算符也应该返回左侧对象的引用 Book \u0026Book::operator+=(const Book \u0026rhs) { price += rhs.price;//这里因为自己写的例子，语义上可能有些问题 return *this; } ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:4:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#复合赋值运算符"},{"categories":["C++"],"content":"14.5 下标运算符下标运算符通常在一些容器中，可以让我们像访问数组那样的形式进行访问，一般会定义为 operator[] 下标运算符必须时成员函数 通常返回值为访问元素的引用，确保下标可以出现在赋值运算符任意一端 如果一个类包含下标运算符，通常会定义两个版本： 一个返回普通引用 另一个是类的常量成员并且返回常量引用 class StrVec { std::string\u0026 operator[](std::size_t n) {return elements[n];} const std::string\u0026 operator[](std::size_t) const {return elements[n];} private: std::string *elements;//指向数组首元素的指针 } 当 StrVec 是非常量时，可以给元素赋值 当对常量对象取小标时，不能为其赋值 const StrVec cvec = svec; if (svec.size() \u0026\u0026 svec[0].empty()) { svec[0] = \"zero\";//正确：下标运算符返回string的引用 cvec[0] = \"zip\"; //错误：cvec取下标返回的为常量引用 } ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:5:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#145-下标运算符"},{"categories":["C++"],"content":"14.6递增和递减运算符一般迭代器类会实现递增运算符（++）和递减运算符（–），使得迭代器可以在元素序列中进行移动，因为它们改变了操作对象的状态，通常设为成员函数 定义递增和递减运算符的类要同时定义前置版本和后置版本，且都为类的成员函数 定义前置递增/递减运算符==为了和内置版本保持一致，前置运算符应该返回递增或递减后对象的引用== 递增和递减运算符工作机理： 首先调用check 函数检查是否有效 如果有效，接着检查给定索引值是否有效 check 函数没有发生异常，返回运算对象的引用 下面时具体例子： class StrBlobPtr { public: //递增和递减运算符 StrBlobPtr\u0026 operator++();//前置版本 StrBlobPtr\u0026 operator--(); //其他成员 } StrBlobPtr\u0026 StrBlobPtr::operator++() { check(curr, \"已经越界\"); ++curr; //curr向前移动一个元素 return *this; } StrBlobPtr\u0026 StrBlobPtr::operator--() { --curr; //curr向后移动一个元素 check(curr, \"已经越界\"); return *this; } 区分前置和后置运算符因为前置和后置版本使用的是同一个符号，重载版本的名字也是相同的，运算对象的数量和类型也是相同的 所以为了解决这个问题，后置版本接受一个额外的但是不使用的 int 类型的参数，编译器会为这个形参提供一个值为 0 的实参 class StrBlobPtr { public: //递增和递减运算符 StrBlobPtr\u0026 operator++(int);//后置版本 StrBlobPtr\u0026 operator--(int); //其他成员 } StrBlobPtr StrBlobPtr::operator++(int) { //这里无须检查有效性，调用前置版本的时候会检查 StrBlobPtr ret = *this;//记录当前的值 ++*this; //向前移动一个元素，前置++会检查有效性 return ret; //返回之前记录的状态 } StrBlobPtr\u0026 StrBlobPtr::operator--(int) { //这里无须检查有效性，调用前置版本的时候会检查 StrBlobPtr ret = *this;//记录当前的值 --*this; //向前移动一个元素，前置++会检查有效性 return ret; //返回之前记录的状态 } 这里主要需要理解内置类型前置版本和后置版本的区别（以int类型为例） ++i 首先会对 i 的值进行递增，然后返回 i 的值 i++ 首先会返回 i 的值，然后再进行运算 int sum = 0, i = 1; sum = ++i; //此时sum的值为2 sum = i++; //此时sum的值为1 显示调用后置运算符如果要显示调用运算符的话，像之前那样利用函数调用的形式进行调用，但是注意必须传入一个整型参数 StrBlobPtr p(a1); //p指向a1的vector p.operator++(0); //调用后置版本的operator++ p.operator++(); //调用前置版本的operator++ ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:6:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#146递增和递减运算符"},{"categories":["C++"],"content":"14.6递增和递减运算符一般迭代器类会实现递增运算符（++）和递减运算符（–），使得迭代器可以在元素序列中进行移动，因为它们改变了操作对象的状态，通常设为成员函数 定义递增和递减运算符的类要同时定义前置版本和后置版本，且都为类的成员函数 定义前置递增/递减运算符==为了和内置版本保持一致，前置运算符应该返回递增或递减后对象的引用== 递增和递减运算符工作机理： 首先调用check 函数检查是否有效 如果有效，接着检查给定索引值是否有效 check 函数没有发生异常，返回运算对象的引用 下面时具体例子： class StrBlobPtr { public: //递增和递减运算符 StrBlobPtr\u0026 operator++();//前置版本 StrBlobPtr\u0026 operator--(); //其他成员 } StrBlobPtr\u0026 StrBlobPtr::operator++() { check(curr, \"已经越界\"); ++curr; //curr向前移动一个元素 return *this; } StrBlobPtr\u0026 StrBlobPtr::operator--() { --curr; //curr向后移动一个元素 check(curr, \"已经越界\"); return *this; } 区分前置和后置运算符因为前置和后置版本使用的是同一个符号，重载版本的名字也是相同的，运算对象的数量和类型也是相同的 所以为了解决这个问题，后置版本接受一个额外的但是不使用的 int 类型的参数，编译器会为这个形参提供一个值为 0 的实参 class StrBlobPtr { public: //递增和递减运算符 StrBlobPtr\u0026 operator++(int);//后置版本 StrBlobPtr\u0026 operator--(int); //其他成员 } StrBlobPtr StrBlobPtr::operator++(int) { //这里无须检查有效性，调用前置版本的时候会检查 StrBlobPtr ret = *this;//记录当前的值 ++*this; //向前移动一个元素，前置++会检查有效性 return ret; //返回之前记录的状态 } StrBlobPtr\u0026 StrBlobPtr::operator--(int) { //这里无须检查有效性，调用前置版本的时候会检查 StrBlobPtr ret = *this;//记录当前的值 --*this; //向前移动一个元素，前置++会检查有效性 return ret; //返回之前记录的状态 } 这里主要需要理解内置类型前置版本和后置版本的区别（以int类型为例） ++i 首先会对 i 的值进行递增，然后返回 i 的值 i++ 首先会返回 i 的值，然后再进行运算 int sum = 0, i = 1; sum = ++i; //此时sum的值为2 sum = i++; //此时sum的值为1 显示调用后置运算符如果要显示调用运算符的话，像之前那样利用函数调用的形式进行调用，但是注意必须传入一个整型参数 StrBlobPtr p(a1); //p指向a1的vector p.operator++(0); //调用后置版本的operator++ p.operator++(); //调用前置版本的operator++ ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:6:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#定义前置递增递减运算符"},{"categories":["C++"],"content":"14.6递增和递减运算符一般迭代器类会实现递增运算符（++）和递减运算符（–），使得迭代器可以在元素序列中进行移动，因为它们改变了操作对象的状态，通常设为成员函数 定义递增和递减运算符的类要同时定义前置版本和后置版本，且都为类的成员函数 定义前置递增/递减运算符==为了和内置版本保持一致，前置运算符应该返回递增或递减后对象的引用== 递增和递减运算符工作机理： 首先调用check 函数检查是否有效 如果有效，接着检查给定索引值是否有效 check 函数没有发生异常，返回运算对象的引用 下面时具体例子： class StrBlobPtr { public: //递增和递减运算符 StrBlobPtr\u0026 operator++();//前置版本 StrBlobPtr\u0026 operator--(); //其他成员 } StrBlobPtr\u0026 StrBlobPtr::operator++() { check(curr, \"已经越界\"); ++curr; //curr向前移动一个元素 return *this; } StrBlobPtr\u0026 StrBlobPtr::operator--() { --curr; //curr向后移动一个元素 check(curr, \"已经越界\"); return *this; } 区分前置和后置运算符因为前置和后置版本使用的是同一个符号，重载版本的名字也是相同的，运算对象的数量和类型也是相同的 所以为了解决这个问题，后置版本接受一个额外的但是不使用的 int 类型的参数，编译器会为这个形参提供一个值为 0 的实参 class StrBlobPtr { public: //递增和递减运算符 StrBlobPtr\u0026 operator++(int);//后置版本 StrBlobPtr\u0026 operator--(int); //其他成员 } StrBlobPtr StrBlobPtr::operator++(int) { //这里无须检查有效性，调用前置版本的时候会检查 StrBlobPtr ret = *this;//记录当前的值 ++*this; //向前移动一个元素，前置++会检查有效性 return ret; //返回之前记录的状态 } StrBlobPtr\u0026 StrBlobPtr::operator--(int) { //这里无须检查有效性，调用前置版本的时候会检查 StrBlobPtr ret = *this;//记录当前的值 --*this; //向前移动一个元素，前置++会检查有效性 return ret; //返回之前记录的状态 } 这里主要需要理解内置类型前置版本和后置版本的区别（以int类型为例） ++i 首先会对 i 的值进行递增，然后返回 i 的值 i++ 首先会返回 i 的值，然后再进行运算 int sum = 0, i = 1; sum = ++i; //此时sum的值为2 sum = i++; //此时sum的值为1 显示调用后置运算符如果要显示调用运算符的话，像之前那样利用函数调用的形式进行调用，但是注意必须传入一个整型参数 StrBlobPtr p(a1); //p指向a1的vector p.operator++(0); //调用后置版本的operator++ p.operator++(); //调用前置版本的operator++ ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:6:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#区分前置和后置运算符"},{"categories":["C++"],"content":"14.6递增和递减运算符一般迭代器类会实现递增运算符（++）和递减运算符（–），使得迭代器可以在元素序列中进行移动，因为它们改变了操作对象的状态，通常设为成员函数 定义递增和递减运算符的类要同时定义前置版本和后置版本，且都为类的成员函数 定义前置递增/递减运算符==为了和内置版本保持一致，前置运算符应该返回递增或递减后对象的引用== 递增和递减运算符工作机理： 首先调用check 函数检查是否有效 如果有效，接着检查给定索引值是否有效 check 函数没有发生异常，返回运算对象的引用 下面时具体例子： class StrBlobPtr { public: //递增和递减运算符 StrBlobPtr\u0026 operator++();//前置版本 StrBlobPtr\u0026 operator--(); //其他成员 } StrBlobPtr\u0026 StrBlobPtr::operator++() { check(curr, \"已经越界\"); ++curr; //curr向前移动一个元素 return *this; } StrBlobPtr\u0026 StrBlobPtr::operator--() { --curr; //curr向后移动一个元素 check(curr, \"已经越界\"); return *this; } 区分前置和后置运算符因为前置和后置版本使用的是同一个符号，重载版本的名字也是相同的，运算对象的数量和类型也是相同的 所以为了解决这个问题，后置版本接受一个额外的但是不使用的 int 类型的参数，编译器会为这个形参提供一个值为 0 的实参 class StrBlobPtr { public: //递增和递减运算符 StrBlobPtr\u0026 operator++(int);//后置版本 StrBlobPtr\u0026 operator--(int); //其他成员 } StrBlobPtr StrBlobPtr::operator++(int) { //这里无须检查有效性，调用前置版本的时候会检查 StrBlobPtr ret = *this;//记录当前的值 ++*this; //向前移动一个元素，前置++会检查有效性 return ret; //返回之前记录的状态 } StrBlobPtr\u0026 StrBlobPtr::operator--(int) { //这里无须检查有效性，调用前置版本的时候会检查 StrBlobPtr ret = *this;//记录当前的值 --*this; //向前移动一个元素，前置++会检查有效性 return ret; //返回之前记录的状态 } 这里主要需要理解内置类型前置版本和后置版本的区别（以int类型为例） ++i 首先会对 i 的值进行递增，然后返回 i 的值 i++ 首先会返回 i 的值，然后再进行运算 int sum = 0, i = 1; sum = ++i; //此时sum的值为2 sum = i++; //此时sum的值为1 显示调用后置运算符如果要显示调用运算符的话，像之前那样利用函数调用的形式进行调用，但是注意必须传入一个整型参数 StrBlobPtr p(a1); //p指向a1的vector p.operator++(0); //调用后置版本的operator++ p.operator++(); //调用前置版本的operator++ ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:6:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#显示调用后置运算符"},{"categories":["C++"],"content":"14.7 成员访问运算符迭代器和智能指针类中常常用到解引用运算符（*）和箭头运算符（-\u003e），例如： class StrBlobPtr { public: std::string \u0026operator*() const { auto p = check(curr, \"dereference past end\"); return (*p)[curr]; //(*p)是对象所指的vector } std::string \u0026operator-\u003e() const { return \u0026 this-\u003eoperator*();//实际工作委托给解引用运算符 } //其他成员 } 解引用运算符首先检查curr是否在作用范围内，如果是返回curr所指元素的引用，箭头运算符返回解引用结果元素的地址 对箭头运算符返回值的限定形如point-\u003emem 的表达式，point必须是指向类对象的指针或者是重载了 operator-\u003e 的类的对象 (*point).mem; //point是一个内置指针类型 point.operator()-\u003emem;//point是一个类的对象 如果 point 是指针，则会应用内置箭头运算符，等价于 (*point).mem 如果 point 是一个定义了 operator-\u003e的类的一个对象，则使用 point.operator-\u003e() 的结果来获取 mem ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:7:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#147-成员访问运算符"},{"categories":["C++"],"content":"14.7 成员访问运算符迭代器和智能指针类中常常用到解引用运算符（*）和箭头运算符（-），例如： class StrBlobPtr { public: std::string \u0026operator*() const { auto p = check(curr, \"dereference past end\"); return (*p)[curr]; //(*p)是对象所指的vector } std::string \u0026operator-() const { return \u0026 this-operator*();//实际工作委托给解引用运算符 } //其他成员 } 解引用运算符首先检查curr是否在作用范围内，如果是返回curr所指元素的引用，箭头运算符返回解引用结果元素的地址 对箭头运算符返回值的限定形如point-mem 的表达式，point必须是指向类对象的指针或者是重载了 operator- 的类的对象 (*point).mem; //point是一个内置指针类型 point.operator()-mem;//point是一个类的对象 如果 point 是指针，则会应用内置箭头运算符，等价于 (*point).mem 如果 point 是一个定义了 operator-的类的一个对象，则使用 point.operator-() 的结果来获取 mem ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:7:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#对箭头运算符返回值的限定"},{"categories":["C++"],"content":"14.8 函数调用运算符如果一个类重载了函数调用运算符（就是()），则可以像调用函数一样使用该类的对象，下面是一个例子： struct absInt { int operator()(int val) const { return val \u003c 0 ? -val : val; } } int i = -42; absInt absObj; //含有函数调用运算符的对象 int ui = absObj(i);//将i传递给absObj.operator() 函数调用运算符必须是成员函数，一个类可以定义多个不同版本的调用运算符 如果类定义了调用运算符，则该类的对象称为函数对象，这些对象的行为像函数一样 含有状态的函数对象类函数对象类除了 operator() 之外也可以包含其他成员，这些成员被用于定制调用运算符中的操作，下面是个例子： class PrintString { public: PrintString(ostream \u0026o = cout, char c = ' ') : os(o), sep(c) {} void operator()(const string \u0026s) const {os \u003c\u003c s \u003c\u003c sep;} private: ostream \u0026os;//用于写入的目的流 char step; //用于将不同输出隔开的字符 } PrintString printer; printer(s); PrintString errors(cerr, '\\n'); errors(s); 函数对象常常作为泛型算法的实参，例如可以用for_each 算法和 PrintString 类来打印容器的内容： for_each(vec.beign(), vec.end(), PrintString(cerr, '\\n')); for_each 第三个实参是类型 PrintString 的一个临时对象，我们用 cerr 和 换行符初始化了改对象，程序调用 for_each 时，会把 vec 每个元素打印到 cerr 中，元素之间以换行符分割 ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:8:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#148-函数调用运算符"},{"categories":["C++"],"content":"14.8 函数调用运算符如果一个类重载了函数调用运算符（就是()），则可以像调用函数一样使用该类的对象，下面是一个例子： struct absInt { int operator()(int val) const { return val ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:8:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#含有状态的函数对象类"},{"categories":["C++"],"content":"14.8.1 lambda 是函数对象使用 PrintString 对象作为 for_each 的实参，类似于使用 lambda 表达式，编译器会将 lambda 表达式 翻译成一个未命名类的未命名对象，举例如下： //根据单词长度进行排序，长度相同的会按照字典序排序 stable_sort(word.begin(), word.end(), [](const string \u0026a, const string \u0026b) { return a.size() \u003c b.size();}); 上面 lambda 表达式类似下面的一个未命名对象 class ShorterString { public: bool operator()(const string \u0026s1, string \u0026s2) const { return s1.size() \u003c s2.size(); } } //替换上面的lambda表达式 stable_sort(word.begin(), word.end(), ShorterString()); 表示 lambda 及相应捕获行为的类 使用一个 lambda 表达式通过引用捕获变量时，程序确保 lambda 执行时引用所引的对象确实存在，编译器可以直接引用而无须在 lambda 产生的类中将其存储为数据成员 使用值捕获的变量会拷贝到 lambda 表达式中，这种 lambda 表达式产生的类必须为每个值捕获的变量建立对应的数据成员，同时创建构造函数，用捕获的变量进行初始化 //获得第一个指向满足条件元素的迭代器，该元素满足size() \u003e= sz auto wc = find_if(word.begin(), word.end(), [sz](const string \u0026a) { return a.size() \u003e= sz;}); //上面的lambda表达式产生的类像下面这样 class SizeComp { SizeComp(size_t n) : sz(n) {} bool operator()(const string \u0026s) const { return s.size() \u003e= sz; } private: size_t sz;//该数据成员对应通过值捕获的变量 } //使用像上面的函数对象时，必须提供一个实参 auto wc = find_if(word.begin(), word.end(), SizeCopm(sz)); lambda 表达式产生的类不含默认构造函数、赋值运算符和默认析构函数；它是否含有默认的拷贝/移动构造函数通常视捕获的数据成员类型而定 ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:8:1","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#1481-lambda-是函数对象"},{"categories":["C++"],"content":"14.8.1 lambda 是函数对象使用 PrintString 对象作为 for_each 的实参，类似于使用 lambda 表达式，编译器会将 lambda 表达式 翻译成一个未命名类的未命名对象，举例如下： //根据单词长度进行排序，长度相同的会按照字典序排序 stable_sort(word.begin(), word.end(), [](const string \u0026a, const string \u0026b) { return a.size() = sz auto wc = find_if(word.begin(), word.end(), [sz](const string \u0026a) { return a.size() = sz;}); //上面的lambda表达式产生的类像下面这样 class SizeComp { SizeComp(size_t n) : sz(n) {} bool operator()(const string \u0026s) const { return s.size() = sz; } private: size_t sz;//该数据成员对应通过值捕获的变量 } //使用像上面的函数对象时，必须提供一个实参 auto wc = find_if(word.begin(), word.end(), SizeCopm(sz)); lambda 表达式产生的类不含默认构造函数、赋值运算符和默认析构函数；它是否含有默认的拷贝/移动构造函数通常视捕获的数据成员类型而定 ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:8:1","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#表示-lambda-及相应捕获行为的类"},{"categories":["C++"],"content":"14.8.2 标准库定义的函数对象标准库定义了一组表示算术运算符、关系运算符和逻辑运算符的类，每个类分别定义了一个执行与类名对应的调用运算符。 如puls 类定义了一个函数调用运算符用于执行 + 操作，modulus类定义了一个调用运算符执行二元 % 的操作 这些类都是模板形式，可以指定具体的应用类型，即对应调用运算符的形参类型 plus\u003cint\u003e intAdd; //执行int加法的函数对象 negate\u003cint\u003e intNegate; //执行int取反的函数对象 int sum = intAdd(10, 20); //sum = 30 sum = intNegate(intAdd(10, 20));//sum = -30 sum = intAdd(10, intNegate(10));//sum = 0 下面时标准库定义的函数对象： 算术 关系 逻辑 plus\u003cType\u003e equal_to\u003cType\u003e logical_and\u003c minus\u003cType not_equal_to\u003cType\u003e logical_or\u003cType\u003e multiplies\u003cType\u003e greater\u003cType\u003e logical_not\u003cType\u003e divides\u003cType\u003e greater_equal\u003cType\u003e modulus\u003cType\u003e less\u003cType\u003e negate\u003cType\u003e less_equal\u003cType\u003e 算法中使用标准库函数对象默认情况下排序算法使用 operator\u003c 将序列按照升序进行排列，如果想执行降序的话，可以用 greater类型的对象 sort(svec.begin(), sec.end(), greater\u003cstring\u003e()); 注意：标准库规定的函数对象对于指针同样适用，如果比较两个无关指针会产生未定义的行为，而我们如果想比较指针内存地址来 sort 指针的 vector。直接比较会产生未定义的行为，而标准库函数对象则可实现这个目的 vector\u003cstring*\u003e nameTable; //错误：nameTable中指针彼此之间没有关系，所以 \u003c 将产生未定义行为 sort(nameTable.begin(), nameTable.end(), [](string *a, string *b) { return a \u003c b;}); // 正确：标准库规定指针的less是定义良好的 sort(nameTable.begin(), nameTable.end(), less\u003cstring*\u003e()); ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:8:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#1482-标准库定义的函数对象"},{"categories":["C++"],"content":"14.8.2 标准库定义的函数对象标准库定义了一组表示算术运算符、关系运算符和逻辑运算符的类，每个类分别定义了一个执行与类名对应的调用运算符。 如puls 类定义了一个函数调用运算符用于执行 + 操作，modulus类定义了一个调用运算符执行二元 % 的操作 这些类都是模板形式，可以指定具体的应用类型，即对应调用运算符的形参类型 plus intAdd; //执行int加法的函数对象 negate intNegate; //执行int取反的函数对象 int sum = intAdd(10, 20); //sum = 30 sum = intNegate(intAdd(10, 20));//sum = -30 sum = intAdd(10, intNegate(10));//sum = 0 下面时标准库定义的函数对象： 算术 关系 逻辑 plus equal_to logical_andlogical_or multiplies greater logical_not divides greater_equal modulus less negate less_equal 算法中使用标准库函数对象默认情况下排序算法使用 operator()); 注意：标准库规定的函数对象对于指针同样适用，如果比较两个无关指针会产生未定义的行为，而我们如果想比较指针内存地址来 sort 指针的 vector。直接比较会产生未定义的行为，而标准库函数对象则可实现这个目的 vector nameTable; //错误：nameTable中指针彼此之间没有关系，所以 ()); ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:8:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#算法中使用标准库函数对象"},{"categories":["C++"],"content":"14.8.3 可调用对象与 functionC++中有几种可调用的对象：函数、函数指针、lambda 表达式、bind 创建的对象以及重载了函数调用运算符的类 这些不同类型的可调用对象可能共享一种调用形式，调用形式指明了返回类型以及实参类型，下面是个例子： //普通函数 int add(int i, int j) { return i + j; } //lambda 表达式 auto mod = [](int i, int j) { return i % j; } //函数对象类 struct divide { int operator()(int denominator, int divisor) { return denominator / divisor; } } 上面的几种可调用对象对参数执行了不同的算术运算，它们类型不相同，但是共享同一种调用形式 int(int, int) 我们如果用这些可调用对象构建一个简单的计算器，可以定义一个函数表用于储存这些可调用对象的指针。 可以通过 map 来实现，用运算符符号的string对象作为关键字，实现运算符函数作为值 //构建运算符到函数指针的映射关系，函数接受两个int，返回一个int map\u003cstring, int(*)(int, int)\u003e binops; //正确：add是一个指向正确类型的函数指针 binops.insert({\"+\", add}); //错误：mod不是一个函数指针 binops.insert({\"%\", mod}); 上面的问题在于 mod 是一个 lambda 表达式，与 binops 的值类型不匹配 标准库 function 类型标准库中一个新的类型 function 可以解决上述问题，下面是 function 定义的操作： function 是一个模板，创建一个具体 function 类型时需要指定 function 表示的对象的调用形式，如 function\u003cint(int, int)\u003e ，这里声明了一个 function 类型，它可以接受两个 int，返回一个 int 类型的可调用对象 function\u003cint(int, int)\u003e f1 = add; //函数指针 function\u003cint(int, int)\u003e f1 = divide();//函数对象类的对象 function\u003cint(int, int)\u003e f1 = [](int i, int j) //lambda { return i * j; }; cout \u003c\u003c f1(4, 2) \u003c\u003c endl; // 6 cout \u003c\u003c f2(4, 2) \u003c\u003c endl; // 2 cout \u003c\u003c f3(4, 2) \u003c\u003c endl; // 8 使用这个 function 类型可以重新定义 map： map\u003cstring, function\u003cint(int, int)\u003e\u003e binops = { {\"+\", add}, //函数指针 {\"-\", std::minus\u003cint\u003e()}, //标准库定义函数对象 {\"/\", divide()}, //用户定义函数对象 {\"*\", [](int i, int j) { return i * j; }},//未命名lambda表达式 {\"%\", mod} //命名的lambda } map 包含5 个元素，虽然可调用对象类型各不相同，但是仍可以存储在同一个 function\u003cint(int, int)\u003e 类型中，这时可以通过索引 map 得到function 对象的引用 binops[\"+\"](10, 5);//add(10, 5); binops[\"-\"](10, 5);//minus\u003cint\u003e(10, 5) binops[\"/\"](10, 5);//divide对象调用运算符 binops[\"*\"](10, 5);//调用lambda函数对象 binops[\"%\"](10, 5);//调用lambda函数对象 重载的函数与 function我们变不能将重载函数名字存入 function 类型的对象中： int add(int i, int j); Sales_data add(const Sales_data\u0026, const Sales_data\u0026); map\u003cstring, function\u003cint(int, int)\u003e\u003e binops; binops.insert({\"+\", add}); //错误：哪个add？ 解决上述二义性问题，可以通过一个函数指针，以及 lambda 表达式进行区分 int (*fp)(int, int) = add; binops.insert({\"+\", fp});//正确：fp指向一个正确的add版本 //正确：使用lambda来指定我们希望使用的add版本 binops.insert({\"+\", [](int a, int b) {return add(a, b);}}); ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:8:3","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#1483-可调用对象与-function"},{"categories":["C++"],"content":"14.8.3 可调用对象与 functionC++中有几种可调用的对象：函数、函数指针、lambda 表达式、bind 创建的对象以及重载了函数调用运算符的类 这些不同类型的可调用对象可能共享一种调用形式，调用形式指明了返回类型以及实参类型，下面是个例子： //普通函数 int add(int i, int j) { return i + j; } //lambda 表达式 auto mod = [](int i, int j) { return i % j; } //函数对象类 struct divide { int operator()(int denominator, int divisor) { return denominator / divisor; } } 上面的几种可调用对象对参数执行了不同的算术运算，它们类型不相同，但是共享同一种调用形式 int(int, int) 我们如果用这些可调用对象构建一个简单的计算器，可以定义一个函数表用于储存这些可调用对象的指针。 可以通过 map 来实现，用运算符符号的string对象作为关键字，实现运算符函数作为值 //构建运算符到函数指针的映射关系，函数接受两个int，返回一个int mapbinops; //正确：add是一个指向正确类型的函数指针 binops.insert({\"+\", add}); //错误：mod不是一个函数指针 binops.insert({\"%\", mod}); 上面的问题在于 mod 是一个 lambda 表达式，与 binops 的值类型不匹配 标准库 function 类型标准库中一个新的类型 function 可以解决上述问题，下面是 function 定义的操作： function 是一个模板，创建一个具体 function 类型时需要指定 function 表示的对象的调用形式，如 function，这里声明了一个 function 类型，它可以接受两个 int，返回一个 int 类型的可调用对象 functionf1 = add; //函数指针 functionf1 = divide();//函数对象类的对象 functionf1 = [](int i, int j) //lambda { return i * j; }; cout binops = { {\"+\", add}, //函数指针 {\"-\", std::minus()}, //标准库定义函数对象 {\"/\", divide()}, //用户定义函数对象 {\"*\", [](int i, int j) { return i * j; }},//未命名lambda表达式 {\"%\", mod} //命名的lambda } map 包含5 个元素，虽然可调用对象类型各不相同，但是仍可以存储在同一个 function类型中，这时可以通过索引 map 得到function 对象的引用 binops[\"+\"](10, 5);//add(10, 5); binops[\"-\"](10, 5);//minus(10, 5) binops[\"/\"](10, 5);//divide对象调用运算符 binops[\"*\"](10, 5);//调用lambda函数对象 binops[\"%\"](10, 5);//调用lambda函数对象 重载的函数与 function我们变不能将重载函数名字存入 function 类型的对象中： int add(int i, int j); Sales_data add(const Sales_data\u0026, const Sales_data\u0026); map binops; binops.insert({\"+\", add}); //错误：哪个add？ 解决上述二义性问题，可以通过一个函数指针，以及 lambda 表达式进行区分 int (*fp)(int, int) = add; binops.insert({\"+\", fp});//正确：fp指向一个正确的add版本 //正确：使用lambda来指定我们希望使用的add版本 binops.insert({\"+\", [](int a, int b) {return add(a, b);}}); ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:8:3","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#标准库-function-类型"},{"categories":["C++"],"content":"14.8.3 可调用对象与 functionC++中有几种可调用的对象：函数、函数指针、lambda 表达式、bind 创建的对象以及重载了函数调用运算符的类 这些不同类型的可调用对象可能共享一种调用形式，调用形式指明了返回类型以及实参类型，下面是个例子： //普通函数 int add(int i, int j) { return i + j; } //lambda 表达式 auto mod = [](int i, int j) { return i % j; } //函数对象类 struct divide { int operator()(int denominator, int divisor) { return denominator / divisor; } } 上面的几种可调用对象对参数执行了不同的算术运算，它们类型不相同，但是共享同一种调用形式 int(int, int) 我们如果用这些可调用对象构建一个简单的计算器，可以定义一个函数表用于储存这些可调用对象的指针。 可以通过 map 来实现，用运算符符号的string对象作为关键字，实现运算符函数作为值 //构建运算符到函数指针的映射关系，函数接受两个int，返回一个int mapbinops; //正确：add是一个指向正确类型的函数指针 binops.insert({\"+\", add}); //错误：mod不是一个函数指针 binops.insert({\"%\", mod}); 上面的问题在于 mod 是一个 lambda 表达式，与 binops 的值类型不匹配 标准库 function 类型标准库中一个新的类型 function 可以解决上述问题，下面是 function 定义的操作： function 是一个模板，创建一个具体 function 类型时需要指定 function 表示的对象的调用形式，如 function，这里声明了一个 function 类型，它可以接受两个 int，返回一个 int 类型的可调用对象 functionf1 = add; //函数指针 functionf1 = divide();//函数对象类的对象 functionf1 = [](int i, int j) //lambda { return i * j; }; cout binops = { {\"+\", add}, //函数指针 {\"-\", std::minus()}, //标准库定义函数对象 {\"/\", divide()}, //用户定义函数对象 {\"*\", [](int i, int j) { return i * j; }},//未命名lambda表达式 {\"%\", mod} //命名的lambda } map 包含5 个元素，虽然可调用对象类型各不相同，但是仍可以存储在同一个 function类型中，这时可以通过索引 map 得到function 对象的引用 binops[\"+\"](10, 5);//add(10, 5); binops[\"-\"](10, 5);//minus(10, 5) binops[\"/\"](10, 5);//divide对象调用运算符 binops[\"*\"](10, 5);//调用lambda函数对象 binops[\"%\"](10, 5);//调用lambda函数对象 重载的函数与 function我们变不能将重载函数名字存入 function 类型的对象中： int add(int i, int j); Sales_data add(const Sales_data\u0026, const Sales_data\u0026); map binops; binops.insert({\"+\", add}); //错误：哪个add？ 解决上述二义性问题，可以通过一个函数指针，以及 lambda 表达式进行区分 int (*fp)(int, int) = add; binops.insert({\"+\", fp});//正确：fp指向一个正确的add版本 //正确：使用lambda来指定我们希望使用的add版本 binops.insert({\"+\", [](int a, int b) {return add(a, b);}}); ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:8:3","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#重载的函数与-function"},{"categories":["C++"],"content":"14.9 重载、类型转换和运算符","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:9:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#149-重载类型转换和运算符"},{"categories":[],"content":"博客搭建初衷半路转行选手，努力学习中，此博客当作个人学习的一个记录，目前仍在建设中…… ","date":"2022-04-19","objectID":"/about/:0:1","series":null,"tags":[],"title":"关于我","uri":"/about/#博客搭建初衷"},{"categories":[],"content":"这是一条树洞测试 ","date":"2022-04-19","objectID":"/life/%E6%9D%82%E8%AE%B0/:0:0","series":null,"tags":[],"title":"树洞测试","uri":"/life/%E6%9D%82%E8%AE%B0/#"}]
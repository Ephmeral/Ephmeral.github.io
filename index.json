[{"categories":["OS"],"content":"sleep比较容易，主要是看系统调用的掌握，注意main函数传入的参数如何处理 #include \"kernel/types.h\"#include \"kernel/stat.h\"#include \"user/user.h\" int main(int argc, char *argv[]) { if (argc != 2) { printf(\"Usage: sleep time\\n\"); exit(1); } sleep(atoi(argv[1])); //直接调用sleep exit(0); } ","date":"2022-07-17","objectID":"/mit6s.081-lab1xv6-and-unix-utilities/:1:0","series":null,"tags":["xv6"],"title":"MIT6S.081-lab1:Xv6 and Unix utilities","uri":"/mit6s.081-lab1xv6-and-unix-utilities/#sleep"},{"categories":["OS"],"content":"pingpong这个考察管道和fork的应用，首先对于管道 pipe，它读入一个长度为2的数组，分别作为管道的读入端和写入端，p[0] 表示写入端，p[1]表示读入端，可以用一个宏来定义，避免01区分不清的情况 然后就是创建一个子进程，父进程向管道写入一个字节后，子进程打印输出\u003cpid\u003e: received ping，然后子进程向父进程写入一个字节，父进程打印输出\u003cpid\u003e: received pong，这里我用了 wait，表示父进程等待子进程结束之后再打印输出 //user/pingpong.c #include \"kernel/types.h\"#include \"kernel/stat.h\"#include \"user/user.h\" #define WRITE 0 #define READ 1 int main(int argc, char *argv[]) { if (argc \u003e= 2) { printf(\"Usage: pingpong\\n\"); exit(1); } char buf[2]; //一个缓冲区原来读写 int p[2]; //文件描述符 pipe(p); //创建一个管道 int pid = fork(); //创建一个子进程 if (pid == 0) { read(p[READ], buf, 1);//从管道读取一个字节 close(p[READ]); //关闭管道读端 printf(\"%d: received ping\\n\", getpid()); write(p[WRITE], buf, 1);//向管道写入一个字节 close(p[WRITE]); //关闭管道写端 } else { write(p[WRITE], buf, 1);//向管道写入一个字节 close(p[WRITE]); //关闭管道写端 wait(0); //这里是关键，要到达子进程结束后父进程才继续执行下去 read(p[READ], buf, 1); //从管道读取一个字节 printf(\"%d: received pong\\n\", getpid()); close(p[READ]); //关闭管道写端 } exit(0); } ","date":"2022-07-17","objectID":"/mit6s.081-lab1xv6-and-unix-utilities/:2:0","series":null,"tags":["xv6"],"title":"MIT6S.081-lab1:Xv6 and Unix utilities","uri":"/mit6s.081-lab1xv6-and-unix-utilities/#pingpong"},{"categories":["OS"],"content":"Primes相比前两个稍微复杂一点，重点是理解给的这张图： 这张图就是先创建一个主进程，然后将数字通过管道依次写入子进程中，由子进程读取来进行处理 子进程再创建一个新的进程，子进程处理时先读到的第一个数字first，然后将后续读到的数字是first倍数的都舍去，将不是first倍数的数字都写入管道中，由子子进程进行递归处理 值得注意的是递归终止的情况，详细见代码，理解了上面的过程就比较好解决了 //user/primes.c #include \"kernel/types.h\"#include \"kernel/stat.h\"#include \"user/user.h\" #define WRITE 1 #define READ 0 void primes(int p[]) { close(p[WRITE]); //关闭原管道的写端 int np[2]; pipe(np); //创建一个新的管道 //两个数分别表示从管道读取的第一个数字，以及接下来的数字 int first = 1, next = 0; //如果此时已经读取不到数字了，关闭管道并且退出 if (read(p[READ], \u0026first, 4) == 0) { close(p[READ]); exit(0); } //如果能读取到数字，打印输出 printf(\"prime %d\\n\", first); int pid = fork(); //创建一个子进程 if (pid == 0) { close(np[WRITE]); //关闭新管道的写端 primes(np); //进入下一层递归调用 close(np[READ]); //关闭新管道的读端 } else { close(np[READ]); //关闭新管道的读端 //从原管道中读取数字，read返回为0，表示已经读取完了 while (read(p[READ], \u0026next, 4) != 0) { //如果读取的数字不能整除读取第一个数字，写入下一层管道 if (next % first != 0) { write(np[WRITE], \u0026next, 4); } } close(p[READ]); //关闭原管道的读端 close(np[WRITE]);//关闭新管道的写端 wait((int*)0); //等待子进程结束 } exit(0); } int main(int argc, char *argv[]) { //参数不符合情况时候返回报错 if (argc \u003e= 2) { printf(\"Usage: primes\\n\"); exit(1); } int p[2]; pipe(p); //创建一个管道 int pid = fork(); //创建一个子进程 if (pid == 0) { close(p[WRITE]);//关闭管道的写端 primes(p); //进行递归调用 } else { close(p[READ]);//关闭管道的读端 //依次将2-35写入到管道中，由子进程进行进一步处理 for (int i = 2; i \u003c= 35; ++i) { write(p[WRITE], \u0026i, 4); } close(p[WRITE]);//关闭管道的写端 wait((int*)0); //等待子进程结束 } exit(0); } ","date":"2022-07-17","objectID":"/mit6s.081-lab1xv6-and-unix-utilities/:3:0","series":null,"tags":["xv6"],"title":"MIT6S.081-lab1:Xv6 and Unix utilities","uri":"/mit6s.081-lab1xv6-and-unix-utilities/#primes"},{"categories":["OS"],"content":"find基本上就是在 user/ls.c 基础上改过来的，要理解其中 char* fmtname(char *path) 函数的作用，它传入一个文件名（包括前面的目录），然后取最后一个 / 之后的文件名，例如a/b/c 最后取出来的是 c //user/find.c #include \"kernel/types.h\"#include \"kernel/stat.h\"#include \"user/user.h\"#include \"kernel/fs.h\" char* fmtname(char *path) { char *p; // Find first character after last slash. for(p=path+strlen(path); p \u003e= path \u0026\u0026 *p != '/'; p--) ; p++; return p; //直接返回/下一个字符，ls中在结尾添加了空格，这里不需要 } void find(char *path, char *filename) { char buf[512], *p; int fd; struct dirent de; struct stat st; //打开文件，如果失败直接报错 if((fd = open(path, 0)) \u003c 0){ fprintf(2, \"find: cannot open %s\\n\", path); return; } //查看文件的信息，失败则报错 if(fstat(fd, \u0026st) \u003c 0){ fprintf(2, \"find: cannot stat %s\\n\", path); close(fd); return; } //st.type为此时文件的类型 switch(st.type){ //当fd指向的是文件类型，进行比较 case T_FILE: //如果比较发现是要查找的文件名，打印输出 if (strcmp(fmtname(path), filename) == 0) { printf(\"%s\\n\", path); } break; //如果fd指向的是目录类型，需要进一步处理 case T_DIR: if(strlen(path) + 1 + DIRSIZ + 1 \u003e sizeof buf){ printf(\"find: path too long\\n\"); break; } strcpy(buf, path); //将此时路径拷贝到buf上 p = buf+strlen(buf);//p指向buf结尾的位置 *p++ = '/'; //在buf结尾加上/，并且p指向下一个位置，先*p = '/'，再p++ //读取目录中的每一个文件 while(read(fd, \u0026de, sizeof(de)) == sizeof(de)){ //de.inum是所有文件的根目录的情况，.是当前目录本身，..是当前目录的父目录，都需要特判 if(de.inum == 0 || strcmp(de.name, \".\") == 0 || strcmp(de.name, \"..\") == 0) continue; //将此时文件名拷贝到p指向的位置，也就是buf后面接上文件名 memmove(p, de.name, DIRSIZ); p[DIRSIZ] = 0; //字符串加上末端的0 //打开此时的绝对路径，如果失败则跳过 if(stat(buf, \u0026st) \u003c 0){ printf(\"find: cannot stat %s\\n\", buf); continue; } //将此时绝对路径buf，进入下一层递归查找 find(buf, filename); // printf(\"%s\\n\", fmtname(buf)); } break; } close(fd); } int main(int argc, char *argv[]) { if(argc == 2) { find(\".\", argv[1]); } else if (argc == 3) { find(argv[1], argv[2]); } else { fprintf(2, \"Usage: find path file\\n\"); exit(1); } exit(0); } ","date":"2022-07-17","objectID":"/mit6s.081-lab1xv6-and-unix-utilities/:4:0","series":null,"tags":["xv6"],"title":"MIT6S.081-lab1:Xv6 and Unix utilities","uri":"/mit6s.081-lab1xv6-and-unix-utilities/#find"},{"categories":["OS"],"content":"xargs这个命令在 Linux 详细用法参考xargs 命令教程 - 阮一峰的网络日志 这里不需要设置额外的参数，只需要将标准输入中的内容读取到参数列表的后面，然后创建一个子进程执行即可 //user/xargs.c #include \"kernel/types.h\"#include \"kernel/stat.h\"#include \"user/user.h\"#include \"kernel/param.h\" int main(int argc, char *argv[]) { if (argc \u003c 2) { fprintf(2, \"Usage: xargs cmd...\\n\"); exit(1); } char buf[1024]; char *argvs[MAXARG]; // memcpy(\u0026argvs[0], \u0026argv[1], sizeof(argv[0]) * (argc - 1)); for (int i = 1; i \u003c argc; ++i) { argvs[i - 1] = argv[i]; } while (1) { int size = 0; //表示从标准输入中读取的字节数目 //从标准输入中一个字节一个字节读取 while (read(0, \u0026buf[size], 1) != 0) { //遇见/n 跳出 if (buf[size] == '\\n') break; ++size; } //如果一个字节都没读取到，说明标准输入内容已经读取完了 if (size == 0) break; buf[size] = 0; //buf结尾置为0 //将从标准输入读取的一行内容放入到argvs末尾中 argvs[argc - 1] = buf; //创建一个子进程，利用exec执行 if (fork() == 0) { exec(argv[1], argvs); exit(0); } wait(0); //等待父进程结束 memset(buf, 0, 1024); //将buf清空 } exit(0); } 这应该是第三次做lab1了，前两次都止步于lab3，这次打算完成学（抄）一遍 完结证明： 参考资料： MIT 6.S081 2020 LAB1记录 - 知乎 ","date":"2022-07-17","objectID":"/mit6s.081-lab1xv6-and-unix-utilities/:5:0","series":null,"tags":["xv6"],"title":"MIT6S.081-lab1:Xv6 and Unix utilities","uri":"/mit6s.081-lab1xv6-and-unix-utilities/#xargs"},{"categories":["Lab"],"content":"前言PA3 存储管理，3-1对cache进行了简单的模拟，3-2开启了类似80386的保护机制，3-3实现了分页机制（虚拟地址转换） PA4-1是异常控制流，4-2是外设和IO的模拟 ","date":"2022-07-17","objectID":"/nju-ics2020-pa3-1-%E5%B0%8F%E7%BB%93/:1:0","series":null,"tags":["ICS","PA"],"title":"NJU-ICS2020 | PA3-1 小结","uri":"/nju-ics2020-pa3-1-%E5%B0%8F%E7%BB%93/#前言"},{"categories":["Lab"],"content":"PA 3-1 Cache的模拟cache原理部分可以看下Cache 的基本工作原理 具体实验要求如下： cache block存储空间的大小为64B cache存储空间的大小为64KB 8-way set associative 标志位只需要valid bit即可 替换算法采用随机方式 write through not write allocate 采用的是8路组相联，随机替换算法和回写法，回写分配法 由于 cache 大小 64KB，每个 cache block 大小是 64B，所以总共有 1024 个 cache 行，也就是可以定义一个1024大小的 CacheLine 数组 关于 CacheLine 的定义如下： typedef struct cacheLine { bool valid; // 1位 标志位 uint32_t tag; //tag 19位 32 - 6 - 7 uint8_t data[64]; //data 6位 64 = 2^6 }CacheLine; 关于主存块地址的分析： 数据大小是64B，而 64 = 2^6，所以对应主存块中的块内地址有6位 而cache总共2^10 = 1024 行，每组分成了 2^3 = 8行，总共也就有2^(10 - 3) = 128 组，则对应主存块中 cache 组号有 7 位 所以对于32位地址的主存来说，最后标志位有19位 详细有注释的实现代码如下：（注意cache读写跨行的情况） #include \"memory/memory.h\" #include \u003cstdlib.h\u003e#include \u003ctime.h\u003e CacheLine caches[1024]; // init the cache void init_cache() { // implement me in PA 3-1 // 1024 cache line for (int i = 0; i \u003c 1024; ++i) { caches[i].valid = false; caches[i].tag = 0; memset(caches[i].data, 0, 64); } } // write data to cache void cache_write(paddr_t paddr, size_t len, uint32_t data) { uint32_t addr = paddr \u0026 0x3f; // trancut lower 6 bit uint32_t line_id = (paddr \u003e\u003e 6) \u0026 0x7f; // cacheline group id uint32_t tag = paddr \u003e\u003e 13; //tag int k = line_id * 8; //record the hit caches for (int i = k; i \u003c k + 8; i++) { //如果命中 if (caches[i].valid == true \u0026\u0026 caches[i].tag == tag) { if (addr + len \u003c= 64) { //update block 将数据data写入主存中 memcpy(hw_mem + paddr, \u0026data, len); //update cache line 并且更新cache行中的数据 memcpy(caches[i].data + addr, \u0026data, len); caches[i].tag = tag; caches[i].valid = true; } else { int cur_len = 64 - addr; //当前行剩余长度 int next_len = len - cur_len;//下一行读取的长度 memcpy(hw_mem + paddr, \u0026data, len); cache_write(paddr, cur_len, data); cache_write(paddr + cur_len, next_len, data\u003e\u003e(cur_len * 8)); } return; } } //没有命中,只写入主存中，不在cache行中添加 memcpy(hw_mem + paddr, \u0026data, len); } // read data from cache uint32_t cache_read(paddr_t paddr, size_t len) { uint32_t addr = paddr \u0026 0x3f; // 块内地址，低 6 位 uint32_t line_id = (paddr \u003e\u003e 6) \u0026 0x7f; // cache组内号 uint32_t tag = paddr \u003e\u003e 13; //tag标志位 int cnt = 0, k = line_id * 8; //k是对于组的起始位置，由于8个一组，第line_id组个cache行对应的即为实际的第8*line_id个 uint32_t ret = 0; //返回地址 //枚举组内8个cache行 for (int i = k; i \u003c k + 8; i++) { //如果cache有效 if (caches[i].valid == true) { //cnt用来记录一组中cache行有效的个数 //cnt==8说明这组cache满了，需要采取替换策略 cnt++; //并且标志位也对应，也即是命中的情况 if (caches[i].tag == tag) { //没有跨行情况 if (addr + len \u003c= 64) { //从最后一个字往前读取 for (int t = len - 1; t \u003e= 0; t--) { if (t != len - 1) ret \u003c\u003c= 8; ret += caches[i].data[addr + t]; } break; } else { //跨行的情况 int cur_len = 64 - addr; //当前行剩余长度 int next_len = len - cur_len;//下一行读取的长度 //将这一行所有的地址都读取完 ret = cache_read(paddr, cur_len); //从下一行开始地址开始读取 next_len 个字节 uint32_t next_data = cache_read(paddr + cur_len, next_len); //移动8 * cur_len位，再加上上一行的数据 next_data \u003c\u003c= 8 * cur_len; ret += next_data; //printf(\"now 跨行, and ret = %u\\n\", ret); } return ret; } } } //cache group is full and not hit, random replace //cnt == 8 说明待读取的cache组已经满了，需要随机算法换出 if (cnt == 8) { //ret = hw_mem_read(paddr, len); //从主存块中读取内容，并设置到ret中 memcpy(\u0026ret, hw_mem + paddr, len); //printf(\"cache满了情况下 ret = %u\\n\", ret); srand((unsigned)time(NULL)); //设置随机数种子 int insert = k + (rand() % 8); //找到随机替换的位置 //将主存块中内容写入cache行中，注意是一整行64 memcpy(caches[insert].data, hw_mem + paddr - addr, 64); caches[insert].valid = true; caches[insert].tag = ret \u003e\u003e 13; } else { //cache缺失, 并且没有满 //从主存块中读取内容，并设置到ret中 memcpy(\u0026ret, hw_mem + paddr, len); //printf(\"cache缺失情况下 ret = %u\\n\", ret); //将主存块中内容写入cache行中，注意是一整行64 for (int i = k; i \u003c k + 8; i++) { if (caches[i].valid == false) { memcpy(caches[i].data, hw_mem + paddr - addr, 64); caches[i].valid = true; caches[i].tag = ret \u003e\u003e 13; } } } return ret; } ","date":"2022-07-17","objectID":"/nju-ics2020-pa3-1-%E5%B0%8F%E7%BB%93/:2:0","series":null,"tags":["ICS","PA"],"title":"NJU-ICS2020 | PA3-1 小结","uri":"/nju-ics2020-pa3-1-%E5%B0%8F%E7%BB%93/#pa-3-1-cache的模拟"},{"categories":["Lab"],"content":"小结PA3-1算是完整的完成了，对于后面的实验内容，发现PA3-2虽然能跑起来，但是好像实现的有问题（自己写的太简单了）。PA3-3之后的内容也没很认真的完成，到了3-3开启虚拟地址空间后，由于前面存在的一些指令的bug，导致PA3-3在运行的时候一直出现段错误，一时也没找到解决的办法，PA4就在别人代码基础上跑了一下 至此PA先告一段落了，后面有机会打算学习一下jyy版本的PA，顺便补一下计算机系统基础理论知识 ","date":"2022-07-17","objectID":"/nju-ics2020-pa3-1-%E5%B0%8F%E7%BB%93/:3:0","series":null,"tags":["ICS","PA"],"title":"NJU-ICS2020 | PA3-1 小结","uri":"/nju-ics2020-pa3-1-%E5%B0%8F%E7%BB%93/#小结"},{"categories":["计算机基础"],"content":"局部性原理时间局部性：指被访问的某个存储单元在一个较短的时间内很可能还会继续被访问 空间局部性：被访问的某个存储单元临近的单元在一个较短时间内很可能被访问 ","date":"2022-07-05","objectID":"/cache-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/:1:0","series":null,"tags":["cache"],"title":"Cache 的基本工作原理","uri":"/cache-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/#局部性原理"},{"categories":["计算机基础"],"content":"cache 基本工作原理cache 是一个小容量的高速缓冲存储器，在 CPU 和主存内部设置 cache 根据局部性原理，CPU访问指令和数据时可以直接从 cache 中读取，而不必到主存内部进行读取，cache 能减少不必要的访问主存，加快读取速度 cache 和主存空间被划分为相等的区域，便于 cache 和主存间交换信息 主存中按照一定的字节划分为一个区域（假定这里是 512 字节），这个区域称为主存块（简称块），而 cache 中存放这样的一个主存块的区域称为 cache 行（简称行） 有了 cache 之后 CPU 的访问过程： 先检查 cache 中有没有要访问的信息 如果有，直接在 cache 中读写 没有，从主存中读写，并且把当前访问的信息复制到 cache 中 在访问的过程中，如果 CPU 需要访问单元所在的主存 cache 中，则称之为 cache 命中，否则称为不命中 那么 CPU 在访问的过程中如何知道 cache 是否命中呢？ ","date":"2022-07-05","objectID":"/cache-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/:2:0","series":null,"tags":["cache"],"title":"Cache 的基本工作原理","uri":"/cache-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/#cache-基本工作原理"},{"categories":["计算机基础"],"content":"cache 行和主存块的映射想要知道 cache 是否命中，cache 和主存块之间需要有个对应的映射关系 主存块和 cache 行之间主要要三种映射关系： 直接映射：每个主存块映射到 cache 固定的行中 全相联：每个主存块映射到 cache 的任意行 组相联：每个主存块映射到 cache 的固定组的任意行中 ","date":"2022-07-05","objectID":"/cache-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/:3:0","series":null,"tags":["cache"],"title":"Cache 的基本工作原理","uri":"/cache-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/#cache-行和主存块的映射"},{"categories":["计算机基础"],"content":"直接映射基本思路是：把主存的每一块映射到固定的 cache 中，也称之为模映射，对应关系如下： cache 行号 = 主存块号 mod cache行数 假设 cache 有2^c 行，主存块有 2^m 块，主存块大小位 2^b 字节，则 cache 行占 c 位，主存块号占 m 位，块内地址有 b 位，m位的主存块号被分为标记字段和 cache 行号字段 下面是主存块和 cache 行之间的映射关系图： ","date":"2022-07-05","objectID":"/cache-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/:3:1","series":null,"tags":["cache"],"title":"Cache 的基本工作原理","uri":"/cache-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/#直接映射"},{"categories":["计算机基础"],"content":"全相联映射全相联映射是将主存块装入到 cache 的任意行中，查找过程中，需要比较所有 cache 行的标记，主存地址只有标记和块内地址两个字段 ","date":"2022-07-05","objectID":"/cache-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/:3:2","series":null,"tags":["cache"],"title":"Cache 的基本工作原理","uri":"/cache-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/#全相联映射"},{"categories":["计算机基础"],"content":"组相联映射组相联映射将 cache 分成大小相等的组，每个主存块被映射到 cache 固定组的任意一，映射关系如下： cache 组号 = 主存块号 mod cache 组数 假设 cache 有 2^c 行，分成 2^q 组，每组有 2^(c-q) 行，设 s = c - q，则cache 映射方式称为 2^s 路组相联映射 如果主存块有2^m 块，大小为 2^b 字节，按照字节编制则，块内地址有 b 位，cache 组号有 q 位，标记和 cache 组号共 m 位，标记 t = m - q位 例子：主存块和 cache 之间按照 2 路组相联映射，块大小512字，cache 数据区容量位 8K 字，主存地址空间为 1M字。问：主存地址如何划分？并说明CPU 对主存单元 01202H 的访问过程 解：cache 数据容量为 8K = 2^13 字 = 2^3组 * 2^1 行/组 * 512字/行 主存地址空间为 1M 字 = 2^20 字 = 2^11块 * 512字/块 = 2^8组群 * 2^3块/组群 * 512 字/块 主存地址位数 n为 20，组号位数 q = 3，标记位t = 8 位，块内地址 b = 9 位 主存地址01202H 二进制为 0000 0001 0010 0000 0010，主存地址划分为： 访问过程： 根据中间3位 001，找到 cache 第一组 将标记位 0000 0001 与第一组 cache 中的两行进行比较 如果相等并且有效位为 1，则命中，此时将低9位块内地址对应行中取出单元内容送到 CPU 中 如果都不相等，或有一个相等但有效位为0，则不命中，此时将01202H单元所在的主存第 0000 0001 001块复制到 cache 第001组中任意一个空闲行中，有效位设置为1，标记设为 0000 0001 ","date":"2022-07-05","objectID":"/cache-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/:3:3","series":null,"tags":["cache"],"title":"Cache 的基本工作原理","uri":"/cache-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/#组相联映射"},{"categories":["计算机基础"],"content":"cache 中主存块的替换算法cache 行数比主存块数小，多个主存块可能会映射到同一个 cache 行中，一旦cache 中对应的行满了，需要考虑淘汰掉一个cache 行中的主存块 如果说新的主存块可以放在多个cache 行中，具体需要调出哪一个块，就是淘汰策略问题，主要包括：先进先出（FIFO）、最近最少使用（LRU）、最不经常使用（LFU）和随机替换等 ","date":"2022-07-05","objectID":"/cache-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/:4:0","series":null,"tags":["cache"],"title":"Cache 的基本工作原理","uri":"/cache-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/#cache-中主存块的替换算法"},{"categories":["计算机基础"],"content":"先进先出算法基本思想是：选择最早装入 cache 的主存块替换掉 ","date":"2022-07-05","objectID":"/cache-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/:4:1","series":null,"tags":["cache"],"title":"Cache 的基本工作原理","uri":"/cache-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/#先进先出算法"},{"categories":["计算机基础"],"content":"最近最少使用算法基本思路是：选择近期最少使用的主存块被替换掉，这种算法能够正确反映访问的局部性，但是实现起来稍微复杂 ","date":"2022-07-05","objectID":"/cache-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/:4:2","series":null,"tags":["cache"],"title":"Cache 的基本工作原理","uri":"/cache-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/#最近最少使用算法"},{"categories":["计算机基础"],"content":"最不经常使用算法基本思路：替换掉 cache 中引用次数最少的块 ","date":"2022-07-05","objectID":"/cache-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/:4:3","series":null,"tags":["cache"],"title":"Cache 的基本工作原理","uri":"/cache-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/#最不经常使用算法"},{"categories":["计算机基础"],"content":"随机替换算法从候选的主存块中随机选取一个淘汰 ","date":"2022-07-05","objectID":"/cache-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/:4:4","series":null,"tags":["cache"],"title":"Cache 的基本工作原理","uri":"/cache-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/#随机替换算法"},{"categories":["计算机基础"],"content":"cache 一致性问题当 CPU 进行写操作时，需要对 cache 中的内容进行更新，此时 cache 和主存需要保持一致 通常两种写操作方式：1）全写法；2）回写法 ","date":"2022-07-05","objectID":"/cache-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/:5:0","series":null,"tags":["cache"],"title":"Cache 的基本工作原理","uri":"/cache-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/#cache-一致性问题"},{"categories":["计算机基础"],"content":"全写法全写法（write through）：基本做法是，当 CPU 执行写操作时，如写命中，则同时写 cache 和主存，如果没有命中，采用下面两种处理方式 写分配法：先在主存块中更新相应的存储单元，然后分配一个 cache 行，将更新后的主存块转入到分配的 cache 行中 非写分配法：仅更新主存单元而不转入 cache 行中 ","date":"2022-07-05","objectID":"/cache-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/:5:1","series":null,"tags":["cache"],"title":"Cache 的基本工作原理","uri":"/cache-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/#全写法"},{"categories":["计算机基础"],"content":"回写法回写法（write back）：当 CPU 执行写操作时，若命中 cache，则信息只写入 cache 而不写入主存；如果没有命中，则cache 中分配一行，将主存块调入改 cache 中并更新 cache 中相应单元的内容 当 CPU 执行写操作时，回写法不会更新主存单元，只有当 cache 行踪主存块被替换时，才将主存快内容一次性写回主存 这种做法能够减少写主存的次数，减少写回主存的开销，但是没有同步更新主存块和 cache，可能会由于两者不一致带来潜在隐患 ","date":"2022-07-05","objectID":"/cache-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/:5:2","series":null,"tags":["cache"],"title":"Cache 的基本工作原理","uri":"/cache-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/#回写法"},{"categories":["Lab"],"content":"前言PA2-1 需要实现每个指令的解码和执行，具体需要在项目根目录下先执行 make test_pa-2-1，查看当前缺少哪条指令，然后去实现对应指令即可，直到所有测试用例通过（除了最后一个test_float） ","date":"2022-06-28","objectID":"/nju-ics2021-pa2-1%E5%B0%8F%E7%BB%93/:1:0","series":null,"tags":["ICS","PA"],"title":"NJU-ICS2021 | PA2-1实验小结","uri":"/nju-ics2021-pa2-1%E5%B0%8F%E7%BB%93/#前言"},{"categories":["Lab"],"content":"指令的查阅过程下面是开始做实验时候，记录的查阅手册过程（仅供参考） 除了已经通过的 mov 测试用例，下一个 mov-cmp 的测试用例，make_test-pa-2-1 出现报错，然后定位到 0x83 f8 01 cmp $0x1, %eax 这条指令 下面查阅手册： 这条指令前面不是 0x66 说明 0x83 即为 opcode 查阅 i-386 手册附录 A，找到 0x83 对应的的指令为 Grp1 Ev, Iv 对应到 Nemu 中即为 Grp1 Iv, Ev 这里因为是一组Grp1 Iv, Ev，所以需要继续查表，先看一下下一位 0xf8 的寄存器对应的为111 反过来查找Grp1对应的 111位置，发现为 cmp ，也符合反汇编的结果 opcode 后面跟着的是 ModR/M 字节，则这里 0xf8 即为 ModR/M 字节，查阅i386手册第17.2.1节。其解析方式对应Table 17-3 ，0xf8这个ModR/M字节的对应的是 EAX/AX/AL 这里应该对应 %eax 寄存器（反汇编结果显示的也比较清楚） 最后 0x01 是个立即数，最后对应 AT\u0026T 格式为 cmp %eax, $0x1 接着查阅 cmp 指令对应的功能，可以看见对于 83这条指令主要是将一个==8 位==立即数存入寄存器或者地址中 这里强调一下 8 位立即数，因为在这里我弄错了，创建立即数时用的时全局的 data_size，导致卡了两三个小时一直没发现错误 此外我在返回长度的时候，返回的是 len + data_size / 8，也一直没发现问题，最开始给我报错的地方是将一个指令切分了，比如说这里报错的 eip = 0x30053 而这里根本不是对应一个指令地址的开始，而是 0x30050 中间的部分，如下图所示：（我还去查了以 0x00 为开始的指令，改了改 add 这条命令，结果发现根本就是 cmp 写错了，导致取地址的时候取的不是某条指令开头的位置！！！） 发现问题后，很快就解决了，cmp 的实现，这里可以使用PA-1 中实现的 alu_sub 函数，手册上说了 cmp 将源操作数减去目的操作数，但是并不保留结果，只改变标志位（CF、OF这些） 最后返回长度的时候，注意要将 len + 1 (因为还有一个8位的立即数) ","date":"2022-06-28","objectID":"/nju-ics2021-pa2-1%E5%B0%8F%E7%BB%93/:2:0","series":null,"tags":["ICS","PA"],"title":"NJU-ICS2021 | PA2-1实验小结","uri":"/nju-ics2021-pa2-1%E5%B0%8F%E7%BB%93/#指令的查阅过程"},{"categories":["Lab"],"content":"个人踩坑点下面是遇见的一些坑： 报错的地方在某条指令中间，很有可能是前面的指令返回地址没有写正确 有一些需要进行符号拓展，例如 cmp、sub这些 test 指令最后的结果需要丢弃，而不是写入 DEST 中，这里详细看一下手册，如果没看下面文字部分的话，就会以为需要写入 DEST 中 指令在实现的时候，尽可能的使用框架代码提供的宏，出错的概率会小很多，其次可以利用 PA1 中已经实现的整数运算 实现一条指令的同时，可以把类似的指令同时实现了，大部分指令都挺有规律的，另外感觉有一个小彩蛋，如果打开opcode_ref.c 这个文件，其实会发现大部分指令的格式已经写好了 ","date":"2022-06-28","objectID":"/nju-ics2021-pa2-1%E5%B0%8F%E7%BB%93/:3:0","series":null,"tags":["ICS","PA"],"title":"NJU-ICS2021 | PA2-1实验小结","uri":"/nju-ics2021-pa2-1%E5%B0%8F%E7%BB%93/#个人踩坑点"},{"categories":["Lab"],"content":"部分指令的实现个人感觉最难实现的是 call、ret、push 和 pop 这几个指令 首先看一下 push 指令的实现，push 指令是将一个寄存器/地址/立即数放入到栈中，看一下手册上的描述 push 指令，先需要将栈帧腾出来相应的位置（即ESP -= 2 或 4），然后将待写入的数据 SOURCE 写到栈帧对应的地址上，最开始我只是简单的先将 cpu.esp -= 2 或 4，然后将 source 赋值给 cpu.esp，后来发现不对，是需要写入到 cpu.esp 对应的地址中，这样的话需要额外创建一个 OPERAND 来进行操作，下面是主要的代码： 6 static void instr_execute_1op() { 7 operand_read(\u0026opr_src); 8 9 if (data_size == 16) { 10 cpu.esp -= 2; 11 } else if (data_size == 32) { 12 cpu.esp -= 4; 13 } 14 15 OPERAND esp; 16 esp.type = OPR_MEM; 17 esp.data_size = data_size; 18 esp.addr = cpu.esp; 19 esp.sreg = SREG_SS; 20 esp.val = sign_ext(opr_src.val, opr_src.data_size); 21 22 operand_write(\u0026esp); 23 } 其实如果弄清楚手册上 (SS:SP) 这种带括号的是写入到地址当中就不容易出错了，就类似是一个指针 int *p = \u0026a;，这里 p 类似于栈帧（ESP），然后我需要将数据写入到 p 所指的那个地址当中，也就是变量 a 的地址 目前我只实现了 E8 这条指令，也就是 call near，看一下这条指令的描述 可以看到首先需要将当前指令执行的位置（也就是 EIP）的下一个指令放入到栈中，然后 EIP 再加上一个立即数地址，Push EIP 前面已经提过思路，具体代码如下，其实很类似： //push(IP) 7 OPERAND esp; 8 esp.data_size = data_size; 9 esp.type = OPR_MEM; 10 11 cpu.esp -= data_size / 8; 12 13 esp.addr = cpu.esp; 14 esp.val = eip + 1 + data_size / 8; //注意这里是当前指令的下一个指令地址，所以需要额外加上 data_size/8 15 //printf(\"in call_near eip is %x\\n\", eip); 16 operand_write(\u0026esp); 然后是加上一个立即数，这里在 jmp_near 指令实现上已经给出类似的思路了 18 //EIP = EIP + rel16/32 19 OPERAND rel; 20 rel.type = OPR_IMM; 21 rel.sreg = SREG_CS; 22 rel.data_size = data_size; 23 rel.addr = eip + 1; 24 25 operand_read(\u0026rel); 26 27 int offset = sign_ext(rel.val, data_size);//符号拓展 28 cpu.eip += offset; //偏移量，加上立即数的值 29 return 1 + data_size / 8; ret 指令注意取出栈帧的值后赋给 eip，最后返回值不需要返回额外的长度，返回 0 即可 ","date":"2022-06-28","objectID":"/nju-ics2021-pa2-1%E5%B0%8F%E7%BB%93/:4:0","series":null,"tags":["ICS","PA"],"title":"NJU-ICS2021 | PA2-1实验小结","uri":"/nju-ics2021-pa2-1%E5%B0%8F%E7%BB%93/#部分指令的实现"},{"categories":["Lab"],"content":"小结PA2-1 总共花了约 35h，最开始折磨在每条指令实现上，后面慢慢发现框架代码提供的宏，比起自己写要准确的多，然后是一些指令的理解没有到位，尤其是后面说的 call、ret、push 和 pop 这几个，导致直接出现死循环的情况，也不知道是哪个地方实现错了，还有就是有的指令实现没有进行符号拓展，最后虽然通过了测试用例，但是感觉还是有很多细节部分没有做的很好，还需要继续加油~ ","date":"2022-06-28","objectID":"/nju-ics2021-pa2-1%E5%B0%8F%E7%BB%93/:5:0","series":null,"tags":["ICS","PA"],"title":"NJU-ICS2021 | PA2-1实验小结","uri":"/nju-ics2021-pa2-1%E5%B0%8F%E7%BB%93/#小结"},{"categories":["Lab"],"content":"前言这里简单记录一下自己做PA实验的体会，既是及时做个整理总结，也希望能够帮助到后续做PA实验的同学。 首先声明本人非南大学生，也并非科班学生，之前学过一点CSAPP，了解过部分汇编、计组相关内容，如果没学过相关课程的话，可以看一下中国大学 MOOC 上，南大的计算机系统基础课程，总共有 5 门课，前三门是基础知识，后面两门结合实践，我这里主要学了第 5 门课程，也就是计算机系统基础（五）：x86模拟器编程实践。 PA实验也是围绕这个课程开展的，不过这门课在中国大学 MOOC 上可能未开放（有时候因为学期结束了，不能上），所以另外推荐授课老师的B站：我是汪犬人的个人空间_哔哩哔哩_Bilibili，可以从老师主页看到相关录屏课程，然后就是PA实验代码和框架代码： Guide的仓库及其镜像地址： GitHub: http://github.com/ics-nju-wl/icspa-public-guide Gitee: https://gitee.com/wlicsnju/icspa-public-guide 实验框架代码及其镜像地址： GitHub: http://github.com/ics-nju-wl/icspa-public Gitee: https://gitee.com/wlicsnju/icspa-public ","date":"2022-06-26","objectID":"/nju-ics2021-pa0pa1%E5%B0%8F%E7%BB%93/:1:0","series":null,"tags":["ICS","PA"],"title":"NJU-ICS2021 | PA0\u0026PA1实验小结","uri":"/nju-ics2021-pa0pa1%E5%B0%8F%E7%BB%93/#前言"},{"categories":["Lab"],"content":"PA0 实验环境配置实验指导上写的很详细，过多内容就不赘述，这里主要记录下自己做实验遇见的一些坑和一些思考 课程推荐的是 Debian ，如果从官网上可以比较难找课程推荐的版本（我最开始就没有找到，也是看了MOOC上讨论区才找到），具体地址如下： https://www.debian.org/releases/buster/debian-installer/ 这是课程对应的Debian 10 buster版本，其他的环境配置跟着实验指导一步一步来就好，暂时没遇见什么问题 ","date":"2022-06-26","objectID":"/nju-ics2021-pa0pa1%E5%B0%8F%E7%BB%93/:2:0","series":null,"tags":["ICS","PA"],"title":"NJU-ICS2021 | PA0\u0026PA1实验小结","uri":"/nju-ics2021-pa0pa1%E5%B0%8F%E7%BB%93/#pa0-实验环境配置"},{"categories":["Lab"],"content":"PA1PA1主要是实现数据在 NEMU 模拟器上的表示和运算，包括整数和浮点数的表示、存储和运算 ","date":"2022-06-26","objectID":"/nju-ics2021-pa0pa1%E5%B0%8F%E7%BB%93/:3:0","series":null,"tags":["ICS","PA"],"title":"NJU-ICS2021 | PA0\u0026PA1实验小结","uri":"/nju-ics2021-pa0pa1%E5%B0%8F%E7%BB%93/#pa1"},{"categories":["Lab"],"content":"PA1-1 寄存器的模拟PA1-1 需要需要数据在计算机内部存储形式，也就是实现寄存器，这里框架代码已经给出来了，利用 C 语言中的 union ，看一下这个答案： typedef struct { union { union { union { uint32_t _32; uint16_t _16; uint8_t _8[2]; }; uint32_t val; } gpr[8]; struct { // do not change the order of the registers uint32_t eax, ecx, edx, ebx, esp, ebp, esi, edi; }; }; } CPU_STATE; 这里用到了 union 联合体，为什么用 union 就可以实现需求呢？ 具体需求如下： 我们希望以cpu.eax形式访问的和以cpu.gpr[0]._32形式访问的是同一个模拟寄存器，同时cpu.gpr[0]._16能够访问到cpu.eax的低16位也就是ax寄存器，cpu.gpr[0]._8[0]访问到cpu.eax的低8位也就是al寄存器等。 这里相当于是模拟了 i386 中寄存器的结构 要理解上面为什么可以实现，首先需要找到 union 联合体的在内存储存方式 union 相当于一个结构，它的所有成员相对于基地址的偏移量都为0，此结构空间要大到足够容纳最“宽”的成员 ——摘自K\u0026R C语言p130 我的理解，一个 union 宽度是它的成员中最大的那个，其他的成员和它存放在同一个地址，相对于起始地址偏移量都为0 举个例子：加入现在一个union 有两个成员，如下： union { char a; short b; int c; }u; 我们可以知道这个 union 所需要的字节数为一个 int 也就是4个字节，假设现在c = 0x12345615，并且存放在0x80000000这个地址开始位置，那么具体存放内容如下（假设这里为小端存放） 此时，对于 u.a = 0x15，而 u.b = 0x5615，相比较起始地址偏移量都为0，char 占用一个字节，则 a 即为 0x15，short 占用两个字节，b 即为 0x5615 了，下面是C程序验证我们的结论 #include \u003cstdio.h\u003e union { char a; short b; int c; }u; int main() { u.c = 0x12345615; printf(\"u.a = 0x%x\\n\", u.a); printf(\"u.b = 0x%x\\n\", u.b); printf(\"u.c = 0x%x\\n\", u.c); return 0; } /** silas@Silas-PC:~/ics4$ gcc -g -o union union.c \u0026\u0026 ./union u.a = 0x15 u.b = 0x5615 u.c = 0x12345615 **/ 上面提到一个小端存放，这个在实验指导书上提到： x86采用小端方式存储数据，它规定了超过一个字节的数据的存储规则：低有效字节放在低地址，高有效字节放在高地址。 这样就比较好理解，为什么下面 union 这个可以模拟出i386 对应寄存器的结构 union { uint32_t _32; uint16_t _16; uint8_t _8[2]; }; _32 在内存中宽度最大，也对应32位的寄存器，例如 eax，而_16 为16为，由于是小端存放，最低有效字节放在低地址，取出16位即为这个值的后16位，也就相当于是寄存器的后16位，同理可以理解 _8[2] 对应的过程 注意另外一点，这里将_32 放在了前面，而不是 _8[2] 根据前面的分析，这里应该也是可以的，但是 union 另外一个特点就是初始化的时候，只能用第一个成员类型的值进行初始化，所以将最宽的成员放在第一位，防止初始化时丢失了后面的精度 下面是代码验证： #include \u003cstdio.h\u003e union u_tag { char a; short b; int c; }u; int main() { u.c = 0x12345615; printf(\"u.a = 0x%x\\n\", u.a); printf(\"u.b = 0x%x\\n\", u.b); printf(\"u.c = 0x%x\\n\", u.c); union u_tag u2 = {0x12345615}; printf(\"u.a = 0x%x\\n\", u2.a); printf(\"u.b = 0x%x\\n\", u2.b); printf(\"u.c = 0x%x\\n\", u2.c); return 0; } /* silas@Silas-PC:~/ics4$ gcc -g -o union union.c \u0026\u0026 ./union union.c: In function ‘main’: union.c:16:20: warning: overflow in conversion from ‘int’ to ‘char’ changes value from ‘305419797’ to ‘21’ [-Woverflow] 16 | union u_tag u2 = {0x12345615}; | ^~~~~~~~~~ u.a = 0x15 u.b = 0x5615 u.c = 0x12345615 u.a = 0x15 u.b = 0x15 u.c = 0x15 */ 可以看到由于 union 第一个成员位 char a，只能存放 1 个字节，初始化后会损失精度 至此，差不多解释了为什么使用 union 可以实现模拟寄存器的功能 ","date":"2022-06-26","objectID":"/nju-ics2021-pa0pa1%E5%B0%8F%E7%BB%93/:3:1","series":null,"tags":["ICS","PA"],"title":"NJU-ICS2021 | PA0\u0026PA1实验小结","uri":"/nju-ics2021-pa0pa1%E5%B0%8F%E7%BB%93/#pa1-1-寄存器的模拟"},{"categories":["Lab"],"content":"PA1-2 ALU的模拟这里需要对整数的各个运算来进行模拟，其实实现中比较好实现，直接用 C 语言中对应操作即可，比如说 alu_add 的实现，结果 res = src + dest，包括后续的加减、移位、逻辑和乘除运算基本上都是可以这样来实现 但是最为关键的是需要对标志位进行设置，这就需要结合 i386 手册了（实验指导上给了相应链接 i386 手册: ） PA中需要设置的是CF、PF、ZF、SF 和 OF （AF不需要设置） CF：进位标志符，这个主要看运算结果是否超过了最高的有效位，相当于是进位了，或者是看运算是否向高位借位了 这里可以类比十进制，比如说89+83，相加的时候 3 + 9 = 12 \u003e 10 这里要进位，而CF标志位则是看最高位是否发生了进位，或者是两个数相减的时候 如91-87，个位上 1 - 7 不够减，所以需要向十位借位，这种情况 CF 会被设置为 1 PF：奇偶标志位，看结果中所有bit 位中 1 的个数是否为偶数，偶数 PF = 1，奇数 PF = 0 ZF：零标志位，看结果是否为 0，如果结果为0 则ZF = 1，否则 ZF = 0 SF：符号标志位，看结果是否为负，如果为负，SF = 1，否则 SF = 0 （PA中由于模拟的是无符号数，所以看最高有效位是否为 1 来判断结果是否为负数） OF：溢出标志位，计算中如果发生溢出则设置为1，溢出包括两种，一个是结果值太大，超过了能表示的最大范围就发生了溢出，另外一个是结果值太小，小于能表示的最小值就发生了溢出 这里注意 CF 和 OF 的区别： 在王爽汇编语言P218书中写到，CF 是针对无符号运算的标志位，OF 是针对有符号的标志位，同样位数情况下无符号的范围，这样就会在解释两个数值相加的时候，如果解释为无符号可能不会产生溢出，而解释为有符号会产生溢出 在PA中模拟的是无符号数，所以两者可能会有区别？其实我自己之前实现的时候，很多时候两个标志位实现逻辑就很类似 另外就是 PF、ZF 和 SF 这三个其实对于每个运算都是一样的，可以直接代码复用 ","date":"2022-06-26","objectID":"/nju-ics2021-pa0pa1%E5%B0%8F%E7%BB%93/:3:2","series":null,"tags":["ICS","PA"],"title":"NJU-ICS2021 | PA0\u0026PA1实验小结","uri":"/nju-ics2021-pa0pa1%E5%B0%8F%E7%BB%93/#pa1-2-alu的模拟"},{"categories":["Lab"],"content":"PA1-3 FPU的实现这个主要实现IEEE 754 单精度浮点数(float)的运算，框架代码已经给出大部分内容了，只需要根据实验手册进行补充即可，最重要的应该就是实现 internal_normalize() 规格化函数 其实这部分代码框架也都设计好了，不过开始没反应过来，自己花了不少时间没用在刀刃上，下面自己在做实验的时候遇见几个坑点： 第一个是粘位的处理 最开始我就是判断每次移位之前，判断(sig_grs » 1) 是否大于 1，开始看错了以为是舍入位左边有非零数字，粘位就为1，后来仔细看了代码框架，发现原来的粘位处理操作是 sticky = stickt | (sig_grs \u0026 0x1); 这才发现问题，另外就是注意粘位判断粘位是否为1，要在移位之前进行判断。 出现溢出或零的情况 最开始处理溢出或者零的时候，我把sig_grs 直接设置为 P_ZERO_F 或者 P_INF_F 等等这些，然后发现不对，这里应该直接返回，同时要根据符号位，判断正负的情况 处理舍入的时候 最开始没弄懂 GRS 位是怎么舍入的，直接将 sig_grs += 0x4 了，我以为只要 GRS 大于0x4 然后就直接进位，后面发现不是怎么回事，这里应该是浮点数默认的向偶数位舍入（这里参考了CSAPP p83)，其实就是我们经常听到的四舍六入五成双，举个例子： 对于十进制(这里保留一位)： 10.04 -\u003e 最后一位是4，直接丢弃，最后结果是 10.0 10.06 -\u003e 最后一位是6，大于5直接进位，结果是10.1 10.05 -\u003e 最后一位是5，要让进位的成为偶数，5前面的0已经是偶数了，所以这里直接丢弃5，结果是10.0 10.15 -\u003e 这里和上面就不一样了，5前面是奇数，所以要进位，结果是10.2 对于二进制，这里 GRS 是3位，所以取半即 0x4(0b100) 如果GRS 大于 0x4 直接进位 如果 GRS 小于 0x4 直接丢弃后面尾数 如果 GRS 等于 0x4，这里需要判断前面一位是否为偶数，偶数直接丢弃 GRS，奇数进行进位 舍入想清楚就基本上很容易解决了 （重新看了MOOC视频，发现老师这里讲的挺清楚的，不过自己最开始看了下视频，如何根据实验手册做的，就把视频内容给忘记了，看来还是需要好好看一下视频的内容） 阶码 exp == 0 \u0026\u0026 sig_grs » (23 + 3) == 1在规格化过程中，遇见这种情况，两个非规格化数运算后得到了一个规格化数，指数需要加 1，即 exp = exp + 1 简单分析下为什么要加1，首先 exp == 0，表示是两个非规格化数相加减（因为加减过程中会对阶，两个数应该同时为规格化或者非规格化数），非规格化数基本形式是 0.bbbb…(小数点后面26个位)，两个非规格化数相加为规格化数的情况就是相当于，第一位小数都为1，即 0.1bbb… 和 0.1bbb… 相加的情况，此时进位，结果为 1.bbbb…，结果上是一个规格化数，exp 应该等于 1，相当于是右规了一位 ","date":"2022-06-26","objectID":"/nju-ics2021-pa0pa1%E5%B0%8F%E7%BB%93/:3:3","series":null,"tags":["ICS","PA"],"title":"NJU-ICS2021 | PA0\u0026PA1实验小结","uri":"/nju-ics2021-pa0pa1%E5%B0%8F%E7%BB%93/#pa1-3-fpu的实现"},{"categories":["Lab"],"content":"PA1-3 FPU的实现这个主要实现IEEE 754 单精度浮点数(float)的运算，框架代码已经给出大部分内容了，只需要根据实验手册进行补充即可，最重要的应该就是实现 internal_normalize() 规格化函数 其实这部分代码框架也都设计好了，不过开始没反应过来，自己花了不少时间没用在刀刃上，下面自己在做实验的时候遇见几个坑点： 第一个是粘位的处理 最开始我就是判断每次移位之前，判断(sig_grs » 1) 是否大于 1，开始看错了以为是舍入位左边有非零数字，粘位就为1，后来仔细看了代码框架，发现原来的粘位处理操作是 sticky = stickt | (sig_grs \u0026 0x1); 这才发现问题，另外就是注意粘位判断粘位是否为1，要在移位之前进行判断。 出现溢出或零的情况 最开始处理溢出或者零的时候，我把sig_grs 直接设置为 P_ZERO_F 或者 P_INF_F 等等这些，然后发现不对，这里应该直接返回，同时要根据符号位，判断正负的情况 处理舍入的时候 最开始没弄懂 GRS 位是怎么舍入的，直接将 sig_grs += 0x4 了，我以为只要 GRS 大于0x4 然后就直接进位，后面发现不是怎么回事，这里应该是浮点数默认的向偶数位舍入（这里参考了CSAPP p83)，其实就是我们经常听到的四舍六入五成双，举个例子： 对于十进制(这里保留一位)： 10.04 - 最后一位是4，直接丢弃，最后结果是 10.0 10.06 - 最后一位是6，大于5直接进位，结果是10.1 10.05 - 最后一位是5，要让进位的成为偶数，5前面的0已经是偶数了，所以这里直接丢弃5，结果是10.0 10.15 - 这里和上面就不一样了，5前面是奇数，所以要进位，结果是10.2 对于二进制，这里 GRS 是3位，所以取半即 0x4(0b100) 如果GRS 大于 0x4 直接进位 如果 GRS 小于 0x4 直接丢弃后面尾数 如果 GRS 等于 0x4，这里需要判断前面一位是否为偶数，偶数直接丢弃 GRS，奇数进行进位 舍入想清楚就基本上很容易解决了 （重新看了MOOC视频，发现老师这里讲的挺清楚的，不过自己最开始看了下视频，如何根据实验手册做的，就把视频内容给忘记了，看来还是需要好好看一下视频的内容） 阶码 exp == 0 \u0026\u0026 sig_grs » (23 + 3) == 1在规格化过程中，遇见这种情况，两个非规格化数运算后得到了一个规格化数，指数需要加 1，即 exp = exp + 1 简单分析下为什么要加1，首先 exp == 0，表示是两个非规格化数相加减（因为加减过程中会对阶，两个数应该同时为规格化或者非规格化数），非规格化数基本形式是 0.bbbb…(小数点后面26个位)，两个非规格化数相加为规格化数的情况就是相当于，第一位小数都为1，即 0.1bbb… 和 0.1bbb… 相加的情况，此时进位，结果为 1.bbbb…，结果上是一个规格化数，exp 应该等于 1，相当于是右规了一位 ","date":"2022-06-26","objectID":"/nju-ics2021-pa0pa1%E5%B0%8F%E7%BB%93/:3:3","series":null,"tags":["ICS","PA"],"title":"NJU-ICS2021 | PA0\u0026PA1实验小结","uri":"/nju-ics2021-pa0pa1%E5%B0%8F%E7%BB%93/#阶码-exp--0--sig_grs--23--3--1"},{"categories":["Lab"],"content":"小结PA1的实验大概花了13.5h，感觉这部分内容在框架代码的基础上，查阅i386手册基本上都能实现相应的功能，最大的感受是在浮点数运算的实现时候，对浮点数规格化、舍入等有了更深入的了解 ","date":"2022-06-26","objectID":"/nju-ics2021-pa0pa1%E5%B0%8F%E7%BB%93/:4:0","series":null,"tags":["ICS","PA"],"title":"NJU-ICS2021 | PA0\u0026PA1实验小结","uri":"/nju-ics2021-pa0pa1%E5%B0%8F%E7%BB%93/#小结"},{"categories":["C++"],"content":"16.1 定义模板如果希望定义两个函数，来比较两个值，对于不同类型，可以通过定义多个重载函数来实现这样的功能 //如果两个值相等，返回0，v1小于v2返回-1，v2小于v1返回1 int compare(const string \u0026v1, const string \u0026v2) { if (v1 \u003c v2) return -1; if (v2 \u003c v1) return 1; return 0; } int compare(const double \u0026v1, const double \u0026v2) { if (v1 \u003c v2) return -1; if (v2 \u003c v1) return 1; return 0; } 这两个函数几乎相同，唯一的区别是参数的类型，函数体完全一样 如果还需要定义其他类型的比较函数，显然这样定义比较麻烦，可以用到下面介绍的函数模板进行简化 ","date":"2022-05-07","objectID":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/:1:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十六章 模板与泛型编程","uri":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/#161-定义模板"},{"categories":["C++"],"content":"16.1.1 函数模板 通过定义一个函数模板，而不需要为每个类型都定义一个新函数； 一个函数模板就是一个公式，可以用来生成针对特定类型的函数版本 template\u003ctypename T\u003e int compare(const T \u0026v1, const T \u0026v2) { if (v1 \u003c v2) return -1; if (v2 \u003c v1) return 1; return 0; } 模板定义以关键字 template 开始，后跟一个模板参数列表，这是一个逗号分隔的一个或多个模板参数的列表，用（\u003c\u003e）包围起来 模板定义中，模板参数列表不能为空 模板参数列表类似函数参数列表，在调用时为函数提供实参来初始化形参；模板参数列表中的类型，只有当调用时，通过显式或隐式指定模板实参，将其绑定到模板参数上，根据具体使用情况来确定 实例化函数模板当调用一个函数模板时，编译器用函数实参来推断模板实参 cout \u003c\u003c compare(1, 0) \u003c\u003c endl; //T为int //实参类型为int, 编译器推断出模板实参为int，将其绑定到模板参数T 编译器用推断出来的模板参数来实例化一个特定版本的函数，对于上面的调用，会实例化出 int compare(const int\u0026, const int\u0026); 函数 同样对于下面的调用： vector\u003cint\u003e vec1{1, 2, 3}, vec2{5, 6, 7}; cout \u003c\u003c compare(vec1, vec2) \u003c\u003c endl; //实例化出 int compare(const vector\u003cint\u003e\u0026, const vector\u003cint\u003e\u0026) 编译器会实例化另一个 compare 版本，其中 T 被替换为 vector\u003cint\u003e int compare(const vector\u003cint\u003e\u0026v1, const vector\u003cint\u003e\u0026v2) { if (v1 \u003c v2) return -1; if (v2 \u003c v1) return 1; return 0; } 这些编译器生成的版本通常称为模板的==实例== 模板类型参数上面定义的 compare 函数有一个模板类型参数，一般可以将类型参数看作类型说明符，就像内置类型或类类型说明符一样使用 类型参数可以用来指定返回类型，函数参数类型，以及函数体内用于变量声明或类型转换 template \u003ctypename T\u003e T foo(T* p) { T tmp = *p; //tmp类型将时指针p指向的类型 //... return tmp; } 类型参数前必须使用关键字 class 或 typename //错误：U前面需要加上关键字class或typename template \u003ctypename T, U\u003e T calc(const T\u0026, const U\u0026); 这两个关键字含义相同，可以互换使用 非类型模板参数 一个非类型参数表示一个值而非一个类型，通过一个特定的类型名而非关键字 class 或 typename 来指定非类型参数 一个模板被实例化时，非类型参数被用户提供或编译器推断出的值所替代，这些值必须是常量表达式 例如：编写一个 compare 版本处理字符串字面常量，这种字面常量是 const char 数组，用于不能拷贝一个数组，所以将自己的参数定义为数组的引用，由于希望比较不同长度的字符串字面值常量，模板定义了两个非类型的参数 template \u003cunsigned N, unsigned M\u003e int compare(const (\u0026p1)[N], const (\u0026p2)[M]) { return strcmp(p1, p2); } 调用这个版本时： compare(\"hi\", \"mom\"); //编译器会用字面值常量的大小代替N，M //编译器会在末尾插入一个空字符作为终结符 //编译器会实例出下面版本 int compare(const char (\u0026p1)[3], const char (\u0026p2)[4]); 一个非类型参数可以是一个整型、一个指向对象或函数类型的指针或（左值）引用 绑定到非类型整型参数的实参必须是一个常量表达式 绑定到指针或引用必须具有静态生存期，不能用普通（非static）局部变量或动态对象作为指针引用的实参 指针参数也可以用 nullptr 或值为 0 的常量表达式来实例化 inline 和 constexpr 的函数模板inline 和 constexpr 说明符放在模板参数列表后面，返回类型之前 //正确：inline说明符在模板参数列表之后 template\u003ctypename T\u003e inline T min(const T\u0026, const T\u0026); //错误：inline位置不正确 inline template\u003ctypename T\u003e T min(const T\u0026, const T\u0026); 编写类型无关的代码编写泛型代码两个重要原则： 模板中的函数参数是 const 的引用 函数体中的条件判断仅用 \u003c 比较运算 使用 const 的引用，保证了函数可以用于不能拷贝的类型，设为引用处理大对象时，函数运行速度会更快 只使用 \u003c 运算符，降低了函数对要处理类型的要求，这些类型必须支持 \u003c，而不必同时支持 \u003e 如果需要类型无关和可移植性，可以使用 less 函数对象来定义 template \u003ctypename T\u003e int compare(const T \u0026v1, const T \u0026v2) { if (less\u003cT\u003e()(v1, v2)) return -1; if (less\u003cT\u003e()(v2, v1)) return 1; return 0; } 模板编译编译器遇见一个模板定义时，并不生成代码，只有当实例化出模板的一个特定版本时，编译器才会生成代码 模板为了生成一个实例化版本，需要函数模板或类模板成员函数的定义，与非模板代码不同，模板的头文件通常即包括声明也包括定义 大多数编译错误在实例化期间报告模板直到实例化才会生成代码，通常编译器在三个阶段报告错误： 编译模板本身，基本的语法错误（忘记分号，变量名拼错等） 编译器遇到模板使用时，函数模板会检查实参数目是否正确，参数类型是否匹配，类模板是否提供了正确数目的模板实参 模板实例化时，只有这个阶段才会发现类型相关的错误 例如：之前的 compare 函数，如果传入一个类类型 Sales_data data1, data2; cout \u003c\u003c compare(data1, data2) \u003c\u003c endl; //错误：Sales_data未定义\u003c 这样的错误只有等到实例化 compare 才会发现 ","date":"2022-05-07","objectID":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/:1:1","series":null,"tags":["C++"],"title":"《C++Primer》| 第十六章 模板与泛型编程","uri":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/#1611-函数模板"},{"categories":["C++"],"content":"16.1.1 函数模板 通过定义一个函数模板，而不需要为每个类型都定义一个新函数； 一个函数模板就是一个公式，可以用来生成针对特定类型的函数版本 templateint compare(const T \u0026v1, const T \u0026v2) { if (v1 ）包围起来 模板定义中，模板参数列表不能为空 模板参数列表类似函数参数列表，在调用时为函数提供实参来初始化形参；模板参数列表中的类型，只有当调用时，通过显式或隐式指定模板实参，将其绑定到模板参数上，根据具体使用情况来确定 实例化函数模板当调用一个函数模板时，编译器用函数实参来推断模板实参 cout vec1{1, 2, 3}, vec2{5, 6, 7}; cout \u0026, const vector\u0026) 编译器会实例化另一个 compare 版本，其中 T 被替换为 vector int compare(const vector\u0026v1, const vector\u0026v2) { if (v1 T foo(T* p) { T tmp = *p; //tmp类型将时指针p指向的类型 //... return tmp; } 类型参数前必须使用关键字 class 或 typename //错误：U前面需要加上关键字class或typename template T calc(const T\u0026, const U\u0026); 这两个关键字含义相同，可以互换使用 非类型模板参数 一个非类型参数表示一个值而非一个类型，通过一个特定的类型名而非关键字 class 或 typename 来指定非类型参数 一个模板被实例化时，非类型参数被用户提供或编译器推断出的值所替代，这些值必须是常量表达式 例如：编写一个 compare 版本处理字符串字面常量，这种字面常量是 const char 数组，用于不能拷贝一个数组，所以将自己的参数定义为数组的引用，由于希望比较不同长度的字符串字面值常量，模板定义了两个非类型的参数 template int compare(const (\u0026p1)[N], const (\u0026p2)[M]) { return strcmp(p1, p2); } 调用这个版本时： compare(\"hi\", \"mom\"); //编译器会用字面值常量的大小代替N，M //编译器会在末尾插入一个空字符作为终结符 //编译器会实例出下面版本 int compare(const char (\u0026p1)[3], const char (\u0026p2)[4]); 一个非类型参数可以是一个整型、一个指向对象或函数类型的指针或（左值）引用 绑定到非类型整型参数的实参必须是一个常量表达式 绑定到指针或引用必须具有静态生存期，不能用普通（非static）局部变量或动态对象作为指针引用的实参 指针参数也可以用 nullptr 或值为 0 的常量表达式来实例化 inline 和 constexpr 的函数模板inline 和 constexpr 说明符放在模板参数列表后面，返回类型之前 //正确：inline说明符在模板参数列表之后 templateinline T min(const T\u0026, const T\u0026); //错误：inline位置不正确 inline templateT min(const T\u0026, const T\u0026); 编写类型无关的代码编写泛型代码两个重要原则： 模板中的函数参数是 const 的引用 函数体中的条件判断仅用 如果需要类型无关和可移植性，可以使用 less 函数对象来定义 template int compare(const T \u0026v1, const T \u0026v2) { if (less()(v1, v2)) return -1; if (less()(v2, v1)) return 1; return 0; } 模板编译编译器遇见一个模板定义时，并不生成代码，只有当实例化出模板的一个特定版本时，编译器才会生成代码 模板为了生成一个实例化版本，需要函数模板或类模板成员函数的定义，与非模板代码不同，模板的头文件通常即包括声明也包括定义 大多数编译错误在实例化期间报告模板直到实例化才会生成代码，通常编译器在三个阶段报告错误： 编译模板本身，基本的语法错误（忘记分号，变量名拼错等） 编译器遇到模板使用时，函数模板会检查实参数目是否正确，参数类型是否匹配，类模板是否提供了正确数目的模板实参 模板实例化时，只有这个阶段才会发现类型相关的错误 例如：之前的 compare 函数，如果传入一个类类型 Sales_data data1, data2; cout ","date":"2022-05-07","objectID":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/:1:1","series":null,"tags":["C++"],"title":"《C++Primer》| 第十六章 模板与泛型编程","uri":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/#实例化函数模板"},{"categories":["C++"],"content":"16.1.1 函数模板 通过定义一个函数模板，而不需要为每个类型都定义一个新函数； 一个函数模板就是一个公式，可以用来生成针对特定类型的函数版本 templateint compare(const T \u0026v1, const T \u0026v2) { if (v1 ）包围起来 模板定义中，模板参数列表不能为空 模板参数列表类似函数参数列表，在调用时为函数提供实参来初始化形参；模板参数列表中的类型，只有当调用时，通过显式或隐式指定模板实参，将其绑定到模板参数上，根据具体使用情况来确定 实例化函数模板当调用一个函数模板时，编译器用函数实参来推断模板实参 cout vec1{1, 2, 3}, vec2{5, 6, 7}; cout \u0026, const vector\u0026) 编译器会实例化另一个 compare 版本，其中 T 被替换为 vector int compare(const vector\u0026v1, const vector\u0026v2) { if (v1 T foo(T* p) { T tmp = *p; //tmp类型将时指针p指向的类型 //... return tmp; } 类型参数前必须使用关键字 class 或 typename //错误：U前面需要加上关键字class或typename template T calc(const T\u0026, const U\u0026); 这两个关键字含义相同，可以互换使用 非类型模板参数 一个非类型参数表示一个值而非一个类型，通过一个特定的类型名而非关键字 class 或 typename 来指定非类型参数 一个模板被实例化时，非类型参数被用户提供或编译器推断出的值所替代，这些值必须是常量表达式 例如：编写一个 compare 版本处理字符串字面常量，这种字面常量是 const char 数组，用于不能拷贝一个数组，所以将自己的参数定义为数组的引用，由于希望比较不同长度的字符串字面值常量，模板定义了两个非类型的参数 template int compare(const (\u0026p1)[N], const (\u0026p2)[M]) { return strcmp(p1, p2); } 调用这个版本时： compare(\"hi\", \"mom\"); //编译器会用字面值常量的大小代替N，M //编译器会在末尾插入一个空字符作为终结符 //编译器会实例出下面版本 int compare(const char (\u0026p1)[3], const char (\u0026p2)[4]); 一个非类型参数可以是一个整型、一个指向对象或函数类型的指针或（左值）引用 绑定到非类型整型参数的实参必须是一个常量表达式 绑定到指针或引用必须具有静态生存期，不能用普通（非static）局部变量或动态对象作为指针引用的实参 指针参数也可以用 nullptr 或值为 0 的常量表达式来实例化 inline 和 constexpr 的函数模板inline 和 constexpr 说明符放在模板参数列表后面，返回类型之前 //正确：inline说明符在模板参数列表之后 templateinline T min(const T\u0026, const T\u0026); //错误：inline位置不正确 inline templateT min(const T\u0026, const T\u0026); 编写类型无关的代码编写泛型代码两个重要原则： 模板中的函数参数是 const 的引用 函数体中的条件判断仅用 如果需要类型无关和可移植性，可以使用 less 函数对象来定义 template int compare(const T \u0026v1, const T \u0026v2) { if (less()(v1, v2)) return -1; if (less()(v2, v1)) return 1; return 0; } 模板编译编译器遇见一个模板定义时，并不生成代码，只有当实例化出模板的一个特定版本时，编译器才会生成代码 模板为了生成一个实例化版本，需要函数模板或类模板成员函数的定义，与非模板代码不同，模板的头文件通常即包括声明也包括定义 大多数编译错误在实例化期间报告模板直到实例化才会生成代码，通常编译器在三个阶段报告错误： 编译模板本身，基本的语法错误（忘记分号，变量名拼错等） 编译器遇到模板使用时，函数模板会检查实参数目是否正确，参数类型是否匹配，类模板是否提供了正确数目的模板实参 模板实例化时，只有这个阶段才会发现类型相关的错误 例如：之前的 compare 函数，如果传入一个类类型 Sales_data data1, data2; cout ","date":"2022-05-07","objectID":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/:1:1","series":null,"tags":["C++"],"title":"《C++Primer》| 第十六章 模板与泛型编程","uri":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/#模板类型参数"},{"categories":["C++"],"content":"16.1.1 函数模板 通过定义一个函数模板，而不需要为每个类型都定义一个新函数； 一个函数模板就是一个公式，可以用来生成针对特定类型的函数版本 templateint compare(const T \u0026v1, const T \u0026v2) { if (v1 ）包围起来 模板定义中，模板参数列表不能为空 模板参数列表类似函数参数列表，在调用时为函数提供实参来初始化形参；模板参数列表中的类型，只有当调用时，通过显式或隐式指定模板实参，将其绑定到模板参数上，根据具体使用情况来确定 实例化函数模板当调用一个函数模板时，编译器用函数实参来推断模板实参 cout vec1{1, 2, 3}, vec2{5, 6, 7}; cout \u0026, const vector\u0026) 编译器会实例化另一个 compare 版本，其中 T 被替换为 vector int compare(const vector\u0026v1, const vector\u0026v2) { if (v1 T foo(T* p) { T tmp = *p; //tmp类型将时指针p指向的类型 //... return tmp; } 类型参数前必须使用关键字 class 或 typename //错误：U前面需要加上关键字class或typename template T calc(const T\u0026, const U\u0026); 这两个关键字含义相同，可以互换使用 非类型模板参数 一个非类型参数表示一个值而非一个类型，通过一个特定的类型名而非关键字 class 或 typename 来指定非类型参数 一个模板被实例化时，非类型参数被用户提供或编译器推断出的值所替代，这些值必须是常量表达式 例如：编写一个 compare 版本处理字符串字面常量，这种字面常量是 const char 数组，用于不能拷贝一个数组，所以将自己的参数定义为数组的引用，由于希望比较不同长度的字符串字面值常量，模板定义了两个非类型的参数 template int compare(const (\u0026p1)[N], const (\u0026p2)[M]) { return strcmp(p1, p2); } 调用这个版本时： compare(\"hi\", \"mom\"); //编译器会用字面值常量的大小代替N，M //编译器会在末尾插入一个空字符作为终结符 //编译器会实例出下面版本 int compare(const char (\u0026p1)[3], const char (\u0026p2)[4]); 一个非类型参数可以是一个整型、一个指向对象或函数类型的指针或（左值）引用 绑定到非类型整型参数的实参必须是一个常量表达式 绑定到指针或引用必须具有静态生存期，不能用普通（非static）局部变量或动态对象作为指针引用的实参 指针参数也可以用 nullptr 或值为 0 的常量表达式来实例化 inline 和 constexpr 的函数模板inline 和 constexpr 说明符放在模板参数列表后面，返回类型之前 //正确：inline说明符在模板参数列表之后 templateinline T min(const T\u0026, const T\u0026); //错误：inline位置不正确 inline templateT min(const T\u0026, const T\u0026); 编写类型无关的代码编写泛型代码两个重要原则： 模板中的函数参数是 const 的引用 函数体中的条件判断仅用 如果需要类型无关和可移植性，可以使用 less 函数对象来定义 template int compare(const T \u0026v1, const T \u0026v2) { if (less()(v1, v2)) return -1; if (less()(v2, v1)) return 1; return 0; } 模板编译编译器遇见一个模板定义时，并不生成代码，只有当实例化出模板的一个特定版本时，编译器才会生成代码 模板为了生成一个实例化版本，需要函数模板或类模板成员函数的定义，与非模板代码不同，模板的头文件通常即包括声明也包括定义 大多数编译错误在实例化期间报告模板直到实例化才会生成代码，通常编译器在三个阶段报告错误： 编译模板本身，基本的语法错误（忘记分号，变量名拼错等） 编译器遇到模板使用时，函数模板会检查实参数目是否正确，参数类型是否匹配，类模板是否提供了正确数目的模板实参 模板实例化时，只有这个阶段才会发现类型相关的错误 例如：之前的 compare 函数，如果传入一个类类型 Sales_data data1, data2; cout ","date":"2022-05-07","objectID":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/:1:1","series":null,"tags":["C++"],"title":"《C++Primer》| 第十六章 模板与泛型编程","uri":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/#非类型模板参数"},{"categories":["C++"],"content":"16.1.1 函数模板 通过定义一个函数模板，而不需要为每个类型都定义一个新函数； 一个函数模板就是一个公式，可以用来生成针对特定类型的函数版本 templateint compare(const T \u0026v1, const T \u0026v2) { if (v1 ）包围起来 模板定义中，模板参数列表不能为空 模板参数列表类似函数参数列表，在调用时为函数提供实参来初始化形参；模板参数列表中的类型，只有当调用时，通过显式或隐式指定模板实参，将其绑定到模板参数上，根据具体使用情况来确定 实例化函数模板当调用一个函数模板时，编译器用函数实参来推断模板实参 cout vec1{1, 2, 3}, vec2{5, 6, 7}; cout \u0026, const vector\u0026) 编译器会实例化另一个 compare 版本，其中 T 被替换为 vector int compare(const vector\u0026v1, const vector\u0026v2) { if (v1 T foo(T* p) { T tmp = *p; //tmp类型将时指针p指向的类型 //... return tmp; } 类型参数前必须使用关键字 class 或 typename //错误：U前面需要加上关键字class或typename template T calc(const T\u0026, const U\u0026); 这两个关键字含义相同，可以互换使用 非类型模板参数 一个非类型参数表示一个值而非一个类型，通过一个特定的类型名而非关键字 class 或 typename 来指定非类型参数 一个模板被实例化时，非类型参数被用户提供或编译器推断出的值所替代，这些值必须是常量表达式 例如：编写一个 compare 版本处理字符串字面常量，这种字面常量是 const char 数组，用于不能拷贝一个数组，所以将自己的参数定义为数组的引用，由于希望比较不同长度的字符串字面值常量，模板定义了两个非类型的参数 template int compare(const (\u0026p1)[N], const (\u0026p2)[M]) { return strcmp(p1, p2); } 调用这个版本时： compare(\"hi\", \"mom\"); //编译器会用字面值常量的大小代替N，M //编译器会在末尾插入一个空字符作为终结符 //编译器会实例出下面版本 int compare(const char (\u0026p1)[3], const char (\u0026p2)[4]); 一个非类型参数可以是一个整型、一个指向对象或函数类型的指针或（左值）引用 绑定到非类型整型参数的实参必须是一个常量表达式 绑定到指针或引用必须具有静态生存期，不能用普通（非static）局部变量或动态对象作为指针引用的实参 指针参数也可以用 nullptr 或值为 0 的常量表达式来实例化 inline 和 constexpr 的函数模板inline 和 constexpr 说明符放在模板参数列表后面，返回类型之前 //正确：inline说明符在模板参数列表之后 templateinline T min(const T\u0026, const T\u0026); //错误：inline位置不正确 inline templateT min(const T\u0026, const T\u0026); 编写类型无关的代码编写泛型代码两个重要原则： 模板中的函数参数是 const 的引用 函数体中的条件判断仅用 如果需要类型无关和可移植性，可以使用 less 函数对象来定义 template int compare(const T \u0026v1, const T \u0026v2) { if (less()(v1, v2)) return -1; if (less()(v2, v1)) return 1; return 0; } 模板编译编译器遇见一个模板定义时，并不生成代码，只有当实例化出模板的一个特定版本时，编译器才会生成代码 模板为了生成一个实例化版本，需要函数模板或类模板成员函数的定义，与非模板代码不同，模板的头文件通常即包括声明也包括定义 大多数编译错误在实例化期间报告模板直到实例化才会生成代码，通常编译器在三个阶段报告错误： 编译模板本身，基本的语法错误（忘记分号，变量名拼错等） 编译器遇到模板使用时，函数模板会检查实参数目是否正确，参数类型是否匹配，类模板是否提供了正确数目的模板实参 模板实例化时，只有这个阶段才会发现类型相关的错误 例如：之前的 compare 函数，如果传入一个类类型 Sales_data data1, data2; cout ","date":"2022-05-07","objectID":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/:1:1","series":null,"tags":["C++"],"title":"《C++Primer》| 第十六章 模板与泛型编程","uri":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/#inline-和-constexpr-的函数模板"},{"categories":["C++"],"content":"16.1.1 函数模板 通过定义一个函数模板，而不需要为每个类型都定义一个新函数； 一个函数模板就是一个公式，可以用来生成针对特定类型的函数版本 templateint compare(const T \u0026v1, const T \u0026v2) { if (v1 ）包围起来 模板定义中，模板参数列表不能为空 模板参数列表类似函数参数列表，在调用时为函数提供实参来初始化形参；模板参数列表中的类型，只有当调用时，通过显式或隐式指定模板实参，将其绑定到模板参数上，根据具体使用情况来确定 实例化函数模板当调用一个函数模板时，编译器用函数实参来推断模板实参 cout vec1{1, 2, 3}, vec2{5, 6, 7}; cout \u0026, const vector\u0026) 编译器会实例化另一个 compare 版本，其中 T 被替换为 vector int compare(const vector\u0026v1, const vector\u0026v2) { if (v1 T foo(T* p) { T tmp = *p; //tmp类型将时指针p指向的类型 //... return tmp; } 类型参数前必须使用关键字 class 或 typename //错误：U前面需要加上关键字class或typename template T calc(const T\u0026, const U\u0026); 这两个关键字含义相同，可以互换使用 非类型模板参数 一个非类型参数表示一个值而非一个类型，通过一个特定的类型名而非关键字 class 或 typename 来指定非类型参数 一个模板被实例化时，非类型参数被用户提供或编译器推断出的值所替代，这些值必须是常量表达式 例如：编写一个 compare 版本处理字符串字面常量，这种字面常量是 const char 数组，用于不能拷贝一个数组，所以将自己的参数定义为数组的引用，由于希望比较不同长度的字符串字面值常量，模板定义了两个非类型的参数 template int compare(const (\u0026p1)[N], const (\u0026p2)[M]) { return strcmp(p1, p2); } 调用这个版本时： compare(\"hi\", \"mom\"); //编译器会用字面值常量的大小代替N，M //编译器会在末尾插入一个空字符作为终结符 //编译器会实例出下面版本 int compare(const char (\u0026p1)[3], const char (\u0026p2)[4]); 一个非类型参数可以是一个整型、一个指向对象或函数类型的指针或（左值）引用 绑定到非类型整型参数的实参必须是一个常量表达式 绑定到指针或引用必须具有静态生存期，不能用普通（非static）局部变量或动态对象作为指针引用的实参 指针参数也可以用 nullptr 或值为 0 的常量表达式来实例化 inline 和 constexpr 的函数模板inline 和 constexpr 说明符放在模板参数列表后面，返回类型之前 //正确：inline说明符在模板参数列表之后 templateinline T min(const T\u0026, const T\u0026); //错误：inline位置不正确 inline templateT min(const T\u0026, const T\u0026); 编写类型无关的代码编写泛型代码两个重要原则： 模板中的函数参数是 const 的引用 函数体中的条件判断仅用 如果需要类型无关和可移植性，可以使用 less 函数对象来定义 template int compare(const T \u0026v1, const T \u0026v2) { if (less()(v1, v2)) return -1; if (less()(v2, v1)) return 1; return 0; } 模板编译编译器遇见一个模板定义时，并不生成代码，只有当实例化出模板的一个特定版本时，编译器才会生成代码 模板为了生成一个实例化版本，需要函数模板或类模板成员函数的定义，与非模板代码不同，模板的头文件通常即包括声明也包括定义 大多数编译错误在实例化期间报告模板直到实例化才会生成代码，通常编译器在三个阶段报告错误： 编译模板本身，基本的语法错误（忘记分号，变量名拼错等） 编译器遇到模板使用时，函数模板会检查实参数目是否正确，参数类型是否匹配，类模板是否提供了正确数目的模板实参 模板实例化时，只有这个阶段才会发现类型相关的错误 例如：之前的 compare 函数，如果传入一个类类型 Sales_data data1, data2; cout ","date":"2022-05-07","objectID":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/:1:1","series":null,"tags":["C++"],"title":"《C++Primer》| 第十六章 模板与泛型编程","uri":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/#编写类型无关的代码"},{"categories":["C++"],"content":"16.1.1 函数模板 通过定义一个函数模板，而不需要为每个类型都定义一个新函数； 一个函数模板就是一个公式，可以用来生成针对特定类型的函数版本 templateint compare(const T \u0026v1, const T \u0026v2) { if (v1 ）包围起来 模板定义中，模板参数列表不能为空 模板参数列表类似函数参数列表，在调用时为函数提供实参来初始化形参；模板参数列表中的类型，只有当调用时，通过显式或隐式指定模板实参，将其绑定到模板参数上，根据具体使用情况来确定 实例化函数模板当调用一个函数模板时，编译器用函数实参来推断模板实参 cout vec1{1, 2, 3}, vec2{5, 6, 7}; cout \u0026, const vector\u0026) 编译器会实例化另一个 compare 版本，其中 T 被替换为 vector int compare(const vector\u0026v1, const vector\u0026v2) { if (v1 T foo(T* p) { T tmp = *p; //tmp类型将时指针p指向的类型 //... return tmp; } 类型参数前必须使用关键字 class 或 typename //错误：U前面需要加上关键字class或typename template T calc(const T\u0026, const U\u0026); 这两个关键字含义相同，可以互换使用 非类型模板参数 一个非类型参数表示一个值而非一个类型，通过一个特定的类型名而非关键字 class 或 typename 来指定非类型参数 一个模板被实例化时，非类型参数被用户提供或编译器推断出的值所替代，这些值必须是常量表达式 例如：编写一个 compare 版本处理字符串字面常量，这种字面常量是 const char 数组，用于不能拷贝一个数组，所以将自己的参数定义为数组的引用，由于希望比较不同长度的字符串字面值常量，模板定义了两个非类型的参数 template int compare(const (\u0026p1)[N], const (\u0026p2)[M]) { return strcmp(p1, p2); } 调用这个版本时： compare(\"hi\", \"mom\"); //编译器会用字面值常量的大小代替N，M //编译器会在末尾插入一个空字符作为终结符 //编译器会实例出下面版本 int compare(const char (\u0026p1)[3], const char (\u0026p2)[4]); 一个非类型参数可以是一个整型、一个指向对象或函数类型的指针或（左值）引用 绑定到非类型整型参数的实参必须是一个常量表达式 绑定到指针或引用必须具有静态生存期，不能用普通（非static）局部变量或动态对象作为指针引用的实参 指针参数也可以用 nullptr 或值为 0 的常量表达式来实例化 inline 和 constexpr 的函数模板inline 和 constexpr 说明符放在模板参数列表后面，返回类型之前 //正确：inline说明符在模板参数列表之后 templateinline T min(const T\u0026, const T\u0026); //错误：inline位置不正确 inline templateT min(const T\u0026, const T\u0026); 编写类型无关的代码编写泛型代码两个重要原则： 模板中的函数参数是 const 的引用 函数体中的条件判断仅用 如果需要类型无关和可移植性，可以使用 less 函数对象来定义 template int compare(const T \u0026v1, const T \u0026v2) { if (less()(v1, v2)) return -1; if (less()(v2, v1)) return 1; return 0; } 模板编译编译器遇见一个模板定义时，并不生成代码，只有当实例化出模板的一个特定版本时，编译器才会生成代码 模板为了生成一个实例化版本，需要函数模板或类模板成员函数的定义，与非模板代码不同，模板的头文件通常即包括声明也包括定义 大多数编译错误在实例化期间报告模板直到实例化才会生成代码，通常编译器在三个阶段报告错误： 编译模板本身，基本的语法错误（忘记分号，变量名拼错等） 编译器遇到模板使用时，函数模板会检查实参数目是否正确，参数类型是否匹配，类模板是否提供了正确数目的模板实参 模板实例化时，只有这个阶段才会发现类型相关的错误 例如：之前的 compare 函数，如果传入一个类类型 Sales_data data1, data2; cout ","date":"2022-05-07","objectID":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/:1:1","series":null,"tags":["C++"],"title":"《C++Primer》| 第十六章 模板与泛型编程","uri":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/#模板编译"},{"categories":["C++"],"content":"16.1.1 函数模板 通过定义一个函数模板，而不需要为每个类型都定义一个新函数； 一个函数模板就是一个公式，可以用来生成针对特定类型的函数版本 templateint compare(const T \u0026v1, const T \u0026v2) { if (v1 ）包围起来 模板定义中，模板参数列表不能为空 模板参数列表类似函数参数列表，在调用时为函数提供实参来初始化形参；模板参数列表中的类型，只有当调用时，通过显式或隐式指定模板实参，将其绑定到模板参数上，根据具体使用情况来确定 实例化函数模板当调用一个函数模板时，编译器用函数实参来推断模板实参 cout vec1{1, 2, 3}, vec2{5, 6, 7}; cout \u0026, const vector\u0026) 编译器会实例化另一个 compare 版本，其中 T 被替换为 vector int compare(const vector\u0026v1, const vector\u0026v2) { if (v1 T foo(T* p) { T tmp = *p; //tmp类型将时指针p指向的类型 //... return tmp; } 类型参数前必须使用关键字 class 或 typename //错误：U前面需要加上关键字class或typename template T calc(const T\u0026, const U\u0026); 这两个关键字含义相同，可以互换使用 非类型模板参数 一个非类型参数表示一个值而非一个类型，通过一个特定的类型名而非关键字 class 或 typename 来指定非类型参数 一个模板被实例化时，非类型参数被用户提供或编译器推断出的值所替代，这些值必须是常量表达式 例如：编写一个 compare 版本处理字符串字面常量，这种字面常量是 const char 数组，用于不能拷贝一个数组，所以将自己的参数定义为数组的引用，由于希望比较不同长度的字符串字面值常量，模板定义了两个非类型的参数 template int compare(const (\u0026p1)[N], const (\u0026p2)[M]) { return strcmp(p1, p2); } 调用这个版本时： compare(\"hi\", \"mom\"); //编译器会用字面值常量的大小代替N，M //编译器会在末尾插入一个空字符作为终结符 //编译器会实例出下面版本 int compare(const char (\u0026p1)[3], const char (\u0026p2)[4]); 一个非类型参数可以是一个整型、一个指向对象或函数类型的指针或（左值）引用 绑定到非类型整型参数的实参必须是一个常量表达式 绑定到指针或引用必须具有静态生存期，不能用普通（非static）局部变量或动态对象作为指针引用的实参 指针参数也可以用 nullptr 或值为 0 的常量表达式来实例化 inline 和 constexpr 的函数模板inline 和 constexpr 说明符放在模板参数列表后面，返回类型之前 //正确：inline说明符在模板参数列表之后 templateinline T min(const T\u0026, const T\u0026); //错误：inline位置不正确 inline templateT min(const T\u0026, const T\u0026); 编写类型无关的代码编写泛型代码两个重要原则： 模板中的函数参数是 const 的引用 函数体中的条件判断仅用 如果需要类型无关和可移植性，可以使用 less 函数对象来定义 template int compare(const T \u0026v1, const T \u0026v2) { if (less()(v1, v2)) return -1; if (less()(v2, v1)) return 1; return 0; } 模板编译编译器遇见一个模板定义时，并不生成代码，只有当实例化出模板的一个特定版本时，编译器才会生成代码 模板为了生成一个实例化版本，需要函数模板或类模板成员函数的定义，与非模板代码不同，模板的头文件通常即包括声明也包括定义 大多数编译错误在实例化期间报告模板直到实例化才会生成代码，通常编译器在三个阶段报告错误： 编译模板本身，基本的语法错误（忘记分号，变量名拼错等） 编译器遇到模板使用时，函数模板会检查实参数目是否正确，参数类型是否匹配，类模板是否提供了正确数目的模板实参 模板实例化时，只有这个阶段才会发现类型相关的错误 例如：之前的 compare 函数，如果传入一个类类型 Sales_data data1, data2; cout ","date":"2022-05-07","objectID":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/:1:1","series":null,"tags":["C++"],"title":"《C++Primer》| 第十六章 模板与泛型编程","uri":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/#大多数编译错误在实例化期间报告"},{"categories":["C++"],"content":"16.1.2 类模板类模板用来生成类的蓝图，类模板必须提供额外的信息，来确定模板的参数类型，一般在模板名后尖括号中提供实参 定义类模板 template \u003ctypename T\u003e class Blob { public: typedef T value_type; typedef typename std::vector\u003cT\u003e::size_type size_type; //构造函数 Blob(); Blob(std::initializer_list\u003cT\u003e il); //Blob中元素数目 size_type size() const { return data-\u003esize(); } bool empty() const { return data-\u003eempty(); } void push_back(const T\u0026 t) { return data-\u003epush_back(t);} void pop_back(); //元素访问 T\u0026 back(); T\u0026 operator[](size_type i); private: std::shared_ptr\u003cstd::vector\u003cT\u003e\u003e data; //若data[i]无效，抛出msg void check(size_type i, const std::string \u0026msg) const; }； 实例化类模板使用一个类模板时，需要提供额外信息，这些额外信息是显示模板实参列表，它们被绑定到模板参数 //使用类模板，必须提供元素类型 Blob\u003cint\u003e ia; Blob\u003cint\u003e ia2 = {0, 1, 2, 3}; ia 和 ia2会实例化以下特定版本的 Blob\u003cint\u003e ` template \u003c\u003e class Blob\u003cint\u003e { typedef typename std::vector\u003cint\u003e::size_type size_type; Blob(); Blob(std::initializer_list\u003cint\u003e il); //... } 当编译器从 Blob 模板中实例化一个类时，它会重写 Blob 模板，将参数 T 的每个实例替换成给定的模板实参 一个类模板的每个实例都形成一个独立的类，类型 Blob\u003cstring\u003e 与其他任何 Blob类型都没有关系，也不会对任何其他 Blob 类型的成员具有特殊的访问权限 类模板的成员函数与其他类一样，既可以在类模板内部，也可以在外部定义其成员函数，且定义在类模板内的成员函数被隐式声明为内联函数 类模板的成员函数本身是一个普通函数 每个类模板的实例都有自己版本的成员函数 类模板的成员函数具有和模板相同的模板参数 定义在类模板之外的成员函数就必须以关键字 template 开始，后接参数列表 简单说就是在类模板内部定义成员函数，可以直接使用参数 T，而在类模板外部定义成员函数，前面需要加上 template 等 template \u003ctypename T\u003e ret-type Blob\u003cT\u003e::member-name(parm-list) 这里必须加上 template 这行 类模板成员函数实例化默认情况下，类模板的成员函数只有当程序使用它的时候才进行实例化 // 实例化Blob\u003cint\u003e和接受initializer_list\u003cint\u003e的构造函数 Blob\u003cint\u003e squares = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; for (size_t i = 0; i != squares.size(); ++i) { squares[i] = i * i; //实例化Blob\u003cint\u003e::operator[](size_t) } 如果一个成员函数没有被使用，则它不会被实例化 类代码内简化模板类名的使用在使用一个类模板类型时必须提供模板实参，但是在类模板自己的作用域中，可以直接使用模板名而不提供实参 template \u003ctypename T\u003e class BlobPtr { public: BlobPtr() : curr(0) {} //其他构造函数 T\u0026 operator*() const { auto p = check(curr, \"derederence past edn\"); return (*p)[curr]; } //递增和递减 BlobPtr\u0026 operator++(); //求值运算符 BlobPtr\u0026 operator--(); private: //其他成员 std::size_t curr; //数组中的位置 } 这里前置递增和递减成员返回的时 BlobPtr\u0026，而不是 BlobPtr\u003cT\u003e\u0026，在类模板作用域中，编译器处理模板自身引用会自动提供模板匹配的实参 类模板外使用类模板名在类模板外定义成员时，此时不在类的作用域，直到遇见类名菜进入类的作用域 //后置++版本 template \u003ctypename T\u003e BlobPtr\u003cT\u003e BlobPtr\u003cT\u003e::operator++(int) { BlobPtr ret = *this; ++*this; return ret; } 返回类型位于类的作用域之外，所以必须指出返回类型是一个实例化的 BlobPtr，在函数体内已经进入类的作用域，则定义 ret 时无须重复提供模板实参，如果不通过模板实参，编译器假定使用的类型与成员实例化所用类型一致，等价于：BlobPtr\u003cT\u003e ret = *this; 类模板和友元 一个类包含一个友元声明，类与友元各自是否是模板是互相无关的 如果一个模板包括一个非模板友元，则友元可以访问所以模板实例 如果友元自身也是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例 一对一友好关系类模板与另一个（类或函数）模板间友好关系的最常见的形式是建立对应实例及其友元间的友好关系。例如，我们的 Blob 类应该将 BlobPtr 类和一个模板版本的 Blob template \u003ctypename\u003e class BlobPtr; //需要提前声明 template \u003ctypename\u003e class Blob; template \u003ctypename T\u003e bool operator==(const Blob\u003cT\u003e\u0026, const Blob\u003cT\u003e\u0026); template \u003ctypename T\u003e class Blob { friend class BlobPtr\u003cT\u003e; friend bool operator==\u003cT\u003e (const Blob\u003cT\u003e\u0026, const Blob\u003cT\u003e\u0026); //其他成员 } 友元的声明用 Blob 的模板形参作为自己的模板实参，友好关系被限定在相同类型实例化的 Blob 和 BlobPtr 相等运算符之间 //BlobPtr\u003cchar\u003e和operator==\u003cchar\u003e都是本对象的友元 Blob\u003cchar\u003e ca; //BlobPtr\u003cint\u003e和operator==\u003cint\u003e都是本对象的友元 Blob\u003cint\u003e ia; 上面例子中，ca 对 ia 或其他实例没有特殊访问权限 通用和特定模板的友好关系一个类也可以将另一个模板的每个实例都声明为自己的友元，或者限定特定的实例为友元 template \u003ctypename T\u003e class Pal; class C { //C是普通非模板类 friend class Pal\u003cC\u003e;//C实例化Pal是C的友元 //Pal2的所有实例都是C的友元，这种情况无须前置声明 template \u003ctypename T\u003e friend class Pal2; }; template \u003ctypename T\u003e class C2 {//C2是个模板类 //C2每个实例将相同实例的Pal声明为友元 friend class Pal\u003cT\u003e; //Pal2所有实例都是C2每个实例的友元，不需要前置声明 template \u003ctypename X\u003e friend class Pal2; //Pal3是一个非模板类，它是C2所有实例的友元 friend class Pal3; }; 为了让所有实例都成为友元，友元声明中必须使用与类模板不同的模板参数 令模板自己的类型参数成为友元在C++11新标准中，可以将模板类型参数声明为友元 template \u003ctypename Type\u003e class Bar { friend Type; //访问权限授予实例化Bar的类型 //... } 此时，对于某个类型 Foo，Foo 将称为 Bar\u003cFoo\u003e 的友元，Sales_data 将成为 Bar\u003cSales_data\u003e 的友元 模板类型别名类模板一个实例定义了一个类类型，我们可以定义一个 typedef 来引用实例化的类： typedef Blob\u003cstring\u003e StrBlob; 由于模板不是一个类型，我们不能定义一个 typedef 引用一个模板，即不能定义一个 typedef 引用 Blob\u003cT\u003e 但是新标准允许为类模板定义一个类型别名： template\u003ctypename T\u003e using twin = pair\u003cT, T\u003e; twin\u003cstring\u003e authors; //authors是一个pair\u003cstring, strin\u003e 使用别名时，也需要像模板那样指出特定类型的 twin 使用一个模板类型别名时，可以固定一个或多个模板参数 template \u003ctypename T\u003e using partNo = pair\u003cT, unsigned\u003e; partNo\u003cstring\u003e books; /","date":"2022-05-07","objectID":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/:1:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十六章 模板与泛型编程","uri":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/#1612-类模板"},{"categories":["C++"],"content":"16.1.2 类模板类模板用来生成类的蓝图，类模板必须提供额外的信息，来确定模板的参数类型，一般在模板名后尖括号中提供实参 定义类模板 template class Blob { public: typedef T value_type; typedef typename std::vector::size_type size_type; //构造函数 Blob(); Blob(std::initializer_list il); //Blob中元素数目 size_type size() const { return data-size(); } bool empty() const { return data-empty(); } void push_back(const T\u0026 t) { return data-push_back(t);} void pop_back(); //元素访问 T\u0026 back(); T\u0026 operator[](size_type i); private: std::shared_ptr data; //若data[i]无效，抛出msg void check(size_type i, const std::string \u0026msg) const; }； 实例化类模板使用一个类模板时，需要提供额外信息，这些额外信息是显示模板实参列表，它们被绑定到模板参数 //使用类模板，必须提供元素类型 Blob ia; Blob ia2 = {0, 1, 2, 3}; ia 和 ia2会实例化以下特定版本的 Blob ` template class Blob { typedef typename std::vector::size_type size_type; Blob(); Blob(std::initializer_list il); //... } 当编译器从 Blob 模板中实例化一个类时，它会重写 Blob 模板，将参数 T 的每个实例替换成给定的模板实参 一个类模板的每个实例都形成一个独立的类，类型 Blob 与其他任何 Blob类型都没有关系，也不会对任何其他 Blob 类型的成员具有特殊的访问权限 类模板的成员函数与其他类一样，既可以在类模板内部，也可以在外部定义其成员函数，且定义在类模板内的成员函数被隐式声明为内联函数 类模板的成员函数本身是一个普通函数 每个类模板的实例都有自己版本的成员函数 类模板的成员函数具有和模板相同的模板参数 定义在类模板之外的成员函数就必须以关键字 template 开始，后接参数列表 简单说就是在类模板内部定义成员函数，可以直接使用参数 T，而在类模板外部定义成员函数，前面需要加上 template 等 template ret-type Blob::member-name(parm-list) 这里必须加上 template 这行 类模板成员函数实例化默认情况下，类模板的成员函数只有当程序使用它的时候才进行实例化 // 实例化Blob和接受initializer_list的构造函数 Blob squares = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; for (size_t i = 0; i != squares.size(); ++i) { squares[i] = i * i; //实例化Blob::operator[](size_t) } 如果一个成员函数没有被使用，则它不会被实例化 类代码内简化模板类名的使用在使用一个类模板类型时必须提供模板实参，但是在类模板自己的作用域中，可以直接使用模板名而不提供实参 template class BlobPtr { public: BlobPtr() : curr(0) {} //其他构造函数 T\u0026 operator*() const { auto p = check(curr, \"derederence past edn\"); return (*p)[curr]; } //递增和递减 BlobPtr\u0026 operator++(); //求值运算符 BlobPtr\u0026 operator--(); private: //其他成员 std::size_t curr; //数组中的位置 } 这里前置递增和递减成员返回的时 BlobPtr\u0026，而不是 BlobPtr\u0026，在类模板作用域中，编译器处理模板自身引用会自动提供模板匹配的实参 类模板外使用类模板名在类模板外定义成员时，此时不在类的作用域，直到遇见类名菜进入类的作用域 //后置++版本 template BlobPtr BlobPtr::operator++(int) { BlobPtr ret = *this; ++*this; return ret; } 返回类型位于类的作用域之外，所以必须指出返回类型是一个实例化的 BlobPtr，在函数体内已经进入类的作用域，则定义 ret 时无须重复提供模板实参，如果不通过模板实参，编译器假定使用的类型与成员实例化所用类型一致，等价于：BlobPtr ret = *this; 类模板和友元 一个类包含一个友元声明，类与友元各自是否是模板是互相无关的 如果一个模板包括一个非模板友元，则友元可以访问所以模板实例 如果友元自身也是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例 一对一友好关系类模板与另一个（类或函数）模板间友好关系的最常见的形式是建立对应实例及其友元间的友好关系。例如，我们的 Blob 类应该将 BlobPtr 类和一个模板版本的 Blob template class BlobPtr; //需要提前声明 template class Blob; template bool operator==(const Blob\u0026, const Blob\u0026); template class Blob { friend class BlobPtr; friend bool operator== (const Blob\u0026, const Blob\u0026); //其他成员 } 友元的声明用 Blob 的模板形参作为自己的模板实参，友好关系被限定在相同类型实例化的 Blob 和 BlobPtr 相等运算符之间 //BlobPtr和operator==都是本对象的友元 Blob ca; //BlobPtr和operator==都是本对象的友元 Blob ia; 上面例子中，ca 对 ia 或其他实例没有特殊访问权限 通用和特定模板的友好关系一个类也可以将另一个模板的每个实例都声明为自己的友元，或者限定特定的实例为友元 template class Pal; class C { //C是普通非模板类 friend class Pal;//C实例化Pal是C的友元 //Pal2的所有实例都是C的友元，这种情况无须前置声明 template friend class Pal2; }; template class C2 {//C2是个模板类 //C2每个实例将相同实例的Pal声明为友元 friend class Pal; //Pal2所有实例都是C2每个实例的友元，不需要前置声明 template friend class Pal2; //Pal3是一个非模板类，它是C2所有实例的友元 friend class Pal3; }; 为了让所有实例都成为友元，友元声明中必须使用与类模板不同的模板参数 令模板自己的类型参数成为友元在C++11新标准中，可以将模板类型参数声明为友元 template class Bar { friend Type; //访问权限授予实例化Bar的类型 //... } 此时，对于某个类型 Foo，Foo 将称为 Bar 的友元，Sales_data 将成为 Bar 的友元 模板类型别名类模板一个实例定义了一个类类型，我们可以定义一个 typedef 来引用实例化的类： typedef Blob StrBlob; 由于模板不是一个类型，我们不能定义一个 typedef 引用一个模板，即不能定义一个 typedef 引用 Blob 但是新标准允许为类模板定义一个类型别名： templateusing twin = pair; twin authors; //authors是一个pair使用别名时，也需要像模板那样指出特定类型的 twin 使用一个模板类型别名时，可以固定一个或多个模板参数 template using partNo = pair; partNo books; /","date":"2022-05-07","objectID":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/:1:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十六章 模板与泛型编程","uri":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/#定义类模板"},{"categories":["C++"],"content":"16.1.2 类模板类模板用来生成类的蓝图，类模板必须提供额外的信息，来确定模板的参数类型，一般在模板名后尖括号中提供实参 定义类模板 template class Blob { public: typedef T value_type; typedef typename std::vector::size_type size_type; //构造函数 Blob(); Blob(std::initializer_list il); //Blob中元素数目 size_type size() const { return data-size(); } bool empty() const { return data-empty(); } void push_back(const T\u0026 t) { return data-push_back(t);} void pop_back(); //元素访问 T\u0026 back(); T\u0026 operator[](size_type i); private: std::shared_ptr data; //若data[i]无效，抛出msg void check(size_type i, const std::string \u0026msg) const; }； 实例化类模板使用一个类模板时，需要提供额外信息，这些额外信息是显示模板实参列表，它们被绑定到模板参数 //使用类模板，必须提供元素类型 Blob ia; Blob ia2 = {0, 1, 2, 3}; ia 和 ia2会实例化以下特定版本的 Blob ` template class Blob { typedef typename std::vector::size_type size_type; Blob(); Blob(std::initializer_list il); //... } 当编译器从 Blob 模板中实例化一个类时，它会重写 Blob 模板，将参数 T 的每个实例替换成给定的模板实参 一个类模板的每个实例都形成一个独立的类，类型 Blob 与其他任何 Blob类型都没有关系，也不会对任何其他 Blob 类型的成员具有特殊的访问权限 类模板的成员函数与其他类一样，既可以在类模板内部，也可以在外部定义其成员函数，且定义在类模板内的成员函数被隐式声明为内联函数 类模板的成员函数本身是一个普通函数 每个类模板的实例都有自己版本的成员函数 类模板的成员函数具有和模板相同的模板参数 定义在类模板之外的成员函数就必须以关键字 template 开始，后接参数列表 简单说就是在类模板内部定义成员函数，可以直接使用参数 T，而在类模板外部定义成员函数，前面需要加上 template 等 template ret-type Blob::member-name(parm-list) 这里必须加上 template 这行 类模板成员函数实例化默认情况下，类模板的成员函数只有当程序使用它的时候才进行实例化 // 实例化Blob和接受initializer_list的构造函数 Blob squares = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; for (size_t i = 0; i != squares.size(); ++i) { squares[i] = i * i; //实例化Blob::operator[](size_t) } 如果一个成员函数没有被使用，则它不会被实例化 类代码内简化模板类名的使用在使用一个类模板类型时必须提供模板实参，但是在类模板自己的作用域中，可以直接使用模板名而不提供实参 template class BlobPtr { public: BlobPtr() : curr(0) {} //其他构造函数 T\u0026 operator*() const { auto p = check(curr, \"derederence past edn\"); return (*p)[curr]; } //递增和递减 BlobPtr\u0026 operator++(); //求值运算符 BlobPtr\u0026 operator--(); private: //其他成员 std::size_t curr; //数组中的位置 } 这里前置递增和递减成员返回的时 BlobPtr\u0026，而不是 BlobPtr\u0026，在类模板作用域中，编译器处理模板自身引用会自动提供模板匹配的实参 类模板外使用类模板名在类模板外定义成员时，此时不在类的作用域，直到遇见类名菜进入类的作用域 //后置++版本 template BlobPtr BlobPtr::operator++(int) { BlobPtr ret = *this; ++*this; return ret; } 返回类型位于类的作用域之外，所以必须指出返回类型是一个实例化的 BlobPtr，在函数体内已经进入类的作用域，则定义 ret 时无须重复提供模板实参，如果不通过模板实参，编译器假定使用的类型与成员实例化所用类型一致，等价于：BlobPtr ret = *this; 类模板和友元 一个类包含一个友元声明，类与友元各自是否是模板是互相无关的 如果一个模板包括一个非模板友元，则友元可以访问所以模板实例 如果友元自身也是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例 一对一友好关系类模板与另一个（类或函数）模板间友好关系的最常见的形式是建立对应实例及其友元间的友好关系。例如，我们的 Blob 类应该将 BlobPtr 类和一个模板版本的 Blob template class BlobPtr; //需要提前声明 template class Blob; template bool operator==(const Blob\u0026, const Blob\u0026); template class Blob { friend class BlobPtr; friend bool operator== (const Blob\u0026, const Blob\u0026); //其他成员 } 友元的声明用 Blob 的模板形参作为自己的模板实参，友好关系被限定在相同类型实例化的 Blob 和 BlobPtr 相等运算符之间 //BlobPtr和operator==都是本对象的友元 Blob ca; //BlobPtr和operator==都是本对象的友元 Blob ia; 上面例子中，ca 对 ia 或其他实例没有特殊访问权限 通用和特定模板的友好关系一个类也可以将另一个模板的每个实例都声明为自己的友元，或者限定特定的实例为友元 template class Pal; class C { //C是普通非模板类 friend class Pal;//C实例化Pal是C的友元 //Pal2的所有实例都是C的友元，这种情况无须前置声明 template friend class Pal2; }; template class C2 {//C2是个模板类 //C2每个实例将相同实例的Pal声明为友元 friend class Pal; //Pal2所有实例都是C2每个实例的友元，不需要前置声明 template friend class Pal2; //Pal3是一个非模板类，它是C2所有实例的友元 friend class Pal3; }; 为了让所有实例都成为友元，友元声明中必须使用与类模板不同的模板参数 令模板自己的类型参数成为友元在C++11新标准中，可以将模板类型参数声明为友元 template class Bar { friend Type; //访问权限授予实例化Bar的类型 //... } 此时，对于某个类型 Foo，Foo 将称为 Bar 的友元，Sales_data 将成为 Bar 的友元 模板类型别名类模板一个实例定义了一个类类型，我们可以定义一个 typedef 来引用实例化的类： typedef Blob StrBlob; 由于模板不是一个类型，我们不能定义一个 typedef 引用一个模板，即不能定义一个 typedef 引用 Blob 但是新标准允许为类模板定义一个类型别名： templateusing twin = pair; twin authors; //authors是一个pair使用别名时，也需要像模板那样指出特定类型的 twin 使用一个模板类型别名时，可以固定一个或多个模板参数 template using partNo = pair; partNo books; /","date":"2022-05-07","objectID":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/:1:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十六章 模板与泛型编程","uri":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/#实例化类模板"},{"categories":["C++"],"content":"16.1.2 类模板类模板用来生成类的蓝图，类模板必须提供额外的信息，来确定模板的参数类型，一般在模板名后尖括号中提供实参 定义类模板 template class Blob { public: typedef T value_type; typedef typename std::vector::size_type size_type; //构造函数 Blob(); Blob(std::initializer_list il); //Blob中元素数目 size_type size() const { return data-size(); } bool empty() const { return data-empty(); } void push_back(const T\u0026 t) { return data-push_back(t);} void pop_back(); //元素访问 T\u0026 back(); T\u0026 operator[](size_type i); private: std::shared_ptr data; //若data[i]无效，抛出msg void check(size_type i, const std::string \u0026msg) const; }； 实例化类模板使用一个类模板时，需要提供额外信息，这些额外信息是显示模板实参列表，它们被绑定到模板参数 //使用类模板，必须提供元素类型 Blob ia; Blob ia2 = {0, 1, 2, 3}; ia 和 ia2会实例化以下特定版本的 Blob ` template class Blob { typedef typename std::vector::size_type size_type; Blob(); Blob(std::initializer_list il); //... } 当编译器从 Blob 模板中实例化一个类时，它会重写 Blob 模板，将参数 T 的每个实例替换成给定的模板实参 一个类模板的每个实例都形成一个独立的类，类型 Blob 与其他任何 Blob类型都没有关系，也不会对任何其他 Blob 类型的成员具有特殊的访问权限 类模板的成员函数与其他类一样，既可以在类模板内部，也可以在外部定义其成员函数，且定义在类模板内的成员函数被隐式声明为内联函数 类模板的成员函数本身是一个普通函数 每个类模板的实例都有自己版本的成员函数 类模板的成员函数具有和模板相同的模板参数 定义在类模板之外的成员函数就必须以关键字 template 开始，后接参数列表 简单说就是在类模板内部定义成员函数，可以直接使用参数 T，而在类模板外部定义成员函数，前面需要加上 template 等 template ret-type Blob::member-name(parm-list) 这里必须加上 template 这行 类模板成员函数实例化默认情况下，类模板的成员函数只有当程序使用它的时候才进行实例化 // 实例化Blob和接受initializer_list的构造函数 Blob squares = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; for (size_t i = 0; i != squares.size(); ++i) { squares[i] = i * i; //实例化Blob::operator[](size_t) } 如果一个成员函数没有被使用，则它不会被实例化 类代码内简化模板类名的使用在使用一个类模板类型时必须提供模板实参，但是在类模板自己的作用域中，可以直接使用模板名而不提供实参 template class BlobPtr { public: BlobPtr() : curr(0) {} //其他构造函数 T\u0026 operator*() const { auto p = check(curr, \"derederence past edn\"); return (*p)[curr]; } //递增和递减 BlobPtr\u0026 operator++(); //求值运算符 BlobPtr\u0026 operator--(); private: //其他成员 std::size_t curr; //数组中的位置 } 这里前置递增和递减成员返回的时 BlobPtr\u0026，而不是 BlobPtr\u0026，在类模板作用域中，编译器处理模板自身引用会自动提供模板匹配的实参 类模板外使用类模板名在类模板外定义成员时，此时不在类的作用域，直到遇见类名菜进入类的作用域 //后置++版本 template BlobPtr BlobPtr::operator++(int) { BlobPtr ret = *this; ++*this; return ret; } 返回类型位于类的作用域之外，所以必须指出返回类型是一个实例化的 BlobPtr，在函数体内已经进入类的作用域，则定义 ret 时无须重复提供模板实参，如果不通过模板实参，编译器假定使用的类型与成员实例化所用类型一致，等价于：BlobPtr ret = *this; 类模板和友元 一个类包含一个友元声明，类与友元各自是否是模板是互相无关的 如果一个模板包括一个非模板友元，则友元可以访问所以模板实例 如果友元自身也是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例 一对一友好关系类模板与另一个（类或函数）模板间友好关系的最常见的形式是建立对应实例及其友元间的友好关系。例如，我们的 Blob 类应该将 BlobPtr 类和一个模板版本的 Blob template class BlobPtr; //需要提前声明 template class Blob; template bool operator==(const Blob\u0026, const Blob\u0026); template class Blob { friend class BlobPtr; friend bool operator== (const Blob\u0026, const Blob\u0026); //其他成员 } 友元的声明用 Blob 的模板形参作为自己的模板实参，友好关系被限定在相同类型实例化的 Blob 和 BlobPtr 相等运算符之间 //BlobPtr和operator==都是本对象的友元 Blob ca; //BlobPtr和operator==都是本对象的友元 Blob ia; 上面例子中，ca 对 ia 或其他实例没有特殊访问权限 通用和特定模板的友好关系一个类也可以将另一个模板的每个实例都声明为自己的友元，或者限定特定的实例为友元 template class Pal; class C { //C是普通非模板类 friend class Pal;//C实例化Pal是C的友元 //Pal2的所有实例都是C的友元，这种情况无须前置声明 template friend class Pal2; }; template class C2 {//C2是个模板类 //C2每个实例将相同实例的Pal声明为友元 friend class Pal; //Pal2所有实例都是C2每个实例的友元，不需要前置声明 template friend class Pal2; //Pal3是一个非模板类，它是C2所有实例的友元 friend class Pal3; }; 为了让所有实例都成为友元，友元声明中必须使用与类模板不同的模板参数 令模板自己的类型参数成为友元在C++11新标准中，可以将模板类型参数声明为友元 template class Bar { friend Type; //访问权限授予实例化Bar的类型 //... } 此时，对于某个类型 Foo，Foo 将称为 Bar 的友元，Sales_data 将成为 Bar 的友元 模板类型别名类模板一个实例定义了一个类类型，我们可以定义一个 typedef 来引用实例化的类： typedef Blob StrBlob; 由于模板不是一个类型，我们不能定义一个 typedef 引用一个模板，即不能定义一个 typedef 引用 Blob 但是新标准允许为类模板定义一个类型别名： templateusing twin = pair; twin authors; //authors是一个pair使用别名时，也需要像模板那样指出特定类型的 twin 使用一个模板类型别名时，可以固定一个或多个模板参数 template using partNo = pair; partNo books; /","date":"2022-05-07","objectID":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/:1:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十六章 模板与泛型编程","uri":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/#类模板的成员函数"},{"categories":["C++"],"content":"16.1.2 类模板类模板用来生成类的蓝图，类模板必须提供额外的信息，来确定模板的参数类型，一般在模板名后尖括号中提供实参 定义类模板 template class Blob { public: typedef T value_type; typedef typename std::vector::size_type size_type; //构造函数 Blob(); Blob(std::initializer_list il); //Blob中元素数目 size_type size() const { return data-size(); } bool empty() const { return data-empty(); } void push_back(const T\u0026 t) { return data-push_back(t);} void pop_back(); //元素访问 T\u0026 back(); T\u0026 operator[](size_type i); private: std::shared_ptr data; //若data[i]无效，抛出msg void check(size_type i, const std::string \u0026msg) const; }； 实例化类模板使用一个类模板时，需要提供额外信息，这些额外信息是显示模板实参列表，它们被绑定到模板参数 //使用类模板，必须提供元素类型 Blob ia; Blob ia2 = {0, 1, 2, 3}; ia 和 ia2会实例化以下特定版本的 Blob ` template class Blob { typedef typename std::vector::size_type size_type; Blob(); Blob(std::initializer_list il); //... } 当编译器从 Blob 模板中实例化一个类时，它会重写 Blob 模板，将参数 T 的每个实例替换成给定的模板实参 一个类模板的每个实例都形成一个独立的类，类型 Blob 与其他任何 Blob类型都没有关系，也不会对任何其他 Blob 类型的成员具有特殊的访问权限 类模板的成员函数与其他类一样，既可以在类模板内部，也可以在外部定义其成员函数，且定义在类模板内的成员函数被隐式声明为内联函数 类模板的成员函数本身是一个普通函数 每个类模板的实例都有自己版本的成员函数 类模板的成员函数具有和模板相同的模板参数 定义在类模板之外的成员函数就必须以关键字 template 开始，后接参数列表 简单说就是在类模板内部定义成员函数，可以直接使用参数 T，而在类模板外部定义成员函数，前面需要加上 template 等 template ret-type Blob::member-name(parm-list) 这里必须加上 template 这行 类模板成员函数实例化默认情况下，类模板的成员函数只有当程序使用它的时候才进行实例化 // 实例化Blob和接受initializer_list的构造函数 Blob squares = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; for (size_t i = 0; i != squares.size(); ++i) { squares[i] = i * i; //实例化Blob::operator[](size_t) } 如果一个成员函数没有被使用，则它不会被实例化 类代码内简化模板类名的使用在使用一个类模板类型时必须提供模板实参，但是在类模板自己的作用域中，可以直接使用模板名而不提供实参 template class BlobPtr { public: BlobPtr() : curr(0) {} //其他构造函数 T\u0026 operator*() const { auto p = check(curr, \"derederence past edn\"); return (*p)[curr]; } //递增和递减 BlobPtr\u0026 operator++(); //求值运算符 BlobPtr\u0026 operator--(); private: //其他成员 std::size_t curr; //数组中的位置 } 这里前置递增和递减成员返回的时 BlobPtr\u0026，而不是 BlobPtr\u0026，在类模板作用域中，编译器处理模板自身引用会自动提供模板匹配的实参 类模板外使用类模板名在类模板外定义成员时，此时不在类的作用域，直到遇见类名菜进入类的作用域 //后置++版本 template BlobPtr BlobPtr::operator++(int) { BlobPtr ret = *this; ++*this; return ret; } 返回类型位于类的作用域之外，所以必须指出返回类型是一个实例化的 BlobPtr，在函数体内已经进入类的作用域，则定义 ret 时无须重复提供模板实参，如果不通过模板实参，编译器假定使用的类型与成员实例化所用类型一致，等价于：BlobPtr ret = *this; 类模板和友元 一个类包含一个友元声明，类与友元各自是否是模板是互相无关的 如果一个模板包括一个非模板友元，则友元可以访问所以模板实例 如果友元自身也是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例 一对一友好关系类模板与另一个（类或函数）模板间友好关系的最常见的形式是建立对应实例及其友元间的友好关系。例如，我们的 Blob 类应该将 BlobPtr 类和一个模板版本的 Blob template class BlobPtr; //需要提前声明 template class Blob; template bool operator==(const Blob\u0026, const Blob\u0026); template class Blob { friend class BlobPtr; friend bool operator== (const Blob\u0026, const Blob\u0026); //其他成员 } 友元的声明用 Blob 的模板形参作为自己的模板实参，友好关系被限定在相同类型实例化的 Blob 和 BlobPtr 相等运算符之间 //BlobPtr和operator==都是本对象的友元 Blob ca; //BlobPtr和operator==都是本对象的友元 Blob ia; 上面例子中，ca 对 ia 或其他实例没有特殊访问权限 通用和特定模板的友好关系一个类也可以将另一个模板的每个实例都声明为自己的友元，或者限定特定的实例为友元 template class Pal; class C { //C是普通非模板类 friend class Pal;//C实例化Pal是C的友元 //Pal2的所有实例都是C的友元，这种情况无须前置声明 template friend class Pal2; }; template class C2 {//C2是个模板类 //C2每个实例将相同实例的Pal声明为友元 friend class Pal; //Pal2所有实例都是C2每个实例的友元，不需要前置声明 template friend class Pal2; //Pal3是一个非模板类，它是C2所有实例的友元 friend class Pal3; }; 为了让所有实例都成为友元，友元声明中必须使用与类模板不同的模板参数 令模板自己的类型参数成为友元在C++11新标准中，可以将模板类型参数声明为友元 template class Bar { friend Type; //访问权限授予实例化Bar的类型 //... } 此时，对于某个类型 Foo，Foo 将称为 Bar 的友元，Sales_data 将成为 Bar 的友元 模板类型别名类模板一个实例定义了一个类类型，我们可以定义一个 typedef 来引用实例化的类： typedef Blob StrBlob; 由于模板不是一个类型，我们不能定义一个 typedef 引用一个模板，即不能定义一个 typedef 引用 Blob 但是新标准允许为类模板定义一个类型别名： templateusing twin = pair; twin authors; //authors是一个pair使用别名时，也需要像模板那样指出特定类型的 twin 使用一个模板类型别名时，可以固定一个或多个模板参数 template using partNo = pair; partNo books; /","date":"2022-05-07","objectID":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/:1:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十六章 模板与泛型编程","uri":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/#类模板成员函数实例化"},{"categories":["C++"],"content":"16.1.2 类模板类模板用来生成类的蓝图，类模板必须提供额外的信息，来确定模板的参数类型，一般在模板名后尖括号中提供实参 定义类模板 template class Blob { public: typedef T value_type; typedef typename std::vector::size_type size_type; //构造函数 Blob(); Blob(std::initializer_list il); //Blob中元素数目 size_type size() const { return data-size(); } bool empty() const { return data-empty(); } void push_back(const T\u0026 t) { return data-push_back(t);} void pop_back(); //元素访问 T\u0026 back(); T\u0026 operator[](size_type i); private: std::shared_ptr data; //若data[i]无效，抛出msg void check(size_type i, const std::string \u0026msg) const; }； 实例化类模板使用一个类模板时，需要提供额外信息，这些额外信息是显示模板实参列表，它们被绑定到模板参数 //使用类模板，必须提供元素类型 Blob ia; Blob ia2 = {0, 1, 2, 3}; ia 和 ia2会实例化以下特定版本的 Blob ` template class Blob { typedef typename std::vector::size_type size_type; Blob(); Blob(std::initializer_list il); //... } 当编译器从 Blob 模板中实例化一个类时，它会重写 Blob 模板，将参数 T 的每个实例替换成给定的模板实参 一个类模板的每个实例都形成一个独立的类，类型 Blob 与其他任何 Blob类型都没有关系，也不会对任何其他 Blob 类型的成员具有特殊的访问权限 类模板的成员函数与其他类一样，既可以在类模板内部，也可以在外部定义其成员函数，且定义在类模板内的成员函数被隐式声明为内联函数 类模板的成员函数本身是一个普通函数 每个类模板的实例都有自己版本的成员函数 类模板的成员函数具有和模板相同的模板参数 定义在类模板之外的成员函数就必须以关键字 template 开始，后接参数列表 简单说就是在类模板内部定义成员函数，可以直接使用参数 T，而在类模板外部定义成员函数，前面需要加上 template 等 template ret-type Blob::member-name(parm-list) 这里必须加上 template 这行 类模板成员函数实例化默认情况下，类模板的成员函数只有当程序使用它的时候才进行实例化 // 实例化Blob和接受initializer_list的构造函数 Blob squares = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; for (size_t i = 0; i != squares.size(); ++i) { squares[i] = i * i; //实例化Blob::operator[](size_t) } 如果一个成员函数没有被使用，则它不会被实例化 类代码内简化模板类名的使用在使用一个类模板类型时必须提供模板实参，但是在类模板自己的作用域中，可以直接使用模板名而不提供实参 template class BlobPtr { public: BlobPtr() : curr(0) {} //其他构造函数 T\u0026 operator*() const { auto p = check(curr, \"derederence past edn\"); return (*p)[curr]; } //递增和递减 BlobPtr\u0026 operator++(); //求值运算符 BlobPtr\u0026 operator--(); private: //其他成员 std::size_t curr; //数组中的位置 } 这里前置递增和递减成员返回的时 BlobPtr\u0026，而不是 BlobPtr\u0026，在类模板作用域中，编译器处理模板自身引用会自动提供模板匹配的实参 类模板外使用类模板名在类模板外定义成员时，此时不在类的作用域，直到遇见类名菜进入类的作用域 //后置++版本 template BlobPtr BlobPtr::operator++(int) { BlobPtr ret = *this; ++*this; return ret; } 返回类型位于类的作用域之外，所以必须指出返回类型是一个实例化的 BlobPtr，在函数体内已经进入类的作用域，则定义 ret 时无须重复提供模板实参，如果不通过模板实参，编译器假定使用的类型与成员实例化所用类型一致，等价于：BlobPtr ret = *this; 类模板和友元 一个类包含一个友元声明，类与友元各自是否是模板是互相无关的 如果一个模板包括一个非模板友元，则友元可以访问所以模板实例 如果友元自身也是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例 一对一友好关系类模板与另一个（类或函数）模板间友好关系的最常见的形式是建立对应实例及其友元间的友好关系。例如，我们的 Blob 类应该将 BlobPtr 类和一个模板版本的 Blob template class BlobPtr; //需要提前声明 template class Blob; template bool operator==(const Blob\u0026, const Blob\u0026); template class Blob { friend class BlobPtr; friend bool operator== (const Blob\u0026, const Blob\u0026); //其他成员 } 友元的声明用 Blob 的模板形参作为自己的模板实参，友好关系被限定在相同类型实例化的 Blob 和 BlobPtr 相等运算符之间 //BlobPtr和operator==都是本对象的友元 Blob ca; //BlobPtr和operator==都是本对象的友元 Blob ia; 上面例子中，ca 对 ia 或其他实例没有特殊访问权限 通用和特定模板的友好关系一个类也可以将另一个模板的每个实例都声明为自己的友元，或者限定特定的实例为友元 template class Pal; class C { //C是普通非模板类 friend class Pal;//C实例化Pal是C的友元 //Pal2的所有实例都是C的友元，这种情况无须前置声明 template friend class Pal2; }; template class C2 {//C2是个模板类 //C2每个实例将相同实例的Pal声明为友元 friend class Pal; //Pal2所有实例都是C2每个实例的友元，不需要前置声明 template friend class Pal2; //Pal3是一个非模板类，它是C2所有实例的友元 friend class Pal3; }; 为了让所有实例都成为友元，友元声明中必须使用与类模板不同的模板参数 令模板自己的类型参数成为友元在C++11新标准中，可以将模板类型参数声明为友元 template class Bar { friend Type; //访问权限授予实例化Bar的类型 //... } 此时，对于某个类型 Foo，Foo 将称为 Bar 的友元，Sales_data 将成为 Bar 的友元 模板类型别名类模板一个实例定义了一个类类型，我们可以定义一个 typedef 来引用实例化的类： typedef Blob StrBlob; 由于模板不是一个类型，我们不能定义一个 typedef 引用一个模板，即不能定义一个 typedef 引用 Blob 但是新标准允许为类模板定义一个类型别名： templateusing twin = pair; twin authors; //authors是一个pair使用别名时，也需要像模板那样指出特定类型的 twin 使用一个模板类型别名时，可以固定一个或多个模板参数 template using partNo = pair; partNo books; /","date":"2022-05-07","objectID":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/:1:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十六章 模板与泛型编程","uri":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/#类代码内简化模板类名的使用"},{"categories":["C++"],"content":"16.1.2 类模板类模板用来生成类的蓝图，类模板必须提供额外的信息，来确定模板的参数类型，一般在模板名后尖括号中提供实参 定义类模板 template class Blob { public: typedef T value_type; typedef typename std::vector::size_type size_type; //构造函数 Blob(); Blob(std::initializer_list il); //Blob中元素数目 size_type size() const { return data-size(); } bool empty() const { return data-empty(); } void push_back(const T\u0026 t) { return data-push_back(t);} void pop_back(); //元素访问 T\u0026 back(); T\u0026 operator[](size_type i); private: std::shared_ptr data; //若data[i]无效，抛出msg void check(size_type i, const std::string \u0026msg) const; }； 实例化类模板使用一个类模板时，需要提供额外信息，这些额外信息是显示模板实参列表，它们被绑定到模板参数 //使用类模板，必须提供元素类型 Blob ia; Blob ia2 = {0, 1, 2, 3}; ia 和 ia2会实例化以下特定版本的 Blob ` template class Blob { typedef typename std::vector::size_type size_type; Blob(); Blob(std::initializer_list il); //... } 当编译器从 Blob 模板中实例化一个类时，它会重写 Blob 模板，将参数 T 的每个实例替换成给定的模板实参 一个类模板的每个实例都形成一个独立的类，类型 Blob 与其他任何 Blob类型都没有关系，也不会对任何其他 Blob 类型的成员具有特殊的访问权限 类模板的成员函数与其他类一样，既可以在类模板内部，也可以在外部定义其成员函数，且定义在类模板内的成员函数被隐式声明为内联函数 类模板的成员函数本身是一个普通函数 每个类模板的实例都有自己版本的成员函数 类模板的成员函数具有和模板相同的模板参数 定义在类模板之外的成员函数就必须以关键字 template 开始，后接参数列表 简单说就是在类模板内部定义成员函数，可以直接使用参数 T，而在类模板外部定义成员函数，前面需要加上 template 等 template ret-type Blob::member-name(parm-list) 这里必须加上 template 这行 类模板成员函数实例化默认情况下，类模板的成员函数只有当程序使用它的时候才进行实例化 // 实例化Blob和接受initializer_list的构造函数 Blob squares = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; for (size_t i = 0; i != squares.size(); ++i) { squares[i] = i * i; //实例化Blob::operator[](size_t) } 如果一个成员函数没有被使用，则它不会被实例化 类代码内简化模板类名的使用在使用一个类模板类型时必须提供模板实参，但是在类模板自己的作用域中，可以直接使用模板名而不提供实参 template class BlobPtr { public: BlobPtr() : curr(0) {} //其他构造函数 T\u0026 operator*() const { auto p = check(curr, \"derederence past edn\"); return (*p)[curr]; } //递增和递减 BlobPtr\u0026 operator++(); //求值运算符 BlobPtr\u0026 operator--(); private: //其他成员 std::size_t curr; //数组中的位置 } 这里前置递增和递减成员返回的时 BlobPtr\u0026，而不是 BlobPtr\u0026，在类模板作用域中，编译器处理模板自身引用会自动提供模板匹配的实参 类模板外使用类模板名在类模板外定义成员时，此时不在类的作用域，直到遇见类名菜进入类的作用域 //后置++版本 template BlobPtr BlobPtr::operator++(int) { BlobPtr ret = *this; ++*this; return ret; } 返回类型位于类的作用域之外，所以必须指出返回类型是一个实例化的 BlobPtr，在函数体内已经进入类的作用域，则定义 ret 时无须重复提供模板实参，如果不通过模板实参，编译器假定使用的类型与成员实例化所用类型一致，等价于：BlobPtr ret = *this; 类模板和友元 一个类包含一个友元声明，类与友元各自是否是模板是互相无关的 如果一个模板包括一个非模板友元，则友元可以访问所以模板实例 如果友元自身也是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例 一对一友好关系类模板与另一个（类或函数）模板间友好关系的最常见的形式是建立对应实例及其友元间的友好关系。例如，我们的 Blob 类应该将 BlobPtr 类和一个模板版本的 Blob template class BlobPtr; //需要提前声明 template class Blob; template bool operator==(const Blob\u0026, const Blob\u0026); template class Blob { friend class BlobPtr; friend bool operator== (const Blob\u0026, const Blob\u0026); //其他成员 } 友元的声明用 Blob 的模板形参作为自己的模板实参，友好关系被限定在相同类型实例化的 Blob 和 BlobPtr 相等运算符之间 //BlobPtr和operator==都是本对象的友元 Blob ca; //BlobPtr和operator==都是本对象的友元 Blob ia; 上面例子中，ca 对 ia 或其他实例没有特殊访问权限 通用和特定模板的友好关系一个类也可以将另一个模板的每个实例都声明为自己的友元，或者限定特定的实例为友元 template class Pal; class C { //C是普通非模板类 friend class Pal;//C实例化Pal是C的友元 //Pal2的所有实例都是C的友元，这种情况无须前置声明 template friend class Pal2; }; template class C2 {//C2是个模板类 //C2每个实例将相同实例的Pal声明为友元 friend class Pal; //Pal2所有实例都是C2每个实例的友元，不需要前置声明 template friend class Pal2; //Pal3是一个非模板类，它是C2所有实例的友元 friend class Pal3; }; 为了让所有实例都成为友元，友元声明中必须使用与类模板不同的模板参数 令模板自己的类型参数成为友元在C++11新标准中，可以将模板类型参数声明为友元 template class Bar { friend Type; //访问权限授予实例化Bar的类型 //... } 此时，对于某个类型 Foo，Foo 将称为 Bar 的友元，Sales_data 将成为 Bar 的友元 模板类型别名类模板一个实例定义了一个类类型，我们可以定义一个 typedef 来引用实例化的类： typedef Blob StrBlob; 由于模板不是一个类型，我们不能定义一个 typedef 引用一个模板，即不能定义一个 typedef 引用 Blob 但是新标准允许为类模板定义一个类型别名： templateusing twin = pair; twin authors; //authors是一个pair使用别名时，也需要像模板那样指出特定类型的 twin 使用一个模板类型别名时，可以固定一个或多个模板参数 template using partNo = pair; partNo books; /","date":"2022-05-07","objectID":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/:1:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十六章 模板与泛型编程","uri":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/#类模板外使用类模板名"},{"categories":["C++"],"content":"16.1.2 类模板类模板用来生成类的蓝图，类模板必须提供额外的信息，来确定模板的参数类型，一般在模板名后尖括号中提供实参 定义类模板 template class Blob { public: typedef T value_type; typedef typename std::vector::size_type size_type; //构造函数 Blob(); Blob(std::initializer_list il); //Blob中元素数目 size_type size() const { return data-size(); } bool empty() const { return data-empty(); } void push_back(const T\u0026 t) { return data-push_back(t);} void pop_back(); //元素访问 T\u0026 back(); T\u0026 operator[](size_type i); private: std::shared_ptr data; //若data[i]无效，抛出msg void check(size_type i, const std::string \u0026msg) const; }； 实例化类模板使用一个类模板时，需要提供额外信息，这些额外信息是显示模板实参列表，它们被绑定到模板参数 //使用类模板，必须提供元素类型 Blob ia; Blob ia2 = {0, 1, 2, 3}; ia 和 ia2会实例化以下特定版本的 Blob ` template class Blob { typedef typename std::vector::size_type size_type; Blob(); Blob(std::initializer_list il); //... } 当编译器从 Blob 模板中实例化一个类时，它会重写 Blob 模板，将参数 T 的每个实例替换成给定的模板实参 一个类模板的每个实例都形成一个独立的类，类型 Blob 与其他任何 Blob类型都没有关系，也不会对任何其他 Blob 类型的成员具有特殊的访问权限 类模板的成员函数与其他类一样，既可以在类模板内部，也可以在外部定义其成员函数，且定义在类模板内的成员函数被隐式声明为内联函数 类模板的成员函数本身是一个普通函数 每个类模板的实例都有自己版本的成员函数 类模板的成员函数具有和模板相同的模板参数 定义在类模板之外的成员函数就必须以关键字 template 开始，后接参数列表 简单说就是在类模板内部定义成员函数，可以直接使用参数 T，而在类模板外部定义成员函数，前面需要加上 template 等 template ret-type Blob::member-name(parm-list) 这里必须加上 template 这行 类模板成员函数实例化默认情况下，类模板的成员函数只有当程序使用它的时候才进行实例化 // 实例化Blob和接受initializer_list的构造函数 Blob squares = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; for (size_t i = 0; i != squares.size(); ++i) { squares[i] = i * i; //实例化Blob::operator[](size_t) } 如果一个成员函数没有被使用，则它不会被实例化 类代码内简化模板类名的使用在使用一个类模板类型时必须提供模板实参，但是在类模板自己的作用域中，可以直接使用模板名而不提供实参 template class BlobPtr { public: BlobPtr() : curr(0) {} //其他构造函数 T\u0026 operator*() const { auto p = check(curr, \"derederence past edn\"); return (*p)[curr]; } //递增和递减 BlobPtr\u0026 operator++(); //求值运算符 BlobPtr\u0026 operator--(); private: //其他成员 std::size_t curr; //数组中的位置 } 这里前置递增和递减成员返回的时 BlobPtr\u0026，而不是 BlobPtr\u0026，在类模板作用域中，编译器处理模板自身引用会自动提供模板匹配的实参 类模板外使用类模板名在类模板外定义成员时，此时不在类的作用域，直到遇见类名菜进入类的作用域 //后置++版本 template BlobPtr BlobPtr::operator++(int) { BlobPtr ret = *this; ++*this; return ret; } 返回类型位于类的作用域之外，所以必须指出返回类型是一个实例化的 BlobPtr，在函数体内已经进入类的作用域，则定义 ret 时无须重复提供模板实参，如果不通过模板实参，编译器假定使用的类型与成员实例化所用类型一致，等价于：BlobPtr ret = *this; 类模板和友元 一个类包含一个友元声明，类与友元各自是否是模板是互相无关的 如果一个模板包括一个非模板友元，则友元可以访问所以模板实例 如果友元自身也是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例 一对一友好关系类模板与另一个（类或函数）模板间友好关系的最常见的形式是建立对应实例及其友元间的友好关系。例如，我们的 Blob 类应该将 BlobPtr 类和一个模板版本的 Blob template class BlobPtr; //需要提前声明 template class Blob; template bool operator==(const Blob\u0026, const Blob\u0026); template class Blob { friend class BlobPtr; friend bool operator== (const Blob\u0026, const Blob\u0026); //其他成员 } 友元的声明用 Blob 的模板形参作为自己的模板实参，友好关系被限定在相同类型实例化的 Blob 和 BlobPtr 相等运算符之间 //BlobPtr和operator==都是本对象的友元 Blob ca; //BlobPtr和operator==都是本对象的友元 Blob ia; 上面例子中，ca 对 ia 或其他实例没有特殊访问权限 通用和特定模板的友好关系一个类也可以将另一个模板的每个实例都声明为自己的友元，或者限定特定的实例为友元 template class Pal; class C { //C是普通非模板类 friend class Pal;//C实例化Pal是C的友元 //Pal2的所有实例都是C的友元，这种情况无须前置声明 template friend class Pal2; }; template class C2 {//C2是个模板类 //C2每个实例将相同实例的Pal声明为友元 friend class Pal; //Pal2所有实例都是C2每个实例的友元，不需要前置声明 template friend class Pal2; //Pal3是一个非模板类，它是C2所有实例的友元 friend class Pal3; }; 为了让所有实例都成为友元，友元声明中必须使用与类模板不同的模板参数 令模板自己的类型参数成为友元在C++11新标准中，可以将模板类型参数声明为友元 template class Bar { friend Type; //访问权限授予实例化Bar的类型 //... } 此时，对于某个类型 Foo，Foo 将称为 Bar 的友元，Sales_data 将成为 Bar 的友元 模板类型别名类模板一个实例定义了一个类类型，我们可以定义一个 typedef 来引用实例化的类： typedef Blob StrBlob; 由于模板不是一个类型，我们不能定义一个 typedef 引用一个模板，即不能定义一个 typedef 引用 Blob 但是新标准允许为类模板定义一个类型别名： templateusing twin = pair; twin authors; //authors是一个pair使用别名时，也需要像模板那样指出特定类型的 twin 使用一个模板类型别名时，可以固定一个或多个模板参数 template using partNo = pair; partNo books; /","date":"2022-05-07","objectID":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/:1:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十六章 模板与泛型编程","uri":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/#类模板和友元"},{"categories":["C++"],"content":"16.1.2 类模板类模板用来生成类的蓝图，类模板必须提供额外的信息，来确定模板的参数类型，一般在模板名后尖括号中提供实参 定义类模板 template class Blob { public: typedef T value_type; typedef typename std::vector::size_type size_type; //构造函数 Blob(); Blob(std::initializer_list il); //Blob中元素数目 size_type size() const { return data-size(); } bool empty() const { return data-empty(); } void push_back(const T\u0026 t) { return data-push_back(t);} void pop_back(); //元素访问 T\u0026 back(); T\u0026 operator[](size_type i); private: std::shared_ptr data; //若data[i]无效，抛出msg void check(size_type i, const std::string \u0026msg) const; }； 实例化类模板使用一个类模板时，需要提供额外信息，这些额外信息是显示模板实参列表，它们被绑定到模板参数 //使用类模板，必须提供元素类型 Blob ia; Blob ia2 = {0, 1, 2, 3}; ia 和 ia2会实例化以下特定版本的 Blob ` template class Blob { typedef typename std::vector::size_type size_type; Blob(); Blob(std::initializer_list il); //... } 当编译器从 Blob 模板中实例化一个类时，它会重写 Blob 模板，将参数 T 的每个实例替换成给定的模板实参 一个类模板的每个实例都形成一个独立的类，类型 Blob 与其他任何 Blob类型都没有关系，也不会对任何其他 Blob 类型的成员具有特殊的访问权限 类模板的成员函数与其他类一样，既可以在类模板内部，也可以在外部定义其成员函数，且定义在类模板内的成员函数被隐式声明为内联函数 类模板的成员函数本身是一个普通函数 每个类模板的实例都有自己版本的成员函数 类模板的成员函数具有和模板相同的模板参数 定义在类模板之外的成员函数就必须以关键字 template 开始，后接参数列表 简单说就是在类模板内部定义成员函数，可以直接使用参数 T，而在类模板外部定义成员函数，前面需要加上 template 等 template ret-type Blob::member-name(parm-list) 这里必须加上 template 这行 类模板成员函数实例化默认情况下，类模板的成员函数只有当程序使用它的时候才进行实例化 // 实例化Blob和接受initializer_list的构造函数 Blob squares = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; for (size_t i = 0; i != squares.size(); ++i) { squares[i] = i * i; //实例化Blob::operator[](size_t) } 如果一个成员函数没有被使用，则它不会被实例化 类代码内简化模板类名的使用在使用一个类模板类型时必须提供模板实参，但是在类模板自己的作用域中，可以直接使用模板名而不提供实参 template class BlobPtr { public: BlobPtr() : curr(0) {} //其他构造函数 T\u0026 operator*() const { auto p = check(curr, \"derederence past edn\"); return (*p)[curr]; } //递增和递减 BlobPtr\u0026 operator++(); //求值运算符 BlobPtr\u0026 operator--(); private: //其他成员 std::size_t curr; //数组中的位置 } 这里前置递增和递减成员返回的时 BlobPtr\u0026，而不是 BlobPtr\u0026，在类模板作用域中，编译器处理模板自身引用会自动提供模板匹配的实参 类模板外使用类模板名在类模板外定义成员时，此时不在类的作用域，直到遇见类名菜进入类的作用域 //后置++版本 template BlobPtr BlobPtr::operator++(int) { BlobPtr ret = *this; ++*this; return ret; } 返回类型位于类的作用域之外，所以必须指出返回类型是一个实例化的 BlobPtr，在函数体内已经进入类的作用域，则定义 ret 时无须重复提供模板实参，如果不通过模板实参，编译器假定使用的类型与成员实例化所用类型一致，等价于：BlobPtr ret = *this; 类模板和友元 一个类包含一个友元声明，类与友元各自是否是模板是互相无关的 如果一个模板包括一个非模板友元，则友元可以访问所以模板实例 如果友元自身也是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例 一对一友好关系类模板与另一个（类或函数）模板间友好关系的最常见的形式是建立对应实例及其友元间的友好关系。例如，我们的 Blob 类应该将 BlobPtr 类和一个模板版本的 Blob template class BlobPtr; //需要提前声明 template class Blob; template bool operator==(const Blob\u0026, const Blob\u0026); template class Blob { friend class BlobPtr; friend bool operator== (const Blob\u0026, const Blob\u0026); //其他成员 } 友元的声明用 Blob 的模板形参作为自己的模板实参，友好关系被限定在相同类型实例化的 Blob 和 BlobPtr 相等运算符之间 //BlobPtr和operator==都是本对象的友元 Blob ca; //BlobPtr和operator==都是本对象的友元 Blob ia; 上面例子中，ca 对 ia 或其他实例没有特殊访问权限 通用和特定模板的友好关系一个类也可以将另一个模板的每个实例都声明为自己的友元，或者限定特定的实例为友元 template class Pal; class C { //C是普通非模板类 friend class Pal;//C实例化Pal是C的友元 //Pal2的所有实例都是C的友元，这种情况无须前置声明 template friend class Pal2; }; template class C2 {//C2是个模板类 //C2每个实例将相同实例的Pal声明为友元 friend class Pal; //Pal2所有实例都是C2每个实例的友元，不需要前置声明 template friend class Pal2; //Pal3是一个非模板类，它是C2所有实例的友元 friend class Pal3; }; 为了让所有实例都成为友元，友元声明中必须使用与类模板不同的模板参数 令模板自己的类型参数成为友元在C++11新标准中，可以将模板类型参数声明为友元 template class Bar { friend Type; //访问权限授予实例化Bar的类型 //... } 此时，对于某个类型 Foo，Foo 将称为 Bar 的友元，Sales_data 将成为 Bar 的友元 模板类型别名类模板一个实例定义了一个类类型，我们可以定义一个 typedef 来引用实例化的类： typedef Blob StrBlob; 由于模板不是一个类型，我们不能定义一个 typedef 引用一个模板，即不能定义一个 typedef 引用 Blob 但是新标准允许为类模板定义一个类型别名： templateusing twin = pair; twin authors; //authors是一个pair使用别名时，也需要像模板那样指出特定类型的 twin 使用一个模板类型别名时，可以固定一个或多个模板参数 template using partNo = pair; partNo books; /","date":"2022-05-07","objectID":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/:1:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十六章 模板与泛型编程","uri":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/#一对一友好关系"},{"categories":["C++"],"content":"16.1.2 类模板类模板用来生成类的蓝图，类模板必须提供额外的信息，来确定模板的参数类型，一般在模板名后尖括号中提供实参 定义类模板 template class Blob { public: typedef T value_type; typedef typename std::vector::size_type size_type; //构造函数 Blob(); Blob(std::initializer_list il); //Blob中元素数目 size_type size() const { return data-size(); } bool empty() const { return data-empty(); } void push_back(const T\u0026 t) { return data-push_back(t);} void pop_back(); //元素访问 T\u0026 back(); T\u0026 operator[](size_type i); private: std::shared_ptr data; //若data[i]无效，抛出msg void check(size_type i, const std::string \u0026msg) const; }； 实例化类模板使用一个类模板时，需要提供额外信息，这些额外信息是显示模板实参列表，它们被绑定到模板参数 //使用类模板，必须提供元素类型 Blob ia; Blob ia2 = {0, 1, 2, 3}; ia 和 ia2会实例化以下特定版本的 Blob ` template class Blob { typedef typename std::vector::size_type size_type; Blob(); Blob(std::initializer_list il); //... } 当编译器从 Blob 模板中实例化一个类时，它会重写 Blob 模板，将参数 T 的每个实例替换成给定的模板实参 一个类模板的每个实例都形成一个独立的类，类型 Blob 与其他任何 Blob类型都没有关系，也不会对任何其他 Blob 类型的成员具有特殊的访问权限 类模板的成员函数与其他类一样，既可以在类模板内部，也可以在外部定义其成员函数，且定义在类模板内的成员函数被隐式声明为内联函数 类模板的成员函数本身是一个普通函数 每个类模板的实例都有自己版本的成员函数 类模板的成员函数具有和模板相同的模板参数 定义在类模板之外的成员函数就必须以关键字 template 开始，后接参数列表 简单说就是在类模板内部定义成员函数，可以直接使用参数 T，而在类模板外部定义成员函数，前面需要加上 template 等 template ret-type Blob::member-name(parm-list) 这里必须加上 template 这行 类模板成员函数实例化默认情况下，类模板的成员函数只有当程序使用它的时候才进行实例化 // 实例化Blob和接受initializer_list的构造函数 Blob squares = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; for (size_t i = 0; i != squares.size(); ++i) { squares[i] = i * i; //实例化Blob::operator[](size_t) } 如果一个成员函数没有被使用，则它不会被实例化 类代码内简化模板类名的使用在使用一个类模板类型时必须提供模板实参，但是在类模板自己的作用域中，可以直接使用模板名而不提供实参 template class BlobPtr { public: BlobPtr() : curr(0) {} //其他构造函数 T\u0026 operator*() const { auto p = check(curr, \"derederence past edn\"); return (*p)[curr]; } //递增和递减 BlobPtr\u0026 operator++(); //求值运算符 BlobPtr\u0026 operator--(); private: //其他成员 std::size_t curr; //数组中的位置 } 这里前置递增和递减成员返回的时 BlobPtr\u0026，而不是 BlobPtr\u0026，在类模板作用域中，编译器处理模板自身引用会自动提供模板匹配的实参 类模板外使用类模板名在类模板外定义成员时，此时不在类的作用域，直到遇见类名菜进入类的作用域 //后置++版本 template BlobPtr BlobPtr::operator++(int) { BlobPtr ret = *this; ++*this; return ret; } 返回类型位于类的作用域之外，所以必须指出返回类型是一个实例化的 BlobPtr，在函数体内已经进入类的作用域，则定义 ret 时无须重复提供模板实参，如果不通过模板实参，编译器假定使用的类型与成员实例化所用类型一致，等价于：BlobPtr ret = *this; 类模板和友元 一个类包含一个友元声明，类与友元各自是否是模板是互相无关的 如果一个模板包括一个非模板友元，则友元可以访问所以模板实例 如果友元自身也是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例 一对一友好关系类模板与另一个（类或函数）模板间友好关系的最常见的形式是建立对应实例及其友元间的友好关系。例如，我们的 Blob 类应该将 BlobPtr 类和一个模板版本的 Blob template class BlobPtr; //需要提前声明 template class Blob; template bool operator==(const Blob\u0026, const Blob\u0026); template class Blob { friend class BlobPtr; friend bool operator== (const Blob\u0026, const Blob\u0026); //其他成员 } 友元的声明用 Blob 的模板形参作为自己的模板实参，友好关系被限定在相同类型实例化的 Blob 和 BlobPtr 相等运算符之间 //BlobPtr和operator==都是本对象的友元 Blob ca; //BlobPtr和operator==都是本对象的友元 Blob ia; 上面例子中，ca 对 ia 或其他实例没有特殊访问权限 通用和特定模板的友好关系一个类也可以将另一个模板的每个实例都声明为自己的友元，或者限定特定的实例为友元 template class Pal; class C { //C是普通非模板类 friend class Pal;//C实例化Pal是C的友元 //Pal2的所有实例都是C的友元，这种情况无须前置声明 template friend class Pal2; }; template class C2 {//C2是个模板类 //C2每个实例将相同实例的Pal声明为友元 friend class Pal; //Pal2所有实例都是C2每个实例的友元，不需要前置声明 template friend class Pal2; //Pal3是一个非模板类，它是C2所有实例的友元 friend class Pal3; }; 为了让所有实例都成为友元，友元声明中必须使用与类模板不同的模板参数 令模板自己的类型参数成为友元在C++11新标准中，可以将模板类型参数声明为友元 template class Bar { friend Type; //访问权限授予实例化Bar的类型 //... } 此时，对于某个类型 Foo，Foo 将称为 Bar 的友元，Sales_data 将成为 Bar 的友元 模板类型别名类模板一个实例定义了一个类类型，我们可以定义一个 typedef 来引用实例化的类： typedef Blob StrBlob; 由于模板不是一个类型，我们不能定义一个 typedef 引用一个模板，即不能定义一个 typedef 引用 Blob 但是新标准允许为类模板定义一个类型别名： templateusing twin = pair; twin authors; //authors是一个pair使用别名时，也需要像模板那样指出特定类型的 twin 使用一个模板类型别名时，可以固定一个或多个模板参数 template using partNo = pair; partNo books; /","date":"2022-05-07","objectID":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/:1:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十六章 模板与泛型编程","uri":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/#通用和特定模板的友好关系"},{"categories":["C++"],"content":"16.1.2 类模板类模板用来生成类的蓝图，类模板必须提供额外的信息，来确定模板的参数类型，一般在模板名后尖括号中提供实参 定义类模板 template class Blob { public: typedef T value_type; typedef typename std::vector::size_type size_type; //构造函数 Blob(); Blob(std::initializer_list il); //Blob中元素数目 size_type size() const { return data-size(); } bool empty() const { return data-empty(); } void push_back(const T\u0026 t) { return data-push_back(t);} void pop_back(); //元素访问 T\u0026 back(); T\u0026 operator[](size_type i); private: std::shared_ptr data; //若data[i]无效，抛出msg void check(size_type i, const std::string \u0026msg) const; }； 实例化类模板使用一个类模板时，需要提供额外信息，这些额外信息是显示模板实参列表，它们被绑定到模板参数 //使用类模板，必须提供元素类型 Blob ia; Blob ia2 = {0, 1, 2, 3}; ia 和 ia2会实例化以下特定版本的 Blob ` template class Blob { typedef typename std::vector::size_type size_type; Blob(); Blob(std::initializer_list il); //... } 当编译器从 Blob 模板中实例化一个类时，它会重写 Blob 模板，将参数 T 的每个实例替换成给定的模板实参 一个类模板的每个实例都形成一个独立的类，类型 Blob 与其他任何 Blob类型都没有关系，也不会对任何其他 Blob 类型的成员具有特殊的访问权限 类模板的成员函数与其他类一样，既可以在类模板内部，也可以在外部定义其成员函数，且定义在类模板内的成员函数被隐式声明为内联函数 类模板的成员函数本身是一个普通函数 每个类模板的实例都有自己版本的成员函数 类模板的成员函数具有和模板相同的模板参数 定义在类模板之外的成员函数就必须以关键字 template 开始，后接参数列表 简单说就是在类模板内部定义成员函数，可以直接使用参数 T，而在类模板外部定义成员函数，前面需要加上 template 等 template ret-type Blob::member-name(parm-list) 这里必须加上 template 这行 类模板成员函数实例化默认情况下，类模板的成员函数只有当程序使用它的时候才进行实例化 // 实例化Blob和接受initializer_list的构造函数 Blob squares = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; for (size_t i = 0; i != squares.size(); ++i) { squares[i] = i * i; //实例化Blob::operator[](size_t) } 如果一个成员函数没有被使用，则它不会被实例化 类代码内简化模板类名的使用在使用一个类模板类型时必须提供模板实参，但是在类模板自己的作用域中，可以直接使用模板名而不提供实参 template class BlobPtr { public: BlobPtr() : curr(0) {} //其他构造函数 T\u0026 operator*() const { auto p = check(curr, \"derederence past edn\"); return (*p)[curr]; } //递增和递减 BlobPtr\u0026 operator++(); //求值运算符 BlobPtr\u0026 operator--(); private: //其他成员 std::size_t curr; //数组中的位置 } 这里前置递增和递减成员返回的时 BlobPtr\u0026，而不是 BlobPtr\u0026，在类模板作用域中，编译器处理模板自身引用会自动提供模板匹配的实参 类模板外使用类模板名在类模板外定义成员时，此时不在类的作用域，直到遇见类名菜进入类的作用域 //后置++版本 template BlobPtr BlobPtr::operator++(int) { BlobPtr ret = *this; ++*this; return ret; } 返回类型位于类的作用域之外，所以必须指出返回类型是一个实例化的 BlobPtr，在函数体内已经进入类的作用域，则定义 ret 时无须重复提供模板实参，如果不通过模板实参，编译器假定使用的类型与成员实例化所用类型一致，等价于：BlobPtr ret = *this; 类模板和友元 一个类包含一个友元声明，类与友元各自是否是模板是互相无关的 如果一个模板包括一个非模板友元，则友元可以访问所以模板实例 如果友元自身也是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例 一对一友好关系类模板与另一个（类或函数）模板间友好关系的最常见的形式是建立对应实例及其友元间的友好关系。例如，我们的 Blob 类应该将 BlobPtr 类和一个模板版本的 Blob template class BlobPtr; //需要提前声明 template class Blob; template bool operator==(const Blob\u0026, const Blob\u0026); template class Blob { friend class BlobPtr; friend bool operator== (const Blob\u0026, const Blob\u0026); //其他成员 } 友元的声明用 Blob 的模板形参作为自己的模板实参，友好关系被限定在相同类型实例化的 Blob 和 BlobPtr 相等运算符之间 //BlobPtr和operator==都是本对象的友元 Blob ca; //BlobPtr和operator==都是本对象的友元 Blob ia; 上面例子中，ca 对 ia 或其他实例没有特殊访问权限 通用和特定模板的友好关系一个类也可以将另一个模板的每个实例都声明为自己的友元，或者限定特定的实例为友元 template class Pal; class C { //C是普通非模板类 friend class Pal;//C实例化Pal是C的友元 //Pal2的所有实例都是C的友元，这种情况无须前置声明 template friend class Pal2; }; template class C2 {//C2是个模板类 //C2每个实例将相同实例的Pal声明为友元 friend class Pal; //Pal2所有实例都是C2每个实例的友元，不需要前置声明 template friend class Pal2; //Pal3是一个非模板类，它是C2所有实例的友元 friend class Pal3; }; 为了让所有实例都成为友元，友元声明中必须使用与类模板不同的模板参数 令模板自己的类型参数成为友元在C++11新标准中，可以将模板类型参数声明为友元 template class Bar { friend Type; //访问权限授予实例化Bar的类型 //... } 此时，对于某个类型 Foo，Foo 将称为 Bar 的友元，Sales_data 将成为 Bar 的友元 模板类型别名类模板一个实例定义了一个类类型，我们可以定义一个 typedef 来引用实例化的类： typedef Blob StrBlob; 由于模板不是一个类型，我们不能定义一个 typedef 引用一个模板，即不能定义一个 typedef 引用 Blob 但是新标准允许为类模板定义一个类型别名： templateusing twin = pair; twin authors; //authors是一个pair使用别名时，也需要像模板那样指出特定类型的 twin 使用一个模板类型别名时，可以固定一个或多个模板参数 template using partNo = pair; partNo books; /","date":"2022-05-07","objectID":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/:1:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十六章 模板与泛型编程","uri":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/#令模板自己的类型参数成为友元"},{"categories":["C++"],"content":"16.1.2 类模板类模板用来生成类的蓝图，类模板必须提供额外的信息，来确定模板的参数类型，一般在模板名后尖括号中提供实参 定义类模板 template class Blob { public: typedef T value_type; typedef typename std::vector::size_type size_type; //构造函数 Blob(); Blob(std::initializer_list il); //Blob中元素数目 size_type size() const { return data-size(); } bool empty() const { return data-empty(); } void push_back(const T\u0026 t) { return data-push_back(t);} void pop_back(); //元素访问 T\u0026 back(); T\u0026 operator[](size_type i); private: std::shared_ptr data; //若data[i]无效，抛出msg void check(size_type i, const std::string \u0026msg) const; }； 实例化类模板使用一个类模板时，需要提供额外信息，这些额外信息是显示模板实参列表，它们被绑定到模板参数 //使用类模板，必须提供元素类型 Blob ia; Blob ia2 = {0, 1, 2, 3}; ia 和 ia2会实例化以下特定版本的 Blob ` template class Blob { typedef typename std::vector::size_type size_type; Blob(); Blob(std::initializer_list il); //... } 当编译器从 Blob 模板中实例化一个类时，它会重写 Blob 模板，将参数 T 的每个实例替换成给定的模板实参 一个类模板的每个实例都形成一个独立的类，类型 Blob 与其他任何 Blob类型都没有关系，也不会对任何其他 Blob 类型的成员具有特殊的访问权限 类模板的成员函数与其他类一样，既可以在类模板内部，也可以在外部定义其成员函数，且定义在类模板内的成员函数被隐式声明为内联函数 类模板的成员函数本身是一个普通函数 每个类模板的实例都有自己版本的成员函数 类模板的成员函数具有和模板相同的模板参数 定义在类模板之外的成员函数就必须以关键字 template 开始，后接参数列表 简单说就是在类模板内部定义成员函数，可以直接使用参数 T，而在类模板外部定义成员函数，前面需要加上 template 等 template ret-type Blob::member-name(parm-list) 这里必须加上 template 这行 类模板成员函数实例化默认情况下，类模板的成员函数只有当程序使用它的时候才进行实例化 // 实例化Blob和接受initializer_list的构造函数 Blob squares = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; for (size_t i = 0; i != squares.size(); ++i) { squares[i] = i * i; //实例化Blob::operator[](size_t) } 如果一个成员函数没有被使用，则它不会被实例化 类代码内简化模板类名的使用在使用一个类模板类型时必须提供模板实参，但是在类模板自己的作用域中，可以直接使用模板名而不提供实参 template class BlobPtr { public: BlobPtr() : curr(0) {} //其他构造函数 T\u0026 operator*() const { auto p = check(curr, \"derederence past edn\"); return (*p)[curr]; } //递增和递减 BlobPtr\u0026 operator++(); //求值运算符 BlobPtr\u0026 operator--(); private: //其他成员 std::size_t curr; //数组中的位置 } 这里前置递增和递减成员返回的时 BlobPtr\u0026，而不是 BlobPtr\u0026，在类模板作用域中，编译器处理模板自身引用会自动提供模板匹配的实参 类模板外使用类模板名在类模板外定义成员时，此时不在类的作用域，直到遇见类名菜进入类的作用域 //后置++版本 template BlobPtr BlobPtr::operator++(int) { BlobPtr ret = *this; ++*this; return ret; } 返回类型位于类的作用域之外，所以必须指出返回类型是一个实例化的 BlobPtr，在函数体内已经进入类的作用域，则定义 ret 时无须重复提供模板实参，如果不通过模板实参，编译器假定使用的类型与成员实例化所用类型一致，等价于：BlobPtr ret = *this; 类模板和友元 一个类包含一个友元声明，类与友元各自是否是模板是互相无关的 如果一个模板包括一个非模板友元，则友元可以访问所以模板实例 如果友元自身也是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例 一对一友好关系类模板与另一个（类或函数）模板间友好关系的最常见的形式是建立对应实例及其友元间的友好关系。例如，我们的 Blob 类应该将 BlobPtr 类和一个模板版本的 Blob template class BlobPtr; //需要提前声明 template class Blob; template bool operator==(const Blob\u0026, const Blob\u0026); template class Blob { friend class BlobPtr; friend bool operator== (const Blob\u0026, const Blob\u0026); //其他成员 } 友元的声明用 Blob 的模板形参作为自己的模板实参，友好关系被限定在相同类型实例化的 Blob 和 BlobPtr 相等运算符之间 //BlobPtr和operator==都是本对象的友元 Blob ca; //BlobPtr和operator==都是本对象的友元 Blob ia; 上面例子中，ca 对 ia 或其他实例没有特殊访问权限 通用和特定模板的友好关系一个类也可以将另一个模板的每个实例都声明为自己的友元，或者限定特定的实例为友元 template class Pal; class C { //C是普通非模板类 friend class Pal;//C实例化Pal是C的友元 //Pal2的所有实例都是C的友元，这种情况无须前置声明 template friend class Pal2; }; template class C2 {//C2是个模板类 //C2每个实例将相同实例的Pal声明为友元 friend class Pal; //Pal2所有实例都是C2每个实例的友元，不需要前置声明 template friend class Pal2; //Pal3是一个非模板类，它是C2所有实例的友元 friend class Pal3; }; 为了让所有实例都成为友元，友元声明中必须使用与类模板不同的模板参数 令模板自己的类型参数成为友元在C++11新标准中，可以将模板类型参数声明为友元 template class Bar { friend Type; //访问权限授予实例化Bar的类型 //... } 此时，对于某个类型 Foo，Foo 将称为 Bar 的友元，Sales_data 将成为 Bar 的友元 模板类型别名类模板一个实例定义了一个类类型，我们可以定义一个 typedef 来引用实例化的类： typedef Blob StrBlob; 由于模板不是一个类型，我们不能定义一个 typedef 引用一个模板，即不能定义一个 typedef 引用 Blob 但是新标准允许为类模板定义一个类型别名： templateusing twin = pair; twin authors; //authors是一个pair使用别名时，也需要像模板那样指出特定类型的 twin 使用一个模板类型别名时，可以固定一个或多个模板参数 template using partNo = pair; partNo books; /","date":"2022-05-07","objectID":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/:1:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十六章 模板与泛型编程","uri":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/#模板类型别名"},{"categories":["C++"],"content":"16.1.2 类模板类模板用来生成类的蓝图，类模板必须提供额外的信息，来确定模板的参数类型，一般在模板名后尖括号中提供实参 定义类模板 template class Blob { public: typedef T value_type; typedef typename std::vector::size_type size_type; //构造函数 Blob(); Blob(std::initializer_list il); //Blob中元素数目 size_type size() const { return data-size(); } bool empty() const { return data-empty(); } void push_back(const T\u0026 t) { return data-push_back(t);} void pop_back(); //元素访问 T\u0026 back(); T\u0026 operator[](size_type i); private: std::shared_ptr data; //若data[i]无效，抛出msg void check(size_type i, const std::string \u0026msg) const; }； 实例化类模板使用一个类模板时，需要提供额外信息，这些额外信息是显示模板实参列表，它们被绑定到模板参数 //使用类模板，必须提供元素类型 Blob ia; Blob ia2 = {0, 1, 2, 3}; ia 和 ia2会实例化以下特定版本的 Blob ` template class Blob { typedef typename std::vector::size_type size_type; Blob(); Blob(std::initializer_list il); //... } 当编译器从 Blob 模板中实例化一个类时，它会重写 Blob 模板，将参数 T 的每个实例替换成给定的模板实参 一个类模板的每个实例都形成一个独立的类，类型 Blob 与其他任何 Blob类型都没有关系，也不会对任何其他 Blob 类型的成员具有特殊的访问权限 类模板的成员函数与其他类一样，既可以在类模板内部，也可以在外部定义其成员函数，且定义在类模板内的成员函数被隐式声明为内联函数 类模板的成员函数本身是一个普通函数 每个类模板的实例都有自己版本的成员函数 类模板的成员函数具有和模板相同的模板参数 定义在类模板之外的成员函数就必须以关键字 template 开始，后接参数列表 简单说就是在类模板内部定义成员函数，可以直接使用参数 T，而在类模板外部定义成员函数，前面需要加上 template 等 template ret-type Blob::member-name(parm-list) 这里必须加上 template 这行 类模板成员函数实例化默认情况下，类模板的成员函数只有当程序使用它的时候才进行实例化 // 实例化Blob和接受initializer_list的构造函数 Blob squares = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; for (size_t i = 0; i != squares.size(); ++i) { squares[i] = i * i; //实例化Blob::operator[](size_t) } 如果一个成员函数没有被使用，则它不会被实例化 类代码内简化模板类名的使用在使用一个类模板类型时必须提供模板实参，但是在类模板自己的作用域中，可以直接使用模板名而不提供实参 template class BlobPtr { public: BlobPtr() : curr(0) {} //其他构造函数 T\u0026 operator*() const { auto p = check(curr, \"derederence past edn\"); return (*p)[curr]; } //递增和递减 BlobPtr\u0026 operator++(); //求值运算符 BlobPtr\u0026 operator--(); private: //其他成员 std::size_t curr; //数组中的位置 } 这里前置递增和递减成员返回的时 BlobPtr\u0026，而不是 BlobPtr\u0026，在类模板作用域中，编译器处理模板自身引用会自动提供模板匹配的实参 类模板外使用类模板名在类模板外定义成员时，此时不在类的作用域，直到遇见类名菜进入类的作用域 //后置++版本 template BlobPtr BlobPtr::operator++(int) { BlobPtr ret = *this; ++*this; return ret; } 返回类型位于类的作用域之外，所以必须指出返回类型是一个实例化的 BlobPtr，在函数体内已经进入类的作用域，则定义 ret 时无须重复提供模板实参，如果不通过模板实参，编译器假定使用的类型与成员实例化所用类型一致，等价于：BlobPtr ret = *this; 类模板和友元 一个类包含一个友元声明，类与友元各自是否是模板是互相无关的 如果一个模板包括一个非模板友元，则友元可以访问所以模板实例 如果友元自身也是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例 一对一友好关系类模板与另一个（类或函数）模板间友好关系的最常见的形式是建立对应实例及其友元间的友好关系。例如，我们的 Blob 类应该将 BlobPtr 类和一个模板版本的 Blob template class BlobPtr; //需要提前声明 template class Blob; template bool operator==(const Blob\u0026, const Blob\u0026); template class Blob { friend class BlobPtr; friend bool operator== (const Blob\u0026, const Blob\u0026); //其他成员 } 友元的声明用 Blob 的模板形参作为自己的模板实参，友好关系被限定在相同类型实例化的 Blob 和 BlobPtr 相等运算符之间 //BlobPtr和operator==都是本对象的友元 Blob ca; //BlobPtr和operator==都是本对象的友元 Blob ia; 上面例子中，ca 对 ia 或其他实例没有特殊访问权限 通用和特定模板的友好关系一个类也可以将另一个模板的每个实例都声明为自己的友元，或者限定特定的实例为友元 template class Pal; class C { //C是普通非模板类 friend class Pal;//C实例化Pal是C的友元 //Pal2的所有实例都是C的友元，这种情况无须前置声明 template friend class Pal2; }; template class C2 {//C2是个模板类 //C2每个实例将相同实例的Pal声明为友元 friend class Pal; //Pal2所有实例都是C2每个实例的友元，不需要前置声明 template friend class Pal2; //Pal3是一个非模板类，它是C2所有实例的友元 friend class Pal3; }; 为了让所有实例都成为友元，友元声明中必须使用与类模板不同的模板参数 令模板自己的类型参数成为友元在C++11新标准中，可以将模板类型参数声明为友元 template class Bar { friend Type; //访问权限授予实例化Bar的类型 //... } 此时，对于某个类型 Foo，Foo 将称为 Bar 的友元，Sales_data 将成为 Bar 的友元 模板类型别名类模板一个实例定义了一个类类型，我们可以定义一个 typedef 来引用实例化的类： typedef Blob StrBlob; 由于模板不是一个类型，我们不能定义一个 typedef 引用一个模板，即不能定义一个 typedef 引用 Blob 但是新标准允许为类模板定义一个类型别名： templateusing twin = pair; twin authors; //authors是一个pair使用别名时，也需要像模板那样指出特定类型的 twin 使用一个模板类型别名时，可以固定一个或多个模板参数 template using partNo = pair; partNo books; /","date":"2022-05-07","objectID":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/:1:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十六章 模板与泛型编程","uri":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/#类模板的static成员"},{"categories":["C++"],"content":"15.1 OOP：概述面向对象程序设计：核心思想是数据抽象、继承和动态绑定 数据抽象：类的接口与实现进行分离 继承：定义相似的类型并对相似关系建模 动态绑定：一定程度上忽略相似类型的区别，用统一的方式使用它们的对象 继承通过继承联系在一起的类构成一种层次关系，这种层次关系的根部有一个基类，其他类直接或间接由基类继承而来，继承得到的类称为派生类，继承的关系满足 is a ，即派生类本身也是一种基类的类型 对于基类中的某些函数，如果派生类需要自定义适合自身的版本，可以在基类中将这些函数声明为虚函数，派生类必须在内部对所有的虚函数重新声明 动态绑定使用动态绑定，可以用同一段代码处理基类和派生类的对象 比如说定义一个函数参入的形参是基类类型，然后打印处基类的成员，此时如果传入一个派生类也同样可以打印派生类的成员，这时调用的函数会根据实际传入的类型进行调用 动态绑定过程是在函数运行时由实参决定，有时也可以称为运行时绑定 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:1:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#151-oop概述"},{"categories":["C++"],"content":"15.1 OOP：概述面向对象程序设计：核心思想是数据抽象、继承和动态绑定 数据抽象：类的接口与实现进行分离 继承：定义相似的类型并对相似关系建模 动态绑定：一定程度上忽略相似类型的区别，用统一的方式使用它们的对象 继承通过继承联系在一起的类构成一种层次关系，这种层次关系的根部有一个基类，其他类直接或间接由基类继承而来，继承得到的类称为派生类，继承的关系满足 is a ，即派生类本身也是一种基类的类型 对于基类中的某些函数，如果派生类需要自定义适合自身的版本，可以在基类中将这些函数声明为虚函数，派生类必须在内部对所有的虚函数重新声明 动态绑定使用动态绑定，可以用同一段代码处理基类和派生类的对象 比如说定义一个函数参入的形参是基类类型，然后打印处基类的成员，此时如果传入一个派生类也同样可以打印派生类的成员，这时调用的函数会根据实际传入的类型进行调用 动态绑定过程是在函数运行时由实参决定，有时也可以称为运行时绑定 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:1:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#继承"},{"categories":["C++"],"content":"15.1 OOP：概述面向对象程序设计：核心思想是数据抽象、继承和动态绑定 数据抽象：类的接口与实现进行分离 继承：定义相似的类型并对相似关系建模 动态绑定：一定程度上忽略相似类型的区别，用统一的方式使用它们的对象 继承通过继承联系在一起的类构成一种层次关系，这种层次关系的根部有一个基类，其他类直接或间接由基类继承而来，继承得到的类称为派生类，继承的关系满足 is a ，即派生类本身也是一种基类的类型 对于基类中的某些函数，如果派生类需要自定义适合自身的版本，可以在基类中将这些函数声明为虚函数，派生类必须在内部对所有的虚函数重新声明 动态绑定使用动态绑定，可以用同一段代码处理基类和派生类的对象 比如说定义一个函数参入的形参是基类类型，然后打印处基类的成员，此时如果传入一个派生类也同样可以打印派生类的成员，这时调用的函数会根据实际传入的类型进行调用 动态绑定过程是在函数运行时由实参决定，有时也可以称为运行时绑定 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:1:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#动态绑定"},{"categories":["C++"],"content":"15.2 定义基类和派生类","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#152-定义基类和派生类"},{"categories":["C++"],"content":"15.2.1 定义基类首先定义 Quote 类： class Quote { public: Quote() = default;//默认构造函数 Quote(const std::string \u0026book, double sales_price) : bookNo(book), price(sales_price) {} std::string isbn() const { return bookNo; } //返回给定数量书籍的销售总额 //派生类负责改写并使用不同的折算算法 virtual double net_price(std::size_t n) const { return n * price; } virtual ~Quote() = default;//对析构函数进行动态绑定 private: std::string bookNo; //书籍ISBN号 protected: double price = 0.0; //普通状态下不打折的价格 } 基类通常定义一个虚析构函数，即使不执行任何操作 成员函数和继承派生类可以继承基类的成员，遇见 net_price 这种与类型相关的操作，派生类需要对这些操作提供自己新定义以覆盖从基类继承而来的定义 通常将基类希望派生类进行覆盖的函数定义为虚函数，当使用指针或者引用调用虚函数时，该调用将被动态绑定 访问控制和继承 派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权访问从基类继承而来的成员 派生类可以访问公有成员，但是不能访问私有成员 如果希望基类的派生类有权访问该成员，同时禁止其他用户访问，可以定义为受保护的（protected） ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:1","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#1521-定义基类"},{"categories":["C++"],"content":"15.2.1 定义基类首先定义 Quote 类： class Quote { public: Quote() = default;//默认构造函数 Quote(const std::string \u0026book, double sales_price) : bookNo(book), price(sales_price) {} std::string isbn() const { return bookNo; } //返回给定数量书籍的销售总额 //派生类负责改写并使用不同的折算算法 virtual double net_price(std::size_t n) const { return n * price; } virtual ~Quote() = default;//对析构函数进行动态绑定 private: std::string bookNo; //书籍ISBN号 protected: double price = 0.0; //普通状态下不打折的价格 } 基类通常定义一个虚析构函数，即使不执行任何操作 成员函数和继承派生类可以继承基类的成员，遇见 net_price 这种与类型相关的操作，派生类需要对这些操作提供自己新定义以覆盖从基类继承而来的定义 通常将基类希望派生类进行覆盖的函数定义为虚函数，当使用指针或者引用调用虚函数时，该调用将被动态绑定 访问控制和继承 派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权访问从基类继承而来的成员 派生类可以访问公有成员，但是不能访问私有成员 如果希望基类的派生类有权访问该成员，同时禁止其他用户访问，可以定义为受保护的（protected） ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:1","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#成员函数和继承"},{"categories":["C++"],"content":"15.2.1 定义基类首先定义 Quote 类： class Quote { public: Quote() = default;//默认构造函数 Quote(const std::string \u0026book, double sales_price) : bookNo(book), price(sales_price) {} std::string isbn() const { return bookNo; } //返回给定数量书籍的销售总额 //派生类负责改写并使用不同的折算算法 virtual double net_price(std::size_t n) const { return n * price; } virtual ~Quote() = default;//对析构函数进行动态绑定 private: std::string bookNo; //书籍ISBN号 protected: double price = 0.0; //普通状态下不打折的价格 } 基类通常定义一个虚析构函数，即使不执行任何操作 成员函数和继承派生类可以继承基类的成员，遇见 net_price 这种与类型相关的操作，派生类需要对这些操作提供自己新定义以覆盖从基类继承而来的定义 通常将基类希望派生类进行覆盖的函数定义为虚函数，当使用指针或者引用调用虚函数时，该调用将被动态绑定 访问控制和继承 派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权访问从基类继承而来的成员 派生类可以访问公有成员，但是不能访问私有成员 如果希望基类的派生类有权访问该成员，同时禁止其他用户访问，可以定义为受保护的（protected） ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:1","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#访问控制和继承"},{"categories":["C++"],"content":"15.2.2 定义派生类派生类必须通过类派生列表来指明它是从哪个基类继承而来的，类派生列表形式是：首先一个冒号，后面紧跟以逗号分隔的基类列表，每个基类前面可以有以下三种访问说明符之一：public、protected和private 定义 Bulk_quote 类 class Bulk_quote : public Quote { //Bulk_quote继承自Quote public: Bulk_quote() = default; Bulk_quote(const std::string\u0026, double, std::size_t, double); //覆盖基类的函数版本以实现基于大量购买的折扣政策 double net_price(std::size_t) const override; private: std::size_t min_qty = 0;//适用折扣政策的最低购买量 double discount = 0.0; //以小数表示折扣额 } Bulk_quote 类从基类 Quote 继承了 isbn 函数和 bookNo、price等数据成员，此外还定义了 net_price 的新版本，同时增加了两个新的数据成员 派生类中的虚函数派生类如果没有覆盖基类的虚函数，则派生类会直接继承基类中的版本 C++11新标准允许派生类显示注明它使用某个成员函数覆盖了它继承的虚函数，具体做法是在函数定义后面加个关键字 override 派生类对象即派生类向基类的类型转换派生类对象含有基类对应的成员部分，我们可以将派生类对象当成基类对象来使用，也能将基类指针或引用绑定到派生类对象的基类部分上 Quote item; //基类对象 Bulk_quote bulk; //派生类对象 Quote *p = \u0026item;//p指向Quote对象 p = \u0026bulk; //p指向bulk的Quote部分 Quote \u0026r = bulk; //r绑定到bulk的Quote部分 这种转换称为派生类到基类的类型转换 派生类构造函数派生类对象中含有从基类继承的成员，但是派生类不能直接初始化这些成员，派生类必须使用基类的构造函数来初始化它的基类部分 派生类在初始化成员时，可以通过构造函数初始化列表将实参传给基类构造函数，如下： //Bulk_quote的构造函数 Bulk_quote(const std::string \u0026book, double p, std::size_t qyt, double disc) : Quote(book, p), min_qty(qty), discount(disc) {} 派生类首先初始化基类部分，然后按照声明顺序初始化派生类的成员 派生类使用基类的成员派生类可以访问基类的公用成员和受保护的成员，例如： //如果达到购买书籍某个最低限度值，就可以享受折扣价格 double Bulk_quote::net_price(size_t cnt) const { if (cnt \u003e= min_qty) return cnt * (1 - discount) * price; else return cnt * price; } 继承与静态成员如果基类定义了一个静态成员，则整个继承体系中只存在该成员的唯一定义，不能派生出来多个各类，每一个静态成员只存在唯一的实例 静态成员遵循通用的访问控制规则，如果基类中定义为 private 的，派生类无权进行访问；如果静态成员可访问，既可以通过基类使用它，也可以通过派生类使用 class Base { public: static void statemen(); }; class Derived : public Base { void f(const Derived\u0026); }; void Derived::f(const Derived \u0026derived_obj) { Base::statemem(); //通过基类访问 Derived::statemem(); //通过派生类访问 derived_obj.statemem(); //通过基类对象访问 statemem(); //通过this对象访问 } 派生类的声明派生类声明和其他类差别不大，声明中包含类名但是不包含它的派生列表： class Bulk_quote : public Quote;//错误，派生列表不能出现在这 class Bulk_quote; //正确：声明派生类的正确方式 被用作基类的类如果想用某个类作为基类，则这个类必须已经定义而非仅仅声明： class Quote;//声明但未定义 //错误：Quote必须被定义 class Bulk_quote : public Quote {...}; 一个类不可以派生它本身 防止继承的发生如果不希望某一个类派生出其他类，或者不考虑将它作为一个基类，C++11新标准提供了一种防止继承发生的方法，即在类名后面跟一个关键字 final： class NoDrived final { /***/ }; class Bad : Noderived { /***/ }; //错误：NoDrived是final的 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#1522-定义派生类"},{"categories":["C++"],"content":"15.2.2 定义派生类派生类必须通过类派生列表来指明它是从哪个基类继承而来的，类派生列表形式是：首先一个冒号，后面紧跟以逗号分隔的基类列表，每个基类前面可以有以下三种访问说明符之一：public、protected和private 定义 Bulk_quote 类 class Bulk_quote : public Quote { //Bulk_quote继承自Quote public: Bulk_quote() = default; Bulk_quote(const std::string\u0026, double, std::size_t, double); //覆盖基类的函数版本以实现基于大量购买的折扣政策 double net_price(std::size_t) const override; private: std::size_t min_qty = 0;//适用折扣政策的最低购买量 double discount = 0.0; //以小数表示折扣额 } Bulk_quote 类从基类 Quote 继承了 isbn 函数和 bookNo、price等数据成员，此外还定义了 net_price 的新版本，同时增加了两个新的数据成员 派生类中的虚函数派生类如果没有覆盖基类的虚函数，则派生类会直接继承基类中的版本 C++11新标准允许派生类显示注明它使用某个成员函数覆盖了它继承的虚函数，具体做法是在函数定义后面加个关键字 override 派生类对象即派生类向基类的类型转换派生类对象含有基类对应的成员部分，我们可以将派生类对象当成基类对象来使用，也能将基类指针或引用绑定到派生类对象的基类部分上 Quote item; //基类对象 Bulk_quote bulk; //派生类对象 Quote *p = \u0026item;//p指向Quote对象 p = \u0026bulk; //p指向bulk的Quote部分 Quote \u0026r = bulk; //r绑定到bulk的Quote部分 这种转换称为派生类到基类的类型转换 派生类构造函数派生类对象中含有从基类继承的成员，但是派生类不能直接初始化这些成员，派生类必须使用基类的构造函数来初始化它的基类部分 派生类在初始化成员时，可以通过构造函数初始化列表将实参传给基类构造函数，如下： //Bulk_quote的构造函数 Bulk_quote(const std::string \u0026book, double p, std::size_t qyt, double disc) : Quote(book, p), min_qty(qty), discount(disc) {} 派生类首先初始化基类部分，然后按照声明顺序初始化派生类的成员 派生类使用基类的成员派生类可以访问基类的公用成员和受保护的成员，例如： //如果达到购买书籍某个最低限度值，就可以享受折扣价格 double Bulk_quote::net_price(size_t cnt) const { if (cnt = min_qty) return cnt * (1 - discount) * price; else return cnt * price; } 继承与静态成员如果基类定义了一个静态成员，则整个继承体系中只存在该成员的唯一定义，不能派生出来多个各类，每一个静态成员只存在唯一的实例 静态成员遵循通用的访问控制规则，如果基类中定义为 private 的，派生类无权进行访问；如果静态成员可访问，既可以通过基类使用它，也可以通过派生类使用 class Base { public: static void statemen(); }; class Derived : public Base { void f(const Derived\u0026); }; void Derived::f(const Derived \u0026derived_obj) { Base::statemem(); //通过基类访问 Derived::statemem(); //通过派生类访问 derived_obj.statemem(); //通过基类对象访问 statemem(); //通过this对象访问 } 派生类的声明派生类声明和其他类差别不大，声明中包含类名但是不包含它的派生列表： class Bulk_quote : public Quote;//错误，派生列表不能出现在这 class Bulk_quote; //正确：声明派生类的正确方式 被用作基类的类如果想用某个类作为基类，则这个类必须已经定义而非仅仅声明： class Quote;//声明但未定义 //错误：Quote必须被定义 class Bulk_quote : public Quote {...}; 一个类不可以派生它本身 防止继承的发生如果不希望某一个类派生出其他类，或者不考虑将它作为一个基类，C++11新标准提供了一种防止继承发生的方法，即在类名后面跟一个关键字 final： class NoDrived final { /***/ }; class Bad : Noderived { /***/ }; //错误：NoDrived是final的 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#派生类中的虚函数"},{"categories":["C++"],"content":"15.2.2 定义派生类派生类必须通过类派生列表来指明它是从哪个基类继承而来的，类派生列表形式是：首先一个冒号，后面紧跟以逗号分隔的基类列表，每个基类前面可以有以下三种访问说明符之一：public、protected和private 定义 Bulk_quote 类 class Bulk_quote : public Quote { //Bulk_quote继承自Quote public: Bulk_quote() = default; Bulk_quote(const std::string\u0026, double, std::size_t, double); //覆盖基类的函数版本以实现基于大量购买的折扣政策 double net_price(std::size_t) const override; private: std::size_t min_qty = 0;//适用折扣政策的最低购买量 double discount = 0.0; //以小数表示折扣额 } Bulk_quote 类从基类 Quote 继承了 isbn 函数和 bookNo、price等数据成员，此外还定义了 net_price 的新版本，同时增加了两个新的数据成员 派生类中的虚函数派生类如果没有覆盖基类的虚函数，则派生类会直接继承基类中的版本 C++11新标准允许派生类显示注明它使用某个成员函数覆盖了它继承的虚函数，具体做法是在函数定义后面加个关键字 override 派生类对象即派生类向基类的类型转换派生类对象含有基类对应的成员部分，我们可以将派生类对象当成基类对象来使用，也能将基类指针或引用绑定到派生类对象的基类部分上 Quote item; //基类对象 Bulk_quote bulk; //派生类对象 Quote *p = \u0026item;//p指向Quote对象 p = \u0026bulk; //p指向bulk的Quote部分 Quote \u0026r = bulk; //r绑定到bulk的Quote部分 这种转换称为派生类到基类的类型转换 派生类构造函数派生类对象中含有从基类继承的成员，但是派生类不能直接初始化这些成员，派生类必须使用基类的构造函数来初始化它的基类部分 派生类在初始化成员时，可以通过构造函数初始化列表将实参传给基类构造函数，如下： //Bulk_quote的构造函数 Bulk_quote(const std::string \u0026book, double p, std::size_t qyt, double disc) : Quote(book, p), min_qty(qty), discount(disc) {} 派生类首先初始化基类部分，然后按照声明顺序初始化派生类的成员 派生类使用基类的成员派生类可以访问基类的公用成员和受保护的成员，例如： //如果达到购买书籍某个最低限度值，就可以享受折扣价格 double Bulk_quote::net_price(size_t cnt) const { if (cnt = min_qty) return cnt * (1 - discount) * price; else return cnt * price; } 继承与静态成员如果基类定义了一个静态成员，则整个继承体系中只存在该成员的唯一定义，不能派生出来多个各类，每一个静态成员只存在唯一的实例 静态成员遵循通用的访问控制规则，如果基类中定义为 private 的，派生类无权进行访问；如果静态成员可访问，既可以通过基类使用它，也可以通过派生类使用 class Base { public: static void statemen(); }; class Derived : public Base { void f(const Derived\u0026); }; void Derived::f(const Derived \u0026derived_obj) { Base::statemem(); //通过基类访问 Derived::statemem(); //通过派生类访问 derived_obj.statemem(); //通过基类对象访问 statemem(); //通过this对象访问 } 派生类的声明派生类声明和其他类差别不大，声明中包含类名但是不包含它的派生列表： class Bulk_quote : public Quote;//错误，派生列表不能出现在这 class Bulk_quote; //正确：声明派生类的正确方式 被用作基类的类如果想用某个类作为基类，则这个类必须已经定义而非仅仅声明： class Quote;//声明但未定义 //错误：Quote必须被定义 class Bulk_quote : public Quote {...}; 一个类不可以派生它本身 防止继承的发生如果不希望某一个类派生出其他类，或者不考虑将它作为一个基类，C++11新标准提供了一种防止继承发生的方法，即在类名后面跟一个关键字 final： class NoDrived final { /***/ }; class Bad : Noderived { /***/ }; //错误：NoDrived是final的 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#派生类对象即派生类向基类的类型转换"},{"categories":["C++"],"content":"15.2.2 定义派生类派生类必须通过类派生列表来指明它是从哪个基类继承而来的，类派生列表形式是：首先一个冒号，后面紧跟以逗号分隔的基类列表，每个基类前面可以有以下三种访问说明符之一：public、protected和private 定义 Bulk_quote 类 class Bulk_quote : public Quote { //Bulk_quote继承自Quote public: Bulk_quote() = default; Bulk_quote(const std::string\u0026, double, std::size_t, double); //覆盖基类的函数版本以实现基于大量购买的折扣政策 double net_price(std::size_t) const override; private: std::size_t min_qty = 0;//适用折扣政策的最低购买量 double discount = 0.0; //以小数表示折扣额 } Bulk_quote 类从基类 Quote 继承了 isbn 函数和 bookNo、price等数据成员，此外还定义了 net_price 的新版本，同时增加了两个新的数据成员 派生类中的虚函数派生类如果没有覆盖基类的虚函数，则派生类会直接继承基类中的版本 C++11新标准允许派生类显示注明它使用某个成员函数覆盖了它继承的虚函数，具体做法是在函数定义后面加个关键字 override 派生类对象即派生类向基类的类型转换派生类对象含有基类对应的成员部分，我们可以将派生类对象当成基类对象来使用，也能将基类指针或引用绑定到派生类对象的基类部分上 Quote item; //基类对象 Bulk_quote bulk; //派生类对象 Quote *p = \u0026item;//p指向Quote对象 p = \u0026bulk; //p指向bulk的Quote部分 Quote \u0026r = bulk; //r绑定到bulk的Quote部分 这种转换称为派生类到基类的类型转换 派生类构造函数派生类对象中含有从基类继承的成员，但是派生类不能直接初始化这些成员，派生类必须使用基类的构造函数来初始化它的基类部分 派生类在初始化成员时，可以通过构造函数初始化列表将实参传给基类构造函数，如下： //Bulk_quote的构造函数 Bulk_quote(const std::string \u0026book, double p, std::size_t qyt, double disc) : Quote(book, p), min_qty(qty), discount(disc) {} 派生类首先初始化基类部分，然后按照声明顺序初始化派生类的成员 派生类使用基类的成员派生类可以访问基类的公用成员和受保护的成员，例如： //如果达到购买书籍某个最低限度值，就可以享受折扣价格 double Bulk_quote::net_price(size_t cnt) const { if (cnt = min_qty) return cnt * (1 - discount) * price; else return cnt * price; } 继承与静态成员如果基类定义了一个静态成员，则整个继承体系中只存在该成员的唯一定义，不能派生出来多个各类，每一个静态成员只存在唯一的实例 静态成员遵循通用的访问控制规则，如果基类中定义为 private 的，派生类无权进行访问；如果静态成员可访问，既可以通过基类使用它，也可以通过派生类使用 class Base { public: static void statemen(); }; class Derived : public Base { void f(const Derived\u0026); }; void Derived::f(const Derived \u0026derived_obj) { Base::statemem(); //通过基类访问 Derived::statemem(); //通过派生类访问 derived_obj.statemem(); //通过基类对象访问 statemem(); //通过this对象访问 } 派生类的声明派生类声明和其他类差别不大，声明中包含类名但是不包含它的派生列表： class Bulk_quote : public Quote;//错误，派生列表不能出现在这 class Bulk_quote; //正确：声明派生类的正确方式 被用作基类的类如果想用某个类作为基类，则这个类必须已经定义而非仅仅声明： class Quote;//声明但未定义 //错误：Quote必须被定义 class Bulk_quote : public Quote {...}; 一个类不可以派生它本身 防止继承的发生如果不希望某一个类派生出其他类，或者不考虑将它作为一个基类，C++11新标准提供了一种防止继承发生的方法，即在类名后面跟一个关键字 final： class NoDrived final { /***/ }; class Bad : Noderived { /***/ }; //错误：NoDrived是final的 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#派生类构造函数"},{"categories":["C++"],"content":"15.2.2 定义派生类派生类必须通过类派生列表来指明它是从哪个基类继承而来的，类派生列表形式是：首先一个冒号，后面紧跟以逗号分隔的基类列表，每个基类前面可以有以下三种访问说明符之一：public、protected和private 定义 Bulk_quote 类 class Bulk_quote : public Quote { //Bulk_quote继承自Quote public: Bulk_quote() = default; Bulk_quote(const std::string\u0026, double, std::size_t, double); //覆盖基类的函数版本以实现基于大量购买的折扣政策 double net_price(std::size_t) const override; private: std::size_t min_qty = 0;//适用折扣政策的最低购买量 double discount = 0.0; //以小数表示折扣额 } Bulk_quote 类从基类 Quote 继承了 isbn 函数和 bookNo、price等数据成员，此外还定义了 net_price 的新版本，同时增加了两个新的数据成员 派生类中的虚函数派生类如果没有覆盖基类的虚函数，则派生类会直接继承基类中的版本 C++11新标准允许派生类显示注明它使用某个成员函数覆盖了它继承的虚函数，具体做法是在函数定义后面加个关键字 override 派生类对象即派生类向基类的类型转换派生类对象含有基类对应的成员部分，我们可以将派生类对象当成基类对象来使用，也能将基类指针或引用绑定到派生类对象的基类部分上 Quote item; //基类对象 Bulk_quote bulk; //派生类对象 Quote *p = \u0026item;//p指向Quote对象 p = \u0026bulk; //p指向bulk的Quote部分 Quote \u0026r = bulk; //r绑定到bulk的Quote部分 这种转换称为派生类到基类的类型转换 派生类构造函数派生类对象中含有从基类继承的成员，但是派生类不能直接初始化这些成员，派生类必须使用基类的构造函数来初始化它的基类部分 派生类在初始化成员时，可以通过构造函数初始化列表将实参传给基类构造函数，如下： //Bulk_quote的构造函数 Bulk_quote(const std::string \u0026book, double p, std::size_t qyt, double disc) : Quote(book, p), min_qty(qty), discount(disc) {} 派生类首先初始化基类部分，然后按照声明顺序初始化派生类的成员 派生类使用基类的成员派生类可以访问基类的公用成员和受保护的成员，例如： //如果达到购买书籍某个最低限度值，就可以享受折扣价格 double Bulk_quote::net_price(size_t cnt) const { if (cnt = min_qty) return cnt * (1 - discount) * price; else return cnt * price; } 继承与静态成员如果基类定义了一个静态成员，则整个继承体系中只存在该成员的唯一定义，不能派生出来多个各类，每一个静态成员只存在唯一的实例 静态成员遵循通用的访问控制规则，如果基类中定义为 private 的，派生类无权进行访问；如果静态成员可访问，既可以通过基类使用它，也可以通过派生类使用 class Base { public: static void statemen(); }; class Derived : public Base { void f(const Derived\u0026); }; void Derived::f(const Derived \u0026derived_obj) { Base::statemem(); //通过基类访问 Derived::statemem(); //通过派生类访问 derived_obj.statemem(); //通过基类对象访问 statemem(); //通过this对象访问 } 派生类的声明派生类声明和其他类差别不大，声明中包含类名但是不包含它的派生列表： class Bulk_quote : public Quote;//错误，派生列表不能出现在这 class Bulk_quote; //正确：声明派生类的正确方式 被用作基类的类如果想用某个类作为基类，则这个类必须已经定义而非仅仅声明： class Quote;//声明但未定义 //错误：Quote必须被定义 class Bulk_quote : public Quote {...}; 一个类不可以派生它本身 防止继承的发生如果不希望某一个类派生出其他类，或者不考虑将它作为一个基类，C++11新标准提供了一种防止继承发生的方法，即在类名后面跟一个关键字 final： class NoDrived final { /***/ }; class Bad : Noderived { /***/ }; //错误：NoDrived是final的 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#派生类使用基类的成员"},{"categories":["C++"],"content":"15.2.2 定义派生类派生类必须通过类派生列表来指明它是从哪个基类继承而来的，类派生列表形式是：首先一个冒号，后面紧跟以逗号分隔的基类列表，每个基类前面可以有以下三种访问说明符之一：public、protected和private 定义 Bulk_quote 类 class Bulk_quote : public Quote { //Bulk_quote继承自Quote public: Bulk_quote() = default; Bulk_quote(const std::string\u0026, double, std::size_t, double); //覆盖基类的函数版本以实现基于大量购买的折扣政策 double net_price(std::size_t) const override; private: std::size_t min_qty = 0;//适用折扣政策的最低购买量 double discount = 0.0; //以小数表示折扣额 } Bulk_quote 类从基类 Quote 继承了 isbn 函数和 bookNo、price等数据成员，此外还定义了 net_price 的新版本，同时增加了两个新的数据成员 派生类中的虚函数派生类如果没有覆盖基类的虚函数，则派生类会直接继承基类中的版本 C++11新标准允许派生类显示注明它使用某个成员函数覆盖了它继承的虚函数，具体做法是在函数定义后面加个关键字 override 派生类对象即派生类向基类的类型转换派生类对象含有基类对应的成员部分，我们可以将派生类对象当成基类对象来使用，也能将基类指针或引用绑定到派生类对象的基类部分上 Quote item; //基类对象 Bulk_quote bulk; //派生类对象 Quote *p = \u0026item;//p指向Quote对象 p = \u0026bulk; //p指向bulk的Quote部分 Quote \u0026r = bulk; //r绑定到bulk的Quote部分 这种转换称为派生类到基类的类型转换 派生类构造函数派生类对象中含有从基类继承的成员，但是派生类不能直接初始化这些成员，派生类必须使用基类的构造函数来初始化它的基类部分 派生类在初始化成员时，可以通过构造函数初始化列表将实参传给基类构造函数，如下： //Bulk_quote的构造函数 Bulk_quote(const std::string \u0026book, double p, std::size_t qyt, double disc) : Quote(book, p), min_qty(qty), discount(disc) {} 派生类首先初始化基类部分，然后按照声明顺序初始化派生类的成员 派生类使用基类的成员派生类可以访问基类的公用成员和受保护的成员，例如： //如果达到购买书籍某个最低限度值，就可以享受折扣价格 double Bulk_quote::net_price(size_t cnt) const { if (cnt = min_qty) return cnt * (1 - discount) * price; else return cnt * price; } 继承与静态成员如果基类定义了一个静态成员，则整个继承体系中只存在该成员的唯一定义，不能派生出来多个各类，每一个静态成员只存在唯一的实例 静态成员遵循通用的访问控制规则，如果基类中定义为 private 的，派生类无权进行访问；如果静态成员可访问，既可以通过基类使用它，也可以通过派生类使用 class Base { public: static void statemen(); }; class Derived : public Base { void f(const Derived\u0026); }; void Derived::f(const Derived \u0026derived_obj) { Base::statemem(); //通过基类访问 Derived::statemem(); //通过派生类访问 derived_obj.statemem(); //通过基类对象访问 statemem(); //通过this对象访问 } 派生类的声明派生类声明和其他类差别不大，声明中包含类名但是不包含它的派生列表： class Bulk_quote : public Quote;//错误，派生列表不能出现在这 class Bulk_quote; //正确：声明派生类的正确方式 被用作基类的类如果想用某个类作为基类，则这个类必须已经定义而非仅仅声明： class Quote;//声明但未定义 //错误：Quote必须被定义 class Bulk_quote : public Quote {...}; 一个类不可以派生它本身 防止继承的发生如果不希望某一个类派生出其他类，或者不考虑将它作为一个基类，C++11新标准提供了一种防止继承发生的方法，即在类名后面跟一个关键字 final： class NoDrived final { /***/ }; class Bad : Noderived { /***/ }; //错误：NoDrived是final的 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#继承与静态成员"},{"categories":["C++"],"content":"15.2.2 定义派生类派生类必须通过类派生列表来指明它是从哪个基类继承而来的，类派生列表形式是：首先一个冒号，后面紧跟以逗号分隔的基类列表，每个基类前面可以有以下三种访问说明符之一：public、protected和private 定义 Bulk_quote 类 class Bulk_quote : public Quote { //Bulk_quote继承自Quote public: Bulk_quote() = default; Bulk_quote(const std::string\u0026, double, std::size_t, double); //覆盖基类的函数版本以实现基于大量购买的折扣政策 double net_price(std::size_t) const override; private: std::size_t min_qty = 0;//适用折扣政策的最低购买量 double discount = 0.0; //以小数表示折扣额 } Bulk_quote 类从基类 Quote 继承了 isbn 函数和 bookNo、price等数据成员，此外还定义了 net_price 的新版本，同时增加了两个新的数据成员 派生类中的虚函数派生类如果没有覆盖基类的虚函数，则派生类会直接继承基类中的版本 C++11新标准允许派生类显示注明它使用某个成员函数覆盖了它继承的虚函数，具体做法是在函数定义后面加个关键字 override 派生类对象即派生类向基类的类型转换派生类对象含有基类对应的成员部分，我们可以将派生类对象当成基类对象来使用，也能将基类指针或引用绑定到派生类对象的基类部分上 Quote item; //基类对象 Bulk_quote bulk; //派生类对象 Quote *p = \u0026item;//p指向Quote对象 p = \u0026bulk; //p指向bulk的Quote部分 Quote \u0026r = bulk; //r绑定到bulk的Quote部分 这种转换称为派生类到基类的类型转换 派生类构造函数派生类对象中含有从基类继承的成员，但是派生类不能直接初始化这些成员，派生类必须使用基类的构造函数来初始化它的基类部分 派生类在初始化成员时，可以通过构造函数初始化列表将实参传给基类构造函数，如下： //Bulk_quote的构造函数 Bulk_quote(const std::string \u0026book, double p, std::size_t qyt, double disc) : Quote(book, p), min_qty(qty), discount(disc) {} 派生类首先初始化基类部分，然后按照声明顺序初始化派生类的成员 派生类使用基类的成员派生类可以访问基类的公用成员和受保护的成员，例如： //如果达到购买书籍某个最低限度值，就可以享受折扣价格 double Bulk_quote::net_price(size_t cnt) const { if (cnt = min_qty) return cnt * (1 - discount) * price; else return cnt * price; } 继承与静态成员如果基类定义了一个静态成员，则整个继承体系中只存在该成员的唯一定义，不能派生出来多个各类，每一个静态成员只存在唯一的实例 静态成员遵循通用的访问控制规则，如果基类中定义为 private 的，派生类无权进行访问；如果静态成员可访问，既可以通过基类使用它，也可以通过派生类使用 class Base { public: static void statemen(); }; class Derived : public Base { void f(const Derived\u0026); }; void Derived::f(const Derived \u0026derived_obj) { Base::statemem(); //通过基类访问 Derived::statemem(); //通过派生类访问 derived_obj.statemem(); //通过基类对象访问 statemem(); //通过this对象访问 } 派生类的声明派生类声明和其他类差别不大，声明中包含类名但是不包含它的派生列表： class Bulk_quote : public Quote;//错误，派生列表不能出现在这 class Bulk_quote; //正确：声明派生类的正确方式 被用作基类的类如果想用某个类作为基类，则这个类必须已经定义而非仅仅声明： class Quote;//声明但未定义 //错误：Quote必须被定义 class Bulk_quote : public Quote {...}; 一个类不可以派生它本身 防止继承的发生如果不希望某一个类派生出其他类，或者不考虑将它作为一个基类，C++11新标准提供了一种防止继承发生的方法，即在类名后面跟一个关键字 final： class NoDrived final { /***/ }; class Bad : Noderived { /***/ }; //错误：NoDrived是final的 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#派生类的声明"},{"categories":["C++"],"content":"15.2.2 定义派生类派生类必须通过类派生列表来指明它是从哪个基类继承而来的，类派生列表形式是：首先一个冒号，后面紧跟以逗号分隔的基类列表，每个基类前面可以有以下三种访问说明符之一：public、protected和private 定义 Bulk_quote 类 class Bulk_quote : public Quote { //Bulk_quote继承自Quote public: Bulk_quote() = default; Bulk_quote(const std::string\u0026, double, std::size_t, double); //覆盖基类的函数版本以实现基于大量购买的折扣政策 double net_price(std::size_t) const override; private: std::size_t min_qty = 0;//适用折扣政策的最低购买量 double discount = 0.0; //以小数表示折扣额 } Bulk_quote 类从基类 Quote 继承了 isbn 函数和 bookNo、price等数据成员，此外还定义了 net_price 的新版本，同时增加了两个新的数据成员 派生类中的虚函数派生类如果没有覆盖基类的虚函数，则派生类会直接继承基类中的版本 C++11新标准允许派生类显示注明它使用某个成员函数覆盖了它继承的虚函数，具体做法是在函数定义后面加个关键字 override 派生类对象即派生类向基类的类型转换派生类对象含有基类对应的成员部分，我们可以将派生类对象当成基类对象来使用，也能将基类指针或引用绑定到派生类对象的基类部分上 Quote item; //基类对象 Bulk_quote bulk; //派生类对象 Quote *p = \u0026item;//p指向Quote对象 p = \u0026bulk; //p指向bulk的Quote部分 Quote \u0026r = bulk; //r绑定到bulk的Quote部分 这种转换称为派生类到基类的类型转换 派生类构造函数派生类对象中含有从基类继承的成员，但是派生类不能直接初始化这些成员，派生类必须使用基类的构造函数来初始化它的基类部分 派生类在初始化成员时，可以通过构造函数初始化列表将实参传给基类构造函数，如下： //Bulk_quote的构造函数 Bulk_quote(const std::string \u0026book, double p, std::size_t qyt, double disc) : Quote(book, p), min_qty(qty), discount(disc) {} 派生类首先初始化基类部分，然后按照声明顺序初始化派生类的成员 派生类使用基类的成员派生类可以访问基类的公用成员和受保护的成员，例如： //如果达到购买书籍某个最低限度值，就可以享受折扣价格 double Bulk_quote::net_price(size_t cnt) const { if (cnt = min_qty) return cnt * (1 - discount) * price; else return cnt * price; } 继承与静态成员如果基类定义了一个静态成员，则整个继承体系中只存在该成员的唯一定义，不能派生出来多个各类，每一个静态成员只存在唯一的实例 静态成员遵循通用的访问控制规则，如果基类中定义为 private 的，派生类无权进行访问；如果静态成员可访问，既可以通过基类使用它，也可以通过派生类使用 class Base { public: static void statemen(); }; class Derived : public Base { void f(const Derived\u0026); }; void Derived::f(const Derived \u0026derived_obj) { Base::statemem(); //通过基类访问 Derived::statemem(); //通过派生类访问 derived_obj.statemem(); //通过基类对象访问 statemem(); //通过this对象访问 } 派生类的声明派生类声明和其他类差别不大，声明中包含类名但是不包含它的派生列表： class Bulk_quote : public Quote;//错误，派生列表不能出现在这 class Bulk_quote; //正确：声明派生类的正确方式 被用作基类的类如果想用某个类作为基类，则这个类必须已经定义而非仅仅声明： class Quote;//声明但未定义 //错误：Quote必须被定义 class Bulk_quote : public Quote {...}; 一个类不可以派生它本身 防止继承的发生如果不希望某一个类派生出其他类，或者不考虑将它作为一个基类，C++11新标准提供了一种防止继承发生的方法，即在类名后面跟一个关键字 final： class NoDrived final { /***/ }; class Bad : Noderived { /***/ }; //错误：NoDrived是final的 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#被用作基类的类"},{"categories":["C++"],"content":"15.2.2 定义派生类派生类必须通过类派生列表来指明它是从哪个基类继承而来的，类派生列表形式是：首先一个冒号，后面紧跟以逗号分隔的基类列表，每个基类前面可以有以下三种访问说明符之一：public、protected和private 定义 Bulk_quote 类 class Bulk_quote : public Quote { //Bulk_quote继承自Quote public: Bulk_quote() = default; Bulk_quote(const std::string\u0026, double, std::size_t, double); //覆盖基类的函数版本以实现基于大量购买的折扣政策 double net_price(std::size_t) const override; private: std::size_t min_qty = 0;//适用折扣政策的最低购买量 double discount = 0.0; //以小数表示折扣额 } Bulk_quote 类从基类 Quote 继承了 isbn 函数和 bookNo、price等数据成员，此外还定义了 net_price 的新版本，同时增加了两个新的数据成员 派生类中的虚函数派生类如果没有覆盖基类的虚函数，则派生类会直接继承基类中的版本 C++11新标准允许派生类显示注明它使用某个成员函数覆盖了它继承的虚函数，具体做法是在函数定义后面加个关键字 override 派生类对象即派生类向基类的类型转换派生类对象含有基类对应的成员部分，我们可以将派生类对象当成基类对象来使用，也能将基类指针或引用绑定到派生类对象的基类部分上 Quote item; //基类对象 Bulk_quote bulk; //派生类对象 Quote *p = \u0026item;//p指向Quote对象 p = \u0026bulk; //p指向bulk的Quote部分 Quote \u0026r = bulk; //r绑定到bulk的Quote部分 这种转换称为派生类到基类的类型转换 派生类构造函数派生类对象中含有从基类继承的成员，但是派生类不能直接初始化这些成员，派生类必须使用基类的构造函数来初始化它的基类部分 派生类在初始化成员时，可以通过构造函数初始化列表将实参传给基类构造函数，如下： //Bulk_quote的构造函数 Bulk_quote(const std::string \u0026book, double p, std::size_t qyt, double disc) : Quote(book, p), min_qty(qty), discount(disc) {} 派生类首先初始化基类部分，然后按照声明顺序初始化派生类的成员 派生类使用基类的成员派生类可以访问基类的公用成员和受保护的成员，例如： //如果达到购买书籍某个最低限度值，就可以享受折扣价格 double Bulk_quote::net_price(size_t cnt) const { if (cnt = min_qty) return cnt * (1 - discount) * price; else return cnt * price; } 继承与静态成员如果基类定义了一个静态成员，则整个继承体系中只存在该成员的唯一定义，不能派生出来多个各类，每一个静态成员只存在唯一的实例 静态成员遵循通用的访问控制规则，如果基类中定义为 private 的，派生类无权进行访问；如果静态成员可访问，既可以通过基类使用它，也可以通过派生类使用 class Base { public: static void statemen(); }; class Derived : public Base { void f(const Derived\u0026); }; void Derived::f(const Derived \u0026derived_obj) { Base::statemem(); //通过基类访问 Derived::statemem(); //通过派生类访问 derived_obj.statemem(); //通过基类对象访问 statemem(); //通过this对象访问 } 派生类的声明派生类声明和其他类差别不大，声明中包含类名但是不包含它的派生列表： class Bulk_quote : public Quote;//错误，派生列表不能出现在这 class Bulk_quote; //正确：声明派生类的正确方式 被用作基类的类如果想用某个类作为基类，则这个类必须已经定义而非仅仅声明： class Quote;//声明但未定义 //错误：Quote必须被定义 class Bulk_quote : public Quote {...}; 一个类不可以派生它本身 防止继承的发生如果不希望某一个类派生出其他类，或者不考虑将它作为一个基类，C++11新标准提供了一种防止继承发生的方法，即在类名后面跟一个关键字 final： class NoDrived final { /***/ }; class Bad : Noderived { /***/ }; //错误：NoDrived是final的 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#防止继承的发生"},{"categories":["C++"],"content":"15.2.3 类型转换与继承我们可以将基类的指针或引用绑定到派生类对象上，例如：可以用 Quote\u0026 指向一个 Bulk_quote 对象 ==当使用基类的引用（或指针）时，我们并不清楚该引用（指针）所绑定对象的真实类型==，可能该对象时基类的对象，也可能时派生类的对象 智能指针类也支持派生类向基类的类型转换 静态类型和动态类型 使用存在继承关系的类型时，需要区分一个变量或者表达式的静态类型和动态类型 静态类型编译时总是已知的，它是变量声明时的类型或者表达式生成的类型 动态类型则是变量或表达式表示内存中的对象的类型，运行时才可以确定 如果表达式既不是引用也不是指针，则它的动态类型和静态类型永远一致 不存在基类向派生类的隐式转换 派生类可以向基类转换是因为派生类中含有基类的成员，基类的引用或指针可以绑定到该基类部分上 而基类对象中可能存在派生类对象中的成员，也可能不存在，所以不能从基类向派生类自动类型转换 Quote base; Bulk_quote* bulkPtr = \u0026base; //错误：基类不能转换为派生类 Bulk_quote\u0026 bulkRef = base; //错误：基类不能转换为派生类 ==即使一个基类指针或者引用类型绑定在派生类对象上，我们也不能执行从基类向派生类的转换== Bulk_quote bulk; Quote *itemPtr = \u0026bulk; //正确：动态类型是Bulk_quote Bulk_quote *bulkPtr = itemPtr; //错误：不能将基类转换为派生类 编译器在编译时候无法确定上述转换过程在运行时是否安全，编译器只能检查静态类型来判断是否合法 对象之间不存在类型转换派生类向基类的自动类型转换只能对指针和引用有效，在派生类和基类类型之间不存在这样的转换。 当对基类进行初始化或者拷贝赋值时，如果传入的是派生类的对象，通常只会将派生类中含有基类的部分进行拷贝复制，而派生类多的部分会被忽略 Bulk_quote bulk; //派生类对象 Quote item(bulk); //使用Quote::Quote(const Quote\u0026)构造函数 item = bulk; //调用Quote::operator=(const Quote\u0026) 当构造 item 时，只会处理 Quote 类中的 bookNo 和 price 两个部分，同时忽略了 bulk 中其他成员 当使用一个派生类对象为基类对象初始化或赋值时，只有派生类对象中基类部分会被拷贝、移动或赋值，它的派生类部分会被忽略 问：给出静态类型和动态类型的定义 静态类型在编译时就己经确定了，它是变量声明时的类型或表达式生成的类型； 而动态类型则是变量或表达式表示的内存中的对象的类型，动态类型直到运行时才能知道； 如果一个变量非指针也非引用，则它的静态类型和动态类型永远一致。但基类的指针或引用的动态类型可能与其动态类型不一致 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:3","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#1523-类型转换与继承"},{"categories":["C++"],"content":"15.2.3 类型转换与继承我们可以将基类的指针或引用绑定到派生类对象上，例如：可以用 Quote\u0026 指向一个 Bulk_quote 对象 ==当使用基类的引用（或指针）时，我们并不清楚该引用（指针）所绑定对象的真实类型==，可能该对象时基类的对象，也可能时派生类的对象 智能指针类也支持派生类向基类的类型转换 静态类型和动态类型 使用存在继承关系的类型时，需要区分一个变量或者表达式的静态类型和动态类型 静态类型编译时总是已知的，它是变量声明时的类型或者表达式生成的类型 动态类型则是变量或表达式表示内存中的对象的类型，运行时才可以确定 如果表达式既不是引用也不是指针，则它的动态类型和静态类型永远一致 不存在基类向派生类的隐式转换 派生类可以向基类转换是因为派生类中含有基类的成员，基类的引用或指针可以绑定到该基类部分上 而基类对象中可能存在派生类对象中的成员，也可能不存在，所以不能从基类向派生类自动类型转换 Quote base; Bulk_quote* bulkPtr = \u0026base; //错误：基类不能转换为派生类 Bulk_quote\u0026 bulkRef = base; //错误：基类不能转换为派生类 ==即使一个基类指针或者引用类型绑定在派生类对象上，我们也不能执行从基类向派生类的转换== Bulk_quote bulk; Quote *itemPtr = \u0026bulk; //正确：动态类型是Bulk_quote Bulk_quote *bulkPtr = itemPtr; //错误：不能将基类转换为派生类 编译器在编译时候无法确定上述转换过程在运行时是否安全，编译器只能检查静态类型来判断是否合法 对象之间不存在类型转换派生类向基类的自动类型转换只能对指针和引用有效，在派生类和基类类型之间不存在这样的转换。 当对基类进行初始化或者拷贝赋值时，如果传入的是派生类的对象，通常只会将派生类中含有基类的部分进行拷贝复制，而派生类多的部分会被忽略 Bulk_quote bulk; //派生类对象 Quote item(bulk); //使用Quote::Quote(const Quote\u0026)构造函数 item = bulk; //调用Quote::operator=(const Quote\u0026) 当构造 item 时，只会处理 Quote 类中的 bookNo 和 price 两个部分，同时忽略了 bulk 中其他成员 当使用一个派生类对象为基类对象初始化或赋值时，只有派生类对象中基类部分会被拷贝、移动或赋值，它的派生类部分会被忽略 问：给出静态类型和动态类型的定义 静态类型在编译时就己经确定了，它是变量声明时的类型或表达式生成的类型； 而动态类型则是变量或表达式表示的内存中的对象的类型，动态类型直到运行时才能知道； 如果一个变量非指针也非引用，则它的静态类型和动态类型永远一致。但基类的指针或引用的动态类型可能与其动态类型不一致 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:3","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#静态类型和动态类型"},{"categories":["C++"],"content":"15.2.3 类型转换与继承我们可以将基类的指针或引用绑定到派生类对象上，例如：可以用 Quote\u0026 指向一个 Bulk_quote 对象 ==当使用基类的引用（或指针）时，我们并不清楚该引用（指针）所绑定对象的真实类型==，可能该对象时基类的对象，也可能时派生类的对象 智能指针类也支持派生类向基类的类型转换 静态类型和动态类型 使用存在继承关系的类型时，需要区分一个变量或者表达式的静态类型和动态类型 静态类型编译时总是已知的，它是变量声明时的类型或者表达式生成的类型 动态类型则是变量或表达式表示内存中的对象的类型，运行时才可以确定 如果表达式既不是引用也不是指针，则它的动态类型和静态类型永远一致 不存在基类向派生类的隐式转换 派生类可以向基类转换是因为派生类中含有基类的成员，基类的引用或指针可以绑定到该基类部分上 而基类对象中可能存在派生类对象中的成员，也可能不存在，所以不能从基类向派生类自动类型转换 Quote base; Bulk_quote* bulkPtr = \u0026base; //错误：基类不能转换为派生类 Bulk_quote\u0026 bulkRef = base; //错误：基类不能转换为派生类 ==即使一个基类指针或者引用类型绑定在派生类对象上，我们也不能执行从基类向派生类的转换== Bulk_quote bulk; Quote *itemPtr = \u0026bulk; //正确：动态类型是Bulk_quote Bulk_quote *bulkPtr = itemPtr; //错误：不能将基类转换为派生类 编译器在编译时候无法确定上述转换过程在运行时是否安全，编译器只能检查静态类型来判断是否合法 对象之间不存在类型转换派生类向基类的自动类型转换只能对指针和引用有效，在派生类和基类类型之间不存在这样的转换。 当对基类进行初始化或者拷贝赋值时，如果传入的是派生类的对象，通常只会将派生类中含有基类的部分进行拷贝复制，而派生类多的部分会被忽略 Bulk_quote bulk; //派生类对象 Quote item(bulk); //使用Quote::Quote(const Quote\u0026)构造函数 item = bulk; //调用Quote::operator=(const Quote\u0026) 当构造 item 时，只会处理 Quote 类中的 bookNo 和 price 两个部分，同时忽略了 bulk 中其他成员 当使用一个派生类对象为基类对象初始化或赋值时，只有派生类对象中基类部分会被拷贝、移动或赋值，它的派生类部分会被忽略 问：给出静态类型和动态类型的定义 静态类型在编译时就己经确定了，它是变量声明时的类型或表达式生成的类型； 而动态类型则是变量或表达式表示的内存中的对象的类型，动态类型直到运行时才能知道； 如果一个变量非指针也非引用，则它的静态类型和动态类型永远一致。但基类的指针或引用的动态类型可能与其动态类型不一致 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:3","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#不存在基类向派生类的隐式转换"},{"categories":["C++"],"content":"15.2.3 类型转换与继承我们可以将基类的指针或引用绑定到派生类对象上，例如：可以用 Quote\u0026 指向一个 Bulk_quote 对象 ==当使用基类的引用（或指针）时，我们并不清楚该引用（指针）所绑定对象的真实类型==，可能该对象时基类的对象，也可能时派生类的对象 智能指针类也支持派生类向基类的类型转换 静态类型和动态类型 使用存在继承关系的类型时，需要区分一个变量或者表达式的静态类型和动态类型 静态类型编译时总是已知的，它是变量声明时的类型或者表达式生成的类型 动态类型则是变量或表达式表示内存中的对象的类型，运行时才可以确定 如果表达式既不是引用也不是指针，则它的动态类型和静态类型永远一致 不存在基类向派生类的隐式转换 派生类可以向基类转换是因为派生类中含有基类的成员，基类的引用或指针可以绑定到该基类部分上 而基类对象中可能存在派生类对象中的成员，也可能不存在，所以不能从基类向派生类自动类型转换 Quote base; Bulk_quote* bulkPtr = \u0026base; //错误：基类不能转换为派生类 Bulk_quote\u0026 bulkRef = base; //错误：基类不能转换为派生类 ==即使一个基类指针或者引用类型绑定在派生类对象上，我们也不能执行从基类向派生类的转换== Bulk_quote bulk; Quote *itemPtr = \u0026bulk; //正确：动态类型是Bulk_quote Bulk_quote *bulkPtr = itemPtr; //错误：不能将基类转换为派生类 编译器在编译时候无法确定上述转换过程在运行时是否安全，编译器只能检查静态类型来判断是否合法 对象之间不存在类型转换派生类向基类的自动类型转换只能对指针和引用有效，在派生类和基类类型之间不存在这样的转换。 当对基类进行初始化或者拷贝赋值时，如果传入的是派生类的对象，通常只会将派生类中含有基类的部分进行拷贝复制，而派生类多的部分会被忽略 Bulk_quote bulk; //派生类对象 Quote item(bulk); //使用Quote::Quote(const Quote\u0026)构造函数 item = bulk; //调用Quote::operator=(const Quote\u0026) 当构造 item 时，只会处理 Quote 类中的 bookNo 和 price 两个部分，同时忽略了 bulk 中其他成员 当使用一个派生类对象为基类对象初始化或赋值时，只有派生类对象中基类部分会被拷贝、移动或赋值，它的派生类部分会被忽略 问：给出静态类型和动态类型的定义 静态类型在编译时就己经确定了，它是变量声明时的类型或表达式生成的类型； 而动态类型则是变量或表达式表示的内存中的对象的类型，动态类型直到运行时才能知道； 如果一个变量非指针也非引用，则它的静态类型和动态类型永远一致。但基类的指针或引用的动态类型可能与其动态类型不一致 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:3","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#对象之间不存在类型转换"},{"categories":["C++"],"content":"15.3 虚函数我们使用基类的引用或指针调用一个虚函数的成员函数时，会执行动态绑定，直到运行时我们才能知道到底调用了哪个版本的虚函数，所以所有的虚函数都必须被定义 虚函数的调用可能在运行时才被解析下面是个例子： Quote base(\"0-201-824-1\", 50); print_total(cout, base, 10); //Quote::net_price Bulk_quote derived(\"021-82470-1\", 50); print_total(cout, derived, 10); //Bulk_quote::net_price 第一次调用 print_total 时，base 绑定到 Quote 上，运行的是 Quote 定义的版本 第二次调用时，derived 绑定的 Bulk_quote 版本上，调用的会是 Bulk_quote 定义的版本 动态绑定只有当通过引用或指针调用虚函数时才会发生 base = derived; //把derived中Quote部分拷贝给base base.net_price(20); //调用Quote::net_price 使用普通类型（非指针非引用）的表达式调用虚函数时，在编译阶段就已经确定下来调用的版本了 派生类中的虚函数 派生类如果覆盖继承而来的虚函数，它的形参类型和返回类型必须和基类函数一致 当派生类返回类型是指针或引用时，返回类型存在例外，如果 D 由 B 派生而来，则派生类的返回类型可以时 B* ，而基类返回类型为 D* final 和 override 说明符派生类如果定义了一个函数和虚函数名字相同但是形参列表不同，编译器会认为这个函数和原有函数相互独立，这样的话就不符合我们的想法，派生类没有覆盖基类中的虚函数。或者是在派生类定义函数时因为疏忽打错了函数名，也会出现上述情况 C++11新标准提供 override 关键字来说明派生类中的虚函数，这样使得程序员意图更清晰同时编译器也可以发现错误 struct B { virtual void f1(int) const; virtual void f2(); void f3(); }; struct D1 : B { void f1(int) const override; //正确：f1与基类f1匹配 void f2(int) override; //错误：形参不匹配 void f3() override; //错误：f3不是虚函数 void f4() override; //错误：基类没有名为f4函数 } 如果我们使用 final 关键字，则之后尝试覆盖该函数操作都会失败 struct D2 : B { //从B继承f2()和f3()，覆盖f1(int) void f1(int) const final;//不允许后续其他类覆盖f1(int) }; struct D3 : D2 { void f2(); //正确：覆盖从基类B间接继承来的f2() void f1(int) const; //错误：D2将f1声明为final } final 和 override 说明符出现在形参列表（包括任何const和引用修饰符）以及尾置返回类型之后 虚函数和默认实参虚函数也可以像其他函数一样拥有默认实参，基类和派生类定义的默认实参最好相同 回避虚函数的机制如果希望对虚函数的调用不要进行动态绑定，而是强迫执行虚函数的特定版本，可以使用作用域运算符实现这一目的 double undiscounted = basePtr-\u003eQuote::net_price(42); 通常情况下，只有成员函数（或友元）中代码才需要使用作用域运算符回避虚函数机制 通常当一个派生类的虚函数想调用基类中虚函数版本时，需要回避虚函数的机制 如果派生类虚函数中没有使用作用域运算符，运行时被解析成调用自身版本，导致无限循环 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:3:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#153-虚函数"},{"categories":["C++"],"content":"15.3 虚函数我们使用基类的引用或指针调用一个虚函数的成员函数时，会执行动态绑定，直到运行时我们才能知道到底调用了哪个版本的虚函数，所以所有的虚函数都必须被定义 虚函数的调用可能在运行时才被解析下面是个例子： Quote base(\"0-201-824-1\", 50); print_total(cout, base, 10); //Quote::net_price Bulk_quote derived(\"021-82470-1\", 50); print_total(cout, derived, 10); //Bulk_quote::net_price 第一次调用 print_total 时，base 绑定到 Quote 上，运行的是 Quote 定义的版本 第二次调用时，derived 绑定的 Bulk_quote 版本上，调用的会是 Bulk_quote 定义的版本 动态绑定只有当通过引用或指针调用虚函数时才会发生 base = derived; //把derived中Quote部分拷贝给base base.net_price(20); //调用Quote::net_price 使用普通类型（非指针非引用）的表达式调用虚函数时，在编译阶段就已经确定下来调用的版本了 派生类中的虚函数 派生类如果覆盖继承而来的虚函数，它的形参类型和返回类型必须和基类函数一致 当派生类返回类型是指针或引用时，返回类型存在例外，如果 D 由 B 派生而来，则派生类的返回类型可以时 B* ，而基类返回类型为 D* final 和 override 说明符派生类如果定义了一个函数和虚函数名字相同但是形参列表不同，编译器会认为这个函数和原有函数相互独立，这样的话就不符合我们的想法，派生类没有覆盖基类中的虚函数。或者是在派生类定义函数时因为疏忽打错了函数名，也会出现上述情况 C++11新标准提供 override 关键字来说明派生类中的虚函数，这样使得程序员意图更清晰同时编译器也可以发现错误 struct B { virtual void f1(int) const; virtual void f2(); void f3(); }; struct D1 : B { void f1(int) const override; //正确：f1与基类f1匹配 void f2(int) override; //错误：形参不匹配 void f3() override; //错误：f3不是虚函数 void f4() override; //错误：基类没有名为f4函数 } 如果我们使用 final 关键字，则之后尝试覆盖该函数操作都会失败 struct D2 : B { //从B继承f2()和f3()，覆盖f1(int) void f1(int) const final;//不允许后续其他类覆盖f1(int) }; struct D3 : D2 { void f2(); //正确：覆盖从基类B间接继承来的f2() void f1(int) const; //错误：D2将f1声明为final } final 和 override 说明符出现在形参列表（包括任何const和引用修饰符）以及尾置返回类型之后 虚函数和默认实参虚函数也可以像其他函数一样拥有默认实参，基类和派生类定义的默认实参最好相同 回避虚函数的机制如果希望对虚函数的调用不要进行动态绑定，而是强迫执行虚函数的特定版本，可以使用作用域运算符实现这一目的 double undiscounted = basePtr-Quote::net_price(42); 通常情况下，只有成员函数（或友元）中代码才需要使用作用域运算符回避虚函数机制 通常当一个派生类的虚函数想调用基类中虚函数版本时，需要回避虚函数的机制 如果派生类虚函数中没有使用作用域运算符，运行时被解析成调用自身版本，导致无限循环 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:3:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#虚函数的调用可能在运行时才被解析"},{"categories":["C++"],"content":"15.3 虚函数我们使用基类的引用或指针调用一个虚函数的成员函数时，会执行动态绑定，直到运行时我们才能知道到底调用了哪个版本的虚函数，所以所有的虚函数都必须被定义 虚函数的调用可能在运行时才被解析下面是个例子： Quote base(\"0-201-824-1\", 50); print_total(cout, base, 10); //Quote::net_price Bulk_quote derived(\"021-82470-1\", 50); print_total(cout, derived, 10); //Bulk_quote::net_price 第一次调用 print_total 时，base 绑定到 Quote 上，运行的是 Quote 定义的版本 第二次调用时，derived 绑定的 Bulk_quote 版本上，调用的会是 Bulk_quote 定义的版本 动态绑定只有当通过引用或指针调用虚函数时才会发生 base = derived; //把derived中Quote部分拷贝给base base.net_price(20); //调用Quote::net_price 使用普通类型（非指针非引用）的表达式调用虚函数时，在编译阶段就已经确定下来调用的版本了 派生类中的虚函数 派生类如果覆盖继承而来的虚函数，它的形参类型和返回类型必须和基类函数一致 当派生类返回类型是指针或引用时，返回类型存在例外，如果 D 由 B 派生而来，则派生类的返回类型可以时 B* ，而基类返回类型为 D* final 和 override 说明符派生类如果定义了一个函数和虚函数名字相同但是形参列表不同，编译器会认为这个函数和原有函数相互独立，这样的话就不符合我们的想法，派生类没有覆盖基类中的虚函数。或者是在派生类定义函数时因为疏忽打错了函数名，也会出现上述情况 C++11新标准提供 override 关键字来说明派生类中的虚函数，这样使得程序员意图更清晰同时编译器也可以发现错误 struct B { virtual void f1(int) const; virtual void f2(); void f3(); }; struct D1 : B { void f1(int) const override; //正确：f1与基类f1匹配 void f2(int) override; //错误：形参不匹配 void f3() override; //错误：f3不是虚函数 void f4() override; //错误：基类没有名为f4函数 } 如果我们使用 final 关键字，则之后尝试覆盖该函数操作都会失败 struct D2 : B { //从B继承f2()和f3()，覆盖f1(int) void f1(int) const final;//不允许后续其他类覆盖f1(int) }; struct D3 : D2 { void f2(); //正确：覆盖从基类B间接继承来的f2() void f1(int) const; //错误：D2将f1声明为final } final 和 override 说明符出现在形参列表（包括任何const和引用修饰符）以及尾置返回类型之后 虚函数和默认实参虚函数也可以像其他函数一样拥有默认实参，基类和派生类定义的默认实参最好相同 回避虚函数的机制如果希望对虚函数的调用不要进行动态绑定，而是强迫执行虚函数的特定版本，可以使用作用域运算符实现这一目的 double undiscounted = basePtr-Quote::net_price(42); 通常情况下，只有成员函数（或友元）中代码才需要使用作用域运算符回避虚函数机制 通常当一个派生类的虚函数想调用基类中虚函数版本时，需要回避虚函数的机制 如果派生类虚函数中没有使用作用域运算符，运行时被解析成调用自身版本，导致无限循环 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:3:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#派生类中的虚函数-1"},{"categories":["C++"],"content":"15.3 虚函数我们使用基类的引用或指针调用一个虚函数的成员函数时，会执行动态绑定，直到运行时我们才能知道到底调用了哪个版本的虚函数，所以所有的虚函数都必须被定义 虚函数的调用可能在运行时才被解析下面是个例子： Quote base(\"0-201-824-1\", 50); print_total(cout, base, 10); //Quote::net_price Bulk_quote derived(\"021-82470-1\", 50); print_total(cout, derived, 10); //Bulk_quote::net_price 第一次调用 print_total 时，base 绑定到 Quote 上，运行的是 Quote 定义的版本 第二次调用时，derived 绑定的 Bulk_quote 版本上，调用的会是 Bulk_quote 定义的版本 动态绑定只有当通过引用或指针调用虚函数时才会发生 base = derived; //把derived中Quote部分拷贝给base base.net_price(20); //调用Quote::net_price 使用普通类型（非指针非引用）的表达式调用虚函数时，在编译阶段就已经确定下来调用的版本了 派生类中的虚函数 派生类如果覆盖继承而来的虚函数，它的形参类型和返回类型必须和基类函数一致 当派生类返回类型是指针或引用时，返回类型存在例外，如果 D 由 B 派生而来，则派生类的返回类型可以时 B* ，而基类返回类型为 D* final 和 override 说明符派生类如果定义了一个函数和虚函数名字相同但是形参列表不同，编译器会认为这个函数和原有函数相互独立，这样的话就不符合我们的想法，派生类没有覆盖基类中的虚函数。或者是在派生类定义函数时因为疏忽打错了函数名，也会出现上述情况 C++11新标准提供 override 关键字来说明派生类中的虚函数，这样使得程序员意图更清晰同时编译器也可以发现错误 struct B { virtual void f1(int) const; virtual void f2(); void f3(); }; struct D1 : B { void f1(int) const override; //正确：f1与基类f1匹配 void f2(int) override; //错误：形参不匹配 void f3() override; //错误：f3不是虚函数 void f4() override; //错误：基类没有名为f4函数 } 如果我们使用 final 关键字，则之后尝试覆盖该函数操作都会失败 struct D2 : B { //从B继承f2()和f3()，覆盖f1(int) void f1(int) const final;//不允许后续其他类覆盖f1(int) }; struct D3 : D2 { void f2(); //正确：覆盖从基类B间接继承来的f2() void f1(int) const; //错误：D2将f1声明为final } final 和 override 说明符出现在形参列表（包括任何const和引用修饰符）以及尾置返回类型之后 虚函数和默认实参虚函数也可以像其他函数一样拥有默认实参，基类和派生类定义的默认实参最好相同 回避虚函数的机制如果希望对虚函数的调用不要进行动态绑定，而是强迫执行虚函数的特定版本，可以使用作用域运算符实现这一目的 double undiscounted = basePtr-Quote::net_price(42); 通常情况下，只有成员函数（或友元）中代码才需要使用作用域运算符回避虚函数机制 通常当一个派生类的虚函数想调用基类中虚函数版本时，需要回避虚函数的机制 如果派生类虚函数中没有使用作用域运算符，运行时被解析成调用自身版本，导致无限循环 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:3:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#final-和-override-说明符"},{"categories":["C++"],"content":"15.3 虚函数我们使用基类的引用或指针调用一个虚函数的成员函数时，会执行动态绑定，直到运行时我们才能知道到底调用了哪个版本的虚函数，所以所有的虚函数都必须被定义 虚函数的调用可能在运行时才被解析下面是个例子： Quote base(\"0-201-824-1\", 50); print_total(cout, base, 10); //Quote::net_price Bulk_quote derived(\"021-82470-1\", 50); print_total(cout, derived, 10); //Bulk_quote::net_price 第一次调用 print_total 时，base 绑定到 Quote 上，运行的是 Quote 定义的版本 第二次调用时，derived 绑定的 Bulk_quote 版本上，调用的会是 Bulk_quote 定义的版本 动态绑定只有当通过引用或指针调用虚函数时才会发生 base = derived; //把derived中Quote部分拷贝给base base.net_price(20); //调用Quote::net_price 使用普通类型（非指针非引用）的表达式调用虚函数时，在编译阶段就已经确定下来调用的版本了 派生类中的虚函数 派生类如果覆盖继承而来的虚函数，它的形参类型和返回类型必须和基类函数一致 当派生类返回类型是指针或引用时，返回类型存在例外，如果 D 由 B 派生而来，则派生类的返回类型可以时 B* ，而基类返回类型为 D* final 和 override 说明符派生类如果定义了一个函数和虚函数名字相同但是形参列表不同，编译器会认为这个函数和原有函数相互独立，这样的话就不符合我们的想法，派生类没有覆盖基类中的虚函数。或者是在派生类定义函数时因为疏忽打错了函数名，也会出现上述情况 C++11新标准提供 override 关键字来说明派生类中的虚函数，这样使得程序员意图更清晰同时编译器也可以发现错误 struct B { virtual void f1(int) const; virtual void f2(); void f3(); }; struct D1 : B { void f1(int) const override; //正确：f1与基类f1匹配 void f2(int) override; //错误：形参不匹配 void f3() override; //错误：f3不是虚函数 void f4() override; //错误：基类没有名为f4函数 } 如果我们使用 final 关键字，则之后尝试覆盖该函数操作都会失败 struct D2 : B { //从B继承f2()和f3()，覆盖f1(int) void f1(int) const final;//不允许后续其他类覆盖f1(int) }; struct D3 : D2 { void f2(); //正确：覆盖从基类B间接继承来的f2() void f1(int) const; //错误：D2将f1声明为final } final 和 override 说明符出现在形参列表（包括任何const和引用修饰符）以及尾置返回类型之后 虚函数和默认实参虚函数也可以像其他函数一样拥有默认实参，基类和派生类定义的默认实参最好相同 回避虚函数的机制如果希望对虚函数的调用不要进行动态绑定，而是强迫执行虚函数的特定版本，可以使用作用域运算符实现这一目的 double undiscounted = basePtr-Quote::net_price(42); 通常情况下，只有成员函数（或友元）中代码才需要使用作用域运算符回避虚函数机制 通常当一个派生类的虚函数想调用基类中虚函数版本时，需要回避虚函数的机制 如果派生类虚函数中没有使用作用域运算符，运行时被解析成调用自身版本，导致无限循环 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:3:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#虚函数和默认实参"},{"categories":["C++"],"content":"15.3 虚函数我们使用基类的引用或指针调用一个虚函数的成员函数时，会执行动态绑定，直到运行时我们才能知道到底调用了哪个版本的虚函数，所以所有的虚函数都必须被定义 虚函数的调用可能在运行时才被解析下面是个例子： Quote base(\"0-201-824-1\", 50); print_total(cout, base, 10); //Quote::net_price Bulk_quote derived(\"021-82470-1\", 50); print_total(cout, derived, 10); //Bulk_quote::net_price 第一次调用 print_total 时，base 绑定到 Quote 上，运行的是 Quote 定义的版本 第二次调用时，derived 绑定的 Bulk_quote 版本上，调用的会是 Bulk_quote 定义的版本 动态绑定只有当通过引用或指针调用虚函数时才会发生 base = derived; //把derived中Quote部分拷贝给base base.net_price(20); //调用Quote::net_price 使用普通类型（非指针非引用）的表达式调用虚函数时，在编译阶段就已经确定下来调用的版本了 派生类中的虚函数 派生类如果覆盖继承而来的虚函数，它的形参类型和返回类型必须和基类函数一致 当派生类返回类型是指针或引用时，返回类型存在例外，如果 D 由 B 派生而来，则派生类的返回类型可以时 B* ，而基类返回类型为 D* final 和 override 说明符派生类如果定义了一个函数和虚函数名字相同但是形参列表不同，编译器会认为这个函数和原有函数相互独立，这样的话就不符合我们的想法，派生类没有覆盖基类中的虚函数。或者是在派生类定义函数时因为疏忽打错了函数名，也会出现上述情况 C++11新标准提供 override 关键字来说明派生类中的虚函数，这样使得程序员意图更清晰同时编译器也可以发现错误 struct B { virtual void f1(int) const; virtual void f2(); void f3(); }; struct D1 : B { void f1(int) const override; //正确：f1与基类f1匹配 void f2(int) override; //错误：形参不匹配 void f3() override; //错误：f3不是虚函数 void f4() override; //错误：基类没有名为f4函数 } 如果我们使用 final 关键字，则之后尝试覆盖该函数操作都会失败 struct D2 : B { //从B继承f2()和f3()，覆盖f1(int) void f1(int) const final;//不允许后续其他类覆盖f1(int) }; struct D3 : D2 { void f2(); //正确：覆盖从基类B间接继承来的f2() void f1(int) const; //错误：D2将f1声明为final } final 和 override 说明符出现在形参列表（包括任何const和引用修饰符）以及尾置返回类型之后 虚函数和默认实参虚函数也可以像其他函数一样拥有默认实参，基类和派生类定义的默认实参最好相同 回避虚函数的机制如果希望对虚函数的调用不要进行动态绑定，而是强迫执行虚函数的特定版本，可以使用作用域运算符实现这一目的 double undiscounted = basePtr-Quote::net_price(42); 通常情况下，只有成员函数（或友元）中代码才需要使用作用域运算符回避虚函数机制 通常当一个派生类的虚函数想调用基类中虚函数版本时，需要回避虚函数的机制 如果派生类虚函数中没有使用作用域运算符，运行时被解析成调用自身版本，导致无限循环 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:3:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#回避虚函数的机制"},{"categories":["C++"],"content":"15.4 抽象基类纯虚函数我们如果将虚函数定义为纯虚函数，含有该函数的类是抽象基类，抽象基类负责定义接口，而后续其他类可以覆盖该接口 我们在函数体的位置（即分号前面）书写 =0 就可以将一个虚函数说明为纯虚函数 class Disc_quote : public Quote { public: Disc_quote() = default; Disc_quote(const std::string\u0026 book, double price, std::size_t qty, double price) : Quote(book, price), quantity(qty), discount(dis) {} double net_price(std::size_t) const = 0; protected: std::size_t quantity = 0; double discount = 0.0; } 纯虚函数无须定义，我们也可以为其定义，但函数体必须写在类的外部，即我们不能在类的内部为一个 =0 的函数提供函数体 我们不能直接创建一个抽象基类的对象 派生类构造函数只初始化它的直接基类下面重新实现 Bulk_quote class Bulk_quote : public Disc_quote { public: Bulk_quote() = default; Bulk_quote(const std::string\u0026 book, double price, std::size_t qty, double price) : Disc_quote(book, price, qty, disc) {} double net_price(std::size_t) const override; }; 每个类各自控制其对象的初始化过程，即使 Bulk_quote 中没有任何数据成员，也需要提供一个构造函数，初始化它的直接基类，也就是 Disc_quote ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:4:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#154-抽象基类"},{"categories":["C++"],"content":"15.4 抽象基类纯虚函数我们如果将虚函数定义为纯虚函数，含有该函数的类是抽象基类，抽象基类负责定义接口，而后续其他类可以覆盖该接口 我们在函数体的位置（即分号前面）书写 =0 就可以将一个虚函数说明为纯虚函数 class Disc_quote : public Quote { public: Disc_quote() = default; Disc_quote(const std::string\u0026 book, double price, std::size_t qty, double price) : Quote(book, price), quantity(qty), discount(dis) {} double net_price(std::size_t) const = 0; protected: std::size_t quantity = 0; double discount = 0.0; } 纯虚函数无须定义，我们也可以为其定义，但函数体必须写在类的外部，即我们不能在类的内部为一个 =0 的函数提供函数体 我们不能直接创建一个抽象基类的对象 派生类构造函数只初始化它的直接基类下面重新实现 Bulk_quote class Bulk_quote : public Disc_quote { public: Bulk_quote() = default; Bulk_quote(const std::string\u0026 book, double price, std::size_t qty, double price) : Disc_quote(book, price, qty, disc) {} double net_price(std::size_t) const override; }; 每个类各自控制其对象的初始化过程，即使 Bulk_quote 中没有任何数据成员，也需要提供一个构造函数，初始化它的直接基类，也就是 Disc_quote ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:4:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#纯虚函数"},{"categories":["C++"],"content":"15.4 抽象基类纯虚函数我们如果将虚函数定义为纯虚函数，含有该函数的类是抽象基类，抽象基类负责定义接口，而后续其他类可以覆盖该接口 我们在函数体的位置（即分号前面）书写 =0 就可以将一个虚函数说明为纯虚函数 class Disc_quote : public Quote { public: Disc_quote() = default; Disc_quote(const std::string\u0026 book, double price, std::size_t qty, double price) : Quote(book, price), quantity(qty), discount(dis) {} double net_price(std::size_t) const = 0; protected: std::size_t quantity = 0; double discount = 0.0; } 纯虚函数无须定义，我们也可以为其定义，但函数体必须写在类的外部，即我们不能在类的内部为一个 =0 的函数提供函数体 我们不能直接创建一个抽象基类的对象 派生类构造函数只初始化它的直接基类下面重新实现 Bulk_quote class Bulk_quote : public Disc_quote { public: Bulk_quote() = default; Bulk_quote(const std::string\u0026 book, double price, std::size_t qty, double price) : Disc_quote(book, price, qty, disc) {} double net_price(std::size_t) const override; }; 每个类各自控制其对象的初始化过程，即使 Bulk_quote 中没有任何数据成员，也需要提供一个构造函数，初始化它的直接基类，也就是 Disc_quote ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:4:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#派生类构造函数只初始化它的直接基类"},{"categories":["C++"],"content":"15.5 访问控制与继承每个类分别控制自己成员初始化过程，每个类还控制着其成员对于派生类来说是否可访问 受保护的成员protected 关键字可以控制那些它希望与派生类分享但是不想和其他公共访问使用的成员 和私有成员类似，受保护的成员对于类的用户是不可访问的 和公有成员类型，受保护的成员对于派生类和友元是可访问的 派生类的成员或友元只能通过派生类对象来访问基类中受保护的成员 派生类对于基类对象中受保护成员没有任何访问权限 class Base { protected: int prot_mem; }; class Sneaky : public Base { friend void clobber(Sneaky\u0026);//能访问Sneaky::prot_mem friend void clobber(Base\u0026*); //不能访问Base::prot_mem int j; //默认为private }; //正确：可以访问Sneaky对象的private和protected成员 void clobber(Sneaky \u0026s) { s.j = s.prot_mem = 0; } //错误：不能访问Base中的protected成员 void clobber(Base \u0026b) { b.prot_mem = 0; } 上面的最后一条的含义是一个派生类成员和友元只能访问派生类继承过来属于基类那部分的受保护成员（这些成员，派生类自己本身也有，成员和友元可以访问自己本身的受保护的成员），而不能直接访问基类对象中的受保护成员 公共、私有和受保护继承类对继承而来的成员的访问权限受到两个因素影响：一是基类在该成员的访问说明符，二是派生类的派生列表中的访问说明符 class Base { public: void pub_mem(); protected: int prot_mem; private: char priv_mem; }; struct Pub_Derv : public Base { //正确：派生类能访问protected成员 int f() { return prot_mem; } //错误：派生类不能访问private成员 char g() { return priv_mem; } }; struct Priv_Derv : private Base { //private不影响派生类访问权限 int f1() const { return prot_mem; } }; 派生类访问说明符对于派生类的成员能否访问直接基类的成员没有什么影响，如上 Pub_Derv 和 Priv_Derv 都可以访问基类 Base 中的 prot_mem 派生类访问说明符是控制派生类用户（包括派生类的派生类）对于基类成员的访问权限，相当于将基类成员定义为相应的访问说明符 Pub_Derv d1; Priv_Derv d2; d1.pub_mem(); //正确：pub_mem在派生类中是public的 d2.pub_mem(); //错误：pub_mem在派生类中是protected的 此时在 Priv_Derv 中基类的成员被定义为 private 的了，这样它创建的对象就不可以直接访问 派生类向基类转换的可访问性派生类向基类的转换是否可访问由使用该转换的代码决定，同时派牛类的派生访问说明符也会有影响。假定D 继承自B :· 只有当 D 公有地继承 B 时，用户代码才能使用派生类向基类的转换；如果 D 继承 B 的方式是受保护的或者私有的，则用户代码不能使用该转换。 不论 D 以什么方式继承B , D 的成员函数和友元都能使用派生类向基类的转换： 派生类向其直接基类的类型转换对千派牛类的成员和友元来说水远是可访问的。 如果 D 继承 B 的方式是公有的或者受保护的，则 D 的派生类的成员和友元可以使用 D 向 B 的类型转换； 反之，如果 D 继承 B 的方式是私有的，则不能使用。 友元和继承友元关系不能传递，也不能继承，基类的友元在访问派生类成员时不具有特殊性 class Base { friend class Pal; protected: int prot_mem; }; class Sneaky : public Base { friend void clobber(Sneaky\u0026);//能访问Sneaky::prot_mem friend void clobber(Base\u0026*); //不能访问Base::prot_mem int j; //默认为private }; class Pal { public: int f(Base b) { return b.prot_mem; } //正确：Pal是Base友元 int f(Sneaky s) { return s.j; } //错误：Pal不是Sneaky友元 int f3(Sneaky s) { return s.prot_mem; }//正确：Pal是Base友元 } f3 访问了派生类中基类部分的成员，Pal 是基类的友元，Pal 能够访问 Base 对象的成员 友元只对做出声明的类有效，而友元的基类或派生类不具有特殊访问能力 class D2 : public Pal { public: int mem(Base b) { return b.prot_mem; } //错误友元不能继承 } 改变个别成员的可访问性如果需要改变派生类继承的某个名字的访问性，可以使用 using 声明达到这个目的 class Base { public: std::size_t size() cont { return n; } protected: std::size_t n; }; class Dervied : private Base { public: using Base::size; protected: using Base::n; }; Derived 为私有继承，继承的size 和 n 默认情况下是 Derived 的私有成员，使用 using 声明语句，可以改变这个成员的可访问性，此时的 Derived 用户都可以使用 size，而只有 Derived 的派生类才可以使用 n using 声明控制的访问权限仅由声明语句前面的访问说明符决定 默认的继承保护级别默认情况下，class 关键字的派生类是私有继承的，struct 关键字的派生类是公有继承的 class Base { /**/ }; struct D1 : Base { /**/ }; //默认public继承 class D2 : Base { /**/ }; //默认private继承 struct 和 class 关键字唯一区别就是默认成员访问说明符默认派生访问说明符的区别 一个私有派生的类最好显示的声明 private，不要仅仅依赖默认设置 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:5:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#155-访问控制与继承"},{"categories":["C++"],"content":"15.5 访问控制与继承每个类分别控制自己成员初始化过程，每个类还控制着其成员对于派生类来说是否可访问 受保护的成员protected 关键字可以控制那些它希望与派生类分享但是不想和其他公共访问使用的成员 和私有成员类似，受保护的成员对于类的用户是不可访问的 和公有成员类型，受保护的成员对于派生类和友元是可访问的 派生类的成员或友元只能通过派生类对象来访问基类中受保护的成员 派生类对于基类对象中受保护成员没有任何访问权限 class Base { protected: int prot_mem; }; class Sneaky : public Base { friend void clobber(Sneaky\u0026);//能访问Sneaky::prot_mem friend void clobber(Base\u0026*); //不能访问Base::prot_mem int j; //默认为private }; //正确：可以访问Sneaky对象的private和protected成员 void clobber(Sneaky \u0026s) { s.j = s.prot_mem = 0; } //错误：不能访问Base中的protected成员 void clobber(Base \u0026b) { b.prot_mem = 0; } 上面的最后一条的含义是一个派生类成员和友元只能访问派生类继承过来属于基类那部分的受保护成员（这些成员，派生类自己本身也有，成员和友元可以访问自己本身的受保护的成员），而不能直接访问基类对象中的受保护成员 公共、私有和受保护继承类对继承而来的成员的访问权限受到两个因素影响：一是基类在该成员的访问说明符，二是派生类的派生列表中的访问说明符 class Base { public: void pub_mem(); protected: int prot_mem; private: char priv_mem; }; struct Pub_Derv : public Base { //正确：派生类能访问protected成员 int f() { return prot_mem; } //错误：派生类不能访问private成员 char g() { return priv_mem; } }; struct Priv_Derv : private Base { //private不影响派生类访问权限 int f1() const { return prot_mem; } }; 派生类访问说明符对于派生类的成员能否访问直接基类的成员没有什么影响，如上 Pub_Derv 和 Priv_Derv 都可以访问基类 Base 中的 prot_mem 派生类访问说明符是控制派生类用户（包括派生类的派生类）对于基类成员的访问权限，相当于将基类成员定义为相应的访问说明符 Pub_Derv d1; Priv_Derv d2; d1.pub_mem(); //正确：pub_mem在派生类中是public的 d2.pub_mem(); //错误：pub_mem在派生类中是protected的 此时在 Priv_Derv 中基类的成员被定义为 private 的了，这样它创建的对象就不可以直接访问 派生类向基类转换的可访问性派生类向基类的转换是否可访问由使用该转换的代码决定，同时派牛类的派生访问说明符也会有影响。假定D 继承自B :· 只有当 D 公有地继承 B 时，用户代码才能使用派生类向基类的转换；如果 D 继承 B 的方式是受保护的或者私有的，则用户代码不能使用该转换。 不论 D 以什么方式继承B , D 的成员函数和友元都能使用派生类向基类的转换： 派生类向其直接基类的类型转换对千派牛类的成员和友元来说水远是可访问的。 如果 D 继承 B 的方式是公有的或者受保护的，则 D 的派生类的成员和友元可以使用 D 向 B 的类型转换； 反之，如果 D 继承 B 的方式是私有的，则不能使用。 友元和继承友元关系不能传递，也不能继承，基类的友元在访问派生类成员时不具有特殊性 class Base { friend class Pal; protected: int prot_mem; }; class Sneaky : public Base { friend void clobber(Sneaky\u0026);//能访问Sneaky::prot_mem friend void clobber(Base\u0026*); //不能访问Base::prot_mem int j; //默认为private }; class Pal { public: int f(Base b) { return b.prot_mem; } //正确：Pal是Base友元 int f(Sneaky s) { return s.j; } //错误：Pal不是Sneaky友元 int f3(Sneaky s) { return s.prot_mem; }//正确：Pal是Base友元 } f3 访问了派生类中基类部分的成员，Pal 是基类的友元，Pal 能够访问 Base 对象的成员 友元只对做出声明的类有效，而友元的基类或派生类不具有特殊访问能力 class D2 : public Pal { public: int mem(Base b) { return b.prot_mem; } //错误友元不能继承 } 改变个别成员的可访问性如果需要改变派生类继承的某个名字的访问性，可以使用 using 声明达到这个目的 class Base { public: std::size_t size() cont { return n; } protected: std::size_t n; }; class Dervied : private Base { public: using Base::size; protected: using Base::n; }; Derived 为私有继承，继承的size 和 n 默认情况下是 Derived 的私有成员，使用 using 声明语句，可以改变这个成员的可访问性，此时的 Derived 用户都可以使用 size，而只有 Derived 的派生类才可以使用 n using 声明控制的访问权限仅由声明语句前面的访问说明符决定 默认的继承保护级别默认情况下，class 关键字的派生类是私有继承的，struct 关键字的派生类是公有继承的 class Base { /**/ }; struct D1 : Base { /**/ }; //默认public继承 class D2 : Base { /**/ }; //默认private继承 struct 和 class 关键字唯一区别就是默认成员访问说明符默认派生访问说明符的区别 一个私有派生的类最好显示的声明 private，不要仅仅依赖默认设置 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:5:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#受保护的成员"},{"categories":["C++"],"content":"15.5 访问控制与继承每个类分别控制自己成员初始化过程，每个类还控制着其成员对于派生类来说是否可访问 受保护的成员protected 关键字可以控制那些它希望与派生类分享但是不想和其他公共访问使用的成员 和私有成员类似，受保护的成员对于类的用户是不可访问的 和公有成员类型，受保护的成员对于派生类和友元是可访问的 派生类的成员或友元只能通过派生类对象来访问基类中受保护的成员 派生类对于基类对象中受保护成员没有任何访问权限 class Base { protected: int prot_mem; }; class Sneaky : public Base { friend void clobber(Sneaky\u0026);//能访问Sneaky::prot_mem friend void clobber(Base\u0026*); //不能访问Base::prot_mem int j; //默认为private }; //正确：可以访问Sneaky对象的private和protected成员 void clobber(Sneaky \u0026s) { s.j = s.prot_mem = 0; } //错误：不能访问Base中的protected成员 void clobber(Base \u0026b) { b.prot_mem = 0; } 上面的最后一条的含义是一个派生类成员和友元只能访问派生类继承过来属于基类那部分的受保护成员（这些成员，派生类自己本身也有，成员和友元可以访问自己本身的受保护的成员），而不能直接访问基类对象中的受保护成员 公共、私有和受保护继承类对继承而来的成员的访问权限受到两个因素影响：一是基类在该成员的访问说明符，二是派生类的派生列表中的访问说明符 class Base { public: void pub_mem(); protected: int prot_mem; private: char priv_mem; }; struct Pub_Derv : public Base { //正确：派生类能访问protected成员 int f() { return prot_mem; } //错误：派生类不能访问private成员 char g() { return priv_mem; } }; struct Priv_Derv : private Base { //private不影响派生类访问权限 int f1() const { return prot_mem; } }; 派生类访问说明符对于派生类的成员能否访问直接基类的成员没有什么影响，如上 Pub_Derv 和 Priv_Derv 都可以访问基类 Base 中的 prot_mem 派生类访问说明符是控制派生类用户（包括派生类的派生类）对于基类成员的访问权限，相当于将基类成员定义为相应的访问说明符 Pub_Derv d1; Priv_Derv d2; d1.pub_mem(); //正确：pub_mem在派生类中是public的 d2.pub_mem(); //错误：pub_mem在派生类中是protected的 此时在 Priv_Derv 中基类的成员被定义为 private 的了，这样它创建的对象就不可以直接访问 派生类向基类转换的可访问性派生类向基类的转换是否可访问由使用该转换的代码决定，同时派牛类的派生访问说明符也会有影响。假定D 继承自B :· 只有当 D 公有地继承 B 时，用户代码才能使用派生类向基类的转换；如果 D 继承 B 的方式是受保护的或者私有的，则用户代码不能使用该转换。 不论 D 以什么方式继承B , D 的成员函数和友元都能使用派生类向基类的转换： 派生类向其直接基类的类型转换对千派牛类的成员和友元来说水远是可访问的。 如果 D 继承 B 的方式是公有的或者受保护的，则 D 的派生类的成员和友元可以使用 D 向 B 的类型转换； 反之，如果 D 继承 B 的方式是私有的，则不能使用。 友元和继承友元关系不能传递，也不能继承，基类的友元在访问派生类成员时不具有特殊性 class Base { friend class Pal; protected: int prot_mem; }; class Sneaky : public Base { friend void clobber(Sneaky\u0026);//能访问Sneaky::prot_mem friend void clobber(Base\u0026*); //不能访问Base::prot_mem int j; //默认为private }; class Pal { public: int f(Base b) { return b.prot_mem; } //正确：Pal是Base友元 int f(Sneaky s) { return s.j; } //错误：Pal不是Sneaky友元 int f3(Sneaky s) { return s.prot_mem; }//正确：Pal是Base友元 } f3 访问了派生类中基类部分的成员，Pal 是基类的友元，Pal 能够访问 Base 对象的成员 友元只对做出声明的类有效，而友元的基类或派生类不具有特殊访问能力 class D2 : public Pal { public: int mem(Base b) { return b.prot_mem; } //错误友元不能继承 } 改变个别成员的可访问性如果需要改变派生类继承的某个名字的访问性，可以使用 using 声明达到这个目的 class Base { public: std::size_t size() cont { return n; } protected: std::size_t n; }; class Dervied : private Base { public: using Base::size; protected: using Base::n; }; Derived 为私有继承，继承的size 和 n 默认情况下是 Derived 的私有成员，使用 using 声明语句，可以改变这个成员的可访问性，此时的 Derived 用户都可以使用 size，而只有 Derived 的派生类才可以使用 n using 声明控制的访问权限仅由声明语句前面的访问说明符决定 默认的继承保护级别默认情况下，class 关键字的派生类是私有继承的，struct 关键字的派生类是公有继承的 class Base { /**/ }; struct D1 : Base { /**/ }; //默认public继承 class D2 : Base { /**/ }; //默认private继承 struct 和 class 关键字唯一区别就是默认成员访问说明符默认派生访问说明符的区别 一个私有派生的类最好显示的声明 private，不要仅仅依赖默认设置 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:5:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#公共私有和受保护继承"},{"categories":["C++"],"content":"15.5 访问控制与继承每个类分别控制自己成员初始化过程，每个类还控制着其成员对于派生类来说是否可访问 受保护的成员protected 关键字可以控制那些它希望与派生类分享但是不想和其他公共访问使用的成员 和私有成员类似，受保护的成员对于类的用户是不可访问的 和公有成员类型，受保护的成员对于派生类和友元是可访问的 派生类的成员或友元只能通过派生类对象来访问基类中受保护的成员 派生类对于基类对象中受保护成员没有任何访问权限 class Base { protected: int prot_mem; }; class Sneaky : public Base { friend void clobber(Sneaky\u0026);//能访问Sneaky::prot_mem friend void clobber(Base\u0026*); //不能访问Base::prot_mem int j; //默认为private }; //正确：可以访问Sneaky对象的private和protected成员 void clobber(Sneaky \u0026s) { s.j = s.prot_mem = 0; } //错误：不能访问Base中的protected成员 void clobber(Base \u0026b) { b.prot_mem = 0; } 上面的最后一条的含义是一个派生类成员和友元只能访问派生类继承过来属于基类那部分的受保护成员（这些成员，派生类自己本身也有，成员和友元可以访问自己本身的受保护的成员），而不能直接访问基类对象中的受保护成员 公共、私有和受保护继承类对继承而来的成员的访问权限受到两个因素影响：一是基类在该成员的访问说明符，二是派生类的派生列表中的访问说明符 class Base { public: void pub_mem(); protected: int prot_mem; private: char priv_mem; }; struct Pub_Derv : public Base { //正确：派生类能访问protected成员 int f() { return prot_mem; } //错误：派生类不能访问private成员 char g() { return priv_mem; } }; struct Priv_Derv : private Base { //private不影响派生类访问权限 int f1() const { return prot_mem; } }; 派生类访问说明符对于派生类的成员能否访问直接基类的成员没有什么影响，如上 Pub_Derv 和 Priv_Derv 都可以访问基类 Base 中的 prot_mem 派生类访问说明符是控制派生类用户（包括派生类的派生类）对于基类成员的访问权限，相当于将基类成员定义为相应的访问说明符 Pub_Derv d1; Priv_Derv d2; d1.pub_mem(); //正确：pub_mem在派生类中是public的 d2.pub_mem(); //错误：pub_mem在派生类中是protected的 此时在 Priv_Derv 中基类的成员被定义为 private 的了，这样它创建的对象就不可以直接访问 派生类向基类转换的可访问性派生类向基类的转换是否可访问由使用该转换的代码决定，同时派牛类的派生访问说明符也会有影响。假定D 继承自B :· 只有当 D 公有地继承 B 时，用户代码才能使用派生类向基类的转换；如果 D 继承 B 的方式是受保护的或者私有的，则用户代码不能使用该转换。 不论 D 以什么方式继承B , D 的成员函数和友元都能使用派生类向基类的转换： 派生类向其直接基类的类型转换对千派牛类的成员和友元来说水远是可访问的。 如果 D 继承 B 的方式是公有的或者受保护的，则 D 的派生类的成员和友元可以使用 D 向 B 的类型转换； 反之，如果 D 继承 B 的方式是私有的，则不能使用。 友元和继承友元关系不能传递，也不能继承，基类的友元在访问派生类成员时不具有特殊性 class Base { friend class Pal; protected: int prot_mem; }; class Sneaky : public Base { friend void clobber(Sneaky\u0026);//能访问Sneaky::prot_mem friend void clobber(Base\u0026*); //不能访问Base::prot_mem int j; //默认为private }; class Pal { public: int f(Base b) { return b.prot_mem; } //正确：Pal是Base友元 int f(Sneaky s) { return s.j; } //错误：Pal不是Sneaky友元 int f3(Sneaky s) { return s.prot_mem; }//正确：Pal是Base友元 } f3 访问了派生类中基类部分的成员，Pal 是基类的友元，Pal 能够访问 Base 对象的成员 友元只对做出声明的类有效，而友元的基类或派生类不具有特殊访问能力 class D2 : public Pal { public: int mem(Base b) { return b.prot_mem; } //错误友元不能继承 } 改变个别成员的可访问性如果需要改变派生类继承的某个名字的访问性，可以使用 using 声明达到这个目的 class Base { public: std::size_t size() cont { return n; } protected: std::size_t n; }; class Dervied : private Base { public: using Base::size; protected: using Base::n; }; Derived 为私有继承，继承的size 和 n 默认情况下是 Derived 的私有成员，使用 using 声明语句，可以改变这个成员的可访问性，此时的 Derived 用户都可以使用 size，而只有 Derived 的派生类才可以使用 n using 声明控制的访问权限仅由声明语句前面的访问说明符决定 默认的继承保护级别默认情况下，class 关键字的派生类是私有继承的，struct 关键字的派生类是公有继承的 class Base { /**/ }; struct D1 : Base { /**/ }; //默认public继承 class D2 : Base { /**/ }; //默认private继承 struct 和 class 关键字唯一区别就是默认成员访问说明符默认派生访问说明符的区别 一个私有派生的类最好显示的声明 private，不要仅仅依赖默认设置 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:5:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#派生类向基类转换的可访问性"},{"categories":["C++"],"content":"15.5 访问控制与继承每个类分别控制自己成员初始化过程，每个类还控制着其成员对于派生类来说是否可访问 受保护的成员protected 关键字可以控制那些它希望与派生类分享但是不想和其他公共访问使用的成员 和私有成员类似，受保护的成员对于类的用户是不可访问的 和公有成员类型，受保护的成员对于派生类和友元是可访问的 派生类的成员或友元只能通过派生类对象来访问基类中受保护的成员 派生类对于基类对象中受保护成员没有任何访问权限 class Base { protected: int prot_mem; }; class Sneaky : public Base { friend void clobber(Sneaky\u0026);//能访问Sneaky::prot_mem friend void clobber(Base\u0026*); //不能访问Base::prot_mem int j; //默认为private }; //正确：可以访问Sneaky对象的private和protected成员 void clobber(Sneaky \u0026s) { s.j = s.prot_mem = 0; } //错误：不能访问Base中的protected成员 void clobber(Base \u0026b) { b.prot_mem = 0; } 上面的最后一条的含义是一个派生类成员和友元只能访问派生类继承过来属于基类那部分的受保护成员（这些成员，派生类自己本身也有，成员和友元可以访问自己本身的受保护的成员），而不能直接访问基类对象中的受保护成员 公共、私有和受保护继承类对继承而来的成员的访问权限受到两个因素影响：一是基类在该成员的访问说明符，二是派生类的派生列表中的访问说明符 class Base { public: void pub_mem(); protected: int prot_mem; private: char priv_mem; }; struct Pub_Derv : public Base { //正确：派生类能访问protected成员 int f() { return prot_mem; } //错误：派生类不能访问private成员 char g() { return priv_mem; } }; struct Priv_Derv : private Base { //private不影响派生类访问权限 int f1() const { return prot_mem; } }; 派生类访问说明符对于派生类的成员能否访问直接基类的成员没有什么影响，如上 Pub_Derv 和 Priv_Derv 都可以访问基类 Base 中的 prot_mem 派生类访问说明符是控制派生类用户（包括派生类的派生类）对于基类成员的访问权限，相当于将基类成员定义为相应的访问说明符 Pub_Derv d1; Priv_Derv d2; d1.pub_mem(); //正确：pub_mem在派生类中是public的 d2.pub_mem(); //错误：pub_mem在派生类中是protected的 此时在 Priv_Derv 中基类的成员被定义为 private 的了，这样它创建的对象就不可以直接访问 派生类向基类转换的可访问性派生类向基类的转换是否可访问由使用该转换的代码决定，同时派牛类的派生访问说明符也会有影响。假定D 继承自B :· 只有当 D 公有地继承 B 时，用户代码才能使用派生类向基类的转换；如果 D 继承 B 的方式是受保护的或者私有的，则用户代码不能使用该转换。 不论 D 以什么方式继承B , D 的成员函数和友元都能使用派生类向基类的转换： 派生类向其直接基类的类型转换对千派牛类的成员和友元来说水远是可访问的。 如果 D 继承 B 的方式是公有的或者受保护的，则 D 的派生类的成员和友元可以使用 D 向 B 的类型转换； 反之，如果 D 继承 B 的方式是私有的，则不能使用。 友元和继承友元关系不能传递，也不能继承，基类的友元在访问派生类成员时不具有特殊性 class Base { friend class Pal; protected: int prot_mem; }; class Sneaky : public Base { friend void clobber(Sneaky\u0026);//能访问Sneaky::prot_mem friend void clobber(Base\u0026*); //不能访问Base::prot_mem int j; //默认为private }; class Pal { public: int f(Base b) { return b.prot_mem; } //正确：Pal是Base友元 int f(Sneaky s) { return s.j; } //错误：Pal不是Sneaky友元 int f3(Sneaky s) { return s.prot_mem; }//正确：Pal是Base友元 } f3 访问了派生类中基类部分的成员，Pal 是基类的友元，Pal 能够访问 Base 对象的成员 友元只对做出声明的类有效，而友元的基类或派生类不具有特殊访问能力 class D2 : public Pal { public: int mem(Base b) { return b.prot_mem; } //错误友元不能继承 } 改变个别成员的可访问性如果需要改变派生类继承的某个名字的访问性，可以使用 using 声明达到这个目的 class Base { public: std::size_t size() cont { return n; } protected: std::size_t n; }; class Dervied : private Base { public: using Base::size; protected: using Base::n; }; Derived 为私有继承，继承的size 和 n 默认情况下是 Derived 的私有成员，使用 using 声明语句，可以改变这个成员的可访问性，此时的 Derived 用户都可以使用 size，而只有 Derived 的派生类才可以使用 n using 声明控制的访问权限仅由声明语句前面的访问说明符决定 默认的继承保护级别默认情况下，class 关键字的派生类是私有继承的，struct 关键字的派生类是公有继承的 class Base { /**/ }; struct D1 : Base { /**/ }; //默认public继承 class D2 : Base { /**/ }; //默认private继承 struct 和 class 关键字唯一区别就是默认成员访问说明符默认派生访问说明符的区别 一个私有派生的类最好显示的声明 private，不要仅仅依赖默认设置 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:5:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#友元和继承"},{"categories":["C++"],"content":"15.5 访问控制与继承每个类分别控制自己成员初始化过程，每个类还控制着其成员对于派生类来说是否可访问 受保护的成员protected 关键字可以控制那些它希望与派生类分享但是不想和其他公共访问使用的成员 和私有成员类似，受保护的成员对于类的用户是不可访问的 和公有成员类型，受保护的成员对于派生类和友元是可访问的 派生类的成员或友元只能通过派生类对象来访问基类中受保护的成员 派生类对于基类对象中受保护成员没有任何访问权限 class Base { protected: int prot_mem; }; class Sneaky : public Base { friend void clobber(Sneaky\u0026);//能访问Sneaky::prot_mem friend void clobber(Base\u0026*); //不能访问Base::prot_mem int j; //默认为private }; //正确：可以访问Sneaky对象的private和protected成员 void clobber(Sneaky \u0026s) { s.j = s.prot_mem = 0; } //错误：不能访问Base中的protected成员 void clobber(Base \u0026b) { b.prot_mem = 0; } 上面的最后一条的含义是一个派生类成员和友元只能访问派生类继承过来属于基类那部分的受保护成员（这些成员，派生类自己本身也有，成员和友元可以访问自己本身的受保护的成员），而不能直接访问基类对象中的受保护成员 公共、私有和受保护继承类对继承而来的成员的访问权限受到两个因素影响：一是基类在该成员的访问说明符，二是派生类的派生列表中的访问说明符 class Base { public: void pub_mem(); protected: int prot_mem; private: char priv_mem; }; struct Pub_Derv : public Base { //正确：派生类能访问protected成员 int f() { return prot_mem; } //错误：派生类不能访问private成员 char g() { return priv_mem; } }; struct Priv_Derv : private Base { //private不影响派生类访问权限 int f1() const { return prot_mem; } }; 派生类访问说明符对于派生类的成员能否访问直接基类的成员没有什么影响，如上 Pub_Derv 和 Priv_Derv 都可以访问基类 Base 中的 prot_mem 派生类访问说明符是控制派生类用户（包括派生类的派生类）对于基类成员的访问权限，相当于将基类成员定义为相应的访问说明符 Pub_Derv d1; Priv_Derv d2; d1.pub_mem(); //正确：pub_mem在派生类中是public的 d2.pub_mem(); //错误：pub_mem在派生类中是protected的 此时在 Priv_Derv 中基类的成员被定义为 private 的了，这样它创建的对象就不可以直接访问 派生类向基类转换的可访问性派生类向基类的转换是否可访问由使用该转换的代码决定，同时派牛类的派生访问说明符也会有影响。假定D 继承自B :· 只有当 D 公有地继承 B 时，用户代码才能使用派生类向基类的转换；如果 D 继承 B 的方式是受保护的或者私有的，则用户代码不能使用该转换。 不论 D 以什么方式继承B , D 的成员函数和友元都能使用派生类向基类的转换： 派生类向其直接基类的类型转换对千派牛类的成员和友元来说水远是可访问的。 如果 D 继承 B 的方式是公有的或者受保护的，则 D 的派生类的成员和友元可以使用 D 向 B 的类型转换； 反之，如果 D 继承 B 的方式是私有的，则不能使用。 友元和继承友元关系不能传递，也不能继承，基类的友元在访问派生类成员时不具有特殊性 class Base { friend class Pal; protected: int prot_mem; }; class Sneaky : public Base { friend void clobber(Sneaky\u0026);//能访问Sneaky::prot_mem friend void clobber(Base\u0026*); //不能访问Base::prot_mem int j; //默认为private }; class Pal { public: int f(Base b) { return b.prot_mem; } //正确：Pal是Base友元 int f(Sneaky s) { return s.j; } //错误：Pal不是Sneaky友元 int f3(Sneaky s) { return s.prot_mem; }//正确：Pal是Base友元 } f3 访问了派生类中基类部分的成员，Pal 是基类的友元，Pal 能够访问 Base 对象的成员 友元只对做出声明的类有效，而友元的基类或派生类不具有特殊访问能力 class D2 : public Pal { public: int mem(Base b) { return b.prot_mem; } //错误友元不能继承 } 改变个别成员的可访问性如果需要改变派生类继承的某个名字的访问性，可以使用 using 声明达到这个目的 class Base { public: std::size_t size() cont { return n; } protected: std::size_t n; }; class Dervied : private Base { public: using Base::size; protected: using Base::n; }; Derived 为私有继承，继承的size 和 n 默认情况下是 Derived 的私有成员，使用 using 声明语句，可以改变这个成员的可访问性，此时的 Derived 用户都可以使用 size，而只有 Derived 的派生类才可以使用 n using 声明控制的访问权限仅由声明语句前面的访问说明符决定 默认的继承保护级别默认情况下，class 关键字的派生类是私有继承的，struct 关键字的派生类是公有继承的 class Base { /**/ }; struct D1 : Base { /**/ }; //默认public继承 class D2 : Base { /**/ }; //默认private继承 struct 和 class 关键字唯一区别就是默认成员访问说明符默认派生访问说明符的区别 一个私有派生的类最好显示的声明 private，不要仅仅依赖默认设置 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:5:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#改变个别成员的可访问性"},{"categories":["C++"],"content":"15.5 访问控制与继承每个类分别控制自己成员初始化过程，每个类还控制着其成员对于派生类来说是否可访问 受保护的成员protected 关键字可以控制那些它希望与派生类分享但是不想和其他公共访问使用的成员 和私有成员类似，受保护的成员对于类的用户是不可访问的 和公有成员类型，受保护的成员对于派生类和友元是可访问的 派生类的成员或友元只能通过派生类对象来访问基类中受保护的成员 派生类对于基类对象中受保护成员没有任何访问权限 class Base { protected: int prot_mem; }; class Sneaky : public Base { friend void clobber(Sneaky\u0026);//能访问Sneaky::prot_mem friend void clobber(Base\u0026*); //不能访问Base::prot_mem int j; //默认为private }; //正确：可以访问Sneaky对象的private和protected成员 void clobber(Sneaky \u0026s) { s.j = s.prot_mem = 0; } //错误：不能访问Base中的protected成员 void clobber(Base \u0026b) { b.prot_mem = 0; } 上面的最后一条的含义是一个派生类成员和友元只能访问派生类继承过来属于基类那部分的受保护成员（这些成员，派生类自己本身也有，成员和友元可以访问自己本身的受保护的成员），而不能直接访问基类对象中的受保护成员 公共、私有和受保护继承类对继承而来的成员的访问权限受到两个因素影响：一是基类在该成员的访问说明符，二是派生类的派生列表中的访问说明符 class Base { public: void pub_mem(); protected: int prot_mem; private: char priv_mem; }; struct Pub_Derv : public Base { //正确：派生类能访问protected成员 int f() { return prot_mem; } //错误：派生类不能访问private成员 char g() { return priv_mem; } }; struct Priv_Derv : private Base { //private不影响派生类访问权限 int f1() const { return prot_mem; } }; 派生类访问说明符对于派生类的成员能否访问直接基类的成员没有什么影响，如上 Pub_Derv 和 Priv_Derv 都可以访问基类 Base 中的 prot_mem 派生类访问说明符是控制派生类用户（包括派生类的派生类）对于基类成员的访问权限，相当于将基类成员定义为相应的访问说明符 Pub_Derv d1; Priv_Derv d2; d1.pub_mem(); //正确：pub_mem在派生类中是public的 d2.pub_mem(); //错误：pub_mem在派生类中是protected的 此时在 Priv_Derv 中基类的成员被定义为 private 的了，这样它创建的对象就不可以直接访问 派生类向基类转换的可访问性派生类向基类的转换是否可访问由使用该转换的代码决定，同时派牛类的派生访问说明符也会有影响。假定D 继承自B :· 只有当 D 公有地继承 B 时，用户代码才能使用派生类向基类的转换；如果 D 继承 B 的方式是受保护的或者私有的，则用户代码不能使用该转换。 不论 D 以什么方式继承B , D 的成员函数和友元都能使用派生类向基类的转换： 派生类向其直接基类的类型转换对千派牛类的成员和友元来说水远是可访问的。 如果 D 继承 B 的方式是公有的或者受保护的，则 D 的派生类的成员和友元可以使用 D 向 B 的类型转换； 反之，如果 D 继承 B 的方式是私有的，则不能使用。 友元和继承友元关系不能传递，也不能继承，基类的友元在访问派生类成员时不具有特殊性 class Base { friend class Pal; protected: int prot_mem; }; class Sneaky : public Base { friend void clobber(Sneaky\u0026);//能访问Sneaky::prot_mem friend void clobber(Base\u0026*); //不能访问Base::prot_mem int j; //默认为private }; class Pal { public: int f(Base b) { return b.prot_mem; } //正确：Pal是Base友元 int f(Sneaky s) { return s.j; } //错误：Pal不是Sneaky友元 int f3(Sneaky s) { return s.prot_mem; }//正确：Pal是Base友元 } f3 访问了派生类中基类部分的成员，Pal 是基类的友元，Pal 能够访问 Base 对象的成员 友元只对做出声明的类有效，而友元的基类或派生类不具有特殊访问能力 class D2 : public Pal { public: int mem(Base b) { return b.prot_mem; } //错误友元不能继承 } 改变个别成员的可访问性如果需要改变派生类继承的某个名字的访问性，可以使用 using 声明达到这个目的 class Base { public: std::size_t size() cont { return n; } protected: std::size_t n; }; class Dervied : private Base { public: using Base::size; protected: using Base::n; }; Derived 为私有继承，继承的size 和 n 默认情况下是 Derived 的私有成员，使用 using 声明语句，可以改变这个成员的可访问性，此时的 Derived 用户都可以使用 size，而只有 Derived 的派生类才可以使用 n using 声明控制的访问权限仅由声明语句前面的访问说明符决定 默认的继承保护级别默认情况下，class 关键字的派生类是私有继承的，struct 关键字的派生类是公有继承的 class Base { /**/ }; struct D1 : Base { /**/ }; //默认public继承 class D2 : Base { /**/ }; //默认private继承 struct 和 class 关键字唯一区别就是默认成员访问说明符默认派生访问说明符的区别 一个私有派生的类最好显示的声明 private，不要仅仅依赖默认设置 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:5:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#默认的继承保护级别"},{"categories":["C++"],"content":"15.6 继承中的类作用域每个类定义自己的作用域，在这个作用域类定义类的成员 存在继承关系时，派生类的作用域嵌套在基类作用域之内，当一个名字在派生类的作用域无法解析，编译器会继续在外层的基类作用域中寻找改名字的含义 Bulk_quote bulk; cout \u003c\u003c bulk.isbn(); 名字 isbn 解析过程如下： 我们通过 Bulk_quote 对象调用 isbn 的，首先在 Bulk_quote 中查找，没有找到 isbn Bulk_quote 由 Disc_quote 派生而来，记下来在 Disc_quote 中查找，仍然找不到 Disc_quote 由 Quote 派生而来，接着在 Quote 中查找，此时找到了 isbn，最终被解析为 Quote 中的 isbn 在编译时进行名字查找一个对象、引用或指针的静态类型决定了对象哪些成员是可见的，静态类型和动态类型可能不一样，但是能使用哪些成员依然由静态类型决定 我们在 Disc_quote 中添加一个新成员 class Disc_quote : public Quote { public: std::pair\u003csize_t, double\u003e discount_policy() const { return {quantity, discount}; } //其他成员与前面一致 } 我们只能通过 Disc_quote 及派生类对象、引用或指针使用 discount_policy Bulk_quote bulk; Bulk_quote *bulkPtr = \u0026bulk; Quote *itemPtr = \u0026bulk; bulkPtr-\u003ediscount_policy();//正确：bulkPtr类型为Bulk_quote* itemPtr-\u003ediscount_policy();//错误：itemPtr类型为Quote* 名字冲突与继承和其他作用域一样，派生类也能重用定义在基类中的名字，此时定义在内层作用域（即派生类）的名字将隐藏定义在外层作用域（即基类）的名字 可以通过作用域运算符来使用一个被隐藏的基类成员 名字查找先于类型检查声明在内层作用域的函数并不会重载声明在外层作用域的函数，定义在派生类中的函数也不会重载基类中的成员 如果派生类和基类某个成员同名，派生类将在其作用域内隐藏该基类成员，即使形参列表不一样，基类成员仍然会被隐藏 struct Base { int memfcn(); }; struct Derived : Base { int memfcn(int);//隐藏基类的memfcn }; Derived d; Base b; b.memfcn(); //调用 Base::memfcn d.memfcn(10); //调用 Derived::memfcn d.memfcn(); //错误：基类memfcn被隐藏了 d.Base::memfcn(); //正确：调用Base::memfcn 虚函数和作用域15.3说到基类和派生类的虚函数必须有相同的形参列表，如果基类和派生类虚函数接受实参不一样，无法通过基类的引用或指针调用派生类的虚函数 class Base { public: virtual int fcn(); }; class D1 : public Base { public: //隐藏了基类的fcn，这个fcn不是虚函数 //D1继承了Base::fcn()定义 int fcn(int); virtual void f2(); }； class D2 : public D1 { public: int fcn(int);//非虚函数，隐藏了D1::fcn(int) int fcn(); //覆盖了Base的虚函数fcn void f2(); //覆盖了D1虚函数f2 } 下面是使用几种函数的方法 Base bobj; D1 d1obj; D2 d2obj; Base *bp1 = \u0026bobj, *bp2 = \u0026d1obj, *bp3 = \u0026d2obj; bp1-\u003efcn(); //虚调用，运行时调用Base::fcn bp2-\u003efcn(); //虚调用，运行时调用Base::fcn bp3-\u003efcn(); //需调用，运行时调用D2::fcn D1 *d1p = \u0026d1obj; D2 *d2p = \u0026d2obj; bp2-\u003ef2(); //错误：Base没有名为f2成员 d1p-\u003ef2(); //虚调用，运行时调用D1::f2() d2p-\u003ef2(); //虚调用，运行时调用D2::f2() Base *p1 = \u0026d2obj; D1 *p2 = \u0026d2obj; D2 *p3 = \u0026d2obj; p1-\u003efcn(42); //错误，Base中没有fcn(int)函数 p2-\u003efcn(42); //静态绑定，调用D1::fcn(int) p3-\u003efcn(42); //静态绑定，调用D2::fcn(int) 覆盖重载的函数成员函数无论是否为虚函数都能被重载，如果派生类希望所有的重载版本对于它都是可见的，那么它就需要覆盖所有的版本，或者一个都不覆盖 如果只需要覆盖其中一些函数，但是不得不自己重新定义覆盖基类的每一个版本，否则未重新定义的函数会被隐藏 通过使用 using 声明，就无须覆盖所有版本。using 声明语句指定一个名字而不指定形参列表，所有一条基类成员函数的 using 声明语句就可以把该函数所有重载实例添加到派生类作用域中。此时派生类只需要定义特有的函数就行了 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:6:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#156-继承中的类作用域"},{"categories":["C++"],"content":"15.6 继承中的类作用域每个类定义自己的作用域，在这个作用域类定义类的成员 存在继承关系时，派生类的作用域嵌套在基类作用域之内，当一个名字在派生类的作用域无法解析，编译器会继续在外层的基类作用域中寻找改名字的含义 Bulk_quote bulk; cout discount_policy() const { return {quantity, discount}; } //其他成员与前面一致 } 我们只能通过 Disc_quote 及派生类对象、引用或指针使用 discount_policy Bulk_quote bulk; Bulk_quote *bulkPtr = \u0026bulk; Quote *itemPtr = \u0026bulk; bulkPtr-discount_policy();//正确：bulkPtr类型为Bulk_quote* itemPtr-discount_policy();//错误：itemPtr类型为Quote* 名字冲突与继承和其他作用域一样，派生类也能重用定义在基类中的名字，此时定义在内层作用域（即派生类）的名字将隐藏定义在外层作用域（即基类）的名字 可以通过作用域运算符来使用一个被隐藏的基类成员 名字查找先于类型检查声明在内层作用域的函数并不会重载声明在外层作用域的函数，定义在派生类中的函数也不会重载基类中的成员 如果派生类和基类某个成员同名，派生类将在其作用域内隐藏该基类成员，即使形参列表不一样，基类成员仍然会被隐藏 struct Base { int memfcn(); }; struct Derived : Base { int memfcn(int);//隐藏基类的memfcn }; Derived d; Base b; b.memfcn(); //调用 Base::memfcn d.memfcn(10); //调用 Derived::memfcn d.memfcn(); //错误：基类memfcn被隐藏了 d.Base::memfcn(); //正确：调用Base::memfcn 虚函数和作用域15.3说到基类和派生类的虚函数必须有相同的形参列表，如果基类和派生类虚函数接受实参不一样，无法通过基类的引用或指针调用派生类的虚函数 class Base { public: virtual int fcn(); }; class D1 : public Base { public: //隐藏了基类的fcn，这个fcn不是虚函数 //D1继承了Base::fcn()定义 int fcn(int); virtual void f2(); }； class D2 : public D1 { public: int fcn(int);//非虚函数，隐藏了D1::fcn(int) int fcn(); //覆盖了Base的虚函数fcn void f2(); //覆盖了D1虚函数f2 } 下面是使用几种函数的方法 Base bobj; D1 d1obj; D2 d2obj; Base *bp1 = \u0026bobj, *bp2 = \u0026d1obj, *bp3 = \u0026d2obj; bp1-fcn(); //虚调用，运行时调用Base::fcn bp2-fcn(); //虚调用，运行时调用Base::fcn bp3-fcn(); //需调用，运行时调用D2::fcn D1 *d1p = \u0026d1obj; D2 *d2p = \u0026d2obj; bp2-f2(); //错误：Base没有名为f2成员 d1p-f2(); //虚调用，运行时调用D1::f2() d2p-f2(); //虚调用，运行时调用D2::f2() Base *p1 = \u0026d2obj; D1 *p2 = \u0026d2obj; D2 *p3 = \u0026d2obj; p1-fcn(42); //错误，Base中没有fcn(int)函数 p2-fcn(42); //静态绑定，调用D1::fcn(int) p3-fcn(42); //静态绑定，调用D2::fcn(int) 覆盖重载的函数成员函数无论是否为虚函数都能被重载，如果派生类希望所有的重载版本对于它都是可见的，那么它就需要覆盖所有的版本，或者一个都不覆盖 如果只需要覆盖其中一些函数，但是不得不自己重新定义覆盖基类的每一个版本，否则未重新定义的函数会被隐藏 通过使用 using 声明，就无须覆盖所有版本。using 声明语句指定一个名字而不指定形参列表，所有一条基类成员函数的 using 声明语句就可以把该函数所有重载实例添加到派生类作用域中。此时派生类只需要定义特有的函数就行了 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:6:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#在编译时进行名字查找"},{"categories":["C++"],"content":"15.6 继承中的类作用域每个类定义自己的作用域，在这个作用域类定义类的成员 存在继承关系时，派生类的作用域嵌套在基类作用域之内，当一个名字在派生类的作用域无法解析，编译器会继续在外层的基类作用域中寻找改名字的含义 Bulk_quote bulk; cout discount_policy() const { return {quantity, discount}; } //其他成员与前面一致 } 我们只能通过 Disc_quote 及派生类对象、引用或指针使用 discount_policy Bulk_quote bulk; Bulk_quote *bulkPtr = \u0026bulk; Quote *itemPtr = \u0026bulk; bulkPtr-discount_policy();//正确：bulkPtr类型为Bulk_quote* itemPtr-discount_policy();//错误：itemPtr类型为Quote* 名字冲突与继承和其他作用域一样，派生类也能重用定义在基类中的名字，此时定义在内层作用域（即派生类）的名字将隐藏定义在外层作用域（即基类）的名字 可以通过作用域运算符来使用一个被隐藏的基类成员 名字查找先于类型检查声明在内层作用域的函数并不会重载声明在外层作用域的函数，定义在派生类中的函数也不会重载基类中的成员 如果派生类和基类某个成员同名，派生类将在其作用域内隐藏该基类成员，即使形参列表不一样，基类成员仍然会被隐藏 struct Base { int memfcn(); }; struct Derived : Base { int memfcn(int);//隐藏基类的memfcn }; Derived d; Base b; b.memfcn(); //调用 Base::memfcn d.memfcn(10); //调用 Derived::memfcn d.memfcn(); //错误：基类memfcn被隐藏了 d.Base::memfcn(); //正确：调用Base::memfcn 虚函数和作用域15.3说到基类和派生类的虚函数必须有相同的形参列表，如果基类和派生类虚函数接受实参不一样，无法通过基类的引用或指针调用派生类的虚函数 class Base { public: virtual int fcn(); }; class D1 : public Base { public: //隐藏了基类的fcn，这个fcn不是虚函数 //D1继承了Base::fcn()定义 int fcn(int); virtual void f2(); }； class D2 : public D1 { public: int fcn(int);//非虚函数，隐藏了D1::fcn(int) int fcn(); //覆盖了Base的虚函数fcn void f2(); //覆盖了D1虚函数f2 } 下面是使用几种函数的方法 Base bobj; D1 d1obj; D2 d2obj; Base *bp1 = \u0026bobj, *bp2 = \u0026d1obj, *bp3 = \u0026d2obj; bp1-fcn(); //虚调用，运行时调用Base::fcn bp2-fcn(); //虚调用，运行时调用Base::fcn bp3-fcn(); //需调用，运行时调用D2::fcn D1 *d1p = \u0026d1obj; D2 *d2p = \u0026d2obj; bp2-f2(); //错误：Base没有名为f2成员 d1p-f2(); //虚调用，运行时调用D1::f2() d2p-f2(); //虚调用，运行时调用D2::f2() Base *p1 = \u0026d2obj; D1 *p2 = \u0026d2obj; D2 *p3 = \u0026d2obj; p1-fcn(42); //错误，Base中没有fcn(int)函数 p2-fcn(42); //静态绑定，调用D1::fcn(int) p3-fcn(42); //静态绑定，调用D2::fcn(int) 覆盖重载的函数成员函数无论是否为虚函数都能被重载，如果派生类希望所有的重载版本对于它都是可见的，那么它就需要覆盖所有的版本，或者一个都不覆盖 如果只需要覆盖其中一些函数，但是不得不自己重新定义覆盖基类的每一个版本，否则未重新定义的函数会被隐藏 通过使用 using 声明，就无须覆盖所有版本。using 声明语句指定一个名字而不指定形参列表，所有一条基类成员函数的 using 声明语句就可以把该函数所有重载实例添加到派生类作用域中。此时派生类只需要定义特有的函数就行了 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:6:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#名字冲突与继承"},{"categories":["C++"],"content":"15.6 继承中的类作用域每个类定义自己的作用域，在这个作用域类定义类的成员 存在继承关系时，派生类的作用域嵌套在基类作用域之内，当一个名字在派生类的作用域无法解析，编译器会继续在外层的基类作用域中寻找改名字的含义 Bulk_quote bulk; cout discount_policy() const { return {quantity, discount}; } //其他成员与前面一致 } 我们只能通过 Disc_quote 及派生类对象、引用或指针使用 discount_policy Bulk_quote bulk; Bulk_quote *bulkPtr = \u0026bulk; Quote *itemPtr = \u0026bulk; bulkPtr-discount_policy();//正确：bulkPtr类型为Bulk_quote* itemPtr-discount_policy();//错误：itemPtr类型为Quote* 名字冲突与继承和其他作用域一样，派生类也能重用定义在基类中的名字，此时定义在内层作用域（即派生类）的名字将隐藏定义在外层作用域（即基类）的名字 可以通过作用域运算符来使用一个被隐藏的基类成员 名字查找先于类型检查声明在内层作用域的函数并不会重载声明在外层作用域的函数，定义在派生类中的函数也不会重载基类中的成员 如果派生类和基类某个成员同名，派生类将在其作用域内隐藏该基类成员，即使形参列表不一样，基类成员仍然会被隐藏 struct Base { int memfcn(); }; struct Derived : Base { int memfcn(int);//隐藏基类的memfcn }; Derived d; Base b; b.memfcn(); //调用 Base::memfcn d.memfcn(10); //调用 Derived::memfcn d.memfcn(); //错误：基类memfcn被隐藏了 d.Base::memfcn(); //正确：调用Base::memfcn 虚函数和作用域15.3说到基类和派生类的虚函数必须有相同的形参列表，如果基类和派生类虚函数接受实参不一样，无法通过基类的引用或指针调用派生类的虚函数 class Base { public: virtual int fcn(); }; class D1 : public Base { public: //隐藏了基类的fcn，这个fcn不是虚函数 //D1继承了Base::fcn()定义 int fcn(int); virtual void f2(); }； class D2 : public D1 { public: int fcn(int);//非虚函数，隐藏了D1::fcn(int) int fcn(); //覆盖了Base的虚函数fcn void f2(); //覆盖了D1虚函数f2 } 下面是使用几种函数的方法 Base bobj; D1 d1obj; D2 d2obj; Base *bp1 = \u0026bobj, *bp2 = \u0026d1obj, *bp3 = \u0026d2obj; bp1-fcn(); //虚调用，运行时调用Base::fcn bp2-fcn(); //虚调用，运行时调用Base::fcn bp3-fcn(); //需调用，运行时调用D2::fcn D1 *d1p = \u0026d1obj; D2 *d2p = \u0026d2obj; bp2-f2(); //错误：Base没有名为f2成员 d1p-f2(); //虚调用，运行时调用D1::f2() d2p-f2(); //虚调用，运行时调用D2::f2() Base *p1 = \u0026d2obj; D1 *p2 = \u0026d2obj; D2 *p3 = \u0026d2obj; p1-fcn(42); //错误，Base中没有fcn(int)函数 p2-fcn(42); //静态绑定，调用D1::fcn(int) p3-fcn(42); //静态绑定，调用D2::fcn(int) 覆盖重载的函数成员函数无论是否为虚函数都能被重载，如果派生类希望所有的重载版本对于它都是可见的，那么它就需要覆盖所有的版本，或者一个都不覆盖 如果只需要覆盖其中一些函数，但是不得不自己重新定义覆盖基类的每一个版本，否则未重新定义的函数会被隐藏 通过使用 using 声明，就无须覆盖所有版本。using 声明语句指定一个名字而不指定形参列表，所有一条基类成员函数的 using 声明语句就可以把该函数所有重载实例添加到派生类作用域中。此时派生类只需要定义特有的函数就行了 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:6:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#名字查找先于类型检查"},{"categories":["C++"],"content":"15.6 继承中的类作用域每个类定义自己的作用域，在这个作用域类定义类的成员 存在继承关系时，派生类的作用域嵌套在基类作用域之内，当一个名字在派生类的作用域无法解析，编译器会继续在外层的基类作用域中寻找改名字的含义 Bulk_quote bulk; cout discount_policy() const { return {quantity, discount}; } //其他成员与前面一致 } 我们只能通过 Disc_quote 及派生类对象、引用或指针使用 discount_policy Bulk_quote bulk; Bulk_quote *bulkPtr = \u0026bulk; Quote *itemPtr = \u0026bulk; bulkPtr-discount_policy();//正确：bulkPtr类型为Bulk_quote* itemPtr-discount_policy();//错误：itemPtr类型为Quote* 名字冲突与继承和其他作用域一样，派生类也能重用定义在基类中的名字，此时定义在内层作用域（即派生类）的名字将隐藏定义在外层作用域（即基类）的名字 可以通过作用域运算符来使用一个被隐藏的基类成员 名字查找先于类型检查声明在内层作用域的函数并不会重载声明在外层作用域的函数，定义在派生类中的函数也不会重载基类中的成员 如果派生类和基类某个成员同名，派生类将在其作用域内隐藏该基类成员，即使形参列表不一样，基类成员仍然会被隐藏 struct Base { int memfcn(); }; struct Derived : Base { int memfcn(int);//隐藏基类的memfcn }; Derived d; Base b; b.memfcn(); //调用 Base::memfcn d.memfcn(10); //调用 Derived::memfcn d.memfcn(); //错误：基类memfcn被隐藏了 d.Base::memfcn(); //正确：调用Base::memfcn 虚函数和作用域15.3说到基类和派生类的虚函数必须有相同的形参列表，如果基类和派生类虚函数接受实参不一样，无法通过基类的引用或指针调用派生类的虚函数 class Base { public: virtual int fcn(); }; class D1 : public Base { public: //隐藏了基类的fcn，这个fcn不是虚函数 //D1继承了Base::fcn()定义 int fcn(int); virtual void f2(); }； class D2 : public D1 { public: int fcn(int);//非虚函数，隐藏了D1::fcn(int) int fcn(); //覆盖了Base的虚函数fcn void f2(); //覆盖了D1虚函数f2 } 下面是使用几种函数的方法 Base bobj; D1 d1obj; D2 d2obj; Base *bp1 = \u0026bobj, *bp2 = \u0026d1obj, *bp3 = \u0026d2obj; bp1-fcn(); //虚调用，运行时调用Base::fcn bp2-fcn(); //虚调用，运行时调用Base::fcn bp3-fcn(); //需调用，运行时调用D2::fcn D1 *d1p = \u0026d1obj; D2 *d2p = \u0026d2obj; bp2-f2(); //错误：Base没有名为f2成员 d1p-f2(); //虚调用，运行时调用D1::f2() d2p-f2(); //虚调用，运行时调用D2::f2() Base *p1 = \u0026d2obj; D1 *p2 = \u0026d2obj; D2 *p3 = \u0026d2obj; p1-fcn(42); //错误，Base中没有fcn(int)函数 p2-fcn(42); //静态绑定，调用D1::fcn(int) p3-fcn(42); //静态绑定，调用D2::fcn(int) 覆盖重载的函数成员函数无论是否为虚函数都能被重载，如果派生类希望所有的重载版本对于它都是可见的，那么它就需要覆盖所有的版本，或者一个都不覆盖 如果只需要覆盖其中一些函数，但是不得不自己重新定义覆盖基类的每一个版本，否则未重新定义的函数会被隐藏 通过使用 using 声明，就无须覆盖所有版本。using 声明语句指定一个名字而不指定形参列表，所有一条基类成员函数的 using 声明语句就可以把该函数所有重载实例添加到派生类作用域中。此时派生类只需要定义特有的函数就行了 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:6:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#虚函数和作用域"},{"categories":["C++"],"content":"15.6 继承中的类作用域每个类定义自己的作用域，在这个作用域类定义类的成员 存在继承关系时，派生类的作用域嵌套在基类作用域之内，当一个名字在派生类的作用域无法解析，编译器会继续在外层的基类作用域中寻找改名字的含义 Bulk_quote bulk; cout discount_policy() const { return {quantity, discount}; } //其他成员与前面一致 } 我们只能通过 Disc_quote 及派生类对象、引用或指针使用 discount_policy Bulk_quote bulk; Bulk_quote *bulkPtr = \u0026bulk; Quote *itemPtr = \u0026bulk; bulkPtr-discount_policy();//正确：bulkPtr类型为Bulk_quote* itemPtr-discount_policy();//错误：itemPtr类型为Quote* 名字冲突与继承和其他作用域一样，派生类也能重用定义在基类中的名字，此时定义在内层作用域（即派生类）的名字将隐藏定义在外层作用域（即基类）的名字 可以通过作用域运算符来使用一个被隐藏的基类成员 名字查找先于类型检查声明在内层作用域的函数并不会重载声明在外层作用域的函数，定义在派生类中的函数也不会重载基类中的成员 如果派生类和基类某个成员同名，派生类将在其作用域内隐藏该基类成员，即使形参列表不一样，基类成员仍然会被隐藏 struct Base { int memfcn(); }; struct Derived : Base { int memfcn(int);//隐藏基类的memfcn }; Derived d; Base b; b.memfcn(); //调用 Base::memfcn d.memfcn(10); //调用 Derived::memfcn d.memfcn(); //错误：基类memfcn被隐藏了 d.Base::memfcn(); //正确：调用Base::memfcn 虚函数和作用域15.3说到基类和派生类的虚函数必须有相同的形参列表，如果基类和派生类虚函数接受实参不一样，无法通过基类的引用或指针调用派生类的虚函数 class Base { public: virtual int fcn(); }; class D1 : public Base { public: //隐藏了基类的fcn，这个fcn不是虚函数 //D1继承了Base::fcn()定义 int fcn(int); virtual void f2(); }； class D2 : public D1 { public: int fcn(int);//非虚函数，隐藏了D1::fcn(int) int fcn(); //覆盖了Base的虚函数fcn void f2(); //覆盖了D1虚函数f2 } 下面是使用几种函数的方法 Base bobj; D1 d1obj; D2 d2obj; Base *bp1 = \u0026bobj, *bp2 = \u0026d1obj, *bp3 = \u0026d2obj; bp1-fcn(); //虚调用，运行时调用Base::fcn bp2-fcn(); //虚调用，运行时调用Base::fcn bp3-fcn(); //需调用，运行时调用D2::fcn D1 *d1p = \u0026d1obj; D2 *d2p = \u0026d2obj; bp2-f2(); //错误：Base没有名为f2成员 d1p-f2(); //虚调用，运行时调用D1::f2() d2p-f2(); //虚调用，运行时调用D2::f2() Base *p1 = \u0026d2obj; D1 *p2 = \u0026d2obj; D2 *p3 = \u0026d2obj; p1-fcn(42); //错误，Base中没有fcn(int)函数 p2-fcn(42); //静态绑定，调用D1::fcn(int) p3-fcn(42); //静态绑定，调用D2::fcn(int) 覆盖重载的函数成员函数无论是否为虚函数都能被重载，如果派生类希望所有的重载版本对于它都是可见的，那么它就需要覆盖所有的版本，或者一个都不覆盖 如果只需要覆盖其中一些函数，但是不得不自己重新定义覆盖基类的每一个版本，否则未重新定义的函数会被隐藏 通过使用 using 声明，就无须覆盖所有版本。using 声明语句指定一个名字而不指定形参列表，所有一条基类成员函数的 using 声明语句就可以把该函数所有重载实例添加到派生类作用域中。此时派生类只需要定义特有的函数就行了 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:6:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#覆盖重载的函数"},{"categories":["C++"],"content":"15.7 构造函数与拷贝控制","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:7:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#157-构造函数与拷贝控制"},{"categories":["C++"],"content":"15.7.1 虚析构函数当我们 delete 一个动态分配的对象指针时，将执行析构函数，如果指向继承体系中的某个类型，则有可能出现指针的静态类型与被删除对象动态类型不符合的情况，这样的话编译器必须确保执行正确的析构函数 通过将基类中的析构函数定义为虚函数来确保执行正确的析构函数版本 class Quote { public: //如果我们删除指向派生类对象的基类指针，需要虚析构函数 virtual ~Quote() = default; //动态绑定析构函数 } 析构函数的虚属性也会继承，基类的析构函数为虚函数就可以确保 delete 基类指针时能够调用正确的析构函数版本 Quote *itemPtr = new Quote; //静态类型与动态类型一致 delete itemPtr; //调用Quote的析构函数 itemPtr = new Bulk_Quote; //静态类型与动态类型一致 delete itemPtr; //调用Bulk_quote析构函数 如果基类的析构函数不是虚函数，则 delete 一个指向派生类对象的基类函数将产生未定义的行为 虚函数将阻止合成移动操作如果一个类定义了一个析构函数，即使通过=default 的形式使用了合成版本，编译器也不会为这个类合成移动操作 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:7:1","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#1571-虚析构函数"},{"categories":["C++"],"content":"15.7.1 虚析构函数当我们 delete 一个动态分配的对象指针时，将执行析构函数，如果指向继承体系中的某个类型，则有可能出现指针的静态类型与被删除对象动态类型不符合的情况，这样的话编译器必须确保执行正确的析构函数 通过将基类中的析构函数定义为虚函数来确保执行正确的析构函数版本 class Quote { public: //如果我们删除指向派生类对象的基类指针，需要虚析构函数 virtual ~Quote() = default; //动态绑定析构函数 } 析构函数的虚属性也会继承，基类的析构函数为虚函数就可以确保 delete 基类指针时能够调用正确的析构函数版本 Quote *itemPtr = new Quote; //静态类型与动态类型一致 delete itemPtr; //调用Quote的析构函数 itemPtr = new Bulk_Quote; //静态类型与动态类型一致 delete itemPtr; //调用Bulk_quote析构函数 如果基类的析构函数不是虚函数，则 delete 一个指向派生类对象的基类函数将产生未定义的行为 虚函数将阻止合成移动操作如果一个类定义了一个析构函数，即使通过=default 的形式使用了合成版本，编译器也不会为这个类合成移动操作 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:7:1","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#虚函数将阻止合成移动操作"},{"categories":["C++"],"content":"15.7.2 合成拷贝控制与继承基类和派生类的合成拷贝控制成员的行为与其他合成的构造函数、赋值运算符或析构函数类似，它们对类本身成员依次进行初始化、赋值和销毁操作，此外还负责对直接基类部分进行初始化、赋值、销毁的操作 这里需要注意的就是顺序问题： 对于构造函数，派生类使用合成的构造函数时，会自动先调用直接基类的构造函数，然后再初始化自己的成员，直接基类又会进一步调用基类的构造函数 构造函数整体的表现为，先初始化基类成员-\u003e初始化直接基类-\u003e派生类 对于析构函数，合成的析构函数体是空的，隐式的析构部分负责销毁类的成员，对于派生类的析构函数来说，除了销毁自己的成员外，还负责销毁派生类的直接基类，依次进行 整体表现为，先调用派生类析构函数-\u003e直接基类析构函数-\u003e基类析构函数 派生类中删除的拷贝控制和基类的关系 如果基类拷贝控制成员是被删除的或者不可访问，派生类中对于的成员也是被删除的 如果基类中有一个不可访问或删除的析构函数，派生类中合成的默认和拷贝构造函数是删除的，因为编译器无法销毁派生类对象中基类部分 class B { public: B() {} B(const B\u0026) = delete; //其他成员，无移动构造函数 }; class D : public B { //没有声明任何构造函数 }; D d; //正确：D合成默认构造函数使用B默认构造函数 D d2(d); //错误：D合成拷贝构造函数是删除的 D d3(std::move(d)); //错误：隐式使用D被删除的拷贝构造函数 如果基类中没有默认、拷贝或移动构造函数，一般情况下派生类也不会定义相应的操作 移动操作和继承大多数基类会定义一个虚析构函数，默认情况下，基类不含有合成的移动操作，派生类也没有 如果需要移动操作，首先应该在基类中进行定义，可以使用合成的版本，但是要显示的定义，一旦定义移动操作，还有同时定义拷贝操作（3/5准则） class Quote { public: Quote() = default; Quote(const Quote\u0026) = default; Quote(Quote\u0026\u0026) = default; Quote\u0026 operator=(const Quote\u0026) = default; Quote\u0026 operator=(Quote\u0026\u0026) = default; virtual ~Quote() = default; }; ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:8:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#1572-合成拷贝控制与继承"},{"categories":["C++"],"content":"15.7.2 合成拷贝控制与继承基类和派生类的合成拷贝控制成员的行为与其他合成的构造函数、赋值运算符或析构函数类似，它们对类本身成员依次进行初始化、赋值和销毁操作，此外还负责对直接基类部分进行初始化、赋值、销毁的操作 这里需要注意的就是顺序问题： 对于构造函数，派生类使用合成的构造函数时，会自动先调用直接基类的构造函数，然后再初始化自己的成员，直接基类又会进一步调用基类的构造函数 构造函数整体的表现为，先初始化基类成员-初始化直接基类-派生类 对于析构函数，合成的析构函数体是空的，隐式的析构部分负责销毁类的成员，对于派生类的析构函数来说，除了销毁自己的成员外，还负责销毁派生类的直接基类，依次进行 整体表现为，先调用派生类析构函数-直接基类析构函数-基类析构函数 派生类中删除的拷贝控制和基类的关系 如果基类拷贝控制成员是被删除的或者不可访问，派生类中对于的成员也是被删除的 如果基类中有一个不可访问或删除的析构函数，派生类中合成的默认和拷贝构造函数是删除的，因为编译器无法销毁派生类对象中基类部分 class B { public: B() {} B(const B\u0026) = delete; //其他成员，无移动构造函数 }; class D : public B { //没有声明任何构造函数 }; D d; //正确：D合成默认构造函数使用B默认构造函数 D d2(d); //错误：D合成拷贝构造函数是删除的 D d3(std::move(d)); //错误：隐式使用D被删除的拷贝构造函数 如果基类中没有默认、拷贝或移动构造函数，一般情况下派生类也不会定义相应的操作 移动操作和继承大多数基类会定义一个虚析构函数，默认情况下，基类不含有合成的移动操作，派生类也没有 如果需要移动操作，首先应该在基类中进行定义，可以使用合成的版本，但是要显示的定义，一旦定义移动操作，还有同时定义拷贝操作（3/5准则） class Quote { public: Quote() = default; Quote(const Quote\u0026) = default; Quote(Quote\u0026\u0026) = default; Quote\u0026 operator=(const Quote\u0026) = default; Quote\u0026 operator=(Quote\u0026\u0026) = default; virtual ~Quote() = default; }; ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:8:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#派生类中删除的拷贝控制和基类的关系"},{"categories":["C++"],"content":"15.7.2 合成拷贝控制与继承基类和派生类的合成拷贝控制成员的行为与其他合成的构造函数、赋值运算符或析构函数类似，它们对类本身成员依次进行初始化、赋值和销毁操作，此外还负责对直接基类部分进行初始化、赋值、销毁的操作 这里需要注意的就是顺序问题： 对于构造函数，派生类使用合成的构造函数时，会自动先调用直接基类的构造函数，然后再初始化自己的成员，直接基类又会进一步调用基类的构造函数 构造函数整体的表现为，先初始化基类成员-初始化直接基类-派生类 对于析构函数，合成的析构函数体是空的，隐式的析构部分负责销毁类的成员，对于派生类的析构函数来说，除了销毁自己的成员外，还负责销毁派生类的直接基类，依次进行 整体表现为，先调用派生类析构函数-直接基类析构函数-基类析构函数 派生类中删除的拷贝控制和基类的关系 如果基类拷贝控制成员是被删除的或者不可访问，派生类中对于的成员也是被删除的 如果基类中有一个不可访问或删除的析构函数，派生类中合成的默认和拷贝构造函数是删除的，因为编译器无法销毁派生类对象中基类部分 class B { public: B() {} B(const B\u0026) = delete; //其他成员，无移动构造函数 }; class D : public B { //没有声明任何构造函数 }; D d; //正确：D合成默认构造函数使用B默认构造函数 D d2(d); //错误：D合成拷贝构造函数是删除的 D d3(std::move(d)); //错误：隐式使用D被删除的拷贝构造函数 如果基类中没有默认、拷贝或移动构造函数，一般情况下派生类也不会定义相应的操作 移动操作和继承大多数基类会定义一个虚析构函数，默认情况下，基类不含有合成的移动操作，派生类也没有 如果需要移动操作，首先应该在基类中进行定义，可以使用合成的版本，但是要显示的定义，一旦定义移动操作，还有同时定义拷贝操作（3/5准则） class Quote { public: Quote() = default; Quote(const Quote\u0026) = default; Quote(Quote\u0026\u0026) = default; Quote\u0026 operator=(const Quote\u0026) = default; Quote\u0026 operator=(Quote\u0026\u0026) = default; virtual ~Quote() = default; }; ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:8:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#移动操作和继承"},{"categories":["C++"],"content":"15.7.3 派生类的拷贝控制成员 派生类构造函数初始化阶段不仅需要初始化派生类自己的成员，还负责初始化派生类对象中基类部分 派生类的拷贝、移动构造函数、赋值运算符也类似，拷贝移动赋值派生类成员的同时，也要对基类部分进行相同的操作 而析构函数只负责销毁派生类自己分配的资源，派生类中基类部分是自动销毁的 定义派生类的拷贝或移动构造函数 class Base { /***/ }; class D : public Base { public: D(const D\u0026 d) : Base(d) //拷贝基类成员 /*D的成员初始值*/ {/**/} D(D\u0026\u0026 d) : Base(std::move(d)) //移动基类成员 /*D的成员初始值*/ {/**/} }; 初始值 Base(d) 将一个 D 对象传递给基类构造函数，值得注意的是，这里传给基类拷贝构造函数是一个 D 对象，它会自动匹配 Base 中的拷贝构造函数 如果没有提供基类初始值的话，基类部分被默认初始化，而不是从其他对象拷贝而来 //D这个拷贝构造函数很可能是不正确的定义 //基类部分被默认初始化，而非拷贝 D(const D\u0026 d) /*成员初始值，但是没有提供基类初始值*/ {/**/} 派生类赋值运算符和拷贝移动构造函数一样，赋值运算符也必须显示为基类部分进行赋值 D \u0026D::operator=(const D \u0026rhs) { Base::operator=(rhs); //D的其他成员赋值 //酌情使用自赋值和释放已有资源 return *this; } 派生类析构函数派生类析构函数只负责销毁派生类自己分配的资源 class D : public B { public: //Base::~Base()被自动执行 ~D() { /*销毁D分配的资源*/} } 构造函数和析构函数中调用虚函数书上这里写的有点绕，我的理解就是： 在基类的构造或析构函数中调用虚函数时，执行的版本时基类的虚函数版本 在派生类的构造或析构函数中调用虚函数时，执行的是派生类的虚函数版本 我自己也写了下面的代码进行了测试，确实是这样： #include \u003ciostream\u003eusing namespace std; class Base { public: Base() { cout \u003c\u003c \"Base default constructor\" \u003c\u003c endl; } Base(int n) : num(n) { cout \u003c\u003c \"Base constructor\" \u003c\u003c endl; print_num(); } virtual void print_num() { cout \u003c\u003c \"this is a base virtual, num = \"; cout \u003c\u003c num \u003c\u003c endl; } ~Base() { cout \u003c\u003c \"this is a Base destructor\" \u003c\u003c endl; print_num(); } protected: int num; }; class Derived : public Base { public: Derived(int n) :Base(n) { print_num(); cnt = n / 2; } void print_num() override { cout \u003c\u003c \"this is a derived virtual, num = \" \u003c\u003c num \u003c\u003c endl; cout \u003c\u003c \"cnt is \" \u003c\u003c cnt \u003c\u003c endl; } ~Derived() { cout \u003c\u003c \"this is a Derived destructor\" \u003c\u003c endl; print_num(); } private: int cnt; }; int main() { Derived *p = new Derived(10); cout \u003c\u003c \"===========\" \u003c\u003c endl; delete p; return 0; } /*打印结果，先执行了构造函数的调用，然后是析构函数的调用 silas@Silas-PC:~/cpp$ g++ construct_virtual.cpp \u0026\u0026 ./a.out Base constructor this is a base virtual, num = 10 this is a derived virtual, num = 10 cnt is 0 =========== this is a Derived destructor this is a derived virtual, num = 10 cnt is 5 this is a Base destructor this is a base virtual, num = 10 */ ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:8:1","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#1573-派生类的拷贝控制成员"},{"categories":["C++"],"content":"15.7.3 派生类的拷贝控制成员 派生类构造函数初始化阶段不仅需要初始化派生类自己的成员，还负责初始化派生类对象中基类部分 派生类的拷贝、移动构造函数、赋值运算符也类似，拷贝移动赋值派生类成员的同时，也要对基类部分进行相同的操作 而析构函数只负责销毁派生类自己分配的资源，派生类中基类部分是自动销毁的 定义派生类的拷贝或移动构造函数 class Base { /***/ }; class D : public Base { public: D(const D\u0026 d) : Base(d) //拷贝基类成员 /*D的成员初始值*/ {/**/} D(D\u0026\u0026 d) : Base(std::move(d)) //移动基类成员 /*D的成员初始值*/ {/**/} }; 初始值 Base(d) 将一个 D 对象传递给基类构造函数，值得注意的是，这里传给基类拷贝构造函数是一个 D 对象，它会自动匹配 Base 中的拷贝构造函数 如果没有提供基类初始值的话，基类部分被默认初始化，而不是从其他对象拷贝而来 //D这个拷贝构造函数很可能是不正确的定义 //基类部分被默认初始化，而非拷贝 D(const D\u0026 d) /*成员初始值，但是没有提供基类初始值*/ {/**/} 派生类赋值运算符和拷贝移动构造函数一样，赋值运算符也必须显示为基类部分进行赋值 D \u0026D::operator=(const D \u0026rhs) { Base::operator=(rhs); //D的其他成员赋值 //酌情使用自赋值和释放已有资源 return *this; } 派生类析构函数派生类析构函数只负责销毁派生类自己分配的资源 class D : public B { public: //Base::~Base()被自动执行 ~D() { /*销毁D分配的资源*/} } 构造函数和析构函数中调用虚函数书上这里写的有点绕，我的理解就是： 在基类的构造或析构函数中调用虚函数时，执行的版本时基类的虚函数版本 在派生类的构造或析构函数中调用虚函数时，执行的是派生类的虚函数版本 我自己也写了下面的代码进行了测试，确实是这样： #include using namespace std; class Base { public: Base() { cout ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:8:1","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#定义派生类的拷贝或移动构造函数"},{"categories":["C++"],"content":"15.7.3 派生类的拷贝控制成员 派生类构造函数初始化阶段不仅需要初始化派生类自己的成员，还负责初始化派生类对象中基类部分 派生类的拷贝、移动构造函数、赋值运算符也类似，拷贝移动赋值派生类成员的同时，也要对基类部分进行相同的操作 而析构函数只负责销毁派生类自己分配的资源，派生类中基类部分是自动销毁的 定义派生类的拷贝或移动构造函数 class Base { /***/ }; class D : public Base { public: D(const D\u0026 d) : Base(d) //拷贝基类成员 /*D的成员初始值*/ {/**/} D(D\u0026\u0026 d) : Base(std::move(d)) //移动基类成员 /*D的成员初始值*/ {/**/} }; 初始值 Base(d) 将一个 D 对象传递给基类构造函数，值得注意的是，这里传给基类拷贝构造函数是一个 D 对象，它会自动匹配 Base 中的拷贝构造函数 如果没有提供基类初始值的话，基类部分被默认初始化，而不是从其他对象拷贝而来 //D这个拷贝构造函数很可能是不正确的定义 //基类部分被默认初始化，而非拷贝 D(const D\u0026 d) /*成员初始值，但是没有提供基类初始值*/ {/**/} 派生类赋值运算符和拷贝移动构造函数一样，赋值运算符也必须显示为基类部分进行赋值 D \u0026D::operator=(const D \u0026rhs) { Base::operator=(rhs); //D的其他成员赋值 //酌情使用自赋值和释放已有资源 return *this; } 派生类析构函数派生类析构函数只负责销毁派生类自己分配的资源 class D : public B { public: //Base::~Base()被自动执行 ~D() { /*销毁D分配的资源*/} } 构造函数和析构函数中调用虚函数书上这里写的有点绕，我的理解就是： 在基类的构造或析构函数中调用虚函数时，执行的版本时基类的虚函数版本 在派生类的构造或析构函数中调用虚函数时，执行的是派生类的虚函数版本 我自己也写了下面的代码进行了测试，确实是这样： #include using namespace std; class Base { public: Base() { cout ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:8:1","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#派生类赋值运算符"},{"categories":["C++"],"content":"15.7.3 派生类的拷贝控制成员 派生类构造函数初始化阶段不仅需要初始化派生类自己的成员，还负责初始化派生类对象中基类部分 派生类的拷贝、移动构造函数、赋值运算符也类似，拷贝移动赋值派生类成员的同时，也要对基类部分进行相同的操作 而析构函数只负责销毁派生类自己分配的资源，派生类中基类部分是自动销毁的 定义派生类的拷贝或移动构造函数 class Base { /***/ }; class D : public Base { public: D(const D\u0026 d) : Base(d) //拷贝基类成员 /*D的成员初始值*/ {/**/} D(D\u0026\u0026 d) : Base(std::move(d)) //移动基类成员 /*D的成员初始值*/ {/**/} }; 初始值 Base(d) 将一个 D 对象传递给基类构造函数，值得注意的是，这里传给基类拷贝构造函数是一个 D 对象，它会自动匹配 Base 中的拷贝构造函数 如果没有提供基类初始值的话，基类部分被默认初始化，而不是从其他对象拷贝而来 //D这个拷贝构造函数很可能是不正确的定义 //基类部分被默认初始化，而非拷贝 D(const D\u0026 d) /*成员初始值，但是没有提供基类初始值*/ {/**/} 派生类赋值运算符和拷贝移动构造函数一样，赋值运算符也必须显示为基类部分进行赋值 D \u0026D::operator=(const D \u0026rhs) { Base::operator=(rhs); //D的其他成员赋值 //酌情使用自赋值和释放已有资源 return *this; } 派生类析构函数派生类析构函数只负责销毁派生类自己分配的资源 class D : public B { public: //Base::~Base()被自动执行 ~D() { /*销毁D分配的资源*/} } 构造函数和析构函数中调用虚函数书上这里写的有点绕，我的理解就是： 在基类的构造或析构函数中调用虚函数时，执行的版本时基类的虚函数版本 在派生类的构造或析构函数中调用虚函数时，执行的是派生类的虚函数版本 我自己也写了下面的代码进行了测试，确实是这样： #include using namespace std; class Base { public: Base() { cout ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:8:1","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#派生类析构函数"},{"categories":["C++"],"content":"15.7.3 派生类的拷贝控制成员 派生类构造函数初始化阶段不仅需要初始化派生类自己的成员，还负责初始化派生类对象中基类部分 派生类的拷贝、移动构造函数、赋值运算符也类似，拷贝移动赋值派生类成员的同时，也要对基类部分进行相同的操作 而析构函数只负责销毁派生类自己分配的资源，派生类中基类部分是自动销毁的 定义派生类的拷贝或移动构造函数 class Base { /***/ }; class D : public Base { public: D(const D\u0026 d) : Base(d) //拷贝基类成员 /*D的成员初始值*/ {/**/} D(D\u0026\u0026 d) : Base(std::move(d)) //移动基类成员 /*D的成员初始值*/ {/**/} }; 初始值 Base(d) 将一个 D 对象传递给基类构造函数，值得注意的是，这里传给基类拷贝构造函数是一个 D 对象，它会自动匹配 Base 中的拷贝构造函数 如果没有提供基类初始值的话，基类部分被默认初始化，而不是从其他对象拷贝而来 //D这个拷贝构造函数很可能是不正确的定义 //基类部分被默认初始化，而非拷贝 D(const D\u0026 d) /*成员初始值，但是没有提供基类初始值*/ {/**/} 派生类赋值运算符和拷贝移动构造函数一样，赋值运算符也必须显示为基类部分进行赋值 D \u0026D::operator=(const D \u0026rhs) { Base::operator=(rhs); //D的其他成员赋值 //酌情使用自赋值和释放已有资源 return *this; } 派生类析构函数派生类析构函数只负责销毁派生类自己分配的资源 class D : public B { public: //Base::~Base()被自动执行 ~D() { /*销毁D分配的资源*/} } 构造函数和析构函数中调用虚函数书上这里写的有点绕，我的理解就是： 在基类的构造或析构函数中调用虚函数时，执行的版本时基类的虚函数版本 在派生类的构造或析构函数中调用虚函数时，执行的是派生类的虚函数版本 我自己也写了下面的代码进行了测试，确实是这样： #include using namespace std; class Base { public: Base() { cout ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:8:1","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#构造函数和析构函数中调用虚函数"},{"categories":["C++"],"content":"15.7.4 继承的构造函数C++11新标准下，派生类可以重用直接基类定义的构造函数，一个类只负责初始化它的直接基类，也只继承直接基类的构造函数。 类不能继承默认、拷贝和移动构造函数，如果派生类没有直接定义这些构造函数，编译器将为派生类合成它们 派生类继承基类构造函数的方式是提供一条注明了直接基类名的 using 声明语句 class Bulk_quote : public Disc_quote { public: using Disc_quote::Disc_quote;//继承了Disc_quote构造函数 double net_price(std::size_t) const; }; using 声明语句作用在构造函数时，将令编译器产生代码，对于基类的每个构造函数，在派生类都会生成一个与之对应的构造函数，形如：derived(parms) : base(args) {} 在上面Bulk_quote 中，继承的构造函数等价于： Bulk_quote(const std::string \u0026book, double price, std::size_t qty, double disc) : Disc_quote(book, price, qty, disc) {} 如果派生类有自己的成员，这些成员将会被默认初始化 继承的构造函数特点 和普通成员 using 声明不一样，using 不会改变构造函数的访问级别，如，基类的私有构造函数在派生类中还是一个私有的构造函数 using 声明不能指定 explicit 或 constexpr，基类构造函数是 explicit 或 constexpr，派生类也是如此 基类构造函数中的默认实参不会被继承，派生类会获得多个继承的构造函数，其中每个构造函数分别省略掉一个含义默认实参的形参 如果派生类定义的构造函数和基类构造函数有相同形参列表，这些构造函数不会被继承 默认、 拷贝和移动构造函数不会被继承，这些按照正常合成规则被合成 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:8:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#1574-继承的构造函数"},{"categories":["C++"],"content":"15.7.4 继承的构造函数C++11新标准下，派生类可以重用直接基类定义的构造函数，一个类只负责初始化它的直接基类，也只继承直接基类的构造函数。 类不能继承默认、拷贝和移动构造函数，如果派生类没有直接定义这些构造函数，编译器将为派生类合成它们 派生类继承基类构造函数的方式是提供一条注明了直接基类名的 using 声明语句 class Bulk_quote : public Disc_quote { public: using Disc_quote::Disc_quote;//继承了Disc_quote构造函数 double net_price(std::size_t) const; }; using 声明语句作用在构造函数时，将令编译器产生代码，对于基类的每个构造函数，在派生类都会生成一个与之对应的构造函数，形如：derived(parms) : base(args) {} 在上面Bulk_quote 中，继承的构造函数等价于： Bulk_quote(const std::string \u0026book, double price, std::size_t qty, double disc) : Disc_quote(book, price, qty, disc) {} 如果派生类有自己的成员，这些成员将会被默认初始化 继承的构造函数特点 和普通成员 using 声明不一样，using 不会改变构造函数的访问级别，如，基类的私有构造函数在派生类中还是一个私有的构造函数 using 声明不能指定 explicit 或 constexpr，基类构造函数是 explicit 或 constexpr，派生类也是如此 基类构造函数中的默认实参不会被继承，派生类会获得多个继承的构造函数，其中每个构造函数分别省略掉一个含义默认实参的形参 如果派生类定义的构造函数和基类构造函数有相同形参列表，这些构造函数不会被继承 默认、 拷贝和移动构造函数不会被继承，这些按照正常合成规则被合成 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:8:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#继承的构造函数特点"},{"categories":["C++"],"content":"第14章 重载运算与类型转换","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:0:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#第14章-重载运算与类型转换"},{"categories":["C++"],"content":"14.1 基本概念重载的运算符是具有特殊名字的函数：它们的名字由关键字 operator 和其后要定义的运算符号共同组成。和其他函数一样，重载的运算符也包含返回类型、参数列表以及函数体。 重载运算符函数的参数数量与该作用的运算对象数量一样多，一元运算符有一个参数，二元运算符有两个参数； 二元运算符左侧运算对象传递给第一个参数，右侧对象传递给第二个对象 除了 operator() 外，其他重载运算符不能含有默认实参 如果一个重载运算符是类的成员函数时，this 会绑定到左侧运算对象，参数数量会比运算对象少一个 重载运算符函数只能是一个类的成员，或者至少有一个类类型的参数，不能对内置类型定义重载运算符 int operator+(int, int);//错误，不能重定义int的运算符 以下是可以重载或者不能重载的运算符： 重载运算符的几种调用形式： 可以间接的用运算符调用重载的运算符函数 也可以像普通函数那样直接调用 //一个非成员运算符函数的等价调用 data1 + data2; //普通表达式 operator+(data1, data2); //等价的函数调用 也可以像调用其他成员函数一样显示的调用成员运算符 data1 += data2; //基于调用的表达式 data1.operator+=(data2); //对成员运算符函数的等价调用 某些运算符不应该被重载 某些运算符会指定运算对象的求值顺序，而关于这些运算对象求值顺序的规则无法应用到重载的运算符上 像逻辑与运算符、逻辑或运算符、逗号运算符的运算对象求值顺序无法保留下来，而 \u0026\u0026 和 || 短路求值属性也无法保留 对于逗号和取地址运算符，用于类类型对象时已经定义了特殊的含义，所以不应该被重载 使用内置类型一致的含义设计一个类时，要考虑这个类提供哪些操作，然后再考虑这些操作设为普通函数还是重载的运算符。如果某些类逻辑上和运算符相关，它们适合定义成重载的运算符 如果类执行 IO 操作，定义移位运算符和内置类型的 IO 保存一致 类检查相等性操作，定义 operator=，同时也应该定义 operator!= 如果类有比较操作，例如 operator\u003c，也该也定义其他关系的操作 返回类型通常情况下要和内置返回类型兼容： 逻辑和关系运算符应该返回 bool 算术运算符应该返回类类型的值 赋值和复合运算符应该返回左侧对象的引用 选择作为成员或者非成员定义重载运算符时，首先要觉得声明为类的成员函数，还是一个普通的非成员函数，下面准则可以帮助判断： 赋值（=），下标（[]），调用（()）和成员访问箭头（-\u003e）必须时成员 复合类型一般为成员，但非必须 改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减、解引用通常为成员 具有对称性的运算符可以转换任意一端的运算对象，如算术、相等性、关系和位运算，通常位普通的非成员函数 string s = \"world\"; string t = s + \"!\"; string u = \"hi \" + s;//如果+是string成员函数，这里会报错 实际上，string 将 + 定义为了普通成员函数，\"hi \" + s 等价于 operator+=(\"hi \", s)，就没有出现问题 ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:1:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#141-基本概念"},{"categories":["C++"],"content":"14.1 基本概念重载的运算符是具有特殊名字的函数：它们的名字由关键字 operator 和其后要定义的运算符号共同组成。和其他函数一样，重载的运算符也包含返回类型、参数列表以及函数体。 重载运算符函数的参数数量与该作用的运算对象数量一样多，一元运算符有一个参数，二元运算符有两个参数； 二元运算符左侧运算对象传递给第一个参数，右侧对象传递给第二个对象 除了 operator() 外，其他重载运算符不能含有默认实参 如果一个重载运算符是类的成员函数时，this 会绑定到左侧运算对象，参数数量会比运算对象少一个 重载运算符函数只能是一个类的成员，或者至少有一个类类型的参数，不能对内置类型定义重载运算符 int operator+(int, int);//错误，不能重定义int的运算符 以下是可以重载或者不能重载的运算符： 重载运算符的几种调用形式： 可以间接的用运算符调用重载的运算符函数 也可以像普通函数那样直接调用 //一个非成员运算符函数的等价调用 data1 + data2; //普通表达式 operator+(data1, data2); //等价的函数调用 也可以像调用其他成员函数一样显示的调用成员运算符 data1 += data2; //基于调用的表达式 data1.operator+=(data2); //对成员运算符函数的等价调用 某些运算符不应该被重载 某些运算符会指定运算对象的求值顺序，而关于这些运算对象求值顺序的规则无法应用到重载的运算符上 像逻辑与运算符、逻辑或运算符、逗号运算符的运算对象求值顺序无法保留下来，而 \u0026\u0026 和 || 短路求值属性也无法保留 对于逗号和取地址运算符，用于类类型对象时已经定义了特殊的含义，所以不应该被重载 使用内置类型一致的含义设计一个类时，要考虑这个类提供哪些操作，然后再考虑这些操作设为普通函数还是重载的运算符。如果某些类逻辑上和运算符相关，它们适合定义成重载的运算符 如果类执行 IO 操作，定义移位运算符和内置类型的 IO 保存一致 类检查相等性操作，定义 operator=，同时也应该定义 operator!= 如果类有比较操作，例如 operator）必须时成员 复合类型一般为成员，但非必须 改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减、解引用通常为成员 具有对称性的运算符可以转换任意一端的运算对象，如算术、相等性、关系和位运算，通常位普通的非成员函数 string s = \"world\"; string t = s + \"!\"; string u = \"hi \" + s;//如果+是string成员函数，这里会报错 实际上，string 将 + 定义为了普通成员函数，\"hi \" + s 等价于 operator+=(\"hi \", s)，就没有出现问题 ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:1:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#重载运算符的几种调用形式"},{"categories":["C++"],"content":"14.1 基本概念重载的运算符是具有特殊名字的函数：它们的名字由关键字 operator 和其后要定义的运算符号共同组成。和其他函数一样，重载的运算符也包含返回类型、参数列表以及函数体。 重载运算符函数的参数数量与该作用的运算对象数量一样多，一元运算符有一个参数，二元运算符有两个参数； 二元运算符左侧运算对象传递给第一个参数，右侧对象传递给第二个对象 除了 operator() 外，其他重载运算符不能含有默认实参 如果一个重载运算符是类的成员函数时，this 会绑定到左侧运算对象，参数数量会比运算对象少一个 重载运算符函数只能是一个类的成员，或者至少有一个类类型的参数，不能对内置类型定义重载运算符 int operator+(int, int);//错误，不能重定义int的运算符 以下是可以重载或者不能重载的运算符： 重载运算符的几种调用形式： 可以间接的用运算符调用重载的运算符函数 也可以像普通函数那样直接调用 //一个非成员运算符函数的等价调用 data1 + data2; //普通表达式 operator+(data1, data2); //等价的函数调用 也可以像调用其他成员函数一样显示的调用成员运算符 data1 += data2; //基于调用的表达式 data1.operator+=(data2); //对成员运算符函数的等价调用 某些运算符不应该被重载 某些运算符会指定运算对象的求值顺序，而关于这些运算对象求值顺序的规则无法应用到重载的运算符上 像逻辑与运算符、逻辑或运算符、逗号运算符的运算对象求值顺序无法保留下来，而 \u0026\u0026 和 || 短路求值属性也无法保留 对于逗号和取地址运算符，用于类类型对象时已经定义了特殊的含义，所以不应该被重载 使用内置类型一致的含义设计一个类时，要考虑这个类提供哪些操作，然后再考虑这些操作设为普通函数还是重载的运算符。如果某些类逻辑上和运算符相关，它们适合定义成重载的运算符 如果类执行 IO 操作，定义移位运算符和内置类型的 IO 保存一致 类检查相等性操作，定义 operator=，同时也应该定义 operator!= 如果类有比较操作，例如 operator）必须时成员 复合类型一般为成员，但非必须 改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减、解引用通常为成员 具有对称性的运算符可以转换任意一端的运算对象，如算术、相等性、关系和位运算，通常位普通的非成员函数 string s = \"world\"; string t = s + \"!\"; string u = \"hi \" + s;//如果+是string成员函数，这里会报错 实际上，string 将 + 定义为了普通成员函数，\"hi \" + s 等价于 operator+=(\"hi \", s)，就没有出现问题 ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:1:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#某些运算符不应该被重载"},{"categories":["C++"],"content":"14.1 基本概念重载的运算符是具有特殊名字的函数：它们的名字由关键字 operator 和其后要定义的运算符号共同组成。和其他函数一样，重载的运算符也包含返回类型、参数列表以及函数体。 重载运算符函数的参数数量与该作用的运算对象数量一样多，一元运算符有一个参数，二元运算符有两个参数； 二元运算符左侧运算对象传递给第一个参数，右侧对象传递给第二个对象 除了 operator() 外，其他重载运算符不能含有默认实参 如果一个重载运算符是类的成员函数时，this 会绑定到左侧运算对象，参数数量会比运算对象少一个 重载运算符函数只能是一个类的成员，或者至少有一个类类型的参数，不能对内置类型定义重载运算符 int operator+(int, int);//错误，不能重定义int的运算符 以下是可以重载或者不能重载的运算符： 重载运算符的几种调用形式： 可以间接的用运算符调用重载的运算符函数 也可以像普通函数那样直接调用 //一个非成员运算符函数的等价调用 data1 + data2; //普通表达式 operator+(data1, data2); //等价的函数调用 也可以像调用其他成员函数一样显示的调用成员运算符 data1 += data2; //基于调用的表达式 data1.operator+=(data2); //对成员运算符函数的等价调用 某些运算符不应该被重载 某些运算符会指定运算对象的求值顺序，而关于这些运算对象求值顺序的规则无法应用到重载的运算符上 像逻辑与运算符、逻辑或运算符、逗号运算符的运算对象求值顺序无法保留下来，而 \u0026\u0026 和 || 短路求值属性也无法保留 对于逗号和取地址运算符，用于类类型对象时已经定义了特殊的含义，所以不应该被重载 使用内置类型一致的含义设计一个类时，要考虑这个类提供哪些操作，然后再考虑这些操作设为普通函数还是重载的运算符。如果某些类逻辑上和运算符相关，它们适合定义成重载的运算符 如果类执行 IO 操作，定义移位运算符和内置类型的 IO 保存一致 类检查相等性操作，定义 operator=，同时也应该定义 operator!= 如果类有比较操作，例如 operator）必须时成员 复合类型一般为成员，但非必须 改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减、解引用通常为成员 具有对称性的运算符可以转换任意一端的运算对象，如算术、相等性、关系和位运算，通常位普通的非成员函数 string s = \"world\"; string t = s + \"!\"; string u = \"hi \" + s;//如果+是string成员函数，这里会报错 实际上，string 将 + 定义为了普通成员函数，\"hi \" + s 等价于 operator+=(\"hi \", s)，就没有出现问题 ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:1:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#使用内置类型一致的含义"},{"categories":["C++"],"content":"14.1 基本概念重载的运算符是具有特殊名字的函数：它们的名字由关键字 operator 和其后要定义的运算符号共同组成。和其他函数一样，重载的运算符也包含返回类型、参数列表以及函数体。 重载运算符函数的参数数量与该作用的运算对象数量一样多，一元运算符有一个参数，二元运算符有两个参数； 二元运算符左侧运算对象传递给第一个参数，右侧对象传递给第二个对象 除了 operator() 外，其他重载运算符不能含有默认实参 如果一个重载运算符是类的成员函数时，this 会绑定到左侧运算对象，参数数量会比运算对象少一个 重载运算符函数只能是一个类的成员，或者至少有一个类类型的参数，不能对内置类型定义重载运算符 int operator+(int, int);//错误，不能重定义int的运算符 以下是可以重载或者不能重载的运算符： 重载运算符的几种调用形式： 可以间接的用运算符调用重载的运算符函数 也可以像普通函数那样直接调用 //一个非成员运算符函数的等价调用 data1 + data2; //普通表达式 operator+(data1, data2); //等价的函数调用 也可以像调用其他成员函数一样显示的调用成员运算符 data1 += data2; //基于调用的表达式 data1.operator+=(data2); //对成员运算符函数的等价调用 某些运算符不应该被重载 某些运算符会指定运算对象的求值顺序，而关于这些运算对象求值顺序的规则无法应用到重载的运算符上 像逻辑与运算符、逻辑或运算符、逗号运算符的运算对象求值顺序无法保留下来，而 \u0026\u0026 和 || 短路求值属性也无法保留 对于逗号和取地址运算符，用于类类型对象时已经定义了特殊的含义，所以不应该被重载 使用内置类型一致的含义设计一个类时，要考虑这个类提供哪些操作，然后再考虑这些操作设为普通函数还是重载的运算符。如果某些类逻辑上和运算符相关，它们适合定义成重载的运算符 如果类执行 IO 操作，定义移位运算符和内置类型的 IO 保存一致 类检查相等性操作，定义 operator=，同时也应该定义 operator!= 如果类有比较操作，例如 operator）必须时成员 复合类型一般为成员，但非必须 改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减、解引用通常为成员 具有对称性的运算符可以转换任意一端的运算对象，如算术、相等性、关系和位运算，通常位普通的非成员函数 string s = \"world\"; string t = s + \"!\"; string u = \"hi \" + s;//如果+是string成员函数，这里会报错 实际上，string 将 + 定义为了普通成员函数，\"hi \" + s 等价于 operator+=(\"hi \", s)，就没有出现问题 ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:1:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#选择作为成员或者非成员"},{"categories":["C++"],"content":"14.2 输入输出运算符","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:2:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#142-输入输出运算符"},{"categories":["C++"],"content":"14.2.1 重载输出运算符«通常情况下，输出运算符第一个形参是一个非常量 ostream 对象的引用，非常量是因为像流写入内容会改变其状态，引用类型是因为无法直接复制一个 ostream 对象（注：拷贝构造函数为 delete） 第二个形参是一个常量的引用，这个常量是需要打印出来的类类型，引用为了避免复制，常量是因为打印不会改变对象的内容 举个例子： ostream \u0026operator(ostream \u0026os, const \u0026Sales_data \u0026item) { os \u003c\u003c item.isbn() \u003c\u003c \" \" \u003c\u003c item.units_sold \u003c\u003c \" \" \u003c\u003c item.revenue \u003c\u003c \" \" \u003c\u003c item.avg_price();//末尾不需要再加换行符 return os; } 通常输出运算符主要负责打印对象内容而不是控制格式，所以一般不打印换行符 输入输出运算符必须是非成员函数输入输出函数必须为非成员函数，不能是类成员函数，否则左侧运算对象将是类的一个对象 Sales_data data; data \u003c\u003c cout; //如果opeator\u003c\u003c是Sales_data的对象 如果输入输出运算符是Sales_data 的成员，它们也必须为 istream 或 ostream 的成员，当然我们不能为标准库定义成员 注：其实这里感觉没看懂，如果像书上写的这样，data « cout 感觉是不是也可以输出？我自己也试了代码，确实可以输出，就是看着有点怪，要是深究起来，感觉书上写的话不够严谨 ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:2:1","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#1421-重载输出运算符"},{"categories":["C++"],"content":"14.2.1 重载输出运算符«通常情况下，输出运算符第一个形参是一个非常量 ostream 对象的引用，非常量是因为像流写入内容会改变其状态，引用类型是因为无法直接复制一个 ostream 对象（注：拷贝构造函数为 delete） 第二个形参是一个常量的引用，这个常量是需要打印出来的类类型，引用为了避免复制，常量是因为打印不会改变对象的内容 举个例子： ostream \u0026operator(ostream \u0026os, const \u0026Sales_data \u0026item) { os ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:2:1","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#输入输出运算符必须是非成员函数"},{"categories":["C++"],"content":"14.2.2 重载输入运算符»输入运算符第一个形参是读取流的引用，第二个形参是读入到对象的引用 例如： istream \u0026operator\u003e\u003e(istream \u0026is, Sales_data \u0026item) { double price; is \u003e\u003e item.bookNo \u003e\u003e item.untis_sold \u003e\u003e price; if (is) {//检查是否输入成功 item.revenue = item.units_sold * price; } else { item = Sales_data();//输入失败，对象初始为默认情况 } return is; } 输入时的错误执行输入运算符时可能发生以下错误： 当流读取到错误类型的数据，后续操作都会失败 当读取操作未达到文件末尾或者遇到输入流其他错误时也会失败 所以使用输入操作符时，需要判断是否有错误的情况发生，因为如果出现错误的情况可能发生在中间，这样的话前面的成员时正确的，而发生读取错误的地方后面的成员就和前面不匹配了 ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:2:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#1422-重载输入运算符"},{"categories":["C++"],"content":"14.2.2 重载输入运算符»输入运算符第一个形参是读取流的引用，第二个形参是读入到对象的引用 例如： istream \u0026operator(istream \u0026is, Sales_data \u0026item) { double price; is item.bookNo item.untis_sold price; if (is) {//检查是否输入成功 item.revenue = item.units_sold * price; } else { item = Sales_data();//输入失败，对象初始为默认情况 } return is; } 输入时的错误执行输入运算符时可能发生以下错误： 当流读取到错误类型的数据，后续操作都会失败 当读取操作未达到文件末尾或者遇到输入流其他错误时也会失败 所以使用输入操作符时，需要判断是否有错误的情况发生，因为如果出现错误的情况可能发生在中间，这样的话前面的成员时正确的，而发生读取错误的地方后面的成员就和前面不匹配了 ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:2:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#输入时的错误"},{"categories":["C++"],"content":"14.3 算术和关系运算符通常情况下，算术和关系运算符定义为非成员函数允许左侧和右侧运算对象进行转换，形参都是常量的引用 算术运算符通常会计算两个对象并得到一个新值，这个值区别于任何一个运算对象，常常位于一个局部变量中，返回值应该为局部变量的副本作为结果，通常也会定义复合赋值运算符 Book operator+(const Book \u0026lhs, const Book \u0026rhs) { Book sum = lhs; sum += rhs; //复合赋值运算符 return sum; } ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:3:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#143-算术和关系运算符"},{"categories":["C++"],"content":"14.3.1 相等运算符一般情况下只有当两个对象每一个数据成员都相等时，才认为他们时相等的 下面是个具体例子： bool operator==(const Book \u0026lhs, const Book \u0026rhs) { return lhs.price == rhs.price \u0026\u0026 lhs.name == rhs.name; } bool operator!=(const Book \u0026lhs, const Book \u0026rhs) { return !(lhs == rhs); } 设计相等运算符函数基本准则如下： 设计一个类判断两个对象是否相等的操作时，通常定义为 operator== 而非其他的像（equl等等）普通的命名函数 如果类定义了 operator== ，则该运算符应该能判断一组给定对象是否含义重复数据 相等运算符应该具有传递性，如 a == b 和 b == c 都为真，那么 a == c 也为真 定义了 operator== 通常也要定义 operator!= 相等和不相等运算符，通常具体写一个即可，另一个进行调用即可 ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:3:1","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#1431-相等运算符"},{"categories":["C++"],"content":"14.3.2 关系运算符对于关联容器和一些算法会用到小于运算符，此时可以定义 operator\u003c 但是一般情况下，关系运算符可能没有那么有必要，比如说上面的 Book 类，如果说定义小于关系的，具体内容如何比较，是先根据书名然后根据价格进行比较？还是说仅仅根据书名比较 一般情况下，对于不相等的对象，一个对象应该小于另一个对象，这样的话，定义关系运算符的时候，逻辑上就不是很清楚了 如果存在唯一一种逻辑可靠的 \u003c 定义，应该考虑定义 \u003c 运算符，但是如果类还包括 == ，仅当\u003c 的定义和 == 结果一致时才定义 \u003c 运算符 ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:3:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#1432-关系运算符"},{"categories":["C++"],"content":"14.4 赋值运算符13章时已经介绍过拷贝赋值和移动赋值运算符，它们把一个对象赋值给另一个对象。我们还可以定义其他的赋值运算符，以使用别的类型作为右侧对象 复合赋值运算符通常把复合赋值运算符等赋值运算符都定义在类的内部，复合赋值运算符也应该返回左侧对象的引用 Book \u0026Book::operator+=(const Book \u0026rhs) { price += rhs.price;//这里因为自己写的例子，语义上可能有些问题 return *this; } ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:4:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#144-赋值运算符"},{"categories":["C++"],"content":"14.4 赋值运算符13章时已经介绍过拷贝赋值和移动赋值运算符，它们把一个对象赋值给另一个对象。我们还可以定义其他的赋值运算符，以使用别的类型作为右侧对象 复合赋值运算符通常把复合赋值运算符等赋值运算符都定义在类的内部，复合赋值运算符也应该返回左侧对象的引用 Book \u0026Book::operator+=(const Book \u0026rhs) { price += rhs.price;//这里因为自己写的例子，语义上可能有些问题 return *this; } ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:4:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#复合赋值运算符"},{"categories":["C++"],"content":"14.5 下标运算符下标运算符通常在一些容器中，可以让我们像访问数组那样的形式进行访问，一般会定义为 operator[] 下标运算符必须时成员函数 通常返回值为访问元素的引用，确保下标可以出现在赋值运算符任意一端 如果一个类包含下标运算符，通常会定义两个版本： 一个返回普通引用 另一个是类的常量成员并且返回常量引用 class StrVec { std::string\u0026 operator[](std::size_t n) {return elements[n];} const std::string\u0026 operator[](std::size_t) const {return elements[n];} private: std::string *elements;//指向数组首元素的指针 } 当 StrVec 是非常量时，可以给元素赋值 当对常量对象取小标时，不能为其赋值 const StrVec cvec = svec; if (svec.size() \u0026\u0026 svec[0].empty()) { svec[0] = \"zero\";//正确：下标运算符返回string的引用 cvec[0] = \"zip\"; //错误：cvec取下标返回的为常量引用 } ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:5:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#145-下标运算符"},{"categories":["C++"],"content":"14.6递增和递减运算符一般迭代器类会实现递增运算符（++）和递减运算符（–），使得迭代器可以在元素序列中进行移动，因为它们改变了操作对象的状态，通常设为成员函数 定义递增和递减运算符的类要同时定义前置版本和后置版本，且都为类的成员函数 定义前置递增/递减运算符==为了和内置版本保持一致，前置运算符应该返回递增或递减后对象的引用== 递增和递减运算符工作机理： 首先调用check 函数检查是否有效 如果有效，接着检查给定索引值是否有效 check 函数没有发生异常，返回运算对象的引用 下面时具体例子： class StrBlobPtr { public: //递增和递减运算符 StrBlobPtr\u0026 operator++();//前置版本 StrBlobPtr\u0026 operator--(); //其他成员 } StrBlobPtr\u0026 StrBlobPtr::operator++() { check(curr, \"已经越界\"); ++curr; //curr向前移动一个元素 return *this; } StrBlobPtr\u0026 StrBlobPtr::operator--() { --curr; //curr向后移动一个元素 check(curr, \"已经越界\"); return *this; } 区分前置和后置运算符因为前置和后置版本使用的是同一个符号，重载版本的名字也是相同的，运算对象的数量和类型也是相同的 所以为了解决这个问题，后置版本接受一个额外的但是不使用的 int 类型的参数，编译器会为这个形参提供一个值为 0 的实参 class StrBlobPtr { public: //递增和递减运算符 StrBlobPtr\u0026 operator++(int);//后置版本 StrBlobPtr\u0026 operator--(int); //其他成员 } StrBlobPtr StrBlobPtr::operator++(int) { //这里无须检查有效性，调用前置版本的时候会检查 StrBlobPtr ret = *this;//记录当前的值 ++*this; //向前移动一个元素，前置++会检查有效性 return ret; //返回之前记录的状态 } StrBlobPtr\u0026 StrBlobPtr::operator--(int) { //这里无须检查有效性，调用前置版本的时候会检查 StrBlobPtr ret = *this;//记录当前的值 --*this; //向前移动一个元素，前置++会检查有效性 return ret; //返回之前记录的状态 } 这里主要需要理解内置类型前置版本和后置版本的区别（以int类型为例） ++i 首先会对 i 的值进行递增，然后返回 i 的值 i++ 首先会返回 i 的值，然后再进行运算 int sum = 0, i = 1; sum = ++i; //此时sum的值为2 sum = i++; //此时sum的值为1 显示调用后置运算符如果要显示调用运算符的话，像之前那样利用函数调用的形式进行调用，但是注意必须传入一个整型参数 StrBlobPtr p(a1); //p指向a1的vector p.operator++(0); //调用后置版本的operator++ p.operator++(); //调用前置版本的operator++ ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:6:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#146递增和递减运算符"},{"categories":["C++"],"content":"14.6递增和递减运算符一般迭代器类会实现递增运算符（++）和递减运算符（–），使得迭代器可以在元素序列中进行移动，因为它们改变了操作对象的状态，通常设为成员函数 定义递增和递减运算符的类要同时定义前置版本和后置版本，且都为类的成员函数 定义前置递增/递减运算符==为了和内置版本保持一致，前置运算符应该返回递增或递减后对象的引用== 递增和递减运算符工作机理： 首先调用check 函数检查是否有效 如果有效，接着检查给定索引值是否有效 check 函数没有发生异常，返回运算对象的引用 下面时具体例子： class StrBlobPtr { public: //递增和递减运算符 StrBlobPtr\u0026 operator++();//前置版本 StrBlobPtr\u0026 operator--(); //其他成员 } StrBlobPtr\u0026 StrBlobPtr::operator++() { check(curr, \"已经越界\"); ++curr; //curr向前移动一个元素 return *this; } StrBlobPtr\u0026 StrBlobPtr::operator--() { --curr; //curr向后移动一个元素 check(curr, \"已经越界\"); return *this; } 区分前置和后置运算符因为前置和后置版本使用的是同一个符号，重载版本的名字也是相同的，运算对象的数量和类型也是相同的 所以为了解决这个问题，后置版本接受一个额外的但是不使用的 int 类型的参数，编译器会为这个形参提供一个值为 0 的实参 class StrBlobPtr { public: //递增和递减运算符 StrBlobPtr\u0026 operator++(int);//后置版本 StrBlobPtr\u0026 operator--(int); //其他成员 } StrBlobPtr StrBlobPtr::operator++(int) { //这里无须检查有效性，调用前置版本的时候会检查 StrBlobPtr ret = *this;//记录当前的值 ++*this; //向前移动一个元素，前置++会检查有效性 return ret; //返回之前记录的状态 } StrBlobPtr\u0026 StrBlobPtr::operator--(int) { //这里无须检查有效性，调用前置版本的时候会检查 StrBlobPtr ret = *this;//记录当前的值 --*this; //向前移动一个元素，前置++会检查有效性 return ret; //返回之前记录的状态 } 这里主要需要理解内置类型前置版本和后置版本的区别（以int类型为例） ++i 首先会对 i 的值进行递增，然后返回 i 的值 i++ 首先会返回 i 的值，然后再进行运算 int sum = 0, i = 1; sum = ++i; //此时sum的值为2 sum = i++; //此时sum的值为1 显示调用后置运算符如果要显示调用运算符的话，像之前那样利用函数调用的形式进行调用，但是注意必须传入一个整型参数 StrBlobPtr p(a1); //p指向a1的vector p.operator++(0); //调用后置版本的operator++ p.operator++(); //调用前置版本的operator++ ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:6:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#定义前置递增递减运算符"},{"categories":["C++"],"content":"14.6递增和递减运算符一般迭代器类会实现递增运算符（++）和递减运算符（–），使得迭代器可以在元素序列中进行移动，因为它们改变了操作对象的状态，通常设为成员函数 定义递增和递减运算符的类要同时定义前置版本和后置版本，且都为类的成员函数 定义前置递增/递减运算符==为了和内置版本保持一致，前置运算符应该返回递增或递减后对象的引用== 递增和递减运算符工作机理： 首先调用check 函数检查是否有效 如果有效，接着检查给定索引值是否有效 check 函数没有发生异常，返回运算对象的引用 下面时具体例子： class StrBlobPtr { public: //递增和递减运算符 StrBlobPtr\u0026 operator++();//前置版本 StrBlobPtr\u0026 operator--(); //其他成员 } StrBlobPtr\u0026 StrBlobPtr::operator++() { check(curr, \"已经越界\"); ++curr; //curr向前移动一个元素 return *this; } StrBlobPtr\u0026 StrBlobPtr::operator--() { --curr; //curr向后移动一个元素 check(curr, \"已经越界\"); return *this; } 区分前置和后置运算符因为前置和后置版本使用的是同一个符号，重载版本的名字也是相同的，运算对象的数量和类型也是相同的 所以为了解决这个问题，后置版本接受一个额外的但是不使用的 int 类型的参数，编译器会为这个形参提供一个值为 0 的实参 class StrBlobPtr { public: //递增和递减运算符 StrBlobPtr\u0026 operator++(int);//后置版本 StrBlobPtr\u0026 operator--(int); //其他成员 } StrBlobPtr StrBlobPtr::operator++(int) { //这里无须检查有效性，调用前置版本的时候会检查 StrBlobPtr ret = *this;//记录当前的值 ++*this; //向前移动一个元素，前置++会检查有效性 return ret; //返回之前记录的状态 } StrBlobPtr\u0026 StrBlobPtr::operator--(int) { //这里无须检查有效性，调用前置版本的时候会检查 StrBlobPtr ret = *this;//记录当前的值 --*this; //向前移动一个元素，前置++会检查有效性 return ret; //返回之前记录的状态 } 这里主要需要理解内置类型前置版本和后置版本的区别（以int类型为例） ++i 首先会对 i 的值进行递增，然后返回 i 的值 i++ 首先会返回 i 的值，然后再进行运算 int sum = 0, i = 1; sum = ++i; //此时sum的值为2 sum = i++; //此时sum的值为1 显示调用后置运算符如果要显示调用运算符的话，像之前那样利用函数调用的形式进行调用，但是注意必须传入一个整型参数 StrBlobPtr p(a1); //p指向a1的vector p.operator++(0); //调用后置版本的operator++ p.operator++(); //调用前置版本的operator++ ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:6:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#区分前置和后置运算符"},{"categories":["C++"],"content":"14.6递增和递减运算符一般迭代器类会实现递增运算符（++）和递减运算符（–），使得迭代器可以在元素序列中进行移动，因为它们改变了操作对象的状态，通常设为成员函数 定义递增和递减运算符的类要同时定义前置版本和后置版本，且都为类的成员函数 定义前置递增/递减运算符==为了和内置版本保持一致，前置运算符应该返回递增或递减后对象的引用== 递增和递减运算符工作机理： 首先调用check 函数检查是否有效 如果有效，接着检查给定索引值是否有效 check 函数没有发生异常，返回运算对象的引用 下面时具体例子： class StrBlobPtr { public: //递增和递减运算符 StrBlobPtr\u0026 operator++();//前置版本 StrBlobPtr\u0026 operator--(); //其他成员 } StrBlobPtr\u0026 StrBlobPtr::operator++() { check(curr, \"已经越界\"); ++curr; //curr向前移动一个元素 return *this; } StrBlobPtr\u0026 StrBlobPtr::operator--() { --curr; //curr向后移动一个元素 check(curr, \"已经越界\"); return *this; } 区分前置和后置运算符因为前置和后置版本使用的是同一个符号，重载版本的名字也是相同的，运算对象的数量和类型也是相同的 所以为了解决这个问题，后置版本接受一个额外的但是不使用的 int 类型的参数，编译器会为这个形参提供一个值为 0 的实参 class StrBlobPtr { public: //递增和递减运算符 StrBlobPtr\u0026 operator++(int);//后置版本 StrBlobPtr\u0026 operator--(int); //其他成员 } StrBlobPtr StrBlobPtr::operator++(int) { //这里无须检查有效性，调用前置版本的时候会检查 StrBlobPtr ret = *this;//记录当前的值 ++*this; //向前移动一个元素，前置++会检查有效性 return ret; //返回之前记录的状态 } StrBlobPtr\u0026 StrBlobPtr::operator--(int) { //这里无须检查有效性，调用前置版本的时候会检查 StrBlobPtr ret = *this;//记录当前的值 --*this; //向前移动一个元素，前置++会检查有效性 return ret; //返回之前记录的状态 } 这里主要需要理解内置类型前置版本和后置版本的区别（以int类型为例） ++i 首先会对 i 的值进行递增，然后返回 i 的值 i++ 首先会返回 i 的值，然后再进行运算 int sum = 0, i = 1; sum = ++i; //此时sum的值为2 sum = i++; //此时sum的值为1 显示调用后置运算符如果要显示调用运算符的话，像之前那样利用函数调用的形式进行调用，但是注意必须传入一个整型参数 StrBlobPtr p(a1); //p指向a1的vector p.operator++(0); //调用后置版本的operator++ p.operator++(); //调用前置版本的operator++ ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:6:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#显示调用后置运算符"},{"categories":["C++"],"content":"14.7 成员访问运算符迭代器和智能指针类中常常用到解引用运算符（*）和箭头运算符（-\u003e），例如： class StrBlobPtr { public: std::string \u0026operator*() const { auto p = check(curr, \"dereference past end\"); return (*p)[curr]; //(*p)是对象所指的vector } std::string \u0026operator-\u003e() const { return \u0026 this-\u003eoperator*();//实际工作委托给解引用运算符 } //其他成员 } 解引用运算符首先检查curr是否在作用范围内，如果是返回curr所指元素的引用，箭头运算符返回解引用结果元素的地址 对箭头运算符返回值的限定形如point-\u003emem 的表达式，point必须是指向类对象的指针或者是重载了 operator-\u003e 的类的对象 (*point).mem; //point是一个内置指针类型 point.operator()-\u003emem;//point是一个类的对象 如果 point 是指针，则会应用内置箭头运算符，等价于 (*point).mem 如果 point 是一个定义了 operator-\u003e的类的一个对象，则使用 point.operator-\u003e() 的结果来获取 mem ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:7:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#147-成员访问运算符"},{"categories":["C++"],"content":"14.7 成员访问运算符迭代器和智能指针类中常常用到解引用运算符（*）和箭头运算符（-），例如： class StrBlobPtr { public: std::string \u0026operator*() const { auto p = check(curr, \"dereference past end\"); return (*p)[curr]; //(*p)是对象所指的vector } std::string \u0026operator-() const { return \u0026 this-operator*();//实际工作委托给解引用运算符 } //其他成员 } 解引用运算符首先检查curr是否在作用范围内，如果是返回curr所指元素的引用，箭头运算符返回解引用结果元素的地址 对箭头运算符返回值的限定形如point-mem 的表达式，point必须是指向类对象的指针或者是重载了 operator- 的类的对象 (*point).mem; //point是一个内置指针类型 point.operator()-mem;//point是一个类的对象 如果 point 是指针，则会应用内置箭头运算符，等价于 (*point).mem 如果 point 是一个定义了 operator-的类的一个对象，则使用 point.operator-() 的结果来获取 mem ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:7:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#对箭头运算符返回值的限定"},{"categories":["C++"],"content":"14.8 函数调用运算符如果一个类重载了函数调用运算符（就是()），则可以像调用函数一样使用该类的对象，下面是一个例子： struct absInt { int operator()(int val) const { return val \u003c 0 ? -val : val; } } int i = -42; absInt absObj; //含有函数调用运算符的对象 int ui = absObj(i);//将i传递给absObj.operator() 函数调用运算符必须是成员函数，一个类可以定义多个不同版本的调用运算符 如果类定义了调用运算符，则该类的对象称为函数对象，这些对象的行为像函数一样 含有状态的函数对象类函数对象类除了 operator() 之外也可以包含其他成员，这些成员被用于定制调用运算符中的操作，下面是个例子： class PrintString { public: PrintString(ostream \u0026o = cout, char c = ' ') : os(o), sep(c) {} void operator()(const string \u0026s) const {os \u003c\u003c s \u003c\u003c sep;} private: ostream \u0026os;//用于写入的目的流 char step; //用于将不同输出隔开的字符 } PrintString printer; printer(s); PrintString errors(cerr, '\\n'); errors(s); 函数对象常常作为泛型算法的实参，例如可以用for_each 算法和 PrintString 类来打印容器的内容： for_each(vec.beign(), vec.end(), PrintString(cerr, '\\n')); for_each 第三个实参是类型 PrintString 的一个临时对象，我们用 cerr 和 换行符初始化了改对象，程序调用 for_each 时，会把 vec 每个元素打印到 cerr 中，元素之间以换行符分割 ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:8:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#148-函数调用运算符"},{"categories":["C++"],"content":"14.8 函数调用运算符如果一个类重载了函数调用运算符（就是()），则可以像调用函数一样使用该类的对象，下面是一个例子： struct absInt { int operator()(int val) const { return val ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:8:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#含有状态的函数对象类"},{"categories":["C++"],"content":"14.8.1 lambda 是函数对象使用 PrintString 对象作为 for_each 的实参，类似于使用 lambda 表达式，编译器会将 lambda 表达式 翻译成一个未命名类的未命名对象，举例如下： //根据单词长度进行排序，长度相同的会按照字典序排序 stable_sort(word.begin(), word.end(), [](const string \u0026a, const string \u0026b) { return a.size() \u003c b.size();}); 上面 lambda 表达式类似下面的一个未命名对象 class ShorterString { public: bool operator()(const string \u0026s1, string \u0026s2) const { return s1.size() \u003c s2.size(); } } //替换上面的lambda表达式 stable_sort(word.begin(), word.end(), ShorterString()); 表示 lambda 及相应捕获行为的类 使用一个 lambda 表达式通过引用捕获变量时，程序确保 lambda 执行时引用所引的对象确实存在，编译器可以直接引用而无须在 lambda 产生的类中将其存储为数据成员 使用值捕获的变量会拷贝到 lambda 表达式中，这种 lambda 表达式产生的类必须为每个值捕获的变量建立对应的数据成员，同时创建构造函数，用捕获的变量进行初始化 //获得第一个指向满足条件元素的迭代器，该元素满足size() \u003e= sz auto wc = find_if(word.begin(), word.end(), [sz](const string \u0026a) { return a.size() \u003e= sz;}); //上面的lambda表达式产生的类像下面这样 class SizeComp { SizeComp(size_t n) : sz(n) {} bool operator()(const string \u0026s) const { return s.size() \u003e= sz; } private: size_t sz;//该数据成员对应通过值捕获的变量 } //使用像上面的函数对象时，必须提供一个实参 auto wc = find_if(word.begin(), word.end(), SizeCopm(sz)); lambda 表达式产生的类不含默认构造函数、赋值运算符和默认析构函数；它是否含有默认的拷贝/移动构造函数通常视捕获的数据成员类型而定 ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:8:1","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#1481-lambda-是函数对象"},{"categories":["C++"],"content":"14.8.1 lambda 是函数对象使用 PrintString 对象作为 for_each 的实参，类似于使用 lambda 表达式，编译器会将 lambda 表达式 翻译成一个未命名类的未命名对象，举例如下： //根据单词长度进行排序，长度相同的会按照字典序排序 stable_sort(word.begin(), word.end(), [](const string \u0026a, const string \u0026b) { return a.size() = sz auto wc = find_if(word.begin(), word.end(), [sz](const string \u0026a) { return a.size() = sz;}); //上面的lambda表达式产生的类像下面这样 class SizeComp { SizeComp(size_t n) : sz(n) {} bool operator()(const string \u0026s) const { return s.size() = sz; } private: size_t sz;//该数据成员对应通过值捕获的变量 } //使用像上面的函数对象时，必须提供一个实参 auto wc = find_if(word.begin(), word.end(), SizeCopm(sz)); lambda 表达式产生的类不含默认构造函数、赋值运算符和默认析构函数；它是否含有默认的拷贝/移动构造函数通常视捕获的数据成员类型而定 ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:8:1","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#表示-lambda-及相应捕获行为的类"},{"categories":["C++"],"content":"14.8.2 标准库定义的函数对象标准库定义了一组表示算术运算符、关系运算符和逻辑运算符的类，每个类分别定义了一个执行与类名对应的调用运算符。 如puls 类定义了一个函数调用运算符用于执行 + 操作，modulus类定义了一个调用运算符执行二元 % 的操作 这些类都是模板形式，可以指定具体的应用类型，即对应调用运算符的形参类型 plus\u003cint\u003e intAdd; //执行int加法的函数对象 negate\u003cint\u003e intNegate; //执行int取反的函数对象 int sum = intAdd(10, 20); //sum = 30 sum = intNegate(intAdd(10, 20));//sum = -30 sum = intAdd(10, intNegate(10));//sum = 0 下面时标准库定义的函数对象： 算术 关系 逻辑 plus\u003cType\u003e equal_to\u003cType\u003e logical_and\u003c minus\u003cType not_equal_to\u003cType\u003e logical_or\u003cType\u003e multiplies\u003cType\u003e greater\u003cType\u003e logical_not\u003cType\u003e divides\u003cType\u003e greater_equal\u003cType\u003e modulus\u003cType\u003e less\u003cType\u003e negate\u003cType\u003e less_equal\u003cType\u003e 算法中使用标准库函数对象默认情况下排序算法使用 operator\u003c 将序列按照升序进行排列，如果想执行降序的话，可以用 greater类型的对象 sort(svec.begin(), sec.end(), greater\u003cstring\u003e()); 注意：标准库规定的函数对象对于指针同样适用，如果比较两个无关指针会产生未定义的行为，而我们如果想比较指针内存地址来 sort 指针的 vector。直接比较会产生未定义的行为，而标准库函数对象则可实现这个目的 vector\u003cstring*\u003e nameTable; //错误：nameTable中指针彼此之间没有关系，所以 \u003c 将产生未定义行为 sort(nameTable.begin(), nameTable.end(), [](string *a, string *b) { return a \u003c b;}); // 正确：标准库规定指针的less是定义良好的 sort(nameTable.begin(), nameTable.end(), less\u003cstring*\u003e()); ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:8:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#1482-标准库定义的函数对象"},{"categories":["C++"],"content":"14.8.2 标准库定义的函数对象标准库定义了一组表示算术运算符、关系运算符和逻辑运算符的类，每个类分别定义了一个执行与类名对应的调用运算符。 如puls 类定义了一个函数调用运算符用于执行 + 操作，modulus类定义了一个调用运算符执行二元 % 的操作 这些类都是模板形式，可以指定具体的应用类型，即对应调用运算符的形参类型 plus intAdd; //执行int加法的函数对象 negate intNegate; //执行int取反的函数对象 int sum = intAdd(10, 20); //sum = 30 sum = intNegate(intAdd(10, 20));//sum = -30 sum = intAdd(10, intNegate(10));//sum = 0 下面时标准库定义的函数对象： 算术 关系 逻辑 plus equal_to logical_andlogical_or multiplies greater logical_not divides greater_equal modulus less negate less_equal 算法中使用标准库函数对象默认情况下排序算法使用 operator()); 注意：标准库规定的函数对象对于指针同样适用，如果比较两个无关指针会产生未定义的行为，而我们如果想比较指针内存地址来 sort 指针的 vector。直接比较会产生未定义的行为，而标准库函数对象则可实现这个目的 vector nameTable; //错误：nameTable中指针彼此之间没有关系，所以 ()); ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:8:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#算法中使用标准库函数对象"},{"categories":["C++"],"content":"14.8.3 可调用对象与 functionC++中有几种可调用的对象：函数、函数指针、lambda 表达式、bind 创建的对象以及重载了函数调用运算符的类 这些不同类型的可调用对象可能共享一种调用形式，调用形式指明了返回类型以及实参类型，下面是个例子： //普通函数 int add(int i, int j) { return i + j; } //lambda 表达式 auto mod = [](int i, int j) { return i % j; } //函数对象类 struct divide { int operator()(int denominator, int divisor) { return denominator / divisor; } } 上面的几种可调用对象对参数执行了不同的算术运算，它们类型不相同，但是共享同一种调用形式 int(int, int) 我们如果用这些可调用对象构建一个简单的计算器，可以定义一个函数表用于储存这些可调用对象的指针。 可以通过 map 来实现，用运算符符号的string对象作为关键字，实现运算符函数作为值 //构建运算符到函数指针的映射关系，函数接受两个int，返回一个int map\u003cstring, int(*)(int, int)\u003e binops; //正确：add是一个指向正确类型的函数指针 binops.insert({\"+\", add}); //错误：mod不是一个函数指针 binops.insert({\"%\", mod}); 上面的问题在于 mod 是一个 lambda 表达式，与 binops 的值类型不匹配 标准库 function 类型标准库中一个新的类型 function 可以解决上述问题，下面是 function 定义的操作： function 是一个模板，创建一个具体 function 类型时需要指定 function 表示的对象的调用形式，如 function\u003cint(int, int)\u003e ，这里声明了一个 function 类型，它可以接受两个 int，返回一个 int 类型的可调用对象 function\u003cint(int, int)\u003e f1 = add; //函数指针 function\u003cint(int, int)\u003e f1 = divide();//函数对象类的对象 function\u003cint(int, int)\u003e f1 = [](int i, int j) //lambda { return i * j; }; cout \u003c\u003c f1(4, 2) \u003c\u003c endl; // 6 cout \u003c\u003c f2(4, 2) \u003c\u003c endl; // 2 cout \u003c\u003c f3(4, 2) \u003c\u003c endl; // 8 使用这个 function 类型可以重新定义 map： map\u003cstring, function\u003cint(int, int)\u003e\u003e binops = { {\"+\", add}, //函数指针 {\"-\", std::minus\u003cint\u003e()}, //标准库定义函数对象 {\"/\", divide()}, //用户定义函数对象 {\"*\", [](int i, int j) { return i * j; }},//未命名lambda表达式 {\"%\", mod} //命名的lambda } map 包含5 个元素，虽然可调用对象类型各不相同，但是仍可以存储在同一个 function\u003cint(int, int)\u003e 类型中，这时可以通过索引 map 得到function 对象的引用 binops[\"+\"](10, 5);//add(10, 5); binops[\"-\"](10, 5);//minus\u003cint\u003e(10, 5) binops[\"/\"](10, 5);//divide对象调用运算符 binops[\"*\"](10, 5);//调用lambda函数对象 binops[\"%\"](10, 5);//调用lambda函数对象 重载的函数与 function我们变不能将重载函数名字存入 function 类型的对象中： int add(int i, int j); Sales_data add(const Sales_data\u0026, const Sales_data\u0026); map\u003cstring, function\u003cint(int, int)\u003e\u003e binops; binops.insert({\"+\", add}); //错误：哪个add？ 解决上述二义性问题，可以通过一个函数指针，以及 lambda 表达式进行区分 int (*fp)(int, int) = add; binops.insert({\"+\", fp});//正确：fp指向一个正确的add版本 //正确：使用lambda来指定我们希望使用的add版本 binops.insert({\"+\", [](int a, int b) {return add(a, b);}}); ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:8:3","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#1483-可调用对象与-function"},{"categories":["C++"],"content":"14.8.3 可调用对象与 functionC++中有几种可调用的对象：函数、函数指针、lambda 表达式、bind 创建的对象以及重载了函数调用运算符的类 这些不同类型的可调用对象可能共享一种调用形式，调用形式指明了返回类型以及实参类型，下面是个例子： //普通函数 int add(int i, int j) { return i + j; } //lambda 表达式 auto mod = [](int i, int j) { return i % j; } //函数对象类 struct divide { int operator()(int denominator, int divisor) { return denominator / divisor; } } 上面的几种可调用对象对参数执行了不同的算术运算，它们类型不相同，但是共享同一种调用形式 int(int, int) 我们如果用这些可调用对象构建一个简单的计算器，可以定义一个函数表用于储存这些可调用对象的指针。 可以通过 map 来实现，用运算符符号的string对象作为关键字，实现运算符函数作为值 //构建运算符到函数指针的映射关系，函数接受两个int，返回一个int mapbinops; //正确：add是一个指向正确类型的函数指针 binops.insert({\"+\", add}); //错误：mod不是一个函数指针 binops.insert({\"%\", mod}); 上面的问题在于 mod 是一个 lambda 表达式，与 binops 的值类型不匹配 标准库 function 类型标准库中一个新的类型 function 可以解决上述问题，下面是 function 定义的操作： function 是一个模板，创建一个具体 function 类型时需要指定 function 表示的对象的调用形式，如 function，这里声明了一个 function 类型，它可以接受两个 int，返回一个 int 类型的可调用对象 functionf1 = add; //函数指针 functionf1 = divide();//函数对象类的对象 functionf1 = [](int i, int j) //lambda { return i * j; }; cout binops = { {\"+\", add}, //函数指针 {\"-\", std::minus()}, //标准库定义函数对象 {\"/\", divide()}, //用户定义函数对象 {\"*\", [](int i, int j) { return i * j; }},//未命名lambda表达式 {\"%\", mod} //命名的lambda } map 包含5 个元素，虽然可调用对象类型各不相同，但是仍可以存储在同一个 function类型中，这时可以通过索引 map 得到function 对象的引用 binops[\"+\"](10, 5);//add(10, 5); binops[\"-\"](10, 5);//minus(10, 5) binops[\"/\"](10, 5);//divide对象调用运算符 binops[\"*\"](10, 5);//调用lambda函数对象 binops[\"%\"](10, 5);//调用lambda函数对象 重载的函数与 function我们变不能将重载函数名字存入 function 类型的对象中： int add(int i, int j); Sales_data add(const Sales_data\u0026, const Sales_data\u0026); map binops; binops.insert({\"+\", add}); //错误：哪个add？ 解决上述二义性问题，可以通过一个函数指针，以及 lambda 表达式进行区分 int (*fp)(int, int) = add; binops.insert({\"+\", fp});//正确：fp指向一个正确的add版本 //正确：使用lambda来指定我们希望使用的add版本 binops.insert({\"+\", [](int a, int b) {return add(a, b);}}); ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:8:3","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#标准库-function-类型"},{"categories":["C++"],"content":"14.8.3 可调用对象与 functionC++中有几种可调用的对象：函数、函数指针、lambda 表达式、bind 创建的对象以及重载了函数调用运算符的类 这些不同类型的可调用对象可能共享一种调用形式，调用形式指明了返回类型以及实参类型，下面是个例子： //普通函数 int add(int i, int j) { return i + j; } //lambda 表达式 auto mod = [](int i, int j) { return i % j; } //函数对象类 struct divide { int operator()(int denominator, int divisor) { return denominator / divisor; } } 上面的几种可调用对象对参数执行了不同的算术运算，它们类型不相同，但是共享同一种调用形式 int(int, int) 我们如果用这些可调用对象构建一个简单的计算器，可以定义一个函数表用于储存这些可调用对象的指针。 可以通过 map 来实现，用运算符符号的string对象作为关键字，实现运算符函数作为值 //构建运算符到函数指针的映射关系，函数接受两个int，返回一个int mapbinops; //正确：add是一个指向正确类型的函数指针 binops.insert({\"+\", add}); //错误：mod不是一个函数指针 binops.insert({\"%\", mod}); 上面的问题在于 mod 是一个 lambda 表达式，与 binops 的值类型不匹配 标准库 function 类型标准库中一个新的类型 function 可以解决上述问题，下面是 function 定义的操作： function 是一个模板，创建一个具体 function 类型时需要指定 function 表示的对象的调用形式，如 function，这里声明了一个 function 类型，它可以接受两个 int，返回一个 int 类型的可调用对象 functionf1 = add; //函数指针 functionf1 = divide();//函数对象类的对象 functionf1 = [](int i, int j) //lambda { return i * j; }; cout binops = { {\"+\", add}, //函数指针 {\"-\", std::minus()}, //标准库定义函数对象 {\"/\", divide()}, //用户定义函数对象 {\"*\", [](int i, int j) { return i * j; }},//未命名lambda表达式 {\"%\", mod} //命名的lambda } map 包含5 个元素，虽然可调用对象类型各不相同，但是仍可以存储在同一个 function类型中，这时可以通过索引 map 得到function 对象的引用 binops[\"+\"](10, 5);//add(10, 5); binops[\"-\"](10, 5);//minus(10, 5) binops[\"/\"](10, 5);//divide对象调用运算符 binops[\"*\"](10, 5);//调用lambda函数对象 binops[\"%\"](10, 5);//调用lambda函数对象 重载的函数与 function我们变不能将重载函数名字存入 function 类型的对象中： int add(int i, int j); Sales_data add(const Sales_data\u0026, const Sales_data\u0026); map binops; binops.insert({\"+\", add}); //错误：哪个add？ 解决上述二义性问题，可以通过一个函数指针，以及 lambda 表达式进行区分 int (*fp)(int, int) = add; binops.insert({\"+\", fp});//正确：fp指向一个正确的add版本 //正确：使用lambda来指定我们希望使用的add版本 binops.insert({\"+\", [](int a, int b) {return add(a, b);}}); ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:8:3","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#重载的函数与-function"},{"categories":["C++"],"content":"14.9 重载、类型转换和运算符","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:9:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#149-重载类型转换和运算符"},{"categories":[],"content":"博客搭建初衷半路转行选手，大学走了很多弯路，兜兜转转最后还是选择计算机，目前软工方向研究生在读，目标是中大厂后端开发，现在仍处于入门阶段，基础知识较为薄弱。 搭建这个博客初衷是为了记录自己学习过程中的笔记，我并不是那种特别善于总结的人，很多内容可能也表述不够清楚，但是我觉得如果学习过程中没有记录相关的笔记，尤其是计算机相关课程，时间一久很容易就忘记之前学过的内容，记录笔记的过程亦是一种思考的过程。 ","date":"2022-04-19","objectID":"/about/:0:1","series":null,"tags":[],"title":"关于我","uri":"/about/#博客搭建初衷"},{"categories":[],"content":"这是一条树洞测试 ","date":"2022-04-19","objectID":"/life/%E6%9D%82%E8%AE%B0/:0:0","series":null,"tags":[],"title":"树洞测试","uri":"/life/%E6%9D%82%E8%AE%B0/#"}]
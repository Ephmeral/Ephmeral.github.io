[{"categories":[],"content":"并查集模板写法 class UnionFind { private: int cnt; // 连通分量 vector\u003cint\u003e parent; //x父节点为parent[x] public: UnionFind(int n) { cnt = n; parent.resize(n); // 开始时，每个节点是自己的父节点 for (int i = 0; i \u003c n; ++i) { parent[i] = i; } } // 连通两个节点 void connect(int p, int q) { int rootP = find(p); int rootQ = find(q); if (rootP == rootQ) return; parent[rootP] = rootQ; // 两个树的根节点合并 cnt--; } // 找到x的根节点 int find(int x) { while (parent[x] != x) { x = parent[x]; } return x; } //判断p, q是否连通 bool isConnected(int p, int q) { int rootP = find(p); int rootQ = find(q); return rootP == rootQ; } // 返回有多少连通分量 int count() { return cnt; } }; ","date":"2022-04-25","objectID":"/notes/%E5%B9%B6%E6%9F%A5%E9%9B%86/:1:0","series":null,"tags":[],"title":"并查集","uri":"/notes/%E5%B9%B6%E6%9F%A5%E9%9B%86/#并查集模板写法"},{"categories":[],"content":"半路转行选手，努力学习中，此博客当作个人学习的一个记录，目前仍在建设中…… ","date":"2022-04-19","objectID":"/about/:0:0","series":null,"tags":[],"title":"关于我","uri":"/about/#"},{"categories":[],"content":"归档界面测试这是一个测试界面 ","date":"2022-04-19","objectID":"/archive/%E5%BD%92%E6%A1%A31/:1:0","series":null,"tags":[],"title":"归档1","uri":"/archive/%E5%BD%92%E6%A1%A31/#归档界面测试"},{"categories":[],"content":"归档界面测试这是一个测试界面 ","date":"2022-04-19","objectID":"/archive/%E5%BD%92%E6%A1%A32/:1:0","series":null,"tags":[],"title":"归档2","uri":"/archive/%E5%BD%92%E6%A1%A32/#归档界面测试"},{"categories":[],"content":"# 测试这是一个树洞树洞测试 ","date":"2022-04-19","objectID":"/memo/%E6%96%B0%E5%BB%BA-markdown/:1:0","series":null,"tags":[],"title":"树洞2","uri":"/memo/%E6%96%B0%E5%BB%BA-markdown/#-测试这是一个树洞"},{"categories":[],"content":"# 测试这是一个树洞树洞测试 ","date":"2022-04-19","objectID":"/memo/%E6%A0%91%E6%B4%9E2/:1:0","series":null,"tags":[],"title":"树洞2","uri":"/memo/%E6%A0%91%E6%B4%9E2/#-测试这是一个树洞"},{"categories":["Algorithm"],"content":"解题思路：本质是遍历图的所有顶点，然后将每个节点深拷贝到新的顶点，图的遍历自然想到DFS和BFS两种方法 问题的关键在于如何深拷贝每个顶点： 首先，用一个哈希表存放旧顶点和新顶点，这样在访问旧顶点的时候，可以快速定位新的顶点 其次，遍历过程中，不能用构造函数直接拷贝每个顶点的邻居，需要单独拷贝 ","date":"2022-04-19","objectID":"/133.%E5%85%8B%E9%9A%86%E5%9B%BE/:0:1","series":null,"tags":["算法"],"title":"133.克隆图","uri":"/133.%E5%85%8B%E9%9A%86%E5%9B%BE/#解题思路"},{"categories":["Algorithm"],"content":"代码方法一：DFS class Solution { public: unordered_map\u003cNode*, Node*\u003e vis; //标记旧顶点到新顶点的映射 Node* cloneGraph(Node* node) { if (node == nullptr) return nullptr;//顶点为空的情况 if (vis.find(node) != vis.end()) { //如果发现vis中已经访问过旧顶点，直接返回对应的新顶点 return vis[node]; } Node *clone = new Node(node-\u003eval); //构造一个克隆的新顶点，主要不能直接调用构造函数拷贝邻居 vis[node] = clone; //标记已经访问过当前顶点node，并对应相应的克隆顶点 for (auto \u0026nb : node-\u003eneighbors) { //对每个邻居加入到新的顶点中，进一步调用cloneGraph clone-\u003eneighbors.emplace_back(cloneGraph(nb)); } return clone; //返回克隆的新顶点 } }; 方法二：BFS class Solution { public: Node* cloneGraph(Node* node) { if (node == nullptr) return nullptr; queue\u003cNode*\u003e que; // 用来BFS遍历时，存放顶点 unordered_map\u003cNode*, Node*\u003e vis; // 标记已经访问过的顶点，并映射到克隆的顶点上 Node *clone = new Node(node-\u003eval); // 创建当前顶点的克隆顶点 que.emplace(node); vis[node] = clone; // 标记当前顶点node已经访问过 while (!que.empty()) { Node* p = que.front(); que.pop(); // 取出队首的顶点 for (auto \u0026 nb : p-\u003eneighbors) { if (vis.find(nb) == mp.end()) { //如果邻居没有访问过，加入到队列中，并且存放到哈希表中 vis[nb] = new Node(nb-\u003eval); que.emplace(nb); } mp[p]-\u003eneighbors.emplace_back(vis[nb]);//依次将每个顶点加入到克隆顶点的邻居数组中 } } return mp[node]; // 返回node对应的克隆顶点，也j } }; ","date":"2022-04-19","objectID":"/133.%E5%85%8B%E9%9A%86%E5%9B%BE/:0:2","series":null,"tags":["算法"],"title":"133.克隆图","uri":"/133.%E5%85%8B%E9%9A%86%E5%9B%BE/#代码"},{"categories":null,"content":"测试 测试1 测试2 测试3 #include \u003ciostream\u003eusing namespace std; int main() { cout \u003c\u003c \"Hello World!\" \u003c\u003c endl; return 0; } 表格测试 测试1 测试2 123 456 789 123 456 789 134 456 789 图片测试 ","date":"2022-04-19","objectID":"/hello_world/:0:0","series":null,"tags":null,"title":"Hello_world","uri":"/hello_world/#测试"},{"categories":["数据结构"],"content":"§5.1 二叉树及其表示","date":"2022-04-05","objectID":"/5.1-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E8%A1%A8%E7%A4%BA/:1:0","series":null,"tags":["二叉树"],"title":"5.1 二叉树及其表示","uri":"/5.1-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E8%A1%A8%E7%A4%BA/#51-二叉树及其表示"},{"categories":["数据结构"],"content":"5.1.1 树有根树从图论的角度看，树等价于连通无环图。因此与一般的图相同，树也由一组顶点（vertex） 以及联接与其间的若干条边（edge） 组成。 在计算机科学中，往往还会在此基础上，再指定某一特定顶点，并称之为根（root）。 在指定根节点之后，我们也称之为有根树（rooted tree）。 此时，从程序实现的角度，我们也更多地将顶点称作节点（node）。 深度与层次由树的连通性，每一节点与根之间都有一条路径相联；而根据树的无环性，由根通往每个节点的路径必然唯一。 因此如图5.1所示，沿每个节点 v到根 r 的唯一通路所经过边的数目，称作 v 的深度（depth），记作 depth(v)。 依据深度排序，可对所有节点做分层归类。特别地，约定根节点的深度 depth(r) = 0，故属于第0层。 祖先、后代与子树任一节点 v 在通往树根沿途所经过的每个节点都是其祖先（ancestor），v 是它们的后代（descendant）。 特别地，v 的祖先/后代包括其本身，而v本身以外的祖先/后代称作真祖先（proper ancestor）/ 真后代（proper descendant）。 节点 v 历代祖先的层次，自下而上以 1 为单位逐层递减；在每一层次上，v 的祖先至多一个。 特别地，若节点 u 是 v 的祖先且恰好比 v 高出一层， 则称 u 是 v 的父亲（parent），v 是 u 的孩子（child）。 v 的孩子总数，称作其度数或度（degree），记作 deg(v)。无孩子的节点称作叶节点（leaf），包括根在内的其余节点皆为内部节点（internal node）。 v 所有的后代及其之间的联边称作子树（subtree），记作 subtree(v)。 ![[有根树的逻辑结构.png]] 高度树 T 中所有节点[[5.1 二叉树及其表示#深度与层次|深度]]的最大值称作该树的高度（height），记作height(T)。 特别地，本书约定，仅含单个节点的树高度为0，空树高度为-1。 推而广之，任一节点 v 所对应子树 subtree(v) 的高度，亦称作该节点的高度，记作 height(v)。特别地，全树的高度亦即其根节点 r 的高度，height(T) = height(r)。 ","date":"2022-04-05","objectID":"/5.1-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E8%A1%A8%E7%A4%BA/:1:1","series":null,"tags":["二叉树"],"title":"5.1 二叉树及其表示","uri":"/5.1-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E8%A1%A8%E7%A4%BA/#511-树"},{"categories":["数据结构"],"content":"5.1.1 树有根树从图论的角度看，树等价于连通无环图。因此与一般的图相同，树也由一组顶点（vertex） 以及联接与其间的若干条边（edge） 组成。 在计算机科学中，往往还会在此基础上，再指定某一特定顶点，并称之为根（root）。 在指定根节点之后，我们也称之为有根树（rooted tree）。 此时，从程序实现的角度，我们也更多地将顶点称作节点（node）。 深度与层次由树的连通性，每一节点与根之间都有一条路径相联；而根据树的无环性，由根通往每个节点的路径必然唯一。 因此如图5.1所示，沿每个节点 v到根 r 的唯一通路所经过边的数目，称作 v 的深度（depth），记作 depth(v)。 依据深度排序，可对所有节点做分层归类。特别地，约定根节点的深度 depth(r) = 0，故属于第0层。 祖先、后代与子树任一节点 v 在通往树根沿途所经过的每个节点都是其祖先（ancestor），v 是它们的后代（descendant）。 特别地，v 的祖先/后代包括其本身，而v本身以外的祖先/后代称作真祖先（proper ancestor）/ 真后代（proper descendant）。 节点 v 历代祖先的层次，自下而上以 1 为单位逐层递减；在每一层次上，v 的祖先至多一个。 特别地，若节点 u 是 v 的祖先且恰好比 v 高出一层， 则称 u 是 v 的父亲（parent），v 是 u 的孩子（child）。 v 的孩子总数，称作其度数或度（degree），记作 deg(v)。无孩子的节点称作叶节点（leaf），包括根在内的其余节点皆为内部节点（internal node）。 v 所有的后代及其之间的联边称作子树（subtree），记作 subtree(v)。 ![[有根树的逻辑结构.png]] 高度树 T 中所有节点[[5.1 二叉树及其表示#深度与层次|深度]]的最大值称作该树的高度（height），记作height(T)。 特别地，本书约定，仅含单个节点的树高度为0，空树高度为-1。 推而广之，任一节点 v 所对应子树 subtree(v) 的高度，亦称作该节点的高度，记作 height(v)。特别地，全树的高度亦即其根节点 r 的高度，height(T) = height(r)。 ","date":"2022-04-05","objectID":"/5.1-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E8%A1%A8%E7%A4%BA/:1:1","series":null,"tags":["二叉树"],"title":"5.1 二叉树及其表示","uri":"/5.1-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E8%A1%A8%E7%A4%BA/#有根树"},{"categories":["数据结构"],"content":"5.1.1 树有根树从图论的角度看，树等价于连通无环图。因此与一般的图相同，树也由一组顶点（vertex） 以及联接与其间的若干条边（edge） 组成。 在计算机科学中，往往还会在此基础上，再指定某一特定顶点，并称之为根（root）。 在指定根节点之后，我们也称之为有根树（rooted tree）。 此时，从程序实现的角度，我们也更多地将顶点称作节点（node）。 深度与层次由树的连通性，每一节点与根之间都有一条路径相联；而根据树的无环性，由根通往每个节点的路径必然唯一。 因此如图5.1所示，沿每个节点 v到根 r 的唯一通路所经过边的数目，称作 v 的深度（depth），记作 depth(v)。 依据深度排序，可对所有节点做分层归类。特别地，约定根节点的深度 depth(r) = 0，故属于第0层。 祖先、后代与子树任一节点 v 在通往树根沿途所经过的每个节点都是其祖先（ancestor），v 是它们的后代（descendant）。 特别地，v 的祖先/后代包括其本身，而v本身以外的祖先/后代称作真祖先（proper ancestor）/ 真后代（proper descendant）。 节点 v 历代祖先的层次，自下而上以 1 为单位逐层递减；在每一层次上，v 的祖先至多一个。 特别地，若节点 u 是 v 的祖先且恰好比 v 高出一层， 则称 u 是 v 的父亲（parent），v 是 u 的孩子（child）。 v 的孩子总数，称作其度数或度（degree），记作 deg(v)。无孩子的节点称作叶节点（leaf），包括根在内的其余节点皆为内部节点（internal node）。 v 所有的后代及其之间的联边称作子树（subtree），记作 subtree(v)。 ![[有根树的逻辑结构.png]] 高度树 T 中所有节点[[5.1 二叉树及其表示#深度与层次|深度]]的最大值称作该树的高度（height），记作height(T)。 特别地，本书约定，仅含单个节点的树高度为0，空树高度为-1。 推而广之，任一节点 v 所对应子树 subtree(v) 的高度，亦称作该节点的高度，记作 height(v)。特别地，全树的高度亦即其根节点 r 的高度，height(T) = height(r)。 ","date":"2022-04-05","objectID":"/5.1-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E8%A1%A8%E7%A4%BA/:1:1","series":null,"tags":["二叉树"],"title":"5.1 二叉树及其表示","uri":"/5.1-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E8%A1%A8%E7%A4%BA/#深度与层次"},{"categories":["数据结构"],"content":"5.1.1 树有根树从图论的角度看，树等价于连通无环图。因此与一般的图相同，树也由一组顶点（vertex） 以及联接与其间的若干条边（edge） 组成。 在计算机科学中，往往还会在此基础上，再指定某一特定顶点，并称之为根（root）。 在指定根节点之后，我们也称之为有根树（rooted tree）。 此时，从程序实现的角度，我们也更多地将顶点称作节点（node）。 深度与层次由树的连通性，每一节点与根之间都有一条路径相联；而根据树的无环性，由根通往每个节点的路径必然唯一。 因此如图5.1所示，沿每个节点 v到根 r 的唯一通路所经过边的数目，称作 v 的深度（depth），记作 depth(v)。 依据深度排序，可对所有节点做分层归类。特别地，约定根节点的深度 depth(r) = 0，故属于第0层。 祖先、后代与子树任一节点 v 在通往树根沿途所经过的每个节点都是其祖先（ancestor），v 是它们的后代（descendant）。 特别地，v 的祖先/后代包括其本身，而v本身以外的祖先/后代称作真祖先（proper ancestor）/ 真后代（proper descendant）。 节点 v 历代祖先的层次，自下而上以 1 为单位逐层递减；在每一层次上，v 的祖先至多一个。 特别地，若节点 u 是 v 的祖先且恰好比 v 高出一层， 则称 u 是 v 的父亲（parent），v 是 u 的孩子（child）。 v 的孩子总数，称作其度数或度（degree），记作 deg(v)。无孩子的节点称作叶节点（leaf），包括根在内的其余节点皆为内部节点（internal node）。 v 所有的后代及其之间的联边称作子树（subtree），记作 subtree(v)。 ![[有根树的逻辑结构.png]] 高度树 T 中所有节点[[5.1 二叉树及其表示#深度与层次|深度]]的最大值称作该树的高度（height），记作height(T)。 特别地，本书约定，仅含单个节点的树高度为0，空树高度为-1。 推而广之，任一节点 v 所对应子树 subtree(v) 的高度，亦称作该节点的高度，记作 height(v)。特别地，全树的高度亦即其根节点 r 的高度，height(T) = height(r)。 ","date":"2022-04-05","objectID":"/5.1-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E8%A1%A8%E7%A4%BA/:1:1","series":null,"tags":["二叉树"],"title":"5.1 二叉树及其表示","uri":"/5.1-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E8%A1%A8%E7%A4%BA/#祖先后代与子树"},{"categories":["数据结构"],"content":"5.1.1 树有根树从图论的角度看，树等价于连通无环图。因此与一般的图相同，树也由一组顶点（vertex） 以及联接与其间的若干条边（edge） 组成。 在计算机科学中，往往还会在此基础上，再指定某一特定顶点，并称之为根（root）。 在指定根节点之后，我们也称之为有根树（rooted tree）。 此时，从程序实现的角度，我们也更多地将顶点称作节点（node）。 深度与层次由树的连通性，每一节点与根之间都有一条路径相联；而根据树的无环性，由根通往每个节点的路径必然唯一。 因此如图5.1所示，沿每个节点 v到根 r 的唯一通路所经过边的数目，称作 v 的深度（depth），记作 depth(v)。 依据深度排序，可对所有节点做分层归类。特别地，约定根节点的深度 depth(r) = 0，故属于第0层。 祖先、后代与子树任一节点 v 在通往树根沿途所经过的每个节点都是其祖先（ancestor），v 是它们的后代（descendant）。 特别地，v 的祖先/后代包括其本身，而v本身以外的祖先/后代称作真祖先（proper ancestor）/ 真后代（proper descendant）。 节点 v 历代祖先的层次，自下而上以 1 为单位逐层递减；在每一层次上，v 的祖先至多一个。 特别地，若节点 u 是 v 的祖先且恰好比 v 高出一层， 则称 u 是 v 的父亲（parent），v 是 u 的孩子（child）。 v 的孩子总数，称作其度数或度（degree），记作 deg(v)。无孩子的节点称作叶节点（leaf），包括根在内的其余节点皆为内部节点（internal node）。 v 所有的后代及其之间的联边称作子树（subtree），记作 subtree(v)。 ![[有根树的逻辑结构.png]] 高度树 T 中所有节点[[5.1 二叉树及其表示#深度与层次|深度]]的最大值称作该树的高度（height），记作height(T)。 特别地，本书约定，仅含单个节点的树高度为0，空树高度为-1。 推而广之，任一节点 v 所对应子树 subtree(v) 的高度，亦称作该节点的高度，记作 height(v)。特别地，全树的高度亦即其根节点 r 的高度，height(T) = height(r)。 ","date":"2022-04-05","objectID":"/5.1-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E8%A1%A8%E7%A4%BA/:1:1","series":null,"tags":["二叉树"],"title":"5.1 二叉树及其表示","uri":"/5.1-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E8%A1%A8%E7%A4%BA/#高度"},{"categories":["数据结构"],"content":"5.1.2 二叉树![[Pasted image 20220405161653.png]] 如图5.2所示，二叉树（binary tree）中每个节点的度数均不超过2。 因此在二叉树中，同一父节点的孩子都可以左、右相互区分——此时，亦称作有序二叉树（ordered binary tree）。本书所提到的二叉树，默认地都是有序的。 ","date":"2022-04-05","objectID":"/5.1-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E8%A1%A8%E7%A4%BA/:1:2","series":null,"tags":["二叉树"],"title":"5.1 二叉树及其表示","uri":"/5.1-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E8%A1%A8%E7%A4%BA/#512-二叉树"},{"categories":["数据结构"],"content":"5.1.3 多叉树一般地，树中各节点的孩子数目并不确定。每个节点的孩子均不超过 k 个的有根树，称作 k 叉树（k-ary tree）。 父节点在多叉树中，根节点以外的任一节点有且仅有一个父节点。 将各节点组织为向量或列表，其中每个元素除保存节点本身的信息（data）外，还需要保存父节点（parent）的秩或位置。可为树根指定一个虚构的父节点 -1 或NULL，以便统一判断。 ![[Pasted image 20220405162142.png]] 所有向量或列表所占的空间总量为 O(n)，线性正比于节点总数 n。 时间方面，仅需常数时间，即可确定任一节点的父节点； 但反过来，孩子节点的查找却不得不花费 O(n) 时间访遍所有节点。 孩子节点若注重孩子节点的快速定位，可如图5.4所示，令各节点将其所有的孩子组织为一个向量或列表。如此，对于拥有 r 个孩子的节点，可在 O(r + 1) 时间内列举出其所有的孩子。 ![[Pasted image 20220405162446.png]] 父节点 + 孩子节点以上父节点表示法和孩子节点表示法各有所长，但也各有所短。为综合二者的优势，消除缺点，可如图5.5所示令各节点既记录父节点，同时也维护一个序列以保存所有孩子。 尽管如此可以高效地兼顾对父节点和孩子的定位，但在节点插入与删除操作频繁的场合，为动态地维护和更新树的拓扑结构，不得不反复地遍历和调整一些节点所对应的孩子序列。然而，向量和列表等线性结构的此类操作都需耗费大量时间，势必影响到整体的效率。 ![[Pasted image 20220405162533.png]] 有序多叉树 = 二叉树解决上述难题的方法之一，就是采用支持高效动态调整的二叉树结构。为此，必须首先建立起从多叉树到二叉树的某种转换关系，并使得在此转换的意义下，任一多叉树都等价于某棵二叉树。 当然，为了保证作为多叉树特例的二叉树有足够的能力表示任何一棵多叉树，我们只需给多叉树增加一项约束条件——同一节点的所有孩子之间必须具有某一线性次序。 仿照有序二叉树的定义，凡符合这一条件的多叉树也称作有序树（ordered tree）。通常根节点的分支可以按照字典序排列 长子 + 兄弟由图5.6(a)的实例可见，有序多叉树中任一非叶节点都有唯一的**“长子”** ，而且从该 “长子” 出发，可按照预先约定或指定的次序遍历所有孩子节点。因此可如图(b)所示，为每个节点设置两个指针，分别指向其 “长子” 和下一“ 兄弟” 。 ![[Pasted image 20220405163134.png]] 现在，若将这两个指针分别与二叉树节点的左、右孩子指针统一对应起来，则可进一步地将原有序多叉树转换为如图(c)所示的常规二叉树。 ","date":"2022-04-05","objectID":"/5.1-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E8%A1%A8%E7%A4%BA/:1:3","series":null,"tags":["二叉树"],"title":"5.1 二叉树及其表示","uri":"/5.1-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E8%A1%A8%E7%A4%BA/#513-多叉树"},{"categories":["数据结构"],"content":"5.1.3 多叉树一般地，树中各节点的孩子数目并不确定。每个节点的孩子均不超过 k 个的有根树，称作 k 叉树（k-ary tree）。 父节点在多叉树中，根节点以外的任一节点有且仅有一个父节点。 将各节点组织为向量或列表，其中每个元素除保存节点本身的信息（data）外，还需要保存父节点（parent）的秩或位置。可为树根指定一个虚构的父节点 -1 或NULL，以便统一判断。 ![[Pasted image 20220405162142.png]] 所有向量或列表所占的空间总量为 O(n)，线性正比于节点总数 n。 时间方面，仅需常数时间，即可确定任一节点的父节点； 但反过来，孩子节点的查找却不得不花费 O(n) 时间访遍所有节点。 孩子节点若注重孩子节点的快速定位，可如图5.4所示，令各节点将其所有的孩子组织为一个向量或列表。如此，对于拥有 r 个孩子的节点，可在 O(r + 1) 时间内列举出其所有的孩子。 ![[Pasted image 20220405162446.png]] 父节点 + 孩子节点以上父节点表示法和孩子节点表示法各有所长，但也各有所短。为综合二者的优势，消除缺点，可如图5.5所示令各节点既记录父节点，同时也维护一个序列以保存所有孩子。 尽管如此可以高效地兼顾对父节点和孩子的定位，但在节点插入与删除操作频繁的场合，为动态地维护和更新树的拓扑结构，不得不反复地遍历和调整一些节点所对应的孩子序列。然而，向量和列表等线性结构的此类操作都需耗费大量时间，势必影响到整体的效率。 ![[Pasted image 20220405162533.png]] 有序多叉树 = 二叉树解决上述难题的方法之一，就是采用支持高效动态调整的二叉树结构。为此，必须首先建立起从多叉树到二叉树的某种转换关系，并使得在此转换的意义下，任一多叉树都等价于某棵二叉树。 当然，为了保证作为多叉树特例的二叉树有足够的能力表示任何一棵多叉树，我们只需给多叉树增加一项约束条件——同一节点的所有孩子之间必须具有某一线性次序。 仿照有序二叉树的定义，凡符合这一条件的多叉树也称作有序树（ordered tree）。通常根节点的分支可以按照字典序排列 长子 + 兄弟由图5.6(a)的实例可见，有序多叉树中任一非叶节点都有唯一的**“长子”** ，而且从该 “长子” 出发，可按照预先约定或指定的次序遍历所有孩子节点。因此可如图(b)所示，为每个节点设置两个指针，分别指向其 “长子” 和下一“ 兄弟” 。 ![[Pasted image 20220405163134.png]] 现在，若将这两个指针分别与二叉树节点的左、右孩子指针统一对应起来，则可进一步地将原有序多叉树转换为如图(c)所示的常规二叉树。 ","date":"2022-04-05","objectID":"/5.1-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E8%A1%A8%E7%A4%BA/:1:3","series":null,"tags":["二叉树"],"title":"5.1 二叉树及其表示","uri":"/5.1-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E8%A1%A8%E7%A4%BA/#父节点"},{"categories":["数据结构"],"content":"5.1.3 多叉树一般地，树中各节点的孩子数目并不确定。每个节点的孩子均不超过 k 个的有根树，称作 k 叉树（k-ary tree）。 父节点在多叉树中，根节点以外的任一节点有且仅有一个父节点。 将各节点组织为向量或列表，其中每个元素除保存节点本身的信息（data）外，还需要保存父节点（parent）的秩或位置。可为树根指定一个虚构的父节点 -1 或NULL，以便统一判断。 ![[Pasted image 20220405162142.png]] 所有向量或列表所占的空间总量为 O(n)，线性正比于节点总数 n。 时间方面，仅需常数时间，即可确定任一节点的父节点； 但反过来，孩子节点的查找却不得不花费 O(n) 时间访遍所有节点。 孩子节点若注重孩子节点的快速定位，可如图5.4所示，令各节点将其所有的孩子组织为一个向量或列表。如此，对于拥有 r 个孩子的节点，可在 O(r + 1) 时间内列举出其所有的孩子。 ![[Pasted image 20220405162446.png]] 父节点 + 孩子节点以上父节点表示法和孩子节点表示法各有所长，但也各有所短。为综合二者的优势，消除缺点，可如图5.5所示令各节点既记录父节点，同时也维护一个序列以保存所有孩子。 尽管如此可以高效地兼顾对父节点和孩子的定位，但在节点插入与删除操作频繁的场合，为动态地维护和更新树的拓扑结构，不得不反复地遍历和调整一些节点所对应的孩子序列。然而，向量和列表等线性结构的此类操作都需耗费大量时间，势必影响到整体的效率。 ![[Pasted image 20220405162533.png]] 有序多叉树 = 二叉树解决上述难题的方法之一，就是采用支持高效动态调整的二叉树结构。为此，必须首先建立起从多叉树到二叉树的某种转换关系，并使得在此转换的意义下，任一多叉树都等价于某棵二叉树。 当然，为了保证作为多叉树特例的二叉树有足够的能力表示任何一棵多叉树，我们只需给多叉树增加一项约束条件——同一节点的所有孩子之间必须具有某一线性次序。 仿照有序二叉树的定义，凡符合这一条件的多叉树也称作有序树（ordered tree）。通常根节点的分支可以按照字典序排列 长子 + 兄弟由图5.6(a)的实例可见，有序多叉树中任一非叶节点都有唯一的**“长子”** ，而且从该 “长子” 出发，可按照预先约定或指定的次序遍历所有孩子节点。因此可如图(b)所示，为每个节点设置两个指针，分别指向其 “长子” 和下一“ 兄弟” 。 ![[Pasted image 20220405163134.png]] 现在，若将这两个指针分别与二叉树节点的左、右孩子指针统一对应起来，则可进一步地将原有序多叉树转换为如图(c)所示的常规二叉树。 ","date":"2022-04-05","objectID":"/5.1-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E8%A1%A8%E7%A4%BA/:1:3","series":null,"tags":["二叉树"],"title":"5.1 二叉树及其表示","uri":"/5.1-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E8%A1%A8%E7%A4%BA/#孩子节点"},{"categories":["数据结构"],"content":"5.1.3 多叉树一般地，树中各节点的孩子数目并不确定。每个节点的孩子均不超过 k 个的有根树，称作 k 叉树（k-ary tree）。 父节点在多叉树中，根节点以外的任一节点有且仅有一个父节点。 将各节点组织为向量或列表，其中每个元素除保存节点本身的信息（data）外，还需要保存父节点（parent）的秩或位置。可为树根指定一个虚构的父节点 -1 或NULL，以便统一判断。 ![[Pasted image 20220405162142.png]] 所有向量或列表所占的空间总量为 O(n)，线性正比于节点总数 n。 时间方面，仅需常数时间，即可确定任一节点的父节点； 但反过来，孩子节点的查找却不得不花费 O(n) 时间访遍所有节点。 孩子节点若注重孩子节点的快速定位，可如图5.4所示，令各节点将其所有的孩子组织为一个向量或列表。如此，对于拥有 r 个孩子的节点，可在 O(r + 1) 时间内列举出其所有的孩子。 ![[Pasted image 20220405162446.png]] 父节点 + 孩子节点以上父节点表示法和孩子节点表示法各有所长，但也各有所短。为综合二者的优势，消除缺点，可如图5.5所示令各节点既记录父节点，同时也维护一个序列以保存所有孩子。 尽管如此可以高效地兼顾对父节点和孩子的定位，但在节点插入与删除操作频繁的场合，为动态地维护和更新树的拓扑结构，不得不反复地遍历和调整一些节点所对应的孩子序列。然而，向量和列表等线性结构的此类操作都需耗费大量时间，势必影响到整体的效率。 ![[Pasted image 20220405162533.png]] 有序多叉树 = 二叉树解决上述难题的方法之一，就是采用支持高效动态调整的二叉树结构。为此，必须首先建立起从多叉树到二叉树的某种转换关系，并使得在此转换的意义下，任一多叉树都等价于某棵二叉树。 当然，为了保证作为多叉树特例的二叉树有足够的能力表示任何一棵多叉树，我们只需给多叉树增加一项约束条件——同一节点的所有孩子之间必须具有某一线性次序。 仿照有序二叉树的定义，凡符合这一条件的多叉树也称作有序树（ordered tree）。通常根节点的分支可以按照字典序排列 长子 + 兄弟由图5.6(a)的实例可见，有序多叉树中任一非叶节点都有唯一的**“长子”** ，而且从该 “长子” 出发，可按照预先约定或指定的次序遍历所有孩子节点。因此可如图(b)所示，为每个节点设置两个指针，分别指向其 “长子” 和下一“ 兄弟” 。 ![[Pasted image 20220405163134.png]] 现在，若将这两个指针分别与二叉树节点的左、右孩子指针统一对应起来，则可进一步地将原有序多叉树转换为如图(c)所示的常规二叉树。 ","date":"2022-04-05","objectID":"/5.1-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E8%A1%A8%E7%A4%BA/:1:3","series":null,"tags":["二叉树"],"title":"5.1 二叉树及其表示","uri":"/5.1-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E8%A1%A8%E7%A4%BA/#父节点--孩子节点"},{"categories":["数据结构"],"content":"5.1.3 多叉树一般地，树中各节点的孩子数目并不确定。每个节点的孩子均不超过 k 个的有根树，称作 k 叉树（k-ary tree）。 父节点在多叉树中，根节点以外的任一节点有且仅有一个父节点。 将各节点组织为向量或列表，其中每个元素除保存节点本身的信息（data）外，还需要保存父节点（parent）的秩或位置。可为树根指定一个虚构的父节点 -1 或NULL，以便统一判断。 ![[Pasted image 20220405162142.png]] 所有向量或列表所占的空间总量为 O(n)，线性正比于节点总数 n。 时间方面，仅需常数时间，即可确定任一节点的父节点； 但反过来，孩子节点的查找却不得不花费 O(n) 时间访遍所有节点。 孩子节点若注重孩子节点的快速定位，可如图5.4所示，令各节点将其所有的孩子组织为一个向量或列表。如此，对于拥有 r 个孩子的节点，可在 O(r + 1) 时间内列举出其所有的孩子。 ![[Pasted image 20220405162446.png]] 父节点 + 孩子节点以上父节点表示法和孩子节点表示法各有所长，但也各有所短。为综合二者的优势，消除缺点，可如图5.5所示令各节点既记录父节点，同时也维护一个序列以保存所有孩子。 尽管如此可以高效地兼顾对父节点和孩子的定位，但在节点插入与删除操作频繁的场合，为动态地维护和更新树的拓扑结构，不得不反复地遍历和调整一些节点所对应的孩子序列。然而，向量和列表等线性结构的此类操作都需耗费大量时间，势必影响到整体的效率。 ![[Pasted image 20220405162533.png]] 有序多叉树 = 二叉树解决上述难题的方法之一，就是采用支持高效动态调整的二叉树结构。为此，必须首先建立起从多叉树到二叉树的某种转换关系，并使得在此转换的意义下，任一多叉树都等价于某棵二叉树。 当然，为了保证作为多叉树特例的二叉树有足够的能力表示任何一棵多叉树，我们只需给多叉树增加一项约束条件——同一节点的所有孩子之间必须具有某一线性次序。 仿照有序二叉树的定义，凡符合这一条件的多叉树也称作有序树（ordered tree）。通常根节点的分支可以按照字典序排列 长子 + 兄弟由图5.6(a)的实例可见，有序多叉树中任一非叶节点都有唯一的**“长子”** ，而且从该 “长子” 出发，可按照预先约定或指定的次序遍历所有孩子节点。因此可如图(b)所示，为每个节点设置两个指针，分别指向其 “长子” 和下一“ 兄弟” 。 ![[Pasted image 20220405163134.png]] 现在，若将这两个指针分别与二叉树节点的左、右孩子指针统一对应起来，则可进一步地将原有序多叉树转换为如图(c)所示的常规二叉树。 ","date":"2022-04-05","objectID":"/5.1-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E8%A1%A8%E7%A4%BA/:1:3","series":null,"tags":["二叉树"],"title":"5.1 二叉树及其表示","uri":"/5.1-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E8%A1%A8%E7%A4%BA/#有序多叉树--二叉树"},{"categories":["数据结构"],"content":"5.1.3 多叉树一般地，树中各节点的孩子数目并不确定。每个节点的孩子均不超过 k 个的有根树，称作 k 叉树（k-ary tree）。 父节点在多叉树中，根节点以外的任一节点有且仅有一个父节点。 将各节点组织为向量或列表，其中每个元素除保存节点本身的信息（data）外，还需要保存父节点（parent）的秩或位置。可为树根指定一个虚构的父节点 -1 或NULL，以便统一判断。 ![[Pasted image 20220405162142.png]] 所有向量或列表所占的空间总量为 O(n)，线性正比于节点总数 n。 时间方面，仅需常数时间，即可确定任一节点的父节点； 但反过来，孩子节点的查找却不得不花费 O(n) 时间访遍所有节点。 孩子节点若注重孩子节点的快速定位，可如图5.4所示，令各节点将其所有的孩子组织为一个向量或列表。如此，对于拥有 r 个孩子的节点，可在 O(r + 1) 时间内列举出其所有的孩子。 ![[Pasted image 20220405162446.png]] 父节点 + 孩子节点以上父节点表示法和孩子节点表示法各有所长，但也各有所短。为综合二者的优势，消除缺点，可如图5.5所示令各节点既记录父节点，同时也维护一个序列以保存所有孩子。 尽管如此可以高效地兼顾对父节点和孩子的定位，但在节点插入与删除操作频繁的场合，为动态地维护和更新树的拓扑结构，不得不反复地遍历和调整一些节点所对应的孩子序列。然而，向量和列表等线性结构的此类操作都需耗费大量时间，势必影响到整体的效率。 ![[Pasted image 20220405162533.png]] 有序多叉树 = 二叉树解决上述难题的方法之一，就是采用支持高效动态调整的二叉树结构。为此，必须首先建立起从多叉树到二叉树的某种转换关系，并使得在此转换的意义下，任一多叉树都等价于某棵二叉树。 当然，为了保证作为多叉树特例的二叉树有足够的能力表示任何一棵多叉树，我们只需给多叉树增加一项约束条件——同一节点的所有孩子之间必须具有某一线性次序。 仿照有序二叉树的定义，凡符合这一条件的多叉树也称作有序树（ordered tree）。通常根节点的分支可以按照字典序排列 长子 + 兄弟由图5.6(a)的实例可见，有序多叉树中任一非叶节点都有唯一的**“长子”** ，而且从该 “长子” 出发，可按照预先约定或指定的次序遍历所有孩子节点。因此可如图(b)所示，为每个节点设置两个指针，分别指向其 “长子” 和下一“ 兄弟” 。 ![[Pasted image 20220405163134.png]] 现在，若将这两个指针分别与二叉树节点的左、右孩子指针统一对应起来，则可进一步地将原有序多叉树转换为如图(c)所示的常规二叉树。 ","date":"2022-04-05","objectID":"/5.1-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E8%A1%A8%E7%A4%BA/:1:3","series":null,"tags":["二叉树"],"title":"5.1 二叉树及其表示","uri":"/5.1-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E8%A1%A8%E7%A4%BA/#长子--兄弟"},{"categories":["数据结构"],"content":"二叉树有序有根树 = 二叉树 Binary Tree：节点度数不超过 2 孩子（子树）可以左右区分（有序） lc() ~ lSubtree() rc() ~ rSubtree() 深度为 k 的二叉树，至多有 2^k个节点 n 个节点，高为 h 的二叉树满足 h + 1 \u003c= n \u003c= 2^(h+1) -1 特殊情况： n = h + 1：退化为一条单链 n = 2^(h+1) - 1 ：为满二叉树 基数 设度数为 0、1、2 的节点各有n0、n1、n2个 边数 e = n - 1 = n1 + 2 * n2 1/2 度节点对应于 1/2 条入边 叶节点树 n0 = n2 + 1 n1 与 n0 无关：h = 0 时，1 = 0 + 1；此后，n0与n2同步递增 节点数 n = n0 + n1 + n2 = 1 + n1 + 2n2 当 n1 = 0 时，有 e = 2 * n2 和 n0 = n2 + 1 = (n + 1) / 2 此时，节点数为偶数，不含单分支节点 ![[Pasted image 20220408085600.png]] ","date":"2022-04-05","objectID":"/5.1-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E8%A1%A8%E7%A4%BA/:1:4","series":null,"tags":["二叉树"],"title":"5.1 二叉树及其表示","uri":"/5.1-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E8%A1%A8%E7%A4%BA/#二叉树"},{"categories":["数据结构"],"content":"二叉树有序有根树 = 二叉树 Binary Tree：节点度数不超过 2 孩子（子树）可以左右区分（有序） lc() ~ lSubtree() rc() ~ rSubtree() 深度为 k 的二叉树，至多有 2^k个节点 n 个节点，高为 h 的二叉树满足 h + 1 ","date":"2022-04-05","objectID":"/5.1-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E8%A1%A8%E7%A4%BA/:1:4","series":null,"tags":["二叉树"],"title":"5.1 二叉树及其表示","uri":"/5.1-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E8%A1%A8%E7%A4%BA/#基数"},{"categories":["数据结构"],"content":"一篇图解树状数组Loading Question… - 力扣（LeetCode） class NumArray { // 累加和 int[] tree; // 更新后数组 int[] nums; public NumArray(int[] nums) { // 原数组长度+1, +1的原因是计算lowbit时,使用下标0会进入死循环 this.sums = new int[nums.length + 1]; this.nums = nums; for (int i = 0; i \u003c nums.length; i++) { // 初始化累加和数组 insert(i, nums[i]); } } /** * 插入数字,初始化 */ private void insert(int index, int val) { // 下标+1 int x = index + 1; while (x \u003c sums.length) { sums[x] = sums[x] + val; x += lowBit(x); } } /** * 计算lowBit */ private int lowBit(int x) { return x \u0026 (-x); } /** * 更新数组以及累加和 */ public void update(int index, int val) { int x = index + 1; while (x \u003c sums.length) { // 减去之前nums[index]的值, 加上新的值 sums[x] = sums[x] - nums[index] + val; x += lowBit(x); } nums[index] = val; } public int sumRange(int left, int right) { return query(right + 1) - query(left); } /** * 查询树状数组 */ public int query(int x) { int s = 0; while (x != 0) { s += sums[x]; x -= lowBit(x); } return s; } } ","date":"2022-04-04","objectID":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:0:0","series":null,"tags":["树状数组"],"title":"树状数组","uri":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/#"},{"categories":["数据结构"],"content":"哈希表基础和实现 1、概念： 哈希表是通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做哈希函数，存放记录的数组称做哈希表。 底层使用数组实现： 数组+链表 数组+二叉树 数组中一般就是存放的单一的数据，而哈希表中存放的是一个键值对。 2、哈希冲突处理： 2.1 拉链法：将哈希值相同的元素构成一个链表，head放在散列表中。如果这里的链表长度大于等于8的话，链表就会转换成树结构，当然如果长度小于等于6的话，就会还原链表。以此来解决链表过长导致的性能问题。 2.2 开放寻址法：发生哈希冲突后，按照某一次序找到下一个空闲的单元，把冲突的元素放入。 **①线性探查法：**从发生冲突的单元开始探查，依次查看下一个单元是否为空，如果到了最后一个单元还是空，那么再从表首依次判断。如此执行直到碰到了空闲的单元或者已经探查完所有单元。如果有空位，冲突元素一定能插入。缺点:可能产生“聚集” **②平方探查法：**依次查找(cnt ± i² )% tablesize 位置，直到遇到空闲的单元；可能存在哈希表中仍然有“空位”，但是冲突元素无法插入的情况。 ③双散列函数探查法：定义两个散列函数分别为s1和s2，s1的算法和前面一致，s2取一个1～m-1之间并和m互为素数的数。s2作为步长。 更适合于造表前无法确定表长的情况；平均查找长度较短；适合结点规模较大时。 3、哈希扩容 当哈希表被占的位置比较多的时候，出现哈希冲突的概率也就变高了，所以很有必要进行扩容。 增长因子0.75：当它当前的容量占总容量的百分之七十五的时候就需要扩容了。 扩容过程：新创建一个数组是原来的2倍，然后把原数组的所有键值对都重新Hash一遍放到新的数组。因为数组扩大了，所以一般哈希函数也会有变化，这里的Hash也就是把之前的数据通过新的哈希函数计算出新的位置来存放。 4、哈希表最重要的是哈希函数： 哈希函数是一种映射关系，根据关键词key，经过一定函数关系得到元素的位置。一个哈希函数设计的足够好的话，就会减少哈希冲突的概率；极大的提升性能 常见的哈希函数构造方法： ①直接定址法：取关键字或关键字的某个线性函数值为散列地址。 H(key) = a*key + b，其中a和b为常数 ②除留余数法：取关键字被某个不大于散列表长度 m 的数 p 求余，得到的作为散列地址。 H(key) = key % p, p \u003c m ③叠加法：将关键字分为位数相同的几部分，然后取这几部分的叠加和（舍去进位）作为散列地址。 用于关键字位数较多，并且关键字中每一位上数字分布大致均匀。 ④随机数法：选择一个随机函数，把关键字的随机函数值作为它的哈希值。 通常当关键字的长度不等时用这种方法。 当关键字是整数类型时就可以用除留余数法；如果关键字是小数类型，选择随机数法会比较好。 参考文献：知识星球 时间：2021-09-07 标签： #算法 ","date":"2021-09-07","objectID":"/%E5%93%88%E5%B8%8C%E8%A1%A8/:0:0","series":null,"tags":["哈希表"],"title":"哈希表","uri":"/%E5%93%88%E5%B8%8C%E8%A1%A8/#"},{"categories":[],"content":"decltype 的作用是选择并返回操作数的数据类型，编译器分析表达式得到它的类型，但是不计算表达式的值 decltype(f()) sum = x; //sum的类型就是 f() 返回类型 decltype 使用的表达式是一个变量，则 decltype 返回该变量的类型（包括顶层 const 和引用） const int ci = 0, \u0026cj = ci; decltype(ci) x = 0; //x类型为 const int decltype(cj) y = x; //y类型为const int\u0026，y绑定到变量 x decltype(cj) z; //错误，z是一个引用，必须初始化 decltype 所用的表达式，如果加上一对括号，会得到引用类型 decltype((i)) d; //错误，d是int\u0026，必须初始化 decltype(i) e; //正确，e是一个未初始化的int ","date":"2021-08-30","objectID":"/decltype/:0:0","series":null,"tags":[],"title":"decltype","uri":"/decltype/#"},{"categories":[],"content":"auto和 decltype的区别主要有三个方面 第一，auto类型说明符用编译器计算变量的初始值来推断其类型，而 decltype虽然也让编译器分析表达式并得到它的类型，但是不实际计算表达式的值。 第二，编译器推断出来的auto类型有时候和初始值的类型并不完全一样，编译器会适当地改变结果类型使其更符合初始化规则。例如，auto一般会叙略掉顶层const,而把底层 const保留下来。与之相反， decltype会保留变量的顶层 const 第三，与auto不同， decltype的结果类型与表达式形式密切相关，如果变量名加上了一对括号，则得到的类型与不加括号时会有不同。如果 decltype使用的是一个不加括号的变量，则得到的结果就是该变量的类型；如果给变量加上了一层或多层括号，则编译器将推断得到引用类型。 ","date":"2021-08-30","objectID":"/decltype/:1:0","series":null,"tags":[],"title":"decltype","uri":"/decltype/#auto和-decltype的区别主要有三个方面"},{"categories":[],"content":"并查集的模板写法 class UnionFind { private: int cnt; // 连通分量 vector\u003cint\u003e parent; //x父节点为parent[x] public: UnionFind(int n) { cnt = n; parent.resize(n); // 开始时，每个节点是自己的父节点 for (int i = 0; i \u003c n; ++i) { parent[i] = i; } } // 连通两个节点 void connect(int p, int q) { int rootP = find(p); int rootQ = find(q); if (rootP == rootQ) return; parent[rootP] = rootQ; // 两个树的根节点合并 cnt--; } // 找到x的根节点 int find(int x) { while (parent[x] != x) { x = parent[x]; } return x; } //判断p, q是否连通 bool isConnected(int p, int q) { int rootP = find(p); int rootQ = find(q); return rootP == rootQ; } // 返回有多少连通分量 int count() { return cnt; } }; ","date":"0001-01-01","objectID":"/%E5%B9%B6%E6%9F%A5%E9%9B%862/:0:0","series":null,"tags":[],"title":"并查集2","uri":"/%E5%B9%B6%E6%9F%A5%E9%9B%862/#"}]
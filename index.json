[{"categories":["C++"],"content":"15.1 OOP：概述面向对象程序设计：核心思想是数据抽象、继承和动态绑定 数据抽象：类的接口与实现进行分离 继承：定义相似的类型并对相似关系建模 动态绑定：一定程度上忽略相似类型的区别，用统一的方式使用它们的对象 继承通过继承联系在一起的类构成一种层次关系，这种层次关系的根部有一个基类，其他类直接或间接由基类继承而来，继承得到的类称为派生类，继承的关系满足 is a ，即派生类本身也是一种基类的类型 对于基类中的某些函数，如果派生类需要自定义适合自身的版本，可以在基类中将这些函数声明为虚函数，派生类必须在内部对所有的虚函数重新声明 动态绑定使用动态绑定，可以用同一段代码处理基类和派生类的对象 比如说定义一个函数参入的形参是基类类型，然后打印处基类的成员，此时如果传入一个派生类也同样可以打印派生类的成员，这时调用的函数会根据实际传入的类型进行调用 动态绑定过程是在函数运行时由实参决定，有时也可以称为运行时绑定 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:1:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#151-oop概述"},{"categories":["C++"],"content":"15.1 OOP：概述面向对象程序设计：核心思想是数据抽象、继承和动态绑定 数据抽象：类的接口与实现进行分离 继承：定义相似的类型并对相似关系建模 动态绑定：一定程度上忽略相似类型的区别，用统一的方式使用它们的对象 继承通过继承联系在一起的类构成一种层次关系，这种层次关系的根部有一个基类，其他类直接或间接由基类继承而来，继承得到的类称为派生类，继承的关系满足 is a ，即派生类本身也是一种基类的类型 对于基类中的某些函数，如果派生类需要自定义适合自身的版本，可以在基类中将这些函数声明为虚函数，派生类必须在内部对所有的虚函数重新声明 动态绑定使用动态绑定，可以用同一段代码处理基类和派生类的对象 比如说定义一个函数参入的形参是基类类型，然后打印处基类的成员，此时如果传入一个派生类也同样可以打印派生类的成员，这时调用的函数会根据实际传入的类型进行调用 动态绑定过程是在函数运行时由实参决定，有时也可以称为运行时绑定 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:1:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#继承"},{"categories":["C++"],"content":"15.1 OOP：概述面向对象程序设计：核心思想是数据抽象、继承和动态绑定 数据抽象：类的接口与实现进行分离 继承：定义相似的类型并对相似关系建模 动态绑定：一定程度上忽略相似类型的区别，用统一的方式使用它们的对象 继承通过继承联系在一起的类构成一种层次关系，这种层次关系的根部有一个基类，其他类直接或间接由基类继承而来，继承得到的类称为派生类，继承的关系满足 is a ，即派生类本身也是一种基类的类型 对于基类中的某些函数，如果派生类需要自定义适合自身的版本，可以在基类中将这些函数声明为虚函数，派生类必须在内部对所有的虚函数重新声明 动态绑定使用动态绑定，可以用同一段代码处理基类和派生类的对象 比如说定义一个函数参入的形参是基类类型，然后打印处基类的成员，此时如果传入一个派生类也同样可以打印派生类的成员，这时调用的函数会根据实际传入的类型进行调用 动态绑定过程是在函数运行时由实参决定，有时也可以称为运行时绑定 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:1:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#动态绑定"},{"categories":["C++"],"content":"15.2 定义基类和派生类","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#152-定义基类和派生类"},{"categories":["C++"],"content":"15.2.1 定义基类首先定义 Quote 类： class Quote { public: Quote() = default;//默认构造函数 Quote(const std::string \u0026book, double sales_price) : bookNo(book), price(sales_price) {} std::string isbn() const { return bookNo; } //返回给定数量书籍的销售总额 //派生类负责改写并使用不同的折算算法 virtual double net_price(std::size_t n) const { return n * price; } virtual ~Quote() = default;//对析构函数进行动态绑定 private: std::string bookNo; //书籍ISBN号 protected: double price = 0.0; //普通状态下不打折的价格 } 基类通常定义一个虚析构函数，即使不执行任何操作 成员函数和继承派生类可以继承基类的成员，遇见 net_price 这种与类型相关的操作，派生类需要对这些操作提供自己新定义以覆盖从基类继承而来的定义 通常将基类希望派生类进行覆盖的函数定义为虚函数，当使用指针或者引用调用虚函数时，该调用将被动态绑定 访问控制和继承 派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权访问从基类继承而来的成员 派生类可以访问公有成员，但是不能访问私有成员 如果希望基类的派生类有权访问该成员，同时禁止其他用户访问，可以定义为受保护的（protected） ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:1","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#1521-定义基类"},{"categories":["C++"],"content":"15.2.1 定义基类首先定义 Quote 类： class Quote { public: Quote() = default;//默认构造函数 Quote(const std::string \u0026book, double sales_price) : bookNo(book), price(sales_price) {} std::string isbn() const { return bookNo; } //返回给定数量书籍的销售总额 //派生类负责改写并使用不同的折算算法 virtual double net_price(std::size_t n) const { return n * price; } virtual ~Quote() = default;//对析构函数进行动态绑定 private: std::string bookNo; //书籍ISBN号 protected: double price = 0.0; //普通状态下不打折的价格 } 基类通常定义一个虚析构函数，即使不执行任何操作 成员函数和继承派生类可以继承基类的成员，遇见 net_price 这种与类型相关的操作，派生类需要对这些操作提供自己新定义以覆盖从基类继承而来的定义 通常将基类希望派生类进行覆盖的函数定义为虚函数，当使用指针或者引用调用虚函数时，该调用将被动态绑定 访问控制和继承 派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权访问从基类继承而来的成员 派生类可以访问公有成员，但是不能访问私有成员 如果希望基类的派生类有权访问该成员，同时禁止其他用户访问，可以定义为受保护的（protected） ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:1","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#成员函数和继承"},{"categories":["C++"],"content":"15.2.1 定义基类首先定义 Quote 类： class Quote { public: Quote() = default;//默认构造函数 Quote(const std::string \u0026book, double sales_price) : bookNo(book), price(sales_price) {} std::string isbn() const { return bookNo; } //返回给定数量书籍的销售总额 //派生类负责改写并使用不同的折算算法 virtual double net_price(std::size_t n) const { return n * price; } virtual ~Quote() = default;//对析构函数进行动态绑定 private: std::string bookNo; //书籍ISBN号 protected: double price = 0.0; //普通状态下不打折的价格 } 基类通常定义一个虚析构函数，即使不执行任何操作 成员函数和继承派生类可以继承基类的成员，遇见 net_price 这种与类型相关的操作，派生类需要对这些操作提供自己新定义以覆盖从基类继承而来的定义 通常将基类希望派生类进行覆盖的函数定义为虚函数，当使用指针或者引用调用虚函数时，该调用将被动态绑定 访问控制和继承 派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权访问从基类继承而来的成员 派生类可以访问公有成员，但是不能访问私有成员 如果希望基类的派生类有权访问该成员，同时禁止其他用户访问，可以定义为受保护的（protected） ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:1","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#访问控制和继承"},{"categories":["C++"],"content":"15.2.2 定义派生类派生类必须通过类派生列表来指明它是从哪个基类继承而来的，类派生列表形式是：首先一个冒号，后面紧跟以逗号分隔的基类列表，每个基类前面可以有以下三种访问说明符之一：public、protected和private 定义 Bulk_quote 类 class Bulk_quote : public Quote { //Bulk_quote继承自Quote public: Bulk_quote() = default; Bulk_quote(const std::string\u0026, double, std::size_t, double); //覆盖基类的函数版本以实现基于大量购买的折扣政策 double net_price(std::size_t) const override; private: std::size_t min_qty = 0;//适用折扣政策的最低购买量 double discount = 0.0; //以小数表示折扣额 } Bulk_quote 类从基类 Quote 继承了 isbn 函数和 bookNo、price等数据成员，此外还定义了 net_price 的新版本，同时增加了两个新的数据成员 派生类中的虚函数派生类如果没有覆盖基类的虚函数，则派生类会直接继承基类中的版本 C++11新标准允许派生类显示注明它使用某个成员函数覆盖了它继承的虚函数，具体做法是在函数定义后面加个关键字 override 派生类对象即派生类向基类的类型转换派生类对象含有基类对应的成员部分，我们可以将派生类对象当成基类对象来使用，也能将基类指针或引用绑定到派生类对象的基类部分上 Quote item; //基类对象 Bulk_quote bulk; //派生类对象 Quote *p = \u0026item;//p指向Quote对象 p = \u0026bulk; //p指向bulk的Quote部分 Quote \u0026r = bulk; //r绑定到bulk的Quote部分 这种转换称为派生类到基类的类型转换 派生类构造函数派生类对象中含有从基类继承的成员，但是派生类不能直接初始化这些成员，派生类必须使用基类的构造函数来初始化它的基类部分 派生类在初始化成员时，可以通过构造函数初始化列表将实参传给基类构造函数，如下： //Bulk_quote的构造函数 Bulk_quote(const std::string \u0026book, double p, std::size_t qyt, double disc) : Quote(book, p), min_qty(qty), discount(disc) {} 派生类首先初始化基类部分，然后按照声明顺序初始化派生类的成员 派生类使用基类的成员派生类可以访问基类的公用成员和受保护的成员，例如： //如果达到购买书籍某个最低限度值，就可以享受折扣价格 double Bulk_quote::net_price(size_t cnt) const { if (cnt \u003e= min_qty) return cnt * (1 - discount) * price; else return cnt * price; } 继承与静态成员如果基类定义了一个静态成员，则整个继承体系中只存在该成员的唯一定义，不能派生出来多个各类，每一个静态成员只存在唯一的实例 静态成员遵循通用的访问控制规则，如果基类中定义为 private 的，派生类无权进行访问；如果静态成员可访问，既可以通过基类使用它，也可以通过派生类使用 class Base { public: static void statemen(); }; class Derived : public Base { void f(const Derived\u0026); }; void Derived::f(const Derived \u0026derived_obj) { Base::statemem(); //通过基类访问 Derived::statemem(); //通过派生类访问 derived_obj.statemem(); //通过基类对象访问 statemem(); //通过this对象访问 } 派生类的声明派生类声明和其他类差别不大，声明中包含类名但是不包含它的派生列表： class Bulk_quote : public Quote;//错误，派生列表不能出现在这 class Bulk_quote; //正确：声明派生类的正确方式 被用作基类的类如果想用某个类作为基类，则这个类必须已经定义而非仅仅声明： class Quote;//声明但未定义 //错误：Quote必须被定义 class Bulk_quote : public Quote {...}; 一个类不可以派生它本身 防止继承的发生如果不希望某一个类派生出其他类，或者不考虑将它作为一个基类，C++11新标准提供了一种防止继承发生的方法，即在类名后面跟一个关键字 final： class NoDrived final { /***/ }; class Bad : Noderived { /***/ }; //错误：NoDrived是final的 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#1522-定义派生类"},{"categories":["C++"],"content":"15.2.2 定义派生类派生类必须通过类派生列表来指明它是从哪个基类继承而来的，类派生列表形式是：首先一个冒号，后面紧跟以逗号分隔的基类列表，每个基类前面可以有以下三种访问说明符之一：public、protected和private 定义 Bulk_quote 类 class Bulk_quote : public Quote { //Bulk_quote继承自Quote public: Bulk_quote() = default; Bulk_quote(const std::string\u0026, double, std::size_t, double); //覆盖基类的函数版本以实现基于大量购买的折扣政策 double net_price(std::size_t) const override; private: std::size_t min_qty = 0;//适用折扣政策的最低购买量 double discount = 0.0; //以小数表示折扣额 } Bulk_quote 类从基类 Quote 继承了 isbn 函数和 bookNo、price等数据成员，此外还定义了 net_price 的新版本，同时增加了两个新的数据成员 派生类中的虚函数派生类如果没有覆盖基类的虚函数，则派生类会直接继承基类中的版本 C++11新标准允许派生类显示注明它使用某个成员函数覆盖了它继承的虚函数，具体做法是在函数定义后面加个关键字 override 派生类对象即派生类向基类的类型转换派生类对象含有基类对应的成员部分，我们可以将派生类对象当成基类对象来使用，也能将基类指针或引用绑定到派生类对象的基类部分上 Quote item; //基类对象 Bulk_quote bulk; //派生类对象 Quote *p = \u0026item;//p指向Quote对象 p = \u0026bulk; //p指向bulk的Quote部分 Quote \u0026r = bulk; //r绑定到bulk的Quote部分 这种转换称为派生类到基类的类型转换 派生类构造函数派生类对象中含有从基类继承的成员，但是派生类不能直接初始化这些成员，派生类必须使用基类的构造函数来初始化它的基类部分 派生类在初始化成员时，可以通过构造函数初始化列表将实参传给基类构造函数，如下： //Bulk_quote的构造函数 Bulk_quote(const std::string \u0026book, double p, std::size_t qyt, double disc) : Quote(book, p), min_qty(qty), discount(disc) {} 派生类首先初始化基类部分，然后按照声明顺序初始化派生类的成员 派生类使用基类的成员派生类可以访问基类的公用成员和受保护的成员，例如： //如果达到购买书籍某个最低限度值，就可以享受折扣价格 double Bulk_quote::net_price(size_t cnt) const { if (cnt = min_qty) return cnt * (1 - discount) * price; else return cnt * price; } 继承与静态成员如果基类定义了一个静态成员，则整个继承体系中只存在该成员的唯一定义，不能派生出来多个各类，每一个静态成员只存在唯一的实例 静态成员遵循通用的访问控制规则，如果基类中定义为 private 的，派生类无权进行访问；如果静态成员可访问，既可以通过基类使用它，也可以通过派生类使用 class Base { public: static void statemen(); }; class Derived : public Base { void f(const Derived\u0026); }; void Derived::f(const Derived \u0026derived_obj) { Base::statemem(); //通过基类访问 Derived::statemem(); //通过派生类访问 derived_obj.statemem(); //通过基类对象访问 statemem(); //通过this对象访问 } 派生类的声明派生类声明和其他类差别不大，声明中包含类名但是不包含它的派生列表： class Bulk_quote : public Quote;//错误，派生列表不能出现在这 class Bulk_quote; //正确：声明派生类的正确方式 被用作基类的类如果想用某个类作为基类，则这个类必须已经定义而非仅仅声明： class Quote;//声明但未定义 //错误：Quote必须被定义 class Bulk_quote : public Quote {...}; 一个类不可以派生它本身 防止继承的发生如果不希望某一个类派生出其他类，或者不考虑将它作为一个基类，C++11新标准提供了一种防止继承发生的方法，即在类名后面跟一个关键字 final： class NoDrived final { /***/ }; class Bad : Noderived { /***/ }; //错误：NoDrived是final的 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#派生类中的虚函数"},{"categories":["C++"],"content":"15.2.2 定义派生类派生类必须通过类派生列表来指明它是从哪个基类继承而来的，类派生列表形式是：首先一个冒号，后面紧跟以逗号分隔的基类列表，每个基类前面可以有以下三种访问说明符之一：public、protected和private 定义 Bulk_quote 类 class Bulk_quote : public Quote { //Bulk_quote继承自Quote public: Bulk_quote() = default; Bulk_quote(const std::string\u0026, double, std::size_t, double); //覆盖基类的函数版本以实现基于大量购买的折扣政策 double net_price(std::size_t) const override; private: std::size_t min_qty = 0;//适用折扣政策的最低购买量 double discount = 0.0; //以小数表示折扣额 } Bulk_quote 类从基类 Quote 继承了 isbn 函数和 bookNo、price等数据成员，此外还定义了 net_price 的新版本，同时增加了两个新的数据成员 派生类中的虚函数派生类如果没有覆盖基类的虚函数，则派生类会直接继承基类中的版本 C++11新标准允许派生类显示注明它使用某个成员函数覆盖了它继承的虚函数，具体做法是在函数定义后面加个关键字 override 派生类对象即派生类向基类的类型转换派生类对象含有基类对应的成员部分，我们可以将派生类对象当成基类对象来使用，也能将基类指针或引用绑定到派生类对象的基类部分上 Quote item; //基类对象 Bulk_quote bulk; //派生类对象 Quote *p = \u0026item;//p指向Quote对象 p = \u0026bulk; //p指向bulk的Quote部分 Quote \u0026r = bulk; //r绑定到bulk的Quote部分 这种转换称为派生类到基类的类型转换 派生类构造函数派生类对象中含有从基类继承的成员，但是派生类不能直接初始化这些成员，派生类必须使用基类的构造函数来初始化它的基类部分 派生类在初始化成员时，可以通过构造函数初始化列表将实参传给基类构造函数，如下： //Bulk_quote的构造函数 Bulk_quote(const std::string \u0026book, double p, std::size_t qyt, double disc) : Quote(book, p), min_qty(qty), discount(disc) {} 派生类首先初始化基类部分，然后按照声明顺序初始化派生类的成员 派生类使用基类的成员派生类可以访问基类的公用成员和受保护的成员，例如： //如果达到购买书籍某个最低限度值，就可以享受折扣价格 double Bulk_quote::net_price(size_t cnt) const { if (cnt = min_qty) return cnt * (1 - discount) * price; else return cnt * price; } 继承与静态成员如果基类定义了一个静态成员，则整个继承体系中只存在该成员的唯一定义，不能派生出来多个各类，每一个静态成员只存在唯一的实例 静态成员遵循通用的访问控制规则，如果基类中定义为 private 的，派生类无权进行访问；如果静态成员可访问，既可以通过基类使用它，也可以通过派生类使用 class Base { public: static void statemen(); }; class Derived : public Base { void f(const Derived\u0026); }; void Derived::f(const Derived \u0026derived_obj) { Base::statemem(); //通过基类访问 Derived::statemem(); //通过派生类访问 derived_obj.statemem(); //通过基类对象访问 statemem(); //通过this对象访问 } 派生类的声明派生类声明和其他类差别不大，声明中包含类名但是不包含它的派生列表： class Bulk_quote : public Quote;//错误，派生列表不能出现在这 class Bulk_quote; //正确：声明派生类的正确方式 被用作基类的类如果想用某个类作为基类，则这个类必须已经定义而非仅仅声明： class Quote;//声明但未定义 //错误：Quote必须被定义 class Bulk_quote : public Quote {...}; 一个类不可以派生它本身 防止继承的发生如果不希望某一个类派生出其他类，或者不考虑将它作为一个基类，C++11新标准提供了一种防止继承发生的方法，即在类名后面跟一个关键字 final： class NoDrived final { /***/ }; class Bad : Noderived { /***/ }; //错误：NoDrived是final的 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#派生类对象即派生类向基类的类型转换"},{"categories":["C++"],"content":"15.2.2 定义派生类派生类必须通过类派生列表来指明它是从哪个基类继承而来的，类派生列表形式是：首先一个冒号，后面紧跟以逗号分隔的基类列表，每个基类前面可以有以下三种访问说明符之一：public、protected和private 定义 Bulk_quote 类 class Bulk_quote : public Quote { //Bulk_quote继承自Quote public: Bulk_quote() = default; Bulk_quote(const std::string\u0026, double, std::size_t, double); //覆盖基类的函数版本以实现基于大量购买的折扣政策 double net_price(std::size_t) const override; private: std::size_t min_qty = 0;//适用折扣政策的最低购买量 double discount = 0.0; //以小数表示折扣额 } Bulk_quote 类从基类 Quote 继承了 isbn 函数和 bookNo、price等数据成员，此外还定义了 net_price 的新版本，同时增加了两个新的数据成员 派生类中的虚函数派生类如果没有覆盖基类的虚函数，则派生类会直接继承基类中的版本 C++11新标准允许派生类显示注明它使用某个成员函数覆盖了它继承的虚函数，具体做法是在函数定义后面加个关键字 override 派生类对象即派生类向基类的类型转换派生类对象含有基类对应的成员部分，我们可以将派生类对象当成基类对象来使用，也能将基类指针或引用绑定到派生类对象的基类部分上 Quote item; //基类对象 Bulk_quote bulk; //派生类对象 Quote *p = \u0026item;//p指向Quote对象 p = \u0026bulk; //p指向bulk的Quote部分 Quote \u0026r = bulk; //r绑定到bulk的Quote部分 这种转换称为派生类到基类的类型转换 派生类构造函数派生类对象中含有从基类继承的成员，但是派生类不能直接初始化这些成员，派生类必须使用基类的构造函数来初始化它的基类部分 派生类在初始化成员时，可以通过构造函数初始化列表将实参传给基类构造函数，如下： //Bulk_quote的构造函数 Bulk_quote(const std::string \u0026book, double p, std::size_t qyt, double disc) : Quote(book, p), min_qty(qty), discount(disc) {} 派生类首先初始化基类部分，然后按照声明顺序初始化派生类的成员 派生类使用基类的成员派生类可以访问基类的公用成员和受保护的成员，例如： //如果达到购买书籍某个最低限度值，就可以享受折扣价格 double Bulk_quote::net_price(size_t cnt) const { if (cnt = min_qty) return cnt * (1 - discount) * price; else return cnt * price; } 继承与静态成员如果基类定义了一个静态成员，则整个继承体系中只存在该成员的唯一定义，不能派生出来多个各类，每一个静态成员只存在唯一的实例 静态成员遵循通用的访问控制规则，如果基类中定义为 private 的，派生类无权进行访问；如果静态成员可访问，既可以通过基类使用它，也可以通过派生类使用 class Base { public: static void statemen(); }; class Derived : public Base { void f(const Derived\u0026); }; void Derived::f(const Derived \u0026derived_obj) { Base::statemem(); //通过基类访问 Derived::statemem(); //通过派生类访问 derived_obj.statemem(); //通过基类对象访问 statemem(); //通过this对象访问 } 派生类的声明派生类声明和其他类差别不大，声明中包含类名但是不包含它的派生列表： class Bulk_quote : public Quote;//错误，派生列表不能出现在这 class Bulk_quote; //正确：声明派生类的正确方式 被用作基类的类如果想用某个类作为基类，则这个类必须已经定义而非仅仅声明： class Quote;//声明但未定义 //错误：Quote必须被定义 class Bulk_quote : public Quote {...}; 一个类不可以派生它本身 防止继承的发生如果不希望某一个类派生出其他类，或者不考虑将它作为一个基类，C++11新标准提供了一种防止继承发生的方法，即在类名后面跟一个关键字 final： class NoDrived final { /***/ }; class Bad : Noderived { /***/ }; //错误：NoDrived是final的 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#派生类构造函数"},{"categories":["C++"],"content":"15.2.2 定义派生类派生类必须通过类派生列表来指明它是从哪个基类继承而来的，类派生列表形式是：首先一个冒号，后面紧跟以逗号分隔的基类列表，每个基类前面可以有以下三种访问说明符之一：public、protected和private 定义 Bulk_quote 类 class Bulk_quote : public Quote { //Bulk_quote继承自Quote public: Bulk_quote() = default; Bulk_quote(const std::string\u0026, double, std::size_t, double); //覆盖基类的函数版本以实现基于大量购买的折扣政策 double net_price(std::size_t) const override; private: std::size_t min_qty = 0;//适用折扣政策的最低购买量 double discount = 0.0; //以小数表示折扣额 } Bulk_quote 类从基类 Quote 继承了 isbn 函数和 bookNo、price等数据成员，此外还定义了 net_price 的新版本，同时增加了两个新的数据成员 派生类中的虚函数派生类如果没有覆盖基类的虚函数，则派生类会直接继承基类中的版本 C++11新标准允许派生类显示注明它使用某个成员函数覆盖了它继承的虚函数，具体做法是在函数定义后面加个关键字 override 派生类对象即派生类向基类的类型转换派生类对象含有基类对应的成员部分，我们可以将派生类对象当成基类对象来使用，也能将基类指针或引用绑定到派生类对象的基类部分上 Quote item; //基类对象 Bulk_quote bulk; //派生类对象 Quote *p = \u0026item;//p指向Quote对象 p = \u0026bulk; //p指向bulk的Quote部分 Quote \u0026r = bulk; //r绑定到bulk的Quote部分 这种转换称为派生类到基类的类型转换 派生类构造函数派生类对象中含有从基类继承的成员，但是派生类不能直接初始化这些成员，派生类必须使用基类的构造函数来初始化它的基类部分 派生类在初始化成员时，可以通过构造函数初始化列表将实参传给基类构造函数，如下： //Bulk_quote的构造函数 Bulk_quote(const std::string \u0026book, double p, std::size_t qyt, double disc) : Quote(book, p), min_qty(qty), discount(disc) {} 派生类首先初始化基类部分，然后按照声明顺序初始化派生类的成员 派生类使用基类的成员派生类可以访问基类的公用成员和受保护的成员，例如： //如果达到购买书籍某个最低限度值，就可以享受折扣价格 double Bulk_quote::net_price(size_t cnt) const { if (cnt = min_qty) return cnt * (1 - discount) * price; else return cnt * price; } 继承与静态成员如果基类定义了一个静态成员，则整个继承体系中只存在该成员的唯一定义，不能派生出来多个各类，每一个静态成员只存在唯一的实例 静态成员遵循通用的访问控制规则，如果基类中定义为 private 的，派生类无权进行访问；如果静态成员可访问，既可以通过基类使用它，也可以通过派生类使用 class Base { public: static void statemen(); }; class Derived : public Base { void f(const Derived\u0026); }; void Derived::f(const Derived \u0026derived_obj) { Base::statemem(); //通过基类访问 Derived::statemem(); //通过派生类访问 derived_obj.statemem(); //通过基类对象访问 statemem(); //通过this对象访问 } 派生类的声明派生类声明和其他类差别不大，声明中包含类名但是不包含它的派生列表： class Bulk_quote : public Quote;//错误，派生列表不能出现在这 class Bulk_quote; //正确：声明派生类的正确方式 被用作基类的类如果想用某个类作为基类，则这个类必须已经定义而非仅仅声明： class Quote;//声明但未定义 //错误：Quote必须被定义 class Bulk_quote : public Quote {...}; 一个类不可以派生它本身 防止继承的发生如果不希望某一个类派生出其他类，或者不考虑将它作为一个基类，C++11新标准提供了一种防止继承发生的方法，即在类名后面跟一个关键字 final： class NoDrived final { /***/ }; class Bad : Noderived { /***/ }; //错误：NoDrived是final的 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#派生类使用基类的成员"},{"categories":["C++"],"content":"15.2.2 定义派生类派生类必须通过类派生列表来指明它是从哪个基类继承而来的，类派生列表形式是：首先一个冒号，后面紧跟以逗号分隔的基类列表，每个基类前面可以有以下三种访问说明符之一：public、protected和private 定义 Bulk_quote 类 class Bulk_quote : public Quote { //Bulk_quote继承自Quote public: Bulk_quote() = default; Bulk_quote(const std::string\u0026, double, std::size_t, double); //覆盖基类的函数版本以实现基于大量购买的折扣政策 double net_price(std::size_t) const override; private: std::size_t min_qty = 0;//适用折扣政策的最低购买量 double discount = 0.0; //以小数表示折扣额 } Bulk_quote 类从基类 Quote 继承了 isbn 函数和 bookNo、price等数据成员，此外还定义了 net_price 的新版本，同时增加了两个新的数据成员 派生类中的虚函数派生类如果没有覆盖基类的虚函数，则派生类会直接继承基类中的版本 C++11新标准允许派生类显示注明它使用某个成员函数覆盖了它继承的虚函数，具体做法是在函数定义后面加个关键字 override 派生类对象即派生类向基类的类型转换派生类对象含有基类对应的成员部分，我们可以将派生类对象当成基类对象来使用，也能将基类指针或引用绑定到派生类对象的基类部分上 Quote item; //基类对象 Bulk_quote bulk; //派生类对象 Quote *p = \u0026item;//p指向Quote对象 p = \u0026bulk; //p指向bulk的Quote部分 Quote \u0026r = bulk; //r绑定到bulk的Quote部分 这种转换称为派生类到基类的类型转换 派生类构造函数派生类对象中含有从基类继承的成员，但是派生类不能直接初始化这些成员，派生类必须使用基类的构造函数来初始化它的基类部分 派生类在初始化成员时，可以通过构造函数初始化列表将实参传给基类构造函数，如下： //Bulk_quote的构造函数 Bulk_quote(const std::string \u0026book, double p, std::size_t qyt, double disc) : Quote(book, p), min_qty(qty), discount(disc) {} 派生类首先初始化基类部分，然后按照声明顺序初始化派生类的成员 派生类使用基类的成员派生类可以访问基类的公用成员和受保护的成员，例如： //如果达到购买书籍某个最低限度值，就可以享受折扣价格 double Bulk_quote::net_price(size_t cnt) const { if (cnt = min_qty) return cnt * (1 - discount) * price; else return cnt * price; } 继承与静态成员如果基类定义了一个静态成员，则整个继承体系中只存在该成员的唯一定义，不能派生出来多个各类，每一个静态成员只存在唯一的实例 静态成员遵循通用的访问控制规则，如果基类中定义为 private 的，派生类无权进行访问；如果静态成员可访问，既可以通过基类使用它，也可以通过派生类使用 class Base { public: static void statemen(); }; class Derived : public Base { void f(const Derived\u0026); }; void Derived::f(const Derived \u0026derived_obj) { Base::statemem(); //通过基类访问 Derived::statemem(); //通过派生类访问 derived_obj.statemem(); //通过基类对象访问 statemem(); //通过this对象访问 } 派生类的声明派生类声明和其他类差别不大，声明中包含类名但是不包含它的派生列表： class Bulk_quote : public Quote;//错误，派生列表不能出现在这 class Bulk_quote; //正确：声明派生类的正确方式 被用作基类的类如果想用某个类作为基类，则这个类必须已经定义而非仅仅声明： class Quote;//声明但未定义 //错误：Quote必须被定义 class Bulk_quote : public Quote {...}; 一个类不可以派生它本身 防止继承的发生如果不希望某一个类派生出其他类，或者不考虑将它作为一个基类，C++11新标准提供了一种防止继承发生的方法，即在类名后面跟一个关键字 final： class NoDrived final { /***/ }; class Bad : Noderived { /***/ }; //错误：NoDrived是final的 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#继承与静态成员"},{"categories":["C++"],"content":"15.2.2 定义派生类派生类必须通过类派生列表来指明它是从哪个基类继承而来的，类派生列表形式是：首先一个冒号，后面紧跟以逗号分隔的基类列表，每个基类前面可以有以下三种访问说明符之一：public、protected和private 定义 Bulk_quote 类 class Bulk_quote : public Quote { //Bulk_quote继承自Quote public: Bulk_quote() = default; Bulk_quote(const std::string\u0026, double, std::size_t, double); //覆盖基类的函数版本以实现基于大量购买的折扣政策 double net_price(std::size_t) const override; private: std::size_t min_qty = 0;//适用折扣政策的最低购买量 double discount = 0.0; //以小数表示折扣额 } Bulk_quote 类从基类 Quote 继承了 isbn 函数和 bookNo、price等数据成员，此外还定义了 net_price 的新版本，同时增加了两个新的数据成员 派生类中的虚函数派生类如果没有覆盖基类的虚函数，则派生类会直接继承基类中的版本 C++11新标准允许派生类显示注明它使用某个成员函数覆盖了它继承的虚函数，具体做法是在函数定义后面加个关键字 override 派生类对象即派生类向基类的类型转换派生类对象含有基类对应的成员部分，我们可以将派生类对象当成基类对象来使用，也能将基类指针或引用绑定到派生类对象的基类部分上 Quote item; //基类对象 Bulk_quote bulk; //派生类对象 Quote *p = \u0026item;//p指向Quote对象 p = \u0026bulk; //p指向bulk的Quote部分 Quote \u0026r = bulk; //r绑定到bulk的Quote部分 这种转换称为派生类到基类的类型转换 派生类构造函数派生类对象中含有从基类继承的成员，但是派生类不能直接初始化这些成员，派生类必须使用基类的构造函数来初始化它的基类部分 派生类在初始化成员时，可以通过构造函数初始化列表将实参传给基类构造函数，如下： //Bulk_quote的构造函数 Bulk_quote(const std::string \u0026book, double p, std::size_t qyt, double disc) : Quote(book, p), min_qty(qty), discount(disc) {} 派生类首先初始化基类部分，然后按照声明顺序初始化派生类的成员 派生类使用基类的成员派生类可以访问基类的公用成员和受保护的成员，例如： //如果达到购买书籍某个最低限度值，就可以享受折扣价格 double Bulk_quote::net_price(size_t cnt) const { if (cnt = min_qty) return cnt * (1 - discount) * price; else return cnt * price; } 继承与静态成员如果基类定义了一个静态成员，则整个继承体系中只存在该成员的唯一定义，不能派生出来多个各类，每一个静态成员只存在唯一的实例 静态成员遵循通用的访问控制规则，如果基类中定义为 private 的，派生类无权进行访问；如果静态成员可访问，既可以通过基类使用它，也可以通过派生类使用 class Base { public: static void statemen(); }; class Derived : public Base { void f(const Derived\u0026); }; void Derived::f(const Derived \u0026derived_obj) { Base::statemem(); //通过基类访问 Derived::statemem(); //通过派生类访问 derived_obj.statemem(); //通过基类对象访问 statemem(); //通过this对象访问 } 派生类的声明派生类声明和其他类差别不大，声明中包含类名但是不包含它的派生列表： class Bulk_quote : public Quote;//错误，派生列表不能出现在这 class Bulk_quote; //正确：声明派生类的正确方式 被用作基类的类如果想用某个类作为基类，则这个类必须已经定义而非仅仅声明： class Quote;//声明但未定义 //错误：Quote必须被定义 class Bulk_quote : public Quote {...}; 一个类不可以派生它本身 防止继承的发生如果不希望某一个类派生出其他类，或者不考虑将它作为一个基类，C++11新标准提供了一种防止继承发生的方法，即在类名后面跟一个关键字 final： class NoDrived final { /***/ }; class Bad : Noderived { /***/ }; //错误：NoDrived是final的 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#派生类的声明"},{"categories":["C++"],"content":"15.2.2 定义派生类派生类必须通过类派生列表来指明它是从哪个基类继承而来的，类派生列表形式是：首先一个冒号，后面紧跟以逗号分隔的基类列表，每个基类前面可以有以下三种访问说明符之一：public、protected和private 定义 Bulk_quote 类 class Bulk_quote : public Quote { //Bulk_quote继承自Quote public: Bulk_quote() = default; Bulk_quote(const std::string\u0026, double, std::size_t, double); //覆盖基类的函数版本以实现基于大量购买的折扣政策 double net_price(std::size_t) const override; private: std::size_t min_qty = 0;//适用折扣政策的最低购买量 double discount = 0.0; //以小数表示折扣额 } Bulk_quote 类从基类 Quote 继承了 isbn 函数和 bookNo、price等数据成员，此外还定义了 net_price 的新版本，同时增加了两个新的数据成员 派生类中的虚函数派生类如果没有覆盖基类的虚函数，则派生类会直接继承基类中的版本 C++11新标准允许派生类显示注明它使用某个成员函数覆盖了它继承的虚函数，具体做法是在函数定义后面加个关键字 override 派生类对象即派生类向基类的类型转换派生类对象含有基类对应的成员部分，我们可以将派生类对象当成基类对象来使用，也能将基类指针或引用绑定到派生类对象的基类部分上 Quote item; //基类对象 Bulk_quote bulk; //派生类对象 Quote *p = \u0026item;//p指向Quote对象 p = \u0026bulk; //p指向bulk的Quote部分 Quote \u0026r = bulk; //r绑定到bulk的Quote部分 这种转换称为派生类到基类的类型转换 派生类构造函数派生类对象中含有从基类继承的成员，但是派生类不能直接初始化这些成员，派生类必须使用基类的构造函数来初始化它的基类部分 派生类在初始化成员时，可以通过构造函数初始化列表将实参传给基类构造函数，如下： //Bulk_quote的构造函数 Bulk_quote(const std::string \u0026book, double p, std::size_t qyt, double disc) : Quote(book, p), min_qty(qty), discount(disc) {} 派生类首先初始化基类部分，然后按照声明顺序初始化派生类的成员 派生类使用基类的成员派生类可以访问基类的公用成员和受保护的成员，例如： //如果达到购买书籍某个最低限度值，就可以享受折扣价格 double Bulk_quote::net_price(size_t cnt) const { if (cnt = min_qty) return cnt * (1 - discount) * price; else return cnt * price; } 继承与静态成员如果基类定义了一个静态成员，则整个继承体系中只存在该成员的唯一定义，不能派生出来多个各类，每一个静态成员只存在唯一的实例 静态成员遵循通用的访问控制规则，如果基类中定义为 private 的，派生类无权进行访问；如果静态成员可访问，既可以通过基类使用它，也可以通过派生类使用 class Base { public: static void statemen(); }; class Derived : public Base { void f(const Derived\u0026); }; void Derived::f(const Derived \u0026derived_obj) { Base::statemem(); //通过基类访问 Derived::statemem(); //通过派生类访问 derived_obj.statemem(); //通过基类对象访问 statemem(); //通过this对象访问 } 派生类的声明派生类声明和其他类差别不大，声明中包含类名但是不包含它的派生列表： class Bulk_quote : public Quote;//错误，派生列表不能出现在这 class Bulk_quote; //正确：声明派生类的正确方式 被用作基类的类如果想用某个类作为基类，则这个类必须已经定义而非仅仅声明： class Quote;//声明但未定义 //错误：Quote必须被定义 class Bulk_quote : public Quote {...}; 一个类不可以派生它本身 防止继承的发生如果不希望某一个类派生出其他类，或者不考虑将它作为一个基类，C++11新标准提供了一种防止继承发生的方法，即在类名后面跟一个关键字 final： class NoDrived final { /***/ }; class Bad : Noderived { /***/ }; //错误：NoDrived是final的 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#被用作基类的类"},{"categories":["C++"],"content":"15.2.2 定义派生类派生类必须通过类派生列表来指明它是从哪个基类继承而来的，类派生列表形式是：首先一个冒号，后面紧跟以逗号分隔的基类列表，每个基类前面可以有以下三种访问说明符之一：public、protected和private 定义 Bulk_quote 类 class Bulk_quote : public Quote { //Bulk_quote继承自Quote public: Bulk_quote() = default; Bulk_quote(const std::string\u0026, double, std::size_t, double); //覆盖基类的函数版本以实现基于大量购买的折扣政策 double net_price(std::size_t) const override; private: std::size_t min_qty = 0;//适用折扣政策的最低购买量 double discount = 0.0; //以小数表示折扣额 } Bulk_quote 类从基类 Quote 继承了 isbn 函数和 bookNo、price等数据成员，此外还定义了 net_price 的新版本，同时增加了两个新的数据成员 派生类中的虚函数派生类如果没有覆盖基类的虚函数，则派生类会直接继承基类中的版本 C++11新标准允许派生类显示注明它使用某个成员函数覆盖了它继承的虚函数，具体做法是在函数定义后面加个关键字 override 派生类对象即派生类向基类的类型转换派生类对象含有基类对应的成员部分，我们可以将派生类对象当成基类对象来使用，也能将基类指针或引用绑定到派生类对象的基类部分上 Quote item; //基类对象 Bulk_quote bulk; //派生类对象 Quote *p = \u0026item;//p指向Quote对象 p = \u0026bulk; //p指向bulk的Quote部分 Quote \u0026r = bulk; //r绑定到bulk的Quote部分 这种转换称为派生类到基类的类型转换 派生类构造函数派生类对象中含有从基类继承的成员，但是派生类不能直接初始化这些成员，派生类必须使用基类的构造函数来初始化它的基类部分 派生类在初始化成员时，可以通过构造函数初始化列表将实参传给基类构造函数，如下： //Bulk_quote的构造函数 Bulk_quote(const std::string \u0026book, double p, std::size_t qyt, double disc) : Quote(book, p), min_qty(qty), discount(disc) {} 派生类首先初始化基类部分，然后按照声明顺序初始化派生类的成员 派生类使用基类的成员派生类可以访问基类的公用成员和受保护的成员，例如： //如果达到购买书籍某个最低限度值，就可以享受折扣价格 double Bulk_quote::net_price(size_t cnt) const { if (cnt = min_qty) return cnt * (1 - discount) * price; else return cnt * price; } 继承与静态成员如果基类定义了一个静态成员，则整个继承体系中只存在该成员的唯一定义，不能派生出来多个各类，每一个静态成员只存在唯一的实例 静态成员遵循通用的访问控制规则，如果基类中定义为 private 的，派生类无权进行访问；如果静态成员可访问，既可以通过基类使用它，也可以通过派生类使用 class Base { public: static void statemen(); }; class Derived : public Base { void f(const Derived\u0026); }; void Derived::f(const Derived \u0026derived_obj) { Base::statemem(); //通过基类访问 Derived::statemem(); //通过派生类访问 derived_obj.statemem(); //通过基类对象访问 statemem(); //通过this对象访问 } 派生类的声明派生类声明和其他类差别不大，声明中包含类名但是不包含它的派生列表： class Bulk_quote : public Quote;//错误，派生列表不能出现在这 class Bulk_quote; //正确：声明派生类的正确方式 被用作基类的类如果想用某个类作为基类，则这个类必须已经定义而非仅仅声明： class Quote;//声明但未定义 //错误：Quote必须被定义 class Bulk_quote : public Quote {...}; 一个类不可以派生它本身 防止继承的发生如果不希望某一个类派生出其他类，或者不考虑将它作为一个基类，C++11新标准提供了一种防止继承发生的方法，即在类名后面跟一个关键字 final： class NoDrived final { /***/ }; class Bad : Noderived { /***/ }; //错误：NoDrived是final的 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#防止继承的发生"},{"categories":["C++"],"content":"15.2.3 类型转换与继承我们可以将基类的指针或引用绑定到派生类对象上，例如：可以用 Quote\u0026 指向一个 Bulk_quote 对象 当使用基类的引用（或指针）时，我们并不清楚该引用（指针）所绑定对象的真实类型，可能该对象时基类的对象，也可能时派生类的对象 智能指针类也支持派生类向基类的类型转换 静态类型和动态类型","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:3","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#1523-类型转换与继承"},{"categories":["C++"],"content":"15.2.3 类型转换与继承我们可以将基类的指针或引用绑定到派生类对象上，例如：可以用 Quote\u0026 指向一个 Bulk_quote 对象 当使用基类的引用（或指针）时，我们并不清楚该引用（指针）所绑定对象的真实类型，可能该对象时基类的对象，也可能时派生类的对象 智能指针类也支持派生类向基类的类型转换 静态类型和动态类型","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:3","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#静态类型和动态类型"},{"categories":["C++"],"content":"第14章 重载运算与类型转换","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:0:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#第14章-重载运算与类型转换"},{"categories":["C++"],"content":"14.1 基本概念重载的运算符是具有特殊名字的函数：它们的名字由关键字 operator 和其后要定义的运算符号共同组成。和其他函数一样，重载的运算符也包含返回类型、参数列表以及函数体。 重载运算符函数的参数数量与该作用的运算对象数量一样多，一元运算符有一个参数，二元运算符有两个参数； 二元运算符左侧运算对象传递给第一个参数，右侧对象传递给第二个对象 除了 operator() 外，其他重载运算符不能含有默认实参 如果一个重载运算符是类的成员函数时，this 会绑定到左侧运算对象，参数数量会比运算对象少一个 重载运算符函数只能是一个类的成员，或者至少有一个类类型的参数，不能对内置类型定义重载运算符 int operator+(int, int);//错误，不能重定义int的运算符 以下是可以重载或者不能重载的运算符： 重载运算符的几种调用形式： 可以间接的用运算符调用重载的运算符函数 也可以像普通函数那样直接调用 //一个非成员运算符函数的等价调用 data1 + data2; //普通表达式 operator+(data1, data2); //等价的函数调用 也可以像调用其他成员函数一样显示的调用成员运算符 data1 += data2; //基于调用的表达式 data1.operator+=(data2); //对成员运算符函数的等价调用 某些运算符不应该被重载 某些运算符会指定运算对象的求值顺序，而关于这些运算对象求值顺序的规则无法应用到重载的运算符上 像逻辑与运算符、逻辑或运算符、逗号运算符的运算对象求值顺序无法保留下来，而 \u0026\u0026 和 || 短路求值属性也无法保留 对于逗号和取地址运算符，用于类类型对象时已经定义了特殊的含义，所以不应该被重载 使用内置类型一致的含义设计一个类时，要考虑这个类提供哪些操作，然后再考虑这些操作设为普通函数还是重载的运算符。如果某些类逻辑上和运算符相关，它们适合定义成重载的运算符 如果类执行 IO 操作，定义移位运算符和内置类型的 IO 保存一致 类检查相等性操作，定义 operator=，同时也应该定义 operator!= 如果类有比较操作，例如 operator\u003c，也该也定义其他关系的操作 返回类型通常情况下要和内置返回类型兼容： 逻辑和关系运算符应该返回 bool 算术运算符应该返回类类型的值 赋值和复合运算符应该返回左侧对象的引用 选择作为成员或者非成员定义重载运算符时，首先要觉得声明为类的成员函数，还是一个普通的非成员函数，下面准则可以帮助判断： 赋值（=），下标（[]），调用（()）和成员访问箭头（-\u003e）必须时成员 复合类型一般为成员，但非必须 改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减、解引用通常为成员 具有对称性的运算符可以转换任意一端的运算对象，如算术、相等性、关系和位运算，通常位普通的非成员函数 string s = \"world\"; string t = s + \"!\"; string u = \"hi \" + s;//如果+是string成员函数，这里会报错 实际上，string 将 + 定义为了普通成员函数，\"hi \" + s 等价于 operator+=(\"hi \", s)，就没有出现问题 ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:1:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#141-基本概念"},{"categories":["C++"],"content":"14.1 基本概念重载的运算符是具有特殊名字的函数：它们的名字由关键字 operator 和其后要定义的运算符号共同组成。和其他函数一样，重载的运算符也包含返回类型、参数列表以及函数体。 重载运算符函数的参数数量与该作用的运算对象数量一样多，一元运算符有一个参数，二元运算符有两个参数； 二元运算符左侧运算对象传递给第一个参数，右侧对象传递给第二个对象 除了 operator() 外，其他重载运算符不能含有默认实参 如果一个重载运算符是类的成员函数时，this 会绑定到左侧运算对象，参数数量会比运算对象少一个 重载运算符函数只能是一个类的成员，或者至少有一个类类型的参数，不能对内置类型定义重载运算符 int operator+(int, int);//错误，不能重定义int的运算符 以下是可以重载或者不能重载的运算符： 重载运算符的几种调用形式： 可以间接的用运算符调用重载的运算符函数 也可以像普通函数那样直接调用 //一个非成员运算符函数的等价调用 data1 + data2; //普通表达式 operator+(data1, data2); //等价的函数调用 也可以像调用其他成员函数一样显示的调用成员运算符 data1 += data2; //基于调用的表达式 data1.operator+=(data2); //对成员运算符函数的等价调用 某些运算符不应该被重载 某些运算符会指定运算对象的求值顺序，而关于这些运算对象求值顺序的规则无法应用到重载的运算符上 像逻辑与运算符、逻辑或运算符、逗号运算符的运算对象求值顺序无法保留下来，而 \u0026\u0026 和 || 短路求值属性也无法保留 对于逗号和取地址运算符，用于类类型对象时已经定义了特殊的含义，所以不应该被重载 使用内置类型一致的含义设计一个类时，要考虑这个类提供哪些操作，然后再考虑这些操作设为普通函数还是重载的运算符。如果某些类逻辑上和运算符相关，它们适合定义成重载的运算符 如果类执行 IO 操作，定义移位运算符和内置类型的 IO 保存一致 类检查相等性操作，定义 operator=，同时也应该定义 operator!= 如果类有比较操作，例如 operator）必须时成员 复合类型一般为成员，但非必须 改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减、解引用通常为成员 具有对称性的运算符可以转换任意一端的运算对象，如算术、相等性、关系和位运算，通常位普通的非成员函数 string s = \"world\"; string t = s + \"!\"; string u = \"hi \" + s;//如果+是string成员函数，这里会报错 实际上，string 将 + 定义为了普通成员函数，\"hi \" + s 等价于 operator+=(\"hi \", s)，就没有出现问题 ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:1:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#重载运算符的几种调用形式"},{"categories":["C++"],"content":"14.1 基本概念重载的运算符是具有特殊名字的函数：它们的名字由关键字 operator 和其后要定义的运算符号共同组成。和其他函数一样，重载的运算符也包含返回类型、参数列表以及函数体。 重载运算符函数的参数数量与该作用的运算对象数量一样多，一元运算符有一个参数，二元运算符有两个参数； 二元运算符左侧运算对象传递给第一个参数，右侧对象传递给第二个对象 除了 operator() 外，其他重载运算符不能含有默认实参 如果一个重载运算符是类的成员函数时，this 会绑定到左侧运算对象，参数数量会比运算对象少一个 重载运算符函数只能是一个类的成员，或者至少有一个类类型的参数，不能对内置类型定义重载运算符 int operator+(int, int);//错误，不能重定义int的运算符 以下是可以重载或者不能重载的运算符： 重载运算符的几种调用形式： 可以间接的用运算符调用重载的运算符函数 也可以像普通函数那样直接调用 //一个非成员运算符函数的等价调用 data1 + data2; //普通表达式 operator+(data1, data2); //等价的函数调用 也可以像调用其他成员函数一样显示的调用成员运算符 data1 += data2; //基于调用的表达式 data1.operator+=(data2); //对成员运算符函数的等价调用 某些运算符不应该被重载 某些运算符会指定运算对象的求值顺序，而关于这些运算对象求值顺序的规则无法应用到重载的运算符上 像逻辑与运算符、逻辑或运算符、逗号运算符的运算对象求值顺序无法保留下来，而 \u0026\u0026 和 || 短路求值属性也无法保留 对于逗号和取地址运算符，用于类类型对象时已经定义了特殊的含义，所以不应该被重载 使用内置类型一致的含义设计一个类时，要考虑这个类提供哪些操作，然后再考虑这些操作设为普通函数还是重载的运算符。如果某些类逻辑上和运算符相关，它们适合定义成重载的运算符 如果类执行 IO 操作，定义移位运算符和内置类型的 IO 保存一致 类检查相等性操作，定义 operator=，同时也应该定义 operator!= 如果类有比较操作，例如 operator）必须时成员 复合类型一般为成员，但非必须 改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减、解引用通常为成员 具有对称性的运算符可以转换任意一端的运算对象，如算术、相等性、关系和位运算，通常位普通的非成员函数 string s = \"world\"; string t = s + \"!\"; string u = \"hi \" + s;//如果+是string成员函数，这里会报错 实际上，string 将 + 定义为了普通成员函数，\"hi \" + s 等价于 operator+=(\"hi \", s)，就没有出现问题 ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:1:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#某些运算符不应该被重载"},{"categories":["C++"],"content":"14.1 基本概念重载的运算符是具有特殊名字的函数：它们的名字由关键字 operator 和其后要定义的运算符号共同组成。和其他函数一样，重载的运算符也包含返回类型、参数列表以及函数体。 重载运算符函数的参数数量与该作用的运算对象数量一样多，一元运算符有一个参数，二元运算符有两个参数； 二元运算符左侧运算对象传递给第一个参数，右侧对象传递给第二个对象 除了 operator() 外，其他重载运算符不能含有默认实参 如果一个重载运算符是类的成员函数时，this 会绑定到左侧运算对象，参数数量会比运算对象少一个 重载运算符函数只能是一个类的成员，或者至少有一个类类型的参数，不能对内置类型定义重载运算符 int operator+(int, int);//错误，不能重定义int的运算符 以下是可以重载或者不能重载的运算符： 重载运算符的几种调用形式： 可以间接的用运算符调用重载的运算符函数 也可以像普通函数那样直接调用 //一个非成员运算符函数的等价调用 data1 + data2; //普通表达式 operator+(data1, data2); //等价的函数调用 也可以像调用其他成员函数一样显示的调用成员运算符 data1 += data2; //基于调用的表达式 data1.operator+=(data2); //对成员运算符函数的等价调用 某些运算符不应该被重载 某些运算符会指定运算对象的求值顺序，而关于这些运算对象求值顺序的规则无法应用到重载的运算符上 像逻辑与运算符、逻辑或运算符、逗号运算符的运算对象求值顺序无法保留下来，而 \u0026\u0026 和 || 短路求值属性也无法保留 对于逗号和取地址运算符，用于类类型对象时已经定义了特殊的含义，所以不应该被重载 使用内置类型一致的含义设计一个类时，要考虑这个类提供哪些操作，然后再考虑这些操作设为普通函数还是重载的运算符。如果某些类逻辑上和运算符相关，它们适合定义成重载的运算符 如果类执行 IO 操作，定义移位运算符和内置类型的 IO 保存一致 类检查相等性操作，定义 operator=，同时也应该定义 operator!= 如果类有比较操作，例如 operator）必须时成员 复合类型一般为成员，但非必须 改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减、解引用通常为成员 具有对称性的运算符可以转换任意一端的运算对象，如算术、相等性、关系和位运算，通常位普通的非成员函数 string s = \"world\"; string t = s + \"!\"; string u = \"hi \" + s;//如果+是string成员函数，这里会报错 实际上，string 将 + 定义为了普通成员函数，\"hi \" + s 等价于 operator+=(\"hi \", s)，就没有出现问题 ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:1:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#使用内置类型一致的含义"},{"categories":["C++"],"content":"14.1 基本概念重载的运算符是具有特殊名字的函数：它们的名字由关键字 operator 和其后要定义的运算符号共同组成。和其他函数一样，重载的运算符也包含返回类型、参数列表以及函数体。 重载运算符函数的参数数量与该作用的运算对象数量一样多，一元运算符有一个参数，二元运算符有两个参数； 二元运算符左侧运算对象传递给第一个参数，右侧对象传递给第二个对象 除了 operator() 外，其他重载运算符不能含有默认实参 如果一个重载运算符是类的成员函数时，this 会绑定到左侧运算对象，参数数量会比运算对象少一个 重载运算符函数只能是一个类的成员，或者至少有一个类类型的参数，不能对内置类型定义重载运算符 int operator+(int, int);//错误，不能重定义int的运算符 以下是可以重载或者不能重载的运算符： 重载运算符的几种调用形式： 可以间接的用运算符调用重载的运算符函数 也可以像普通函数那样直接调用 //一个非成员运算符函数的等价调用 data1 + data2; //普通表达式 operator+(data1, data2); //等价的函数调用 也可以像调用其他成员函数一样显示的调用成员运算符 data1 += data2; //基于调用的表达式 data1.operator+=(data2); //对成员运算符函数的等价调用 某些运算符不应该被重载 某些运算符会指定运算对象的求值顺序，而关于这些运算对象求值顺序的规则无法应用到重载的运算符上 像逻辑与运算符、逻辑或运算符、逗号运算符的运算对象求值顺序无法保留下来，而 \u0026\u0026 和 || 短路求值属性也无法保留 对于逗号和取地址运算符，用于类类型对象时已经定义了特殊的含义，所以不应该被重载 使用内置类型一致的含义设计一个类时，要考虑这个类提供哪些操作，然后再考虑这些操作设为普通函数还是重载的运算符。如果某些类逻辑上和运算符相关，它们适合定义成重载的运算符 如果类执行 IO 操作，定义移位运算符和内置类型的 IO 保存一致 类检查相等性操作，定义 operator=，同时也应该定义 operator!= 如果类有比较操作，例如 operator）必须时成员 复合类型一般为成员，但非必须 改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减、解引用通常为成员 具有对称性的运算符可以转换任意一端的运算对象，如算术、相等性、关系和位运算，通常位普通的非成员函数 string s = \"world\"; string t = s + \"!\"; string u = \"hi \" + s;//如果+是string成员函数，这里会报错 实际上，string 将 + 定义为了普通成员函数，\"hi \" + s 等价于 operator+=(\"hi \", s)，就没有出现问题 ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:1:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#选择作为成员或者非成员"},{"categories":["C++"],"content":"14.2 输入输出运算符","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:2:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#142-输入输出运算符"},{"categories":["C++"],"content":"14.2.1 重载输出运算符«通常情况下，输出运算符第一个形参是一个非常量 ostream 对象的引用，非常量是因为像流写入内容会改变其状态，引用类型是因为无法直接复制一个 ostream 对象（注：拷贝构造函数为 delete） 第二个形参是一个常量的引用，这个常量是需要打印出来的类类型，引用为了避免复制，常量是因为打印不会改变对象的内容 举个例子： ostream \u0026operator(ostream \u0026os, const \u0026Sales_data \u0026item) { os \u003c\u003c item.isbn() \u003c\u003c \" \" \u003c\u003c item.units_sold \u003c\u003c \" \" \u003c\u003c item.revenue \u003c\u003c \" \" \u003c\u003c item.avg_price();//末尾不需要再加换行符 return os; } 通常输出运算符主要负责打印对象内容而不是控制格式，所以一般不打印换行符 输入输出运算符必须是非成员函数输入输出函数必须为非成员函数，不能是类成员函数，否则左侧运算对象将是类的一个对象 Sales_data data; data \u003c\u003c cout; //如果opeator\u003c\u003c是Sales_data的对象 如果输入输出运算符是Sales_data 的成员，它们也必须为 istream 或 ostream 的成员，当然我们不能为标准库定义成员 注：其实这里感觉没看懂，如果像书上写的这样，data « cout 感觉是不是也可以输出？我自己也试了代码，确实可以输出，就是看着有点怪，要是深究起来，感觉书上写的话不够严谨 ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:2:1","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#1421-重载输出运算符"},{"categories":["C++"],"content":"14.2.1 重载输出运算符«通常情况下，输出运算符第一个形参是一个非常量 ostream 对象的引用，非常量是因为像流写入内容会改变其状态，引用类型是因为无法直接复制一个 ostream 对象（注：拷贝构造函数为 delete） 第二个形参是一个常量的引用，这个常量是需要打印出来的类类型，引用为了避免复制，常量是因为打印不会改变对象的内容 举个例子： ostream \u0026operator(ostream \u0026os, const \u0026Sales_data \u0026item) { os ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:2:1","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#输入输出运算符必须是非成员函数"},{"categories":["C++"],"content":"14.2.2 重载输入运算符»输入运算符第一个形参是读取流的引用，第二个形参是读入到对象的引用 例如： istream \u0026operator\u003e\u003e(istream \u0026is, Sales_data \u0026item) { double price; is \u003e\u003e item.bookNo \u003e\u003e item.untis_sold \u003e\u003e price; if (is) {//检查是否输入成功 item.revenue = item.units_sold * price; } else { item = Sales_data();//输入失败，对象初始为默认情况 } return is; } 输入时的错误执行输入运算符时可能发生以下错误： 当流读取到错误类型的数据，后续操作都会失败 当读取操作未达到文件末尾或者遇到输入流其他错误时也会失败 所以使用输入操作符时，需要判断是否有错误的情况发生，因为如果出现错误的情况可能发生在中间，这样的话前面的成员时正确的，而发生读取错误的地方后面的成员就和前面不匹配了 ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:2:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#1422-重载输入运算符"},{"categories":["C++"],"content":"14.2.2 重载输入运算符»输入运算符第一个形参是读取流的引用，第二个形参是读入到对象的引用 例如： istream \u0026operator(istream \u0026is, Sales_data \u0026item) { double price; is item.bookNo item.untis_sold price; if (is) {//检查是否输入成功 item.revenue = item.units_sold * price; } else { item = Sales_data();//输入失败，对象初始为默认情况 } return is; } 输入时的错误执行输入运算符时可能发生以下错误： 当流读取到错误类型的数据，后续操作都会失败 当读取操作未达到文件末尾或者遇到输入流其他错误时也会失败 所以使用输入操作符时，需要判断是否有错误的情况发生，因为如果出现错误的情况可能发生在中间，这样的话前面的成员时正确的，而发生读取错误的地方后面的成员就和前面不匹配了 ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:2:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#输入时的错误"},{"categories":["C++"],"content":"14.3 算术和关系运算符通常情况下，算术和关系运算符定义为非成员函数允许左侧和右侧运算对象进行转换，形参都是常量的引用 算术运算符通常会计算两个对象并得到一个新值，这个值区别于任何一个运算对象，常常位于一个局部变量中，返回值应该为局部变量的副本作为结果，通常也会定义复合赋值运算符 Book operator+(const Book \u0026lhs, const Book \u0026rhs) { Book sum = lhs; sum += rhs; //复合赋值运算符 return sum; } ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:3:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#143-算术和关系运算符"},{"categories":["C++"],"content":"14.3.1 相等运算符一般情况下只有当两个对象每一个数据成员都相等时，才认为他们时相等的 下面是个具体例子： bool operator==(const Book \u0026lhs, const Book \u0026rhs) { return lhs.price == rhs.price \u0026\u0026 lhs.name == rhs.name; } bool operator!=(const Book \u0026lhs, const Book \u0026rhs) { return !(lhs == rhs); } 设计相等运算符函数基本准则如下： 设计一个类判断两个对象是否相等的操作时，通常定义为 operator== 而非其他的像（equl等等）普通的命名函数 如果类定义了 operator== ，则该运算符应该能判断一组给定对象是否含义重复数据 相等运算符应该具有传递性，如 a == b 和 b == c 都为真，那么 a == c 也为真 定义了 operator== 通常也要定义 operator!= 相等和不相等运算符，通常具体写一个即可，另一个进行调用即可 ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:3:1","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#1431-相等运算符"},{"categories":["C++"],"content":"14.3.2 关系运算符对于关联容器和一些算法会用到小于运算符，此时可以定义 operator\u003c 但是一般情况下，关系运算符可能没有那么有必要，比如说上面的 Book 类，如果说定义小于关系的，具体内容如何比较，是先根据书名然后根据价格进行比较？还是说仅仅根据书名比较 一般情况下，对于不相等的对象，一个对象应该小于另一个对象，这样的话，定义关系运算符的时候，逻辑上就不是很清楚了 如果存在唯一一种逻辑可靠的 \u003c 定义，应该考虑定义 \u003c 运算符，但是如果类还包括 == ，仅当\u003c 的定义和 == 结果一致时才定义 \u003c 运算符 ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:3:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#1432-关系运算符"},{"categories":["C++"],"content":"14.4 赋值运算符13章时已经介绍过拷贝赋值和移动赋值运算符，它们把一个对象赋值给另一个对象。我们还可以定义其他的赋值运算符，以使用别的类型作为右侧对象 复合赋值运算符通常把复合赋值运算符等赋值运算符都定义在类的内部，复合赋值运算符也应该返回左侧对象的引用 Book \u0026Book::operator+=(const Book \u0026rhs) { price += rhs.price;//这里因为自己写的例子，语义上可能有些问题 return *this; } ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:4:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#144-赋值运算符"},{"categories":["C++"],"content":"14.4 赋值运算符13章时已经介绍过拷贝赋值和移动赋值运算符，它们把一个对象赋值给另一个对象。我们还可以定义其他的赋值运算符，以使用别的类型作为右侧对象 复合赋值运算符通常把复合赋值运算符等赋值运算符都定义在类的内部，复合赋值运算符也应该返回左侧对象的引用 Book \u0026Book::operator+=(const Book \u0026rhs) { price += rhs.price;//这里因为自己写的例子，语义上可能有些问题 return *this; } ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:4:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#复合赋值运算符"},{"categories":["C++"],"content":"14.5 下标运算符下标运算符通常在一些容器中，可以让我们像访问数组那样的形式进行访问，一般会定义为 operator[] 下标运算符必须时成员函数 通常返回值为访问元素的引用，确保下标可以出现在赋值运算符任意一端 如果一个类包含下标运算符，通常会定义两个版本： 一个返回普通引用 另一个是类的常量成员并且返回常量引用 class StrVec { std::string\u0026 operator[](std::size_t n) {return elements[n];} const std::string\u0026 operator[](std::size_t) const {return elements[n];} private: std::string *elements;//指向数组首元素的指针 } 当 StrVec 是非常量时，可以给元素赋值 当对常量对象取小标时，不能为其赋值 const StrVec cvec = svec; if (svec.size() \u0026\u0026 svec[0].empty()) { svec[0] = \"zero\";//正确：下标运算符返回string的引用 cvec[0] = \"zip\"; //错误：cvec取下标返回的为常量引用 } ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:5:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#145-下标运算符"},{"categories":["C++"],"content":"14.6递增和递减运算符一般迭代器类会实现递增运算符（++）和递减运算符（–），使得迭代器可以在元素序列中进行移动，因为它们改变了操作对象的状态，通常设为成员函数 定义递增和递减运算符的类要同时定义前置版本和后置版本，且都为类的成员函数 定义前置递增/递减运算符==为了和内置版本保持一致，前置运算符应该返回递增或递减后对象的引用== 递增和递减运算符工作机理： 首先调用check 函数检查是否有效 如果有效，接着检查给定索引值是否有效 check 函数没有发生异常，返回运算对象的引用 下面时具体例子： class StrBlobPtr { public: //递增和递减运算符 StrBlobPtr\u0026 operator++();//前置版本 StrBlobPtr\u0026 operator--(); //其他成员 } StrBlobPtr\u0026 StrBlobPtr::operator++() { check(curr, \"已经越界\"); ++curr; //curr向前移动一个元素 return *this; } StrBlobPtr\u0026 StrBlobPtr::operator--() { --curr; //curr向后移动一个元素 check(curr, \"已经越界\"); return *this; } 区分前置和后置运算符因为前置和后置版本使用的是同一个符号，重载版本的名字也是相同的，运算对象的数量和类型也是相同的 所以为了解决这个问题，后置版本接受一个额外的但是不使用的 int 类型的参数，编译器会为这个形参提供一个值为 0 的实参 class StrBlobPtr { public: //递增和递减运算符 StrBlobPtr\u0026 operator++(int);//后置版本 StrBlobPtr\u0026 operator--(int); //其他成员 } StrBlobPtr StrBlobPtr::operator++(int) { //这里无须检查有效性，调用前置版本的时候会检查 StrBlobPtr ret = *this;//记录当前的值 ++*this; //向前移动一个元素，前置++会检查有效性 return ret; //返回之前记录的状态 } StrBlobPtr\u0026 StrBlobPtr::operator--(int) { //这里无须检查有效性，调用前置版本的时候会检查 StrBlobPtr ret = *this;//记录当前的值 --*this; //向前移动一个元素，前置++会检查有效性 return ret; //返回之前记录的状态 } 这里主要需要理解内置类型前置版本和后置版本的区别（以int类型为例） ++i 首先会对 i 的值进行递增，然后返回 i 的值 i++ 首先会返回 i 的值，然后再进行运算 int sum = 0, i = 1; sum = ++i; //此时sum的值为2 sum = i++; //此时sum的值为1 显示调用后置运算符如果要显示调用运算符的话，像之前那样利用函数调用的形式进行调用，但是注意必须传入一个整型参数 StrBlobPtr p(a1); //p指向a1的vector p.operator++(0); //调用后置版本的operator++ p.operator++(); //调用前置版本的operator++ ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:6:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#146递增和递减运算符"},{"categories":["C++"],"content":"14.6递增和递减运算符一般迭代器类会实现递增运算符（++）和递减运算符（–），使得迭代器可以在元素序列中进行移动，因为它们改变了操作对象的状态，通常设为成员函数 定义递增和递减运算符的类要同时定义前置版本和后置版本，且都为类的成员函数 定义前置递增/递减运算符==为了和内置版本保持一致，前置运算符应该返回递增或递减后对象的引用== 递增和递减运算符工作机理： 首先调用check 函数检查是否有效 如果有效，接着检查给定索引值是否有效 check 函数没有发生异常，返回运算对象的引用 下面时具体例子： class StrBlobPtr { public: //递增和递减运算符 StrBlobPtr\u0026 operator++();//前置版本 StrBlobPtr\u0026 operator--(); //其他成员 } StrBlobPtr\u0026 StrBlobPtr::operator++() { check(curr, \"已经越界\"); ++curr; //curr向前移动一个元素 return *this; } StrBlobPtr\u0026 StrBlobPtr::operator--() { --curr; //curr向后移动一个元素 check(curr, \"已经越界\"); return *this; } 区分前置和后置运算符因为前置和后置版本使用的是同一个符号，重载版本的名字也是相同的，运算对象的数量和类型也是相同的 所以为了解决这个问题，后置版本接受一个额外的但是不使用的 int 类型的参数，编译器会为这个形参提供一个值为 0 的实参 class StrBlobPtr { public: //递增和递减运算符 StrBlobPtr\u0026 operator++(int);//后置版本 StrBlobPtr\u0026 operator--(int); //其他成员 } StrBlobPtr StrBlobPtr::operator++(int) { //这里无须检查有效性，调用前置版本的时候会检查 StrBlobPtr ret = *this;//记录当前的值 ++*this; //向前移动一个元素，前置++会检查有效性 return ret; //返回之前记录的状态 } StrBlobPtr\u0026 StrBlobPtr::operator--(int) { //这里无须检查有效性，调用前置版本的时候会检查 StrBlobPtr ret = *this;//记录当前的值 --*this; //向前移动一个元素，前置++会检查有效性 return ret; //返回之前记录的状态 } 这里主要需要理解内置类型前置版本和后置版本的区别（以int类型为例） ++i 首先会对 i 的值进行递增，然后返回 i 的值 i++ 首先会返回 i 的值，然后再进行运算 int sum = 0, i = 1; sum = ++i; //此时sum的值为2 sum = i++; //此时sum的值为1 显示调用后置运算符如果要显示调用运算符的话，像之前那样利用函数调用的形式进行调用，但是注意必须传入一个整型参数 StrBlobPtr p(a1); //p指向a1的vector p.operator++(0); //调用后置版本的operator++ p.operator++(); //调用前置版本的operator++ ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:6:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#定义前置递增递减运算符"},{"categories":["C++"],"content":"14.6递增和递减运算符一般迭代器类会实现递增运算符（++）和递减运算符（–），使得迭代器可以在元素序列中进行移动，因为它们改变了操作对象的状态，通常设为成员函数 定义递增和递减运算符的类要同时定义前置版本和后置版本，且都为类的成员函数 定义前置递增/递减运算符==为了和内置版本保持一致，前置运算符应该返回递增或递减后对象的引用== 递增和递减运算符工作机理： 首先调用check 函数检查是否有效 如果有效，接着检查给定索引值是否有效 check 函数没有发生异常，返回运算对象的引用 下面时具体例子： class StrBlobPtr { public: //递增和递减运算符 StrBlobPtr\u0026 operator++();//前置版本 StrBlobPtr\u0026 operator--(); //其他成员 } StrBlobPtr\u0026 StrBlobPtr::operator++() { check(curr, \"已经越界\"); ++curr; //curr向前移动一个元素 return *this; } StrBlobPtr\u0026 StrBlobPtr::operator--() { --curr; //curr向后移动一个元素 check(curr, \"已经越界\"); return *this; } 区分前置和后置运算符因为前置和后置版本使用的是同一个符号，重载版本的名字也是相同的，运算对象的数量和类型也是相同的 所以为了解决这个问题，后置版本接受一个额外的但是不使用的 int 类型的参数，编译器会为这个形参提供一个值为 0 的实参 class StrBlobPtr { public: //递增和递减运算符 StrBlobPtr\u0026 operator++(int);//后置版本 StrBlobPtr\u0026 operator--(int); //其他成员 } StrBlobPtr StrBlobPtr::operator++(int) { //这里无须检查有效性，调用前置版本的时候会检查 StrBlobPtr ret = *this;//记录当前的值 ++*this; //向前移动一个元素，前置++会检查有效性 return ret; //返回之前记录的状态 } StrBlobPtr\u0026 StrBlobPtr::operator--(int) { //这里无须检查有效性，调用前置版本的时候会检查 StrBlobPtr ret = *this;//记录当前的值 --*this; //向前移动一个元素，前置++会检查有效性 return ret; //返回之前记录的状态 } 这里主要需要理解内置类型前置版本和后置版本的区别（以int类型为例） ++i 首先会对 i 的值进行递增，然后返回 i 的值 i++ 首先会返回 i 的值，然后再进行运算 int sum = 0, i = 1; sum = ++i; //此时sum的值为2 sum = i++; //此时sum的值为1 显示调用后置运算符如果要显示调用运算符的话，像之前那样利用函数调用的形式进行调用，但是注意必须传入一个整型参数 StrBlobPtr p(a1); //p指向a1的vector p.operator++(0); //调用后置版本的operator++ p.operator++(); //调用前置版本的operator++ ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:6:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#区分前置和后置运算符"},{"categories":["C++"],"content":"14.6递增和递减运算符一般迭代器类会实现递增运算符（++）和递减运算符（–），使得迭代器可以在元素序列中进行移动，因为它们改变了操作对象的状态，通常设为成员函数 定义递增和递减运算符的类要同时定义前置版本和后置版本，且都为类的成员函数 定义前置递增/递减运算符==为了和内置版本保持一致，前置运算符应该返回递增或递减后对象的引用== 递增和递减运算符工作机理： 首先调用check 函数检查是否有效 如果有效，接着检查给定索引值是否有效 check 函数没有发生异常，返回运算对象的引用 下面时具体例子： class StrBlobPtr { public: //递增和递减运算符 StrBlobPtr\u0026 operator++();//前置版本 StrBlobPtr\u0026 operator--(); //其他成员 } StrBlobPtr\u0026 StrBlobPtr::operator++() { check(curr, \"已经越界\"); ++curr; //curr向前移动一个元素 return *this; } StrBlobPtr\u0026 StrBlobPtr::operator--() { --curr; //curr向后移动一个元素 check(curr, \"已经越界\"); return *this; } 区分前置和后置运算符因为前置和后置版本使用的是同一个符号，重载版本的名字也是相同的，运算对象的数量和类型也是相同的 所以为了解决这个问题，后置版本接受一个额外的但是不使用的 int 类型的参数，编译器会为这个形参提供一个值为 0 的实参 class StrBlobPtr { public: //递增和递减运算符 StrBlobPtr\u0026 operator++(int);//后置版本 StrBlobPtr\u0026 operator--(int); //其他成员 } StrBlobPtr StrBlobPtr::operator++(int) { //这里无须检查有效性，调用前置版本的时候会检查 StrBlobPtr ret = *this;//记录当前的值 ++*this; //向前移动一个元素，前置++会检查有效性 return ret; //返回之前记录的状态 } StrBlobPtr\u0026 StrBlobPtr::operator--(int) { //这里无须检查有效性，调用前置版本的时候会检查 StrBlobPtr ret = *this;//记录当前的值 --*this; //向前移动一个元素，前置++会检查有效性 return ret; //返回之前记录的状态 } 这里主要需要理解内置类型前置版本和后置版本的区别（以int类型为例） ++i 首先会对 i 的值进行递增，然后返回 i 的值 i++ 首先会返回 i 的值，然后再进行运算 int sum = 0, i = 1; sum = ++i; //此时sum的值为2 sum = i++; //此时sum的值为1 显示调用后置运算符如果要显示调用运算符的话，像之前那样利用函数调用的形式进行调用，但是注意必须传入一个整型参数 StrBlobPtr p(a1); //p指向a1的vector p.operator++(0); //调用后置版本的operator++ p.operator++(); //调用前置版本的operator++ ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:6:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#显示调用后置运算符"},{"categories":["C++"],"content":"14.7 成员访问运算符迭代器和智能指针类中常常用到解引用运算符（*）和箭头运算符（-\u003e），例如： class StrBlobPtr { public: std::string \u0026operator*() const { auto p = check(curr, \"dereference past end\"); return (*p)[curr]; //(*p)是对象所指的vector } std::string \u0026operator-\u003e() const { return \u0026 this-\u003eoperator*();//实际工作委托给解引用运算符 } //其他成员 } 解引用运算符首先检查curr是否在作用范围内，如果是返回curr所指元素的引用，箭头运算符返回解引用结果元素的地址 对箭头运算符返回值的限定形如point-\u003emem 的表达式，point必须是指向类对象的指针或者是重载了 operator-\u003e 的类的对象 (*point).mem; //point是一个内置指针类型 point.operator()-\u003emem;//point是一个类的对象 如果 point 是指针，则会应用内置箭头运算符，等价于 (*point).mem 如果 point 是一个定义了 operator-\u003e的类的一个对象，则使用 point.operator-\u003e() 的结果来获取 mem ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:7:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#147-成员访问运算符"},{"categories":["C++"],"content":"14.7 成员访问运算符迭代器和智能指针类中常常用到解引用运算符（*）和箭头运算符（-），例如： class StrBlobPtr { public: std::string \u0026operator*() const { auto p = check(curr, \"dereference past end\"); return (*p)[curr]; //(*p)是对象所指的vector } std::string \u0026operator-() const { return \u0026 this-operator*();//实际工作委托给解引用运算符 } //其他成员 } 解引用运算符首先检查curr是否在作用范围内，如果是返回curr所指元素的引用，箭头运算符返回解引用结果元素的地址 对箭头运算符返回值的限定形如point-mem 的表达式，point必须是指向类对象的指针或者是重载了 operator- 的类的对象 (*point).mem; //point是一个内置指针类型 point.operator()-mem;//point是一个类的对象 如果 point 是指针，则会应用内置箭头运算符，等价于 (*point).mem 如果 point 是一个定义了 operator-的类的一个对象，则使用 point.operator-() 的结果来获取 mem ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:7:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#对箭头运算符返回值的限定"},{"categories":["C++"],"content":"14.8 函数调用运算符如果一个类重载了函数调用运算符（就是()），则可以像调用函数一样使用该类的对象，下面是一个例子： struct absInt { int operator()(int val) const { return val \u003c 0 ? -val : val; } } int i = -42; absInt absObj; //含有函数调用运算符的对象 int ui = absObj(i);//将i传递给absObj.operator() 函数调用运算符必须是成员函数，一个类可以定义多个不同版本的调用运算符 如果类定义了调用运算符，则该类的对象称为函数对象，这些对象的行为像函数一样 含有状态的函数对象类函数对象类除了 operator() 之外也可以包含其他成员，这些成员被用于定制调用运算符中的操作，下面是个例子： class PrintString { public: PrintString(ostream \u0026o = cout, char c = ' ') : os(o), sep(c) {} void operator()(const string \u0026s) const {os \u003c\u003c s \u003c\u003c sep;} private: ostream \u0026os;//用于写入的目的流 char step; //用于将不同输出隔开的字符 } PrintString printer; printer(s); PrintString errors(cerr, '\\n'); errors(s); 函数对象常常作为泛型算法的实参，例如可以用for_each 算法和 PrintString 类来打印容器的内容： for_each(vec.beign(), vec.end(), PrintString(cerr, '\\n')); for_each 第三个实参是类型 PrintString 的一个临时对象，我们用 cerr 和 换行符初始化了改对象，程序调用 for_each 时，会把 vec 每个元素打印到 cerr 中，元素之间以换行符分割 ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:8:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#148-函数调用运算符"},{"categories":["C++"],"content":"14.8 函数调用运算符如果一个类重载了函数调用运算符（就是()），则可以像调用函数一样使用该类的对象，下面是一个例子： struct absInt { int operator()(int val) const { return val ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:8:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#含有状态的函数对象类"},{"categories":["C++"],"content":"14.8.1 lambda 是函数对象使用 PrintString 对象作为 for_each 的实参，类似于使用 lambda 表达式，编译器会将 lambda 表达式 翻译成一个未命名类的未命名对象，举例如下： //根据单词长度进行排序，长度相同的会按照字典序排序 stable_sort(word.begin(), word.end(), [](const string \u0026a, const string \u0026b) { return a.size() \u003c b.size();}); 上面 lambda 表达式类似下面的一个未命名对象 class ShorterString { public: bool operator()(const string \u0026s1, string \u0026s2) const { return s1.size() \u003c s2.size(); } } //替换上面的lambda表达式 stable_sort(word.begin(), word.end(), ShorterString()); 表示 lambda 及相应捕获行为的类 使用一个 lambda 表达式通过引用捕获变量时，程序确保 lambda 执行时引用所引的对象确实存在，编译器可以直接引用而无须在 lambda 产生的类中将其存储为数据成员 使用值捕获的变量会拷贝到 lambda 表达式中，这种 lambda 表达式产生的类必须为每个值捕获的变量建立对应的数据成员，同时创建构造函数，用捕获的变量进行初始化 //获得第一个指向满足条件元素的迭代器，该元素满足size() \u003e= sz auto wc = find_if(word.begin(), word.end(), [sz](const string \u0026a) { return a.size() \u003e= sz;}); //上面的lambda表达式产生的类像下面这样 class SizeComp { SizeComp(size_t n) : sz(n) {} bool operator()(const string \u0026s) const { return s.size() \u003e= sz; } private: size_t sz;//该数据成员对应通过值捕获的变量 } //使用像上面的函数对象时，必须提供一个实参 auto wc = find_if(word.begin(), word.end(), SizeCopm(sz)); lambda 表达式产生的类不含默认构造函数、赋值运算符和默认析构函数；它是否含有默认的拷贝/移动构造函数通常视捕获的数据成员类型而定 ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:8:1","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#1481-lambda-是函数对象"},{"categories":["C++"],"content":"14.8.1 lambda 是函数对象使用 PrintString 对象作为 for_each 的实参，类似于使用 lambda 表达式，编译器会将 lambda 表达式 翻译成一个未命名类的未命名对象，举例如下： //根据单词长度进行排序，长度相同的会按照字典序排序 stable_sort(word.begin(), word.end(), [](const string \u0026a, const string \u0026b) { return a.size() = sz auto wc = find_if(word.begin(), word.end(), [sz](const string \u0026a) { return a.size() = sz;}); //上面的lambda表达式产生的类像下面这样 class SizeComp { SizeComp(size_t n) : sz(n) {} bool operator()(const string \u0026s) const { return s.size() = sz; } private: size_t sz;//该数据成员对应通过值捕获的变量 } //使用像上面的函数对象时，必须提供一个实参 auto wc = find_if(word.begin(), word.end(), SizeCopm(sz)); lambda 表达式产生的类不含默认构造函数、赋值运算符和默认析构函数；它是否含有默认的拷贝/移动构造函数通常视捕获的数据成员类型而定 ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:8:1","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#表示-lambda-及相应捕获行为的类"},{"categories":["C++"],"content":"14.8.2 标准库定义的函数对象标准库定义了一组表示算术运算符、关系运算符和逻辑运算符的类，每个类分别定义了一个执行与类名对应的调用运算符。 如puls 类定义了一个函数调用运算符用于执行 + 操作，modulus类定义了一个调用运算符执行二元 % 的操作 这些类都是模板形式，可以指定具体的应用类型，即对应调用运算符的形参类型 plus\u003cint\u003e intAdd; //执行int加法的函数对象 negate\u003cint\u003e intNegate; //执行int取反的函数对象 int sum = intAdd(10, 20); //sum = 30 sum = intNegate(intAdd(10, 20));//sum = -30 sum = intAdd(10, intNegate(10));//sum = 0 下面时标准库定义的函数对象： 算术 关系 逻辑 plus\u003cType\u003e equal_to\u003cType\u003e logical_and\u003c minus\u003cType not_equal_to\u003cType\u003e logical_or\u003cType\u003e multiplies\u003cType\u003e greater\u003cType\u003e logical_not\u003cType\u003e divides\u003cType\u003e greater_equal\u003cType\u003e modulus\u003cType\u003e less\u003cType\u003e negate\u003cType\u003e less_equal\u003cType\u003e 算法中使用标准库函数对象默认情况下排序算法使用 operator\u003c 将序列按照升序进行排列，如果想执行降序的话，可以用 greater类型的对象 sort(svec.begin(), sec.end(), greater\u003cstring\u003e()); 注意：标准库规定的函数对象对于指针同样适用，如果比较两个无关指针会产生未定义的行为，而我们如果想比较指针内存地址来 sort 指针的 vector。直接比较会产生未定义的行为，而标准库函数对象则可实现这个目的 vector\u003cstring*\u003e nameTable; //错误：nameTable中指针彼此之间没有关系，所以 \u003c 将产生未定义行为 sort(nameTable.begin(), nameTable.end(), [](string *a, string *b) { return a \u003c b;}); // 正确：标准库规定指针的less是定义良好的 sort(nameTable.begin(), nameTable.end(), less\u003cstring*\u003e()); ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:8:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#1482-标准库定义的函数对象"},{"categories":["C++"],"content":"14.8.2 标准库定义的函数对象标准库定义了一组表示算术运算符、关系运算符和逻辑运算符的类，每个类分别定义了一个执行与类名对应的调用运算符。 如puls 类定义了一个函数调用运算符用于执行 + 操作，modulus类定义了一个调用运算符执行二元 % 的操作 这些类都是模板形式，可以指定具体的应用类型，即对应调用运算符的形参类型 plus intAdd; //执行int加法的函数对象 negate intNegate; //执行int取反的函数对象 int sum = intAdd(10, 20); //sum = 30 sum = intNegate(intAdd(10, 20));//sum = -30 sum = intAdd(10, intNegate(10));//sum = 0 下面时标准库定义的函数对象： 算术 关系 逻辑 plus equal_to logical_andlogical_or multiplies greater logical_not divides greater_equal modulus less negate less_equal 算法中使用标准库函数对象默认情况下排序算法使用 operator()); 注意：标准库规定的函数对象对于指针同样适用，如果比较两个无关指针会产生未定义的行为，而我们如果想比较指针内存地址来 sort 指针的 vector。直接比较会产生未定义的行为，而标准库函数对象则可实现这个目的 vector nameTable; //错误：nameTable中指针彼此之间没有关系，所以 ()); ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:8:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#算法中使用标准库函数对象"},{"categories":["C++"],"content":"14.8.3 可调用对象与 functionC++中有几种可调用的对象：函数、函数指针、lambda 表达式、bind 创建的对象以及重载了函数调用运算符的类 这些不同类型的可调用对象可能共享一种调用形式，调用形式指明了返回类型以及实参类型，下面是个例子： //普通函数 int add(int i, int j) { return i + j; } //lambda 表达式 auto mod = [](int i, int j) { return i % j; } //函数对象类 struct divide { int operator()(int denominator, int divisor) { return denominator / divisor; } } 上面的几种可调用对象对参数执行了不同的算术运算，它们类型不相同，但是共享同一种调用形式 int(int, int) 我们如果用这些可调用对象构建一个简单的计算器，可以定义一个函数表用于储存这些可调用对象的指针。 可以通过 map 来实现，用运算符符号的string对象作为关键字，实现运算符函数作为值 //构建运算符到函数指针的映射关系，函数接受两个int，返回一个int map\u003cstring, int(*)(int, int)\u003e binops; //正确：add是一个指向正确类型的函数指针 binops.insert({\"+\", add}); //错误：mod不是一个函数指针 binops.insert({\"%\", mod}); 上面的问题在于 mod 是一个 lambda 表达式，与 binops 的值类型不匹配 标准库 function 类型标准库中一个新的类型 function 可以解决上述问题，下面是 function 定义的操作： function 是一个模板，创建一个具体 function 类型时需要指定 function 表示的对象的调用形式，如 function\u003cint(int, int)\u003e ，这里声明了一个 function 类型，它可以接受两个 int，返回一个 int 类型的可调用对象 function\u003cint(int, int)\u003e f1 = add; //函数指针 function\u003cint(int, int)\u003e f1 = divide();//函数对象类的对象 function\u003cint(int, int)\u003e f1 = [](int i, int j) //lambda { return i * j; }; cout \u003c\u003c f1(4, 2) \u003c\u003c endl; // 6 cout \u003c\u003c f2(4, 2) \u003c\u003c endl; // 2 cout \u003c\u003c f3(4, 2) \u003c\u003c endl; // 8 使用这个 function 类型可以重新定义 map： map\u003cstring, function\u003cint(int, int)\u003e\u003e binops = { {\"+\", add}, //函数指针 {\"-\", std::minus\u003cint\u003e()}, //标准库定义函数对象 {\"/\", divide()}, //用户定义函数对象 {\"*\", [](int i, int j) { return i * j; }},//未命名lambda表达式 {\"%\", mod} //命名的lambda } map 包含5 个元素，虽然可调用对象类型各不相同，但是仍可以存储在同一个 function\u003cint(int, int)\u003e 类型中，这时可以通过索引 map 得到function 对象的引用 binops[\"+\"](10, 5);//add(10, 5); binops[\"-\"](10, 5);//minus\u003cint\u003e(10, 5) binops[\"/\"](10, 5);//divide对象调用运算符 binops[\"*\"](10, 5);//调用lambda函数对象 binops[\"%\"](10, 5);//调用lambda函数对象 重载的函数与 function我们变不能将重载函数名字存入 function 类型的对象中： int add(int i, int j); Sales_data add(const Sales_data\u0026, const Sales_data\u0026); map\u003cstring, function\u003cint(int, int)\u003e\u003e binops; binops.insert({\"+\", add}); //错误：哪个add？ 解决上述二义性问题，可以通过一个函数指针，以及 lambda 表达式进行区分 int (*fp)(int, int) = add; binops.insert({\"+\", fp});//正确：fp指向一个正确的add版本 //正确：使用lambda来指定我们希望使用的add版本 binops.insert({\"+\", [](int a, int b) {return add(a, b);}}); ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:8:3","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#1483-可调用对象与-function"},{"categories":["C++"],"content":"14.8.3 可调用对象与 functionC++中有几种可调用的对象：函数、函数指针、lambda 表达式、bind 创建的对象以及重载了函数调用运算符的类 这些不同类型的可调用对象可能共享一种调用形式，调用形式指明了返回类型以及实参类型，下面是个例子： //普通函数 int add(int i, int j) { return i + j; } //lambda 表达式 auto mod = [](int i, int j) { return i % j; } //函数对象类 struct divide { int operator()(int denominator, int divisor) { return denominator / divisor; } } 上面的几种可调用对象对参数执行了不同的算术运算，它们类型不相同，但是共享同一种调用形式 int(int, int) 我们如果用这些可调用对象构建一个简单的计算器，可以定义一个函数表用于储存这些可调用对象的指针。 可以通过 map 来实现，用运算符符号的string对象作为关键字，实现运算符函数作为值 //构建运算符到函数指针的映射关系，函数接受两个int，返回一个int mapbinops; //正确：add是一个指向正确类型的函数指针 binops.insert({\"+\", add}); //错误：mod不是一个函数指针 binops.insert({\"%\", mod}); 上面的问题在于 mod 是一个 lambda 表达式，与 binops 的值类型不匹配 标准库 function 类型标准库中一个新的类型 function 可以解决上述问题，下面是 function 定义的操作： function 是一个模板，创建一个具体 function 类型时需要指定 function 表示的对象的调用形式，如 function，这里声明了一个 function 类型，它可以接受两个 int，返回一个 int 类型的可调用对象 functionf1 = add; //函数指针 functionf1 = divide();//函数对象类的对象 functionf1 = [](int i, int j) //lambda { return i * j; }; cout binops = { {\"+\", add}, //函数指针 {\"-\", std::minus()}, //标准库定义函数对象 {\"/\", divide()}, //用户定义函数对象 {\"*\", [](int i, int j) { return i * j; }},//未命名lambda表达式 {\"%\", mod} //命名的lambda } map 包含5 个元素，虽然可调用对象类型各不相同，但是仍可以存储在同一个 function类型中，这时可以通过索引 map 得到function 对象的引用 binops[\"+\"](10, 5);//add(10, 5); binops[\"-\"](10, 5);//minus(10, 5) binops[\"/\"](10, 5);//divide对象调用运算符 binops[\"*\"](10, 5);//调用lambda函数对象 binops[\"%\"](10, 5);//调用lambda函数对象 重载的函数与 function我们变不能将重载函数名字存入 function 类型的对象中： int add(int i, int j); Sales_data add(const Sales_data\u0026, const Sales_data\u0026); map binops; binops.insert({\"+\", add}); //错误：哪个add？ 解决上述二义性问题，可以通过一个函数指针，以及 lambda 表达式进行区分 int (*fp)(int, int) = add; binops.insert({\"+\", fp});//正确：fp指向一个正确的add版本 //正确：使用lambda来指定我们希望使用的add版本 binops.insert({\"+\", [](int a, int b) {return add(a, b);}}); ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:8:3","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#标准库-function-类型"},{"categories":["C++"],"content":"14.8.3 可调用对象与 functionC++中有几种可调用的对象：函数、函数指针、lambda 表达式、bind 创建的对象以及重载了函数调用运算符的类 这些不同类型的可调用对象可能共享一种调用形式，调用形式指明了返回类型以及实参类型，下面是个例子： //普通函数 int add(int i, int j) { return i + j; } //lambda 表达式 auto mod = [](int i, int j) { return i % j; } //函数对象类 struct divide { int operator()(int denominator, int divisor) { return denominator / divisor; } } 上面的几种可调用对象对参数执行了不同的算术运算，它们类型不相同，但是共享同一种调用形式 int(int, int) 我们如果用这些可调用对象构建一个简单的计算器，可以定义一个函数表用于储存这些可调用对象的指针。 可以通过 map 来实现，用运算符符号的string对象作为关键字，实现运算符函数作为值 //构建运算符到函数指针的映射关系，函数接受两个int，返回一个int mapbinops; //正确：add是一个指向正确类型的函数指针 binops.insert({\"+\", add}); //错误：mod不是一个函数指针 binops.insert({\"%\", mod}); 上面的问题在于 mod 是一个 lambda 表达式，与 binops 的值类型不匹配 标准库 function 类型标准库中一个新的类型 function 可以解决上述问题，下面是 function 定义的操作： function 是一个模板，创建一个具体 function 类型时需要指定 function 表示的对象的调用形式，如 function，这里声明了一个 function 类型，它可以接受两个 int，返回一个 int 类型的可调用对象 functionf1 = add; //函数指针 functionf1 = divide();//函数对象类的对象 functionf1 = [](int i, int j) //lambda { return i * j; }; cout binops = { {\"+\", add}, //函数指针 {\"-\", std::minus()}, //标准库定义函数对象 {\"/\", divide()}, //用户定义函数对象 {\"*\", [](int i, int j) { return i * j; }},//未命名lambda表达式 {\"%\", mod} //命名的lambda } map 包含5 个元素，虽然可调用对象类型各不相同，但是仍可以存储在同一个 function类型中，这时可以通过索引 map 得到function 对象的引用 binops[\"+\"](10, 5);//add(10, 5); binops[\"-\"](10, 5);//minus(10, 5) binops[\"/\"](10, 5);//divide对象调用运算符 binops[\"*\"](10, 5);//调用lambda函数对象 binops[\"%\"](10, 5);//调用lambda函数对象 重载的函数与 function我们变不能将重载函数名字存入 function 类型的对象中： int add(int i, int j); Sales_data add(const Sales_data\u0026, const Sales_data\u0026); map binops; binops.insert({\"+\", add}); //错误：哪个add？ 解决上述二义性问题，可以通过一个函数指针，以及 lambda 表达式进行区分 int (*fp)(int, int) = add; binops.insert({\"+\", fp});//正确：fp指向一个正确的add版本 //正确：使用lambda来指定我们希望使用的add版本 binops.insert({\"+\", [](int a, int b) {return add(a, b);}}); ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:8:3","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#重载的函数与-function"},{"categories":["C++"],"content":"14.9 重载、类型转换和运算符","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:9:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#149-重载类型转换和运算符"},{"categories":[],"content":"博客搭建初衷半路转行选手，努力学习中，此博客当作个人学习的一个记录，目前仍在建设中…… ","date":"2022-04-19","objectID":"/about/:0:1","series":null,"tags":[],"title":"关于我","uri":"/about/#博客搭建初衷"},{"categories":[],"content":"这是一条树洞测试 ","date":"2022-04-19","objectID":"/life/%E6%9D%82%E8%AE%B0/:0:0","series":null,"tags":[],"title":"树洞测试","uri":"/life/%E6%9D%82%E8%AE%B0/#"},{"categories":["LeetCode"],"content":"解题思路：本质是遍历图的所有顶点，然后将每个节点深拷贝到新的顶点，图的遍历自然想到DFS和BFS两种方法 问题的关键在于如何深拷贝每个顶点： 首先，用一个哈希表存放旧顶点和新顶点，这样在访问旧顶点的时候，可以快速定位新的顶点 其次，遍历过程中，不能用构造函数直接拷贝每个顶点的邻居，需要单独拷贝 ","date":"2022-04-19","objectID":"/133.%E5%85%8B%E9%9A%86%E5%9B%BE/:0:1","series":null,"tags":["DFS","BFS"],"title":"LC 133.克隆图","uri":"/133.%E5%85%8B%E9%9A%86%E5%9B%BE/#解题思路"},{"categories":["LeetCode"],"content":"代码方法一：DFS class Solution { public: unordered_map\u003cNode*, Node*\u003e vis; //标记旧顶点到新顶点的映射 Node* cloneGraph(Node* node) { if (node == nullptr) return nullptr;//顶点为空的情况 if (vis.find(node) != vis.end()) { //如果发现vis中已经访问过旧顶点，直接返回对应的新顶点 return vis[node]; } Node *clone = new Node(node-\u003eval); //构造一个克隆的新顶点，主要不能直接调用构造函数拷贝邻居 vis[node] = clone; //标记已经访问过当前顶点node，并对应相应的克隆顶点 for (auto \u0026nb : node-\u003eneighbors) { //对每个邻居加入到新的顶点中，进一步调用cloneGraph clone-\u003eneighbors.emplace_back(cloneGraph(nb)); } return clone; //返回克隆的新顶点 } }; 方法二：BFS class Solution { public: Node* cloneGraph(Node* node) { if (node == nullptr) return nullptr; queue\u003cNode*\u003e que; // 用来BFS遍历时，存放顶点 unordered_map\u003cNode*, Node*\u003e vis; // 标记已经访问过的顶点，并映射到克隆的顶点上 Node *clone = new Node(node-\u003eval); // 创建当前顶点的克隆顶点 que.emplace(node); vis[node] = clone; // 标记当前顶点node已经访问过 while (!que.empty()) { Node* p = que.front(); que.pop(); // 取出队首的顶点 for (auto \u0026 nb : p-\u003eneighbors) { if (vis.find(nb) == mp.end()) { //如果邻居没有访问过，加入到队列中，并且存放到哈希表中 vis[nb] = new Node(nb-\u003eval); que.emplace(nb); } mp[p]-\u003eneighbors.emplace_back(vis[nb]);//依次将每个顶点加入到克隆顶点的邻居数组中 } } return mp[node]; // 返回node对应的克隆顶点，也j } }; ","date":"2022-04-19","objectID":"/133.%E5%85%8B%E9%9A%86%E5%9B%BE/:0:2","series":null,"tags":["DFS","BFS"],"title":"LC 133.克隆图","uri":"/133.%E5%85%8B%E9%9A%86%E5%9B%BE/#代码"},{"categories":["数据结构"],"content":"§5.1 二叉树及其表示","date":"2022-04-05","objectID":"/5.1-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E8%A1%A8%E7%A4%BA/:1:0","series":null,"tags":["二叉树"],"title":"5.1 二叉树及其表示","uri":"/5.1-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E8%A1%A8%E7%A4%BA/#51-二叉树及其表示"},{"categories":["数据结构"],"content":"5.1.1 树有根树从图论的角度看，树等价于连通无环图。因此与一般的图相同，树也由一组顶点（vertex） 以及联接与其间的若干条边（edge） 组成。 在计算机科学中，往往还会在此基础上，再指定某一特定顶点，并称之为根（root）。 在指定根节点之后，我们也称之为有根树（rooted tree）。 此时，从程序实现的角度，我们也更多地将顶点称作节点（node）。 深度与层次由树的连通性，每一节点与根之间都有一条路径相联；而根据树的无环性，由根通往每个节点的路径必然唯一。 因此如图5.1所示，沿每个节点 v到根 r 的唯一通路所经过边的数目，称作 v 的深度（depth），记作 depth(v)。 依据深度排序，可对所有节点做分层归类。特别地，约定根节点的深度 depth(r) = 0，故属于第0层。 祖先、后代与子树任一节点 v 在通往树根沿途所经过的每个节点都是其祖先（ancestor），v 是它们的后代（descendant）。 特别地，v 的祖先/后代包括其本身，而v本身以外的祖先/后代称作真祖先（proper ancestor）/ 真后代（proper descendant）。 节点 v 历代祖先的层次，自下而上以 1 为单位逐层递减；在每一层次上，v 的祖先至多一个。 特别地，若节点 u 是 v 的祖先且恰好比 v 高出一层， 则称 u 是 v 的父亲（parent），v 是 u 的孩子（child）。 v 的孩子总数，称作其度数或度（degree），记作 deg(v)。无孩子的节点称作叶节点（leaf），包括根在内的其余节点皆为内部节点（internal node）。 v 所有的后代及其之间的联边称作子树（subtree），记作 subtree(v)。 ![[有根树的逻辑结构.png]] 高度树 T 中所有节点[[5.1 二叉树及其表示#深度与层次|深度]]的最大值称作该树的高度（height），记作height(T)。 特别地，本书约定，仅含单个节点的树高度为0，空树高度为-1。 推而广之，任一节点 v 所对应子树 subtree(v) 的高度，亦称作该节点的高度，记作 height(v)。特别地，全树的高度亦即其根节点 r 的高度，height(T) = height(r)。 ","date":"2022-04-05","objectID":"/5.1-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E8%A1%A8%E7%A4%BA/:1:1","series":null,"tags":["二叉树"],"title":"5.1 二叉树及其表示","uri":"/5.1-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E8%A1%A8%E7%A4%BA/#511-树"},{"categories":["数据结构"],"content":"5.1.1 树有根树从图论的角度看，树等价于连通无环图。因此与一般的图相同，树也由一组顶点（vertex） 以及联接与其间的若干条边（edge） 组成。 在计算机科学中，往往还会在此基础上，再指定某一特定顶点，并称之为根（root）。 在指定根节点之后，我们也称之为有根树（rooted tree）。 此时，从程序实现的角度，我们也更多地将顶点称作节点（node）。 深度与层次由树的连通性，每一节点与根之间都有一条路径相联；而根据树的无环性，由根通往每个节点的路径必然唯一。 因此如图5.1所示，沿每个节点 v到根 r 的唯一通路所经过边的数目，称作 v 的深度（depth），记作 depth(v)。 依据深度排序，可对所有节点做分层归类。特别地，约定根节点的深度 depth(r) = 0，故属于第0层。 祖先、后代与子树任一节点 v 在通往树根沿途所经过的每个节点都是其祖先（ancestor），v 是它们的后代（descendant）。 特别地，v 的祖先/后代包括其本身，而v本身以外的祖先/后代称作真祖先（proper ancestor）/ 真后代（proper descendant）。 节点 v 历代祖先的层次，自下而上以 1 为单位逐层递减；在每一层次上，v 的祖先至多一个。 特别地，若节点 u 是 v 的祖先且恰好比 v 高出一层， 则称 u 是 v 的父亲（parent），v 是 u 的孩子（child）。 v 的孩子总数，称作其度数或度（degree），记作 deg(v)。无孩子的节点称作叶节点（leaf），包括根在内的其余节点皆为内部节点（internal node）。 v 所有的后代及其之间的联边称作子树（subtree），记作 subtree(v)。 ![[有根树的逻辑结构.png]] 高度树 T 中所有节点[[5.1 二叉树及其表示#深度与层次|深度]]的最大值称作该树的高度（height），记作height(T)。 特别地，本书约定，仅含单个节点的树高度为0，空树高度为-1。 推而广之，任一节点 v 所对应子树 subtree(v) 的高度，亦称作该节点的高度，记作 height(v)。特别地，全树的高度亦即其根节点 r 的高度，height(T) = height(r)。 ","date":"2022-04-05","objectID":"/5.1-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E8%A1%A8%E7%A4%BA/:1:1","series":null,"tags":["二叉树"],"title":"5.1 二叉树及其表示","uri":"/5.1-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E8%A1%A8%E7%A4%BA/#有根树"},{"categories":["数据结构"],"content":"5.1.1 树有根树从图论的角度看，树等价于连通无环图。因此与一般的图相同，树也由一组顶点（vertex） 以及联接与其间的若干条边（edge） 组成。 在计算机科学中，往往还会在此基础上，再指定某一特定顶点，并称之为根（root）。 在指定根节点之后，我们也称之为有根树（rooted tree）。 此时，从程序实现的角度，我们也更多地将顶点称作节点（node）。 深度与层次由树的连通性，每一节点与根之间都有一条路径相联；而根据树的无环性，由根通往每个节点的路径必然唯一。 因此如图5.1所示，沿每个节点 v到根 r 的唯一通路所经过边的数目，称作 v 的深度（depth），记作 depth(v)。 依据深度排序，可对所有节点做分层归类。特别地，约定根节点的深度 depth(r) = 0，故属于第0层。 祖先、后代与子树任一节点 v 在通往树根沿途所经过的每个节点都是其祖先（ancestor），v 是它们的后代（descendant）。 特别地，v 的祖先/后代包括其本身，而v本身以外的祖先/后代称作真祖先（proper ancestor）/ 真后代（proper descendant）。 节点 v 历代祖先的层次，自下而上以 1 为单位逐层递减；在每一层次上，v 的祖先至多一个。 特别地，若节点 u 是 v 的祖先且恰好比 v 高出一层， 则称 u 是 v 的父亲（parent），v 是 u 的孩子（child）。 v 的孩子总数，称作其度数或度（degree），记作 deg(v)。无孩子的节点称作叶节点（leaf），包括根在内的其余节点皆为内部节点（internal node）。 v 所有的后代及其之间的联边称作子树（subtree），记作 subtree(v)。 ![[有根树的逻辑结构.png]] 高度树 T 中所有节点[[5.1 二叉树及其表示#深度与层次|深度]]的最大值称作该树的高度（height），记作height(T)。 特别地，本书约定，仅含单个节点的树高度为0，空树高度为-1。 推而广之，任一节点 v 所对应子树 subtree(v) 的高度，亦称作该节点的高度，记作 height(v)。特别地，全树的高度亦即其根节点 r 的高度，height(T) = height(r)。 ","date":"2022-04-05","objectID":"/5.1-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E8%A1%A8%E7%A4%BA/:1:1","series":null,"tags":["二叉树"],"title":"5.1 二叉树及其表示","uri":"/5.1-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E8%A1%A8%E7%A4%BA/#深度与层次"},{"categories":["数据结构"],"content":"5.1.1 树有根树从图论的角度看，树等价于连通无环图。因此与一般的图相同，树也由一组顶点（vertex） 以及联接与其间的若干条边（edge） 组成。 在计算机科学中，往往还会在此基础上，再指定某一特定顶点，并称之为根（root）。 在指定根节点之后，我们也称之为有根树（rooted tree）。 此时，从程序实现的角度，我们也更多地将顶点称作节点（node）。 深度与层次由树的连通性，每一节点与根之间都有一条路径相联；而根据树的无环性，由根通往每个节点的路径必然唯一。 因此如图5.1所示，沿每个节点 v到根 r 的唯一通路所经过边的数目，称作 v 的深度（depth），记作 depth(v)。 依据深度排序，可对所有节点做分层归类。特别地，约定根节点的深度 depth(r) = 0，故属于第0层。 祖先、后代与子树任一节点 v 在通往树根沿途所经过的每个节点都是其祖先（ancestor），v 是它们的后代（descendant）。 特别地，v 的祖先/后代包括其本身，而v本身以外的祖先/后代称作真祖先（proper ancestor）/ 真后代（proper descendant）。 节点 v 历代祖先的层次，自下而上以 1 为单位逐层递减；在每一层次上，v 的祖先至多一个。 特别地，若节点 u 是 v 的祖先且恰好比 v 高出一层， 则称 u 是 v 的父亲（parent），v 是 u 的孩子（child）。 v 的孩子总数，称作其度数或度（degree），记作 deg(v)。无孩子的节点称作叶节点（leaf），包括根在内的其余节点皆为内部节点（internal node）。 v 所有的后代及其之间的联边称作子树（subtree），记作 subtree(v)。 ![[有根树的逻辑结构.png]] 高度树 T 中所有节点[[5.1 二叉树及其表示#深度与层次|深度]]的最大值称作该树的高度（height），记作height(T)。 特别地，本书约定，仅含单个节点的树高度为0，空树高度为-1。 推而广之，任一节点 v 所对应子树 subtree(v) 的高度，亦称作该节点的高度，记作 height(v)。特别地，全树的高度亦即其根节点 r 的高度，height(T) = height(r)。 ","date":"2022-04-05","objectID":"/5.1-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E8%A1%A8%E7%A4%BA/:1:1","series":null,"tags":["二叉树"],"title":"5.1 二叉树及其表示","uri":"/5.1-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E8%A1%A8%E7%A4%BA/#祖先后代与子树"},{"categories":["数据结构"],"content":"5.1.1 树有根树从图论的角度看，树等价于连通无环图。因此与一般的图相同，树也由一组顶点（vertex） 以及联接与其间的若干条边（edge） 组成。 在计算机科学中，往往还会在此基础上，再指定某一特定顶点，并称之为根（root）。 在指定根节点之后，我们也称之为有根树（rooted tree）。 此时，从程序实现的角度，我们也更多地将顶点称作节点（node）。 深度与层次由树的连通性，每一节点与根之间都有一条路径相联；而根据树的无环性，由根通往每个节点的路径必然唯一。 因此如图5.1所示，沿每个节点 v到根 r 的唯一通路所经过边的数目，称作 v 的深度（depth），记作 depth(v)。 依据深度排序，可对所有节点做分层归类。特别地，约定根节点的深度 depth(r) = 0，故属于第0层。 祖先、后代与子树任一节点 v 在通往树根沿途所经过的每个节点都是其祖先（ancestor），v 是它们的后代（descendant）。 特别地，v 的祖先/后代包括其本身，而v本身以外的祖先/后代称作真祖先（proper ancestor）/ 真后代（proper descendant）。 节点 v 历代祖先的层次，自下而上以 1 为单位逐层递减；在每一层次上，v 的祖先至多一个。 特别地，若节点 u 是 v 的祖先且恰好比 v 高出一层， 则称 u 是 v 的父亲（parent），v 是 u 的孩子（child）。 v 的孩子总数，称作其度数或度（degree），记作 deg(v)。无孩子的节点称作叶节点（leaf），包括根在内的其余节点皆为内部节点（internal node）。 v 所有的后代及其之间的联边称作子树（subtree），记作 subtree(v)。 ![[有根树的逻辑结构.png]] 高度树 T 中所有节点[[5.1 二叉树及其表示#深度与层次|深度]]的最大值称作该树的高度（height），记作height(T)。 特别地，本书约定，仅含单个节点的树高度为0，空树高度为-1。 推而广之，任一节点 v 所对应子树 subtree(v) 的高度，亦称作该节点的高度，记作 height(v)。特别地，全树的高度亦即其根节点 r 的高度，height(T) = height(r)。 ","date":"2022-04-05","objectID":"/5.1-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E8%A1%A8%E7%A4%BA/:1:1","series":null,"tags":["二叉树"],"title":"5.1 二叉树及其表示","uri":"/5.1-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E8%A1%A8%E7%A4%BA/#高度"},{"categories":["数据结构"],"content":"5.1.2 二叉树![[Pasted image 20220405161653.png]] 如图5.2所示，二叉树（binary tree）中每个节点的度数均不超过2。 因此在二叉树中，同一父节点的孩子都可以左、右相互区分——此时，亦称作有序二叉树（ordered binary tree）。本书所提到的二叉树，默认地都是有序的。 ","date":"2022-04-05","objectID":"/5.1-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E8%A1%A8%E7%A4%BA/:1:2","series":null,"tags":["二叉树"],"title":"5.1 二叉树及其表示","uri":"/5.1-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E8%A1%A8%E7%A4%BA/#512-二叉树"},{"categories":["数据结构"],"content":"5.1.3 多叉树一般地，树中各节点的孩子数目并不确定。每个节点的孩子均不超过 k 个的有根树，称作 k 叉树（k-ary tree）。 父节点在多叉树中，根节点以外的任一节点有且仅有一个父节点。 将各节点组织为向量或列表，其中每个元素除保存节点本身的信息（data）外，还需要保存父节点（parent）的秩或位置。可为树根指定一个虚构的父节点 -1 或NULL，以便统一判断。 ![[Pasted image 20220405162142.png]] 所有向量或列表所占的空间总量为 O(n)，线性正比于节点总数 n。 时间方面，仅需常数时间，即可确定任一节点的父节点； 但反过来，孩子节点的查找却不得不花费 O(n) 时间访遍所有节点。 孩子节点若注重孩子节点的快速定位，可如图5.4所示，令各节点将其所有的孩子组织为一个向量或列表。如此，对于拥有 r 个孩子的节点，可在 O(r + 1) 时间内列举出其所有的孩子。 ![[Pasted image 20220405162446.png]] 父节点 + 孩子节点以上父节点表示法和孩子节点表示法各有所长，但也各有所短。为综合二者的优势，消除缺点，可如图5.5所示令各节点既记录父节点，同时也维护一个序列以保存所有孩子。 尽管如此可以高效地兼顾对父节点和孩子的定位，但在节点插入与删除操作频繁的场合，为动态地维护和更新树的拓扑结构，不得不反复地遍历和调整一些节点所对应的孩子序列。然而，向量和列表等线性结构的此类操作都需耗费大量时间，势必影响到整体的效率。 ![[Pasted image 20220405162533.png]] 有序多叉树 = 二叉树解决上述难题的方法之一，就是采用支持高效动态调整的二叉树结构。为此，必须首先建立起从多叉树到二叉树的某种转换关系，并使得在此转换的意义下，任一多叉树都等价于某棵二叉树。 当然，为了保证作为多叉树特例的二叉树有足够的能力表示任何一棵多叉树，我们只需给多叉树增加一项约束条件——同一节点的所有孩子之间必须具有某一线性次序。 仿照有序二叉树的定义，凡符合这一条件的多叉树也称作有序树（ordered tree）。通常根节点的分支可以按照字典序排列 长子 + 兄弟由图5.6(a)的实例可见，有序多叉树中任一非叶节点都有唯一的**“长子”** ，而且从该 “长子” 出发，可按照预先约定或指定的次序遍历所有孩子节点。因此可如图(b)所示，为每个节点设置两个指针，分别指向其 “长子” 和下一“ 兄弟” 。 ![[Pasted image 20220405163134.png]] 现在，若将这两个指针分别与二叉树节点的左、右孩子指针统一对应起来，则可进一步地将原有序多叉树转换为如图(c)所示的常规二叉树。 ","date":"2022-04-05","objectID":"/5.1-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E8%A1%A8%E7%A4%BA/:1:3","series":null,"tags":["二叉树"],"title":"5.1 二叉树及其表示","uri":"/5.1-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E8%A1%A8%E7%A4%BA/#513-多叉树"},{"categories":["数据结构"],"content":"5.1.3 多叉树一般地，树中各节点的孩子数目并不确定。每个节点的孩子均不超过 k 个的有根树，称作 k 叉树（k-ary tree）。 父节点在多叉树中，根节点以外的任一节点有且仅有一个父节点。 将各节点组织为向量或列表，其中每个元素除保存节点本身的信息（data）外，还需要保存父节点（parent）的秩或位置。可为树根指定一个虚构的父节点 -1 或NULL，以便统一判断。 ![[Pasted image 20220405162142.png]] 所有向量或列表所占的空间总量为 O(n)，线性正比于节点总数 n。 时间方面，仅需常数时间，即可确定任一节点的父节点； 但反过来，孩子节点的查找却不得不花费 O(n) 时间访遍所有节点。 孩子节点若注重孩子节点的快速定位，可如图5.4所示，令各节点将其所有的孩子组织为一个向量或列表。如此，对于拥有 r 个孩子的节点，可在 O(r + 1) 时间内列举出其所有的孩子。 ![[Pasted image 20220405162446.png]] 父节点 + 孩子节点以上父节点表示法和孩子节点表示法各有所长，但也各有所短。为综合二者的优势，消除缺点，可如图5.5所示令各节点既记录父节点，同时也维护一个序列以保存所有孩子。 尽管如此可以高效地兼顾对父节点和孩子的定位，但在节点插入与删除操作频繁的场合，为动态地维护和更新树的拓扑结构，不得不反复地遍历和调整一些节点所对应的孩子序列。然而，向量和列表等线性结构的此类操作都需耗费大量时间，势必影响到整体的效率。 ![[Pasted image 20220405162533.png]] 有序多叉树 = 二叉树解决上述难题的方法之一，就是采用支持高效动态调整的二叉树结构。为此，必须首先建立起从多叉树到二叉树的某种转换关系，并使得在此转换的意义下，任一多叉树都等价于某棵二叉树。 当然，为了保证作为多叉树特例的二叉树有足够的能力表示任何一棵多叉树，我们只需给多叉树增加一项约束条件——同一节点的所有孩子之间必须具有某一线性次序。 仿照有序二叉树的定义，凡符合这一条件的多叉树也称作有序树（ordered tree）。通常根节点的分支可以按照字典序排列 长子 + 兄弟由图5.6(a)的实例可见，有序多叉树中任一非叶节点都有唯一的**“长子”** ，而且从该 “长子” 出发，可按照预先约定或指定的次序遍历所有孩子节点。因此可如图(b)所示，为每个节点设置两个指针，分别指向其 “长子” 和下一“ 兄弟” 。 ![[Pasted image 20220405163134.png]] 现在，若将这两个指针分别与二叉树节点的左、右孩子指针统一对应起来，则可进一步地将原有序多叉树转换为如图(c)所示的常规二叉树。 ","date":"2022-04-05","objectID":"/5.1-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E8%A1%A8%E7%A4%BA/:1:3","series":null,"tags":["二叉树"],"title":"5.1 二叉树及其表示","uri":"/5.1-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E8%A1%A8%E7%A4%BA/#父节点"},{"categories":["数据结构"],"content":"5.1.3 多叉树一般地，树中各节点的孩子数目并不确定。每个节点的孩子均不超过 k 个的有根树，称作 k 叉树（k-ary tree）。 父节点在多叉树中，根节点以外的任一节点有且仅有一个父节点。 将各节点组织为向量或列表，其中每个元素除保存节点本身的信息（data）外，还需要保存父节点（parent）的秩或位置。可为树根指定一个虚构的父节点 -1 或NULL，以便统一判断。 ![[Pasted image 20220405162142.png]] 所有向量或列表所占的空间总量为 O(n)，线性正比于节点总数 n。 时间方面，仅需常数时间，即可确定任一节点的父节点； 但反过来，孩子节点的查找却不得不花费 O(n) 时间访遍所有节点。 孩子节点若注重孩子节点的快速定位，可如图5.4所示，令各节点将其所有的孩子组织为一个向量或列表。如此，对于拥有 r 个孩子的节点，可在 O(r + 1) 时间内列举出其所有的孩子。 ![[Pasted image 20220405162446.png]] 父节点 + 孩子节点以上父节点表示法和孩子节点表示法各有所长，但也各有所短。为综合二者的优势，消除缺点，可如图5.5所示令各节点既记录父节点，同时也维护一个序列以保存所有孩子。 尽管如此可以高效地兼顾对父节点和孩子的定位，但在节点插入与删除操作频繁的场合，为动态地维护和更新树的拓扑结构，不得不反复地遍历和调整一些节点所对应的孩子序列。然而，向量和列表等线性结构的此类操作都需耗费大量时间，势必影响到整体的效率。 ![[Pasted image 20220405162533.png]] 有序多叉树 = 二叉树解决上述难题的方法之一，就是采用支持高效动态调整的二叉树结构。为此，必须首先建立起从多叉树到二叉树的某种转换关系，并使得在此转换的意义下，任一多叉树都等价于某棵二叉树。 当然，为了保证作为多叉树特例的二叉树有足够的能力表示任何一棵多叉树，我们只需给多叉树增加一项约束条件——同一节点的所有孩子之间必须具有某一线性次序。 仿照有序二叉树的定义，凡符合这一条件的多叉树也称作有序树（ordered tree）。通常根节点的分支可以按照字典序排列 长子 + 兄弟由图5.6(a)的实例可见，有序多叉树中任一非叶节点都有唯一的**“长子”** ，而且从该 “长子” 出发，可按照预先约定或指定的次序遍历所有孩子节点。因此可如图(b)所示，为每个节点设置两个指针，分别指向其 “长子” 和下一“ 兄弟” 。 ![[Pasted image 20220405163134.png]] 现在，若将这两个指针分别与二叉树节点的左、右孩子指针统一对应起来，则可进一步地将原有序多叉树转换为如图(c)所示的常规二叉树。 ","date":"2022-04-05","objectID":"/5.1-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E8%A1%A8%E7%A4%BA/:1:3","series":null,"tags":["二叉树"],"title":"5.1 二叉树及其表示","uri":"/5.1-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E8%A1%A8%E7%A4%BA/#孩子节点"},{"categories":["数据结构"],"content":"5.1.3 多叉树一般地，树中各节点的孩子数目并不确定。每个节点的孩子均不超过 k 个的有根树，称作 k 叉树（k-ary tree）。 父节点在多叉树中，根节点以外的任一节点有且仅有一个父节点。 将各节点组织为向量或列表，其中每个元素除保存节点本身的信息（data）外，还需要保存父节点（parent）的秩或位置。可为树根指定一个虚构的父节点 -1 或NULL，以便统一判断。 ![[Pasted image 20220405162142.png]] 所有向量或列表所占的空间总量为 O(n)，线性正比于节点总数 n。 时间方面，仅需常数时间，即可确定任一节点的父节点； 但反过来，孩子节点的查找却不得不花费 O(n) 时间访遍所有节点。 孩子节点若注重孩子节点的快速定位，可如图5.4所示，令各节点将其所有的孩子组织为一个向量或列表。如此，对于拥有 r 个孩子的节点，可在 O(r + 1) 时间内列举出其所有的孩子。 ![[Pasted image 20220405162446.png]] 父节点 + 孩子节点以上父节点表示法和孩子节点表示法各有所长，但也各有所短。为综合二者的优势，消除缺点，可如图5.5所示令各节点既记录父节点，同时也维护一个序列以保存所有孩子。 尽管如此可以高效地兼顾对父节点和孩子的定位，但在节点插入与删除操作频繁的场合，为动态地维护和更新树的拓扑结构，不得不反复地遍历和调整一些节点所对应的孩子序列。然而，向量和列表等线性结构的此类操作都需耗费大量时间，势必影响到整体的效率。 ![[Pasted image 20220405162533.png]] 有序多叉树 = 二叉树解决上述难题的方法之一，就是采用支持高效动态调整的二叉树结构。为此，必须首先建立起从多叉树到二叉树的某种转换关系，并使得在此转换的意义下，任一多叉树都等价于某棵二叉树。 当然，为了保证作为多叉树特例的二叉树有足够的能力表示任何一棵多叉树，我们只需给多叉树增加一项约束条件——同一节点的所有孩子之间必须具有某一线性次序。 仿照有序二叉树的定义，凡符合这一条件的多叉树也称作有序树（ordered tree）。通常根节点的分支可以按照字典序排列 长子 + 兄弟由图5.6(a)的实例可见，有序多叉树中任一非叶节点都有唯一的**“长子”** ，而且从该 “长子” 出发，可按照预先约定或指定的次序遍历所有孩子节点。因此可如图(b)所示，为每个节点设置两个指针，分别指向其 “长子” 和下一“ 兄弟” 。 ![[Pasted image 20220405163134.png]] 现在，若将这两个指针分别与二叉树节点的左、右孩子指针统一对应起来，则可进一步地将原有序多叉树转换为如图(c)所示的常规二叉树。 ","date":"2022-04-05","objectID":"/5.1-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E8%A1%A8%E7%A4%BA/:1:3","series":null,"tags":["二叉树"],"title":"5.1 二叉树及其表示","uri":"/5.1-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E8%A1%A8%E7%A4%BA/#父节点--孩子节点"},{"categories":["数据结构"],"content":"5.1.3 多叉树一般地，树中各节点的孩子数目并不确定。每个节点的孩子均不超过 k 个的有根树，称作 k 叉树（k-ary tree）。 父节点在多叉树中，根节点以外的任一节点有且仅有一个父节点。 将各节点组织为向量或列表，其中每个元素除保存节点本身的信息（data）外，还需要保存父节点（parent）的秩或位置。可为树根指定一个虚构的父节点 -1 或NULL，以便统一判断。 ![[Pasted image 20220405162142.png]] 所有向量或列表所占的空间总量为 O(n)，线性正比于节点总数 n。 时间方面，仅需常数时间，即可确定任一节点的父节点； 但反过来，孩子节点的查找却不得不花费 O(n) 时间访遍所有节点。 孩子节点若注重孩子节点的快速定位，可如图5.4所示，令各节点将其所有的孩子组织为一个向量或列表。如此，对于拥有 r 个孩子的节点，可在 O(r + 1) 时间内列举出其所有的孩子。 ![[Pasted image 20220405162446.png]] 父节点 + 孩子节点以上父节点表示法和孩子节点表示法各有所长，但也各有所短。为综合二者的优势，消除缺点，可如图5.5所示令各节点既记录父节点，同时也维护一个序列以保存所有孩子。 尽管如此可以高效地兼顾对父节点和孩子的定位，但在节点插入与删除操作频繁的场合，为动态地维护和更新树的拓扑结构，不得不反复地遍历和调整一些节点所对应的孩子序列。然而，向量和列表等线性结构的此类操作都需耗费大量时间，势必影响到整体的效率。 ![[Pasted image 20220405162533.png]] 有序多叉树 = 二叉树解决上述难题的方法之一，就是采用支持高效动态调整的二叉树结构。为此，必须首先建立起从多叉树到二叉树的某种转换关系，并使得在此转换的意义下，任一多叉树都等价于某棵二叉树。 当然，为了保证作为多叉树特例的二叉树有足够的能力表示任何一棵多叉树，我们只需给多叉树增加一项约束条件——同一节点的所有孩子之间必须具有某一线性次序。 仿照有序二叉树的定义，凡符合这一条件的多叉树也称作有序树（ordered tree）。通常根节点的分支可以按照字典序排列 长子 + 兄弟由图5.6(a)的实例可见，有序多叉树中任一非叶节点都有唯一的**“长子”** ，而且从该 “长子” 出发，可按照预先约定或指定的次序遍历所有孩子节点。因此可如图(b)所示，为每个节点设置两个指针，分别指向其 “长子” 和下一“ 兄弟” 。 ![[Pasted image 20220405163134.png]] 现在，若将这两个指针分别与二叉树节点的左、右孩子指针统一对应起来，则可进一步地将原有序多叉树转换为如图(c)所示的常规二叉树。 ","date":"2022-04-05","objectID":"/5.1-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E8%A1%A8%E7%A4%BA/:1:3","series":null,"tags":["二叉树"],"title":"5.1 二叉树及其表示","uri":"/5.1-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E8%A1%A8%E7%A4%BA/#有序多叉树--二叉树"},{"categories":["数据结构"],"content":"5.1.3 多叉树一般地，树中各节点的孩子数目并不确定。每个节点的孩子均不超过 k 个的有根树，称作 k 叉树（k-ary tree）。 父节点在多叉树中，根节点以外的任一节点有且仅有一个父节点。 将各节点组织为向量或列表，其中每个元素除保存节点本身的信息（data）外，还需要保存父节点（parent）的秩或位置。可为树根指定一个虚构的父节点 -1 或NULL，以便统一判断。 ![[Pasted image 20220405162142.png]] 所有向量或列表所占的空间总量为 O(n)，线性正比于节点总数 n。 时间方面，仅需常数时间，即可确定任一节点的父节点； 但反过来，孩子节点的查找却不得不花费 O(n) 时间访遍所有节点。 孩子节点若注重孩子节点的快速定位，可如图5.4所示，令各节点将其所有的孩子组织为一个向量或列表。如此，对于拥有 r 个孩子的节点，可在 O(r + 1) 时间内列举出其所有的孩子。 ![[Pasted image 20220405162446.png]] 父节点 + 孩子节点以上父节点表示法和孩子节点表示法各有所长，但也各有所短。为综合二者的优势，消除缺点，可如图5.5所示令各节点既记录父节点，同时也维护一个序列以保存所有孩子。 尽管如此可以高效地兼顾对父节点和孩子的定位，但在节点插入与删除操作频繁的场合，为动态地维护和更新树的拓扑结构，不得不反复地遍历和调整一些节点所对应的孩子序列。然而，向量和列表等线性结构的此类操作都需耗费大量时间，势必影响到整体的效率。 ![[Pasted image 20220405162533.png]] 有序多叉树 = 二叉树解决上述难题的方法之一，就是采用支持高效动态调整的二叉树结构。为此，必须首先建立起从多叉树到二叉树的某种转换关系，并使得在此转换的意义下，任一多叉树都等价于某棵二叉树。 当然，为了保证作为多叉树特例的二叉树有足够的能力表示任何一棵多叉树，我们只需给多叉树增加一项约束条件——同一节点的所有孩子之间必须具有某一线性次序。 仿照有序二叉树的定义，凡符合这一条件的多叉树也称作有序树（ordered tree）。通常根节点的分支可以按照字典序排列 长子 + 兄弟由图5.6(a)的实例可见，有序多叉树中任一非叶节点都有唯一的**“长子”** ，而且从该 “长子” 出发，可按照预先约定或指定的次序遍历所有孩子节点。因此可如图(b)所示，为每个节点设置两个指针，分别指向其 “长子” 和下一“ 兄弟” 。 ![[Pasted image 20220405163134.png]] 现在，若将这两个指针分别与二叉树节点的左、右孩子指针统一对应起来，则可进一步地将原有序多叉树转换为如图(c)所示的常规二叉树。 ","date":"2022-04-05","objectID":"/5.1-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E8%A1%A8%E7%A4%BA/:1:3","series":null,"tags":["二叉树"],"title":"5.1 二叉树及其表示","uri":"/5.1-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E8%A1%A8%E7%A4%BA/#长子--兄弟"},{"categories":["数据结构"],"content":"二叉树有序有根树 = 二叉树 Binary Tree：节点度数不超过 2 孩子（子树）可以左右区分（有序） lc() ~ lSubtree() rc() ~ rSubtree() 深度为 k 的二叉树，至多有 2^k个节点 n 个节点，高为 h 的二叉树满足 h + 1 \u003c= n \u003c= 2^(h+1) -1 特殊情况： n = h + 1：退化为一条单链 n = 2^(h+1) - 1 ：为满二叉树 基数 设度数为 0、1、2 的节点各有n0、n1、n2个 边数 e = n - 1 = n1 + 2 * n2 1/2 度节点对应于 1/2 条入边 叶节点树 n0 = n2 + 1 n1 与 n0 无关：h = 0 时，1 = 0 + 1；此后，n0与n2同步递增 节点数 n = n0 + n1 + n2 = 1 + n1 + 2n2 当 n1 = 0 时，有 e = 2 * n2 和 n0 = n2 + 1 = (n + 1) / 2 此时，节点数为偶数，不含单分支节点 ![[Pasted image 20220408085600.png]] ","date":"2022-04-05","objectID":"/5.1-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E8%A1%A8%E7%A4%BA/:1:4","series":null,"tags":["二叉树"],"title":"5.1 二叉树及其表示","uri":"/5.1-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E8%A1%A8%E7%A4%BA/#二叉树"},{"categories":["数据结构"],"content":"二叉树有序有根树 = 二叉树 Binary Tree：节点度数不超过 2 孩子（子树）可以左右区分（有序） lc() ~ lSubtree() rc() ~ rSubtree() 深度为 k 的二叉树，至多有 2^k个节点 n 个节点，高为 h 的二叉树满足 h + 1 ","date":"2022-04-05","objectID":"/5.1-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E8%A1%A8%E7%A4%BA/:1:4","series":null,"tags":["二叉树"],"title":"5.1 二叉树及其表示","uri":"/5.1-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E8%A1%A8%E7%A4%BA/#基数"}]
[{"categories":[],"content":"半路转行选手，努力学习中，此博客当作个人学习的一个记录，目前仍在建设中…… ","date":"2022-04-19","objectID":"/about/:0:0","series":null,"tags":[],"title":"关于我","uri":"/about/#"},{"categories":[],"content":"归档界面测试这是一个测试界面 ","date":"2022-04-19","objectID":"/archive/%E5%BD%92%E6%A1%A31/:1:0","series":null,"tags":[],"title":"归档1","uri":"/archive/%E5%BD%92%E6%A1%A31/#归档界面测试"},{"categories":[],"content":"归档界面测试这是一个测试界面 ","date":"2022-04-19","objectID":"/archive/%E5%BD%92%E6%A1%A32/:1:0","series":null,"tags":[],"title":"归档2","uri":"/archive/%E5%BD%92%E6%A1%A32/#归档界面测试"},{"categories":[],"content":"# 测试这是一个树洞树洞测试 ","date":"2022-04-19","objectID":"/memo/%E6%96%B0%E5%BB%BA-markdown/:1:0","series":null,"tags":[],"title":"树洞2","uri":"/memo/%E6%96%B0%E5%BB%BA-markdown/#-测试这是一个树洞"},{"categories":[],"content":"# 测试这是一个树洞树洞测试 ","date":"2022-04-19","objectID":"/memo/%E6%A0%91%E6%B4%9E2/:1:0","series":null,"tags":[],"title":"树洞2","uri":"/memo/%E6%A0%91%E6%B4%9E2/#-测试这是一个树洞"},{"categories":["Algorithm"],"content":"解题思路：本质是遍历图的所有顶点，然后将每个节点深拷贝到新的顶点，图的遍历自然想到DFS和BFS两种方法 问题的关键在于如何深拷贝每个顶点： 首先，用一个哈希表存放旧顶点和新顶点，这样在访问旧顶点的时候，可以快速定位新的顶点 其次，遍历过程中，不能用构造函数直接拷贝每个顶点的邻居，需要单独拷贝 ","date":"2022-04-19","objectID":"/133.%E5%85%8B%E9%9A%86%E5%9B%BE/:0:1","series":null,"tags":["算法"],"title":"133.克隆图","uri":"/133.%E5%85%8B%E9%9A%86%E5%9B%BE/#解题思路"},{"categories":["Algorithm"],"content":"代码方法一：DFS class Solution { public: unordered_map\u003cNode*, Node*\u003e vis; //标记旧顶点到新顶点的映射 Node* cloneGraph(Node* node) { if (node == nullptr) return nullptr;//顶点为空的情况 if (vis.find(node) != vis.end()) { //如果发现vis中已经访问过旧顶点，直接返回对应的新顶点 return vis[node]; } Node *clone = new Node(node-\u003eval); //构造一个克隆的新顶点，主要不能直接调用构造函数拷贝邻居 vis[node] = clone; //标记已经访问过当前顶点node，并对应相应的克隆顶点 for (auto \u0026nb : node-\u003eneighbors) { //对每个邻居加入到新的顶点中，进一步调用cloneGraph clone-\u003eneighbors.emplace_back(cloneGraph(nb)); } return clone; //返回克隆的新顶点 } }; 方法二：BFS class Solution { public: Node* cloneGraph(Node* node) { if (node == nullptr) return nullptr; queue\u003cNode*\u003e que; // 用来BFS遍历时，存放顶点 unordered_map\u003cNode*, Node*\u003e vis; // 标记已经访问过的顶点，并映射到克隆的顶点上 Node *clone = new Node(node-\u003eval); // 创建当前顶点的克隆顶点 que.emplace(node); vis[node] = clone; // 标记当前顶点node已经访问过 while (!que.empty()) { Node* p = que.front(); que.pop(); // 取出队首的顶点 for (auto \u0026 nb : p-\u003eneighbors) { if (vis.find(nb) == mp.end()) { //如果邻居没有访问过，加入到队列中，并且存放到哈希表中 vis[nb] = new Node(nb-\u003eval); que.emplace(nb); } mp[p]-\u003eneighbors.emplace_back(vis[nb]);//依次将每个顶点加入到克隆顶点的邻居数组中 } } return mp[node]; // 返回node对应的克隆顶点，也j } }; ","date":"2022-04-19","objectID":"/133.%E5%85%8B%E9%9A%86%E5%9B%BE/:0:2","series":null,"tags":["算法"],"title":"133.克隆图","uri":"/133.%E5%85%8B%E9%9A%86%E5%9B%BE/#代码"},{"categories":null,"content":"测试 测试1 测试2 测试3 #include \u003ciostream\u003eusing namespace std; int main() { cout \u003c\u003c \"Hello World!\" \u003c\u003c endl; return 0; } 表格测试 测试1 测试2 123 456 789 123 456 789 134 456 789 图片测试 ","date":"2022-04-19","objectID":"/hello_world/:0:0","series":null,"tags":null,"title":"Hello_world","uri":"/hello_world/#测试"}]
[{"categories":["Database","Lab"],"content":"前言我做的是 CMU15-445 2022年秋季版本，目前课程尚未完结，poject和 gradescope 也在慢慢开放中，目前我的进度到Project1 buffer pool，这篇总结一下我做这个实验的基本思路以及遇见的一些坑 首先说一下做这个实验的感受，这个实验大概拖了一个月才完成，中间半个月国庆摸鱼去了。。。大概花了40个多小时才写完，前面十几个小时其实已经写差不多了，最后20多个小时因为一个小bug导致卡了这么长时间，实验的文档和代码注释写的比较清晰了，可能就是前两个 task 涉及的知识点不熟悉的话，需要去网上找找相关资料，知道咋回事之后就没那么难 ","date":"2022-10-12","objectID":"/cmu15-445-project1-buffer-pool/:1:0","series":null,"tags":["CMU15-445"],"title":"CMU15-445 - Project1 Buffer Pool","uri":"/cmu15-445-project1-buffer-pool/#前言"},{"categories":["Database","Lab"],"content":"Task #1 - Extendible Hash Table可以先参考一下这两篇文章大概弄清楚可拓展哈希的原理 【转】动态hash方法（数据库索引技术） - Gwa - 博客园 数据库——可拓展哈希（Extendable Hashing） - 知乎 后来我发现书上好像有这部分内容，刚开始没有书，只能参考博客了，后面去图书馆借了一本。因为也是最开始做的，过了好久了，具体细节也忘记了，这部分就略过吧 ","date":"2022-10-12","objectID":"/cmu15-445-project1-buffer-pool/:2:0","series":null,"tags":["CMU15-445"],"title":"CMU15-445 - Project1 Buffer Pool","uri":"/cmu15-445-project1-buffer-pool/#task-1---extendible-hash-table"},{"categories":["Database","Lab"],"content":"Task #2 - LRU-K Replacement Policy经典的 LRU 在可以先去力扣做一下 146. LRU 缓存，基本思路就是双链表+哈希表，链表记录数据，哈希表记录数据存放在链表中对应的迭代器 LRU-K 的话，网上我看到的说法是用一个历史队列存放访问次数小于k的数据，当访问次数达到k的时候，将数据从历史队列移动到缓存队列中，缓存队列采用LRU算法进行淘汰 最开始我把历史队列也采取LRU策略进行淘汰，然后会发现有问题，仔细看看LRU-K的头文件关于 Evict 方法的描述 最后如果有较多超过 k-distance 的，替换出最早时间戳的 frame，其实就是根据入队列的先后顺序要替换，注意当一个 frame 再次被访问的时候，不需要改变 frame 在历史队列中的顺序，除非访问次数大于等于k，也就是说只需要根据 frame 第一次访问的时间进行 FIFO 替换即可 然后说一下我在这里遇见的一个bug，我是用链表+哈希表模拟队列（即上述的历史队列），这样就可以O(1) 的复杂度记录以及查找 frame 对应的位置，我遇见的问题是我用了一个迭代器从哈希表中查找 frame 的迭代器，然后在访问次数大于等于k的时候，先转移到缓存队列中，然后再删除历史队列的记录，删除的时候我先把哈希表中 frame_id 删除了，然后导致原来的迭代器失效了，我最后又去根据迭代器删除链表中的 frame，就导致删除一个未定义的位置！这个bug卡了我接近20h，开始的时候先在gradescope上面提交发现除了LRU-K通不过其他都能通过，然后我换了个方法实现LRU-K，结果buffer pool一直过不去，我又找了其他已经通过的小伙伴，把他的 buffer pool 拿了过来，发现还是不行，只能说明还是LRU-K有问题，最后回到之前提交的，一调试发现这个bug，这告诉我卡在一个地方的时候一定要进行调试，调试找到问题并解决之后再去做下一个任务，不然可能会花费大量的时间做无用功 ","date":"2022-10-12","objectID":"/cmu15-445-project1-buffer-pool/:3:0","series":null,"tags":["CMU15-445"],"title":"CMU15-445 - Project1 Buffer Pool","uri":"/cmu15-445-project1-buffer-pool/#task-2---lru-k-replacement-policy"},{"categories":["Database","Lab"],"content":"Task #3 - Buffer Pool Manager Instance刚开始做这个的时候没有搞清楚，page_id 和 frame_id 的关系，其实就是 page_id 对应的是磁盘中文件的下标（可以将磁盘抽象看出一个大的数组，page_id 就是数组的下标），而 frame_id 是 Buffer Pool 的下标，这两个很清楚再去看代码框架给的提示就很清晰了 可能会出问题的地方： Unpin 的时候，只有当 is_dirty 是 true 的时候才设置 page 的 dirty标记，如果为 false，不能直接设置，因为可能原来就是 true 创建一个新页和获取一个页面的时候都需要调用 replacer_ 的 RecordAccess 以及 SetEvictable 设置 frame 不可以被替换出 当替换出一个页面的时候如果是脏页需要将数据写回磁盘中 LRU上锁的时候要在一开始就上锁，我写Remove的时候，把find函数写在锁外面了，导致测试时候出现data race的情况，原因是unordered_map本身也不是线程安全的，所以加锁的时候记得要加全局的 其他的感觉可能出现问题的地方比较少，前提是前面两个实现的没有问题（逃 ~） ","date":"2022-10-12","objectID":"/cmu15-445-project1-buffer-pool/:4:0","series":null,"tags":["CMU15-445"],"title":"CMU15-445 - Project1 Buffer Pool","uri":"/cmu15-445-project1-buffer-pool/#task-3---buffer-pool-manager-instance"},{"categories":["Database","Lab"],"content":"小结这部分前前后后加上调试总共花了41.5h，如果早点进行调试估计会少花一半的时间，不得不说调试真的很重要，另外就是多看看提示，很多可能出现问题的地方代码注释都写出来了 最后是完结证明： 写于：2022/10/12 总共实验用时大约41.5h ","date":"2022-10-12","objectID":"/cmu15-445-project1-buffer-pool/:5:0","series":null,"tags":["CMU15-445"],"title":"CMU15-445 - Project1 Buffer Pool","uri":"/cmu15-445-project1-buffer-pool/#小结"},{"categories":["Database","Lab"],"content":"Data RaceData Race是指多个线程在没有正确加锁的情况下，同时访问同一块数据，并且至少有一个线程是写操作，对数据的读取和修改产生了竞争，从而导致各种不可预计的问题。 ","date":"2022-10-12","objectID":"/cmu15-445-project1-buffer-pool/:5:1","series":null,"tags":["CMU15-445"],"title":"CMU15-445 - Project1 Buffer Pool","uri":"/cmu15-445-project1-buffer-pool/#data-race"},{"categories":["Database","Lab"],"content":"前言PROJECT #0 - C++ PRIMER：是要求实现一个支持并发插入键值对的字典树，如果堆字典树不了解可以先看一下 Leetcode 这道题 208. 实现 Trie (前缀树) 写这个 project 一定要好好看看清楚给的提示以及代码当中的注释，写的很详细，根据这些各个函数的功能基本上可以实现。可能需要注意的就是一些 C++11 的语法，像智能指针、移动构造、std::move 函数等这些，如果不了解的话比较难上手，建议提前稍微了解一下，关于并发其实就是上个锁即可，并不涉及比较高级的技巧，这个不需要太担心 ","date":"2022-09-16","objectID":"/cmu15-445-project0-%E5%AD%97%E5%85%B8%E6%A0%91/:1:0","series":null,"tags":["CMU15-445"],"title":"CMU15-445: Project0-字典树","uri":"/cmu15-445-project0-%E5%AD%97%E5%85%B8%E6%A0%91/#前言"},{"categories":["Database","Lab"],"content":"一些问题 首先是移动构造 最开始我也不是很熟悉，但是我把涉及移动构造的都用 std::move 函数进行转移所有权（应该是这样），然后就没啥大问题了，使用 std::move 之后原来的变量就不存在了，不能继续使用了 关于Trie::Insert() 这个函数 最开始理解错了，把每一步都由 TrieNode 转换为 TrieNodeWithValue 了，其实只要到最后一个字符对应的 TrieNode 看看是否需要转换即可 关于 TrieNodeWithValue 和 TrieNode 的转换 这个是运行时多态，可以动态绑定，具体转换我是创建一个新的变量，然后用 std::move 转移所有权（也可以用 std::make_unique 函数直接创建） 关于 Trie::Remove() 函数 个人感觉用迭代会简单点，递归不太好想，而且工程上尽量避免递归吧，可以用 vector 存放父节点模拟一下栈（这里的思路主要参考自这个博客 关于 Trie::GetValue() 函数 最开始写错了，类型不匹配的时候 success 也设置成 true 了 最后的最后卡了我好久的小bug 一直以为我的 Remove 写错了，直到后来发现是 TrieNode::HasChildren() 这个函数实现错了，其实本来很简单，我写成了遍历26个字母分别调用 HasChild 这个函数，后来发现不只是26个字母。。。还有数字啥的，这个错误导致我卡了两三天，一定一定要仔细看提示和代码注释 ","date":"2022-09-16","objectID":"/cmu15-445-project0-%E5%AD%97%E5%85%B8%E6%A0%91/:2:0","series":null,"tags":["CMU15-445"],"title":"CMU15-445: Project0-字典树","uri":"/cmu15-445-project0-%E5%AD%97%E5%85%B8%E6%A0%91/#一些问题"},{"categories":["Database","Lab"],"content":"小Tips本地测试会比gradescope 测试少很多，如果想知道gradescope上面的测试代码，可以根据提交之后上面会显示测试代码的路径，这个时候可以把代码打印出来，就可以知道测试代码了 下面是我打印测试用例的代码，文件名换成其他的应该也可以把其他 project 测试用例打印出来 std::string buffer; std::ifstream in_file(\"/autograder/bustub/test/primer/grading_starter_trie_test.cpp\"); if (in_file.is_open()) { while (!in_file.eof()) { getline(in_file, buffer); std::cout \u003c\u003c buffer \u003c\u003c std::endl; } } in_file.close(); ","date":"2022-09-16","objectID":"/cmu15-445-project0-%E5%AD%97%E5%85%B8%E6%A0%91/:3:0","series":null,"tags":["CMU15-445"],"title":"CMU15-445: Project0-字典树","uri":"/cmu15-445-project0-%E5%AD%97%E5%85%B8%E6%A0%91/#小tips"},{"categories":["Database","Lab"],"content":"完结证明写于：2022/09/19 17:39 总共实验用时大约 12.5h ","date":"2022-09-16","objectID":"/cmu15-445-project0-%E5%AD%97%E5%85%B8%E6%A0%91/:4:0","series":null,"tags":["CMU15-445"],"title":"CMU15-445: Project0-字典树","uri":"/cmu15-445-project0-%E5%AD%97%E5%85%B8%E6%A0%91/#完结证明"},{"categories":["Internet","Lab"],"content":"lab2 主要是实现 TCPReceiver，就是将接收到的 TCPSegment （TCP报文段）写入到我们之前实现的流当中 ","date":"2022-08-01","objectID":"/cs144-2021-lab2/:0:0","series":null,"tags":["cs144"],"title":"CS144-2021 lab2","uri":"/cs144-2021-lab2/#"},{"categories":["Internet","Lab"],"content":"3.1 Translating between 64-bit indexes and 32-bit seqnos我们在lab1实现的 StreamReassembler 重组字符串，每个字符串对应流当中的索引是 64 位的，但是在 TCP 报文段头部中，确认序号（sequence number/seqno）是 32 位的，所以对于大于 32 位的索引我们就无法用 32 位的确认序号存储，就需要进行一定的转换，大于 32 位的索引我们将其对 2^32 取模 实验指导给了个例子，我们要做的就是将 seqno(32位) 和 absolute seqno(64位) 之间进行转换 64 位的 absolute seqno 转为 32位的 seqno 比较好办，直接取模即可 WrappingInt32 wrap(uint64_t n, WrappingInt32 isn) { uint64_t res = (n + static_cast\u003cuint64_t\u003e (isn.raw_value())) % (1UL \u003c\u003c 32); return WrappingInt32{static_cast\u003cuint32_t\u003e (res)}; } 但是对于 32 位的 seqno 转换为 64位的 absolute seqno 就稍微麻烦点，因为比如现在有一个对 5 取模后得到为 3 的数，那么我们可以推出这个数如果可以 8，也可以是 13、18、23、28… 这里也是同样的道理，这里的解决办法就是给一个数，然后根据这个数找到最近的结果，对于上面 5 的例子，如果我们给定 10 的话，那么最近的为 8 （10-8 =2，13 - 10 = 3） 回到实验部分，unwrap 的实现首先我们根据 isn 来找到第 n 个的绝对位置 absqeno（注意这里可能出现负数的情况，但是对于无符号数，负数会变成一个很大的正数），然后我们根据得到的绝对位置和给定的 checkpoint 进行比较，分别相减得到低32位结果和高32位结果，如果低32位小于2^32 / 2 的话 absqeno + k * 2^32 即是离checkpoint 最近的位置，如果大于2^32 / 2 的话 absqeno + (k+1) * 2^32 即是离checkpoint 最近的位置 我画了一个图大概理解一下，就是如果absqeno 和 checkpoint 的低32位差值小于一半的 2^32，那么他们低32位的差加上高32位的差得到的结果就是最小的，如果两个差值大于 2^32 的一半那么 absqeno + 2^32 就是最接近 checkpoint 的（图可能有点抽象，建议和代码结合理解一下） uint64_t unwrap(WrappingInt32 n, WrappingInt32 isn, uint64_t checkpoint) { uint64_t absqeno = static_cast\u003cuint64_t\u003e(n.raw_value() - isn.raw_value()); if (checkpoint \u003c= absqeno) return absqeno; uint64_t k = (checkpoint - absqeno) \u003e\u003e 32; uint64_t lowbit = ((checkpoint - absqeno) \u003c\u003c 32) \u003e\u003e 32; if (lowbit \u003c (1UL \u003c\u003c 31)) { return absqeno + k * (1UL \u003c\u003c 32); } return absqeno + (k + 1) * (1UL \u003c\u003c 32); } ","date":"2022-08-01","objectID":"/cs144-2021-lab2/:1:0","series":null,"tags":["cs144"],"title":"CS144-2021 lab2","uri":"/cs144-2021-lab2/#31-translating-between-64-bit-indexes-and-32-bit-seqnos"},{"categories":["Internet","Lab"],"content":"3.2 Implementing the TCP receiver这个部分就是实现 TCP receiver，感觉最关键的理解要做的 receiver 要做的事情，reveiver 将每次得到的 TCP 报文段根据标志位来决定是否写入 StreamReassembler 中（也就是lab1实现的流组装器），如果要写入的话需要确定写入的下标 先看一下 TCP 首部几个标志位的含义： ACK：确认标记，确认序号有效 SYN：同步标记，表示发起一个新的连接 FIN：结束标记，表示释放一个连接 首先在 TCPReceiver 中定义一个变量 _is_syn 来判断是否发起了新的连接，如果有将报文首部中的序列号（seqno）存入到另外一个变量 _isn 中（这也是初始序号） class TCPReceiver { //! Our data structure for re-assembling bytes. StreamReassembler _reassembler; //! The maximum number of bytes we'll store. size_t _capacity; bool _is_syn = false; WrappingInt32 _isn{0}; public: ... }; 然后是报文段接收函数的实现，详细看注释： void TCPReceiver::segment_received(const TCPSegment \u0026seg) { //得到TCP报文段的头部 TCPHeader header = seg.header(); bool eof = header.fin; //eof标记根据FIN标志来决定 //在发起新的连接之前，所有报文段都丢弃 if (_is_syn == false \u0026\u0026 header.syn == false) { return; } //得到序列号 WrappingInt32 seqno = header.seqno; //如果SYN标记位为真，表示发起一个新的连接 //此时设置对应的变量，序列号也要+1 //序列号加1的原因是syn标记位也占了一位，但是不会写入流当中 if (header.syn) { _is_syn = true; _isn = header.seqno; seqno = seqno + 1; } //获取当前已经写入流当中的字节数，用来推导seqno的下标 uint64_t lastIndex = stream_out().bytes_written(); //利用前面实现的unwrap得到待写入数据的起始下标 uint64_t index = unwrap(seqno, _isn, lastIndex) - 1; //将数据部分写入流当中 _reassembler.push_substring(seg.payload().copy(), index, eof); } 对于 ackno() 函数，如果没有发起新的连接直接返回空，否则的话，如果已经发起新的连接了，将返回下一个准备接收的确认号（这里需要根据加上标记位对应的长度） optional\u003cWrappingInt32\u003e TCPReceiver::ackno() const { //已经发起新的连接了 if (_is_syn) { //这里需要加上SYN标记位的长度 size_t ack = stream_out().bytes_written() + 1; //如果结束了还需要加上FIN标记位的长度 if (stream_out().input_ended()) ack++; return wrap(ack, _isn); } //没有发起连接，返回空 return {}; } 参考资料： CS144计算机网络 Lab2 | Kiprey’s Blog Stanford CS144 Lab2 小结 - 知乎 完结证明： 这个实验代码量不多，但是写正确不是那么容易，我最开始没有理解到位，也是参考了别人的博客才搞清楚要具体干什么，另外就是对TCP三次握手四次挥手不是特别的熟悉，这些标志位也是，需要学习一下理论知识，不然上来直接做实验就是一头雾水 ","date":"2022-08-01","objectID":"/cs144-2021-lab2/:2:0","series":null,"tags":["cs144"],"title":"CS144-2021 lab2","uri":"/cs144-2021-lab2/#32-implementing-the-tcp-receiver"},{"categories":["OS","Lab"],"content":"Large files这个部分是要拓展xv6原来的文件系统，本来的inode是一级的，addrs数组中最后一个元素对应一个间接引用节点的地址，这个节点又包括了256个节点的地址，加上本身的12个节点数据，总共有256+12 = 268个节点，我们要做的就是将这个一级间接引用拓展到二级 最开始我没弄清楚具体要怎么实现，再原有基础上直接加成了二级引用的形式，但是对于原本的inode并没有链接上，后来发现需要再原有的addrs数组进行拓展 首先看一下这几个宏，先将 NDIRECT 个直接块减少 1，给二级引用间接块腾出个空间，这样对应 dinode 和 inode 对应的 addrs 数组为了和原本大小保持一致需要加上 1 //fs.h #define NDIRECT 11 #define NINDIRECT (BSIZE / sizeof(uint)) #define DNINDIRECT ((NINDIRECT) * (NINDIRECT)) #define MAXFILE (NDIRECT + NINDIRECT + DNINDIRECT) struct dinode { short type; // File type short major; // Major device number (T_DEVICE only) short minor; // Minor device number (T_DEVICE only) short nlink; // Number of links to inode in file system uint size; // Size of file (bytes) uint addrs[NDIRECT+2]; // Data block addresses }; //file.c struct inode { uint dev; // Device number uint inum; // Inode number int ref; // Reference count struct sleeplock lock; // protects everything below here int valid; // inode has been read from disk? short type; // copy of disk inode short major; short minor; short nlink; uint size; uint addrs[NDIRECT+2]; }; 然后是修改 bmap ，使其能进行二级映射（看懂原本 bmap 应该不难想到） static uint bmap(struct inode *ip, uint bn) { uint addr, *a; struct buf *bp; if(bn \u003c NDIRECT){ if((addr = ip-\u003eaddrs[bn]) == 0) ip-\u003eaddrs[bn] = addr = balloc(ip-\u003edev); return addr; } bn -= NDIRECT; if(bn \u003c NINDIRECT){ // Load indirect block, allocating if necessary. if((addr = ip-\u003eaddrs[NDIRECT]) == 0) ip-\u003eaddrs[NDIRECT] = addr = balloc(ip-\u003edev); bp = bread(ip-\u003edev, addr); a = (uint*)bp-\u003edata; if((addr = a[bn]) == 0){ a[bn] = addr = balloc(ip-\u003edev); log_write(bp); } brelse(bp); return addr; } bn -= NINDIRECT; if(bn \u003c NINDIRECT * NINDIRECT){ // Load indirect block, allocating if necessary. if((addr = ip-\u003eaddrs[NDIRECT + 1]) == 0) ip-\u003eaddrs[NDIRECT + 1] = addr = balloc(ip-\u003edev); bp = bread(ip-\u003edev, addr); a = (uint*)bp-\u003edata; if((addr = a[bn / NINDIRECT]) == 0){ a[bn / NINDIRECT] = addr = balloc(ip-\u003edev); log_write(bp); } brelse(bp); bp = bread(ip-\u003edev, addr); a = (uint*)bp-\u003edata; if((addr = a[bn % NINDIRECT]) == 0){ a[bn % NINDIRECT] = addr = balloc(ip-\u003edev); log_write(bp); } brelse(bp); return addr; } panic(\"bmap: out of range\"); } 以及将 itrunc 中对应的二级间接块也进行删除 // Truncate inode (discard contents). // Caller must hold ip-\u003elock. void itrunc(struct inode *ip) { int i, j, k; struct buf *bp, *nbp; uint *a, *na; for(i = 0; i \u003c NDIRECT; i++){ if(ip-\u003eaddrs[i]){ bfree(ip-\u003edev, ip-\u003eaddrs[i]); ip-\u003eaddrs[i] = 0; } } if(ip-\u003eaddrs[NDIRECT]){ bp = bread(ip-\u003edev, ip-\u003eaddrs[NDIRECT]); a = (uint*)bp-\u003edata; for(j = 0; j \u003c NINDIRECT; j++){ if(a[j]) bfree(ip-\u003edev, a[j]); } brelse(bp); bfree(ip-\u003edev, ip-\u003eaddrs[NDIRECT]); ip-\u003eaddrs[NDIRECT] = 0; } if(ip-\u003eaddrs[NDIRECT + 1]){ bp = bread(ip-\u003edev, ip-\u003eaddrs[NDIRECT + 1]); a = (uint*)bp-\u003edata; for(j = 0; j \u003c NDIRECT; j++){ if(a[j]) { nbp = bread(ip-\u003edev, a[j]); na = (uint*)nbp-\u003edata; for(k = 0; k \u003c NDIRECT; k++){ if(na[k]) { bfree(ip-\u003edev, na[k]); } } brelse(nbp); bfree(ip-\u003edev, a[j]); a[j] = 0; } } brelse(bp); bfree(ip-\u003edev, ip-\u003eaddrs[NDIRECT + 1]); ip-\u003eaddrs[NDIRECT + 1] = 0; } ip-\u003esize = 0; iupdate(ip); } ","date":"2022-07-30","objectID":"/mit6s.081-lab9-file-system/:1:0","series":null,"tags":["xv6-lab-2021"],"title":"MIT6S.081-Lab9 File system","uri":"/mit6s.081-lab9-file-system/#large-files"},{"categories":["OS","Lab"],"content":"Symbolic links这部分是为xv6添加系统调用 symlink，也就是符号链接 头文件什么的这里就不赘述了，先前也做过好几次，这里主要是系统调用 sys_symlink 的实现以及 sys_open 的修改，最开始我理解的是 symlink 打开一个符号链接文件然后将内容写入到文件 inode 的信息中，后来发现这是创建一个符号链接文件而不是打开一个文件！另外就是我把数据存放在 inode 的 addrs 数组中是直接通过 (char*) 强制类型转换的。。。参考了别人的文章发现这个大问题，原来是有相关的函数将数据写入 inode 中的，还是要好好看一下 xv6 book 代码就不贴了，内容和下面参考资料大差不差 参考资料： Lab9: File system · 6.S081 All-In-One MIT 6.S081 Lab9: file system - 知乎 完结证明： 我发现我好几次测试都会超时，不知道是不是虚拟机的问题，跑的太慢了，在qemu中测试的时候都可以通过，但是就会超时，只能改测试代码的时间限制了…… ","date":"2022-07-30","objectID":"/mit6s.081-lab9-file-system/:2:0","series":null,"tags":["xv6-lab-2021"],"title":"MIT6S.081-Lab9 File system","uri":"/mit6s.081-lab9-file-system/#symbolic-links"},{"categories":["Internet","Lab"],"content":"lab1 StreamReassembler这个 lab 是为了将得到不同的字节流重新组合得到完整的连续的字节信息，我们知道tcp在传输过程中不是将一大段报文直接发送过去，而是分成一小段一小段再发出去，这样的话客户端就需要将不同片段的信息重新组合得到完整的tcp报文，这个实验就是需要我们将不同的片段重新组合一下 最关键的是理解给的那种图，关于字节信息的 蓝色区域：已经接收并且已经排完序 绿色区域：已经排序但是还没有写入到字节流中 红色区域：已经接受但是没有排序 然后就是 capacity 这个字段，感觉有点像是流量控制（这里理论部分我掌握的不是很扎实，大概有这个印象），就是整体字节流大小最多为 capacity 这么大，然后再接受字节流的时候最多宽度为 capacity 我最开始的想法，先维护一个上一个已经排完序的字节流位置 _endid，然后是利用一个哈希表记录每个位置 index 到字符串 data 的映射，这样的话对于每次输入的字符串我们可以通过字符串首字母所在的下标（指整体分段前的下标）和 _endid 来比较看属于哪个区域 如果 index \u003e _endid 的话，说明此时字符串属于红色区域，暂时存储在哈希表中待处理 如果 index \u003c= _endid，说明此时有一部分字符串是从 _endid 开始，这样我们将合适的部分写入给定的 _output 也就是我们lab0 实现的 ByteStream 然后就有了我第一次尝试，下面代码虽然只有两个测试用例通不过，但是存在较大的问题，这里只是记录一下最开始我的想法（可以忽略这部分代码） #include \"stream_reassembler.hh\" // Dummy implementation of a stream reassembler. // For Lab 1, please replace with a real implementation that passes the // automated checks run by `make check_lab1`. // You will need to add private members to the class declaration in `stream_reassembler.hh` template \u003ctypename... Targs\u003e void DUMMY_CODE(Targs \u0026\u0026... /* unused */) {} using namespace std; StreamReassembler::StreamReassembler(const size_t capacity) : _maps(), _endid(0), _output(capacity), _capacity(capacity), eof_index(0), _unassembled_len(0) {} //merge的意思就是可能在插入新的字符串之后之前未排序部分可能空隙刚好补上 //所以这时候根据index从小到达枚举，将合适的字符串长度写入_output中 void StreamReassembler::merge() { size_t real_id, real_len; //枚举哈希表中所有键值对，默认根据index从小到大排序 for (auto it = _maps.begin(); it != _maps.end(); ) { size_t index = it-\u003efirst; string data = it-\u003esecond; // 如果此时字符串起始位置小于等于上一次最后一个下标位置 //并且字符串最终位置大于上一次最后一个下标位置 //说明此时有部分/全部字符可以写入output中 if (index \u003c= this-\u003e_endid \u0026\u0026 index + data.length() \u003e= this-\u003e_endid) { real_id = _endid - index; // 防止超过cap的情况 //！注意这里其实有点问题，因为最开始我把capacity当成了从那张图stream start开始到结尾是capcity，后来才发现是从first unread开始 real_len = min(data.length() - real_id, _capacity - _endid); _output.write(data.substr(real_id, real_len)); _unassembled_len -= real_len; _endid += real_len; ++it; //这里迭代器需要先加一下再删除，不然对应迭代器删除了，无法到达下一个迭代器位置 _maps.erase(index); } else if (index \u003c this-\u003e_endid \u0026\u0026 index + data.length() \u003c this-\u003e_endid) { //这个分支其实多余了 ++it; _maps.erase(index); } else { ++it; } } } //! \\details This function accepts a substring (aka a segment) of bytes, //! possibly out-of-order, from the logical stream, and assembles any newly //! contiguous substrings and writes them into the output stream in order. void StreamReassembler::push_substring(const string \u0026data, const size_t index, const bool eof) { // 如果字符串最后一个位置都小于上一次结尾的下标的话，说明肯定已经写入output了，直接删除即可 if (index \u003c this-\u003e_endid \u0026\u0026 index + data.length() \u003c this-\u003e_endid) { return; } if (!_maps.count(index) || _maps[index].length() \u003c data.length()) { _maps[index] = data; } _unassembled_len += data.length(); merge(); //这里是参考别人的思路，后文有链接 if (eof) { eof_index = index + data.size() + 1; // 注意，这里的+1很重要 } if (_output.bytes_written() + 1 == eof_index) { // 和上面的+1对应上 _output.end_input(); } } //这里我的想法就是，对于哈希表中的字符串都是没有写入output中的，也就是未排序红色部分，然后将他们重叠部分去掉，最后的长度就是没有组装的长度 size_t StreamReassembler::unassembled_bytes() const { size_t total = 0; size_t preid = 0, prelen = 0; for (auto it = _maps.begin(); it != _maps.end(); ++it) { size_t curid = it-\u003efirst, curlen = it-\u003esecond.length(); if (curid \u003c preid + prelen) { total -= preid + prelen - curid; //减掉重叠部分 } total += curlen; preid = curid; prelen = curlen; } // return total; return total; } //这里我就理解错了，以为是整体输出的字节流的为空 //其实是看未组装的部分是否为空 bool StreamReassembler::empty() const { return _maps.empty() \u0026\u0026 _output.buffer_empty(); } 下面是上面对应头文件的声明 class StreamReassembler { private: // Your code here -- add private members as necessary. std::map\u003csize_t, std::string\u003e _maps; size_t _endid; ByteStream _output; //!\u003c The reassembled in-order byte stream size_t _capacity; //!\u003c The maximum number of bytes size_t eof_index; size_t _unassembled_len; void merge(); //... } 第一次的尝试有两个测试用例过不了 这里感觉问题挺多的，所以有了第二次尝试，参考了这两篇文章的思路 Stanford CS144 Lab1 小结 - 知乎 CS144-斯坦福大学计算机网络-lab1实现 - 知乎 第二次尝试，我用的是两个数组，一个数组记录读入的字符串内容，另一个数组表示对应位置的字符串是否有效（避免读入的是空字符串情况），下面是代码 class StreamReasse","date":"2022-07-26","objectID":"/cs144-2021-lab1/:1:0","series":null,"tags":["cs144"],"title":"CS144-2021: lab1","uri":"/cs144-2021-lab1/#lab1-streamreassembler"},{"categories":["Internet","Lab"],"content":"小结lab1 理解了需要实现的内容就不是太难，但是想要完整的写对代码就有点困难了，很多边界条件啥的一开始都没考虑清楚，部分内容的理解上有有点出入，后面还是需要先仔细读一下实验指导书的内容再开始写代码 ","date":"2022-07-26","objectID":"/cs144-2021-lab1/:2:0","series":null,"tags":["cs144"],"title":"CS144-2021: lab1","uri":"/cs144-2021-lab1/#小结"},{"categories":["Internet","Lab"],"content":"关于现代 C++，CS144建议以下几点： Use the language documentation at https://en.cppreference.com as a resource. Never use malloc() or free(). Never use new or delete. Essentially never use raw pointers (*), and use “smart” pointers (unique ptr or shared ptr) only when necessary(You will not need to use these in CS144.) Avoid templates, threads, locks, and virtual functions. (You will not need to use these in CS144.) Avoid C-style strings (char *str) or string functions (strlen(), strcpy()). These are pretty error-prone. Use a std::string instead Never use C-style casts (e.g., (FILE *)x). Use a C++ static cast if you have to (you generally will not need this in CS144). Prefer passing function arguments by const reference (e.g.: const Address \u0026 address). Make every variable const unless it needs to be mutated. Make every method const unless it needs to mutate the object. Avoid global variables, and give every variable the smallest scope possible. Before handing in an assignment, please run make format to normalize the coding style 感觉还是挺严格的，不知道实际工程项目当中是不是也有类似的要求 ","date":"2022-07-24","objectID":"/cs144-2021-lab0/:0:0","series":null,"tags":["cs144"],"title":"CS144-2021: lab0","uri":"/cs144-2021-lab0/#"},{"categories":["Internet","Lab"],"content":"3.4 Writing webget这个就是让我们熟悉一下 Socket 的 API 如何使用，刚开始不太理解，没仔细看实验手册给的链接 仔细看下给的 TCPSocket 的使用发现其实就是首先客户端和服务器建立连接，然后客户端向服务器发送请求，最后读取服务器响应的内容，代码如下： 注意：请求报文的换行是 \\r\\n 并且请求结束时要多加一个换行 void get_URL(const string \u0026host, const string \u0026path) { // Your code here. TCPSocket sock; sock.connect(Address(host, \"http\")); sock.write(\"GET \" + path + \" HTTP/1.1\\r\\n\"); sock.write(\"Host: \" + host + \"\\r\\n\"); sock.write(\"Connection: close\\r\\n\\r\\n\"); // sock.shutdown(SHUT_WR); while (!sock.eof()) { cout \u003c\u003c sock.read(); } sock.close(); // You will need to connect to the \"http\" service on // the computer whose name is in the \"host\" string, // then request the URL path given in the \"path\" string. // Then you'll need to print out everything the server sends back, // (not just one call to read() -- everything) until you reach // the \"eof\" (end of file). // cerr \u003c\u003c \"Function called: get_URL(\" \u003c\u003c host \u003c\u003c \", \" \u003c\u003c path \u003c\u003c \").\\n\"; // cerr \u003c\u003c \"Warning: get_URL() has not been implemented yet.\\n\"; } 完成测试的样子： ","date":"2022-07-24","objectID":"/cs144-2021-lab0/:1:0","series":null,"tags":["cs144"],"title":"CS144-2021: lab0","uri":"/cs144-2021-lab0/#34-writing-webget"},{"categories":["Internet","Lab"],"content":"4 An in-memory reliable byte stream这个就是实现一个可靠的字节流，类似于管道，从一端写入，另外一端读取，这样的话用双端队列 deque 比较合适 下面是添加在头文件中的变量： class ByteStream { private: // Your code here -- add private members as necessary. std::deque\u003cchar\u003e buffer; size_t cap; size_t size = 0; size_t read_len = false; size_t write_len = false; bool input_end = false; // Hint: This doesn't need to be a sophisticated data structure at // all, but if any of your tests are taking longer than a second, // that's a sign that you probably want to keep exploring // different approaches. bool _error{}; //!\u003c Flag indicating that the stream suffered an error. //... } 然后是具体 ByteStream 的实现，比较重要的是 eof 的判断，也是参考了其他博客的思路，当字符流也就是 buffer 为空了，并且没有继续输入的字符也就是 input_end 结束了，就达到 eof 了 然后踩坑的地方：当实现完的时候，以为直接结束了，可以测试，然后一直通不过，也不知道啥原因，后来发现需要先 make 把错误代码改过来，并且编译一下，然后再make check_lab0 就可以测试了 然后就是我写代码过程中发现的错误：C++的列表初始化顺序要和变量定义的顺序一致（感觉之前C++白学了，笑） #include \"byte_stream.hh\" // Dummy implementation of a flow-controlled in-memory byte stream. // For Lab 0, please replace with a real implementation that passes the // automated checks run by `make check_lab0`. // You will need to add private members to the class declaration in `byte_stream.hh` template \u003ctypename... Targs\u003e void DUMMY_CODE(Targs \u0026\u0026... /* unused */) {} using namespace std; ByteStream::ByteStream(const size_t capacity) : buffer(capacity), cap(capacity) { buffer.erase(buffer.begin(), buffer.end()); } size_t ByteStream::write(const string \u0026data) { if (input_end) { return 0; } size_t pre = buffer.size(); for (char c : data) { if (buffer.size() \u003c this-\u003ecap) { buffer.push_back(c); this-\u003ewrite_len++; } else { break; } } return buffer.size() - pre; } //! \\param[in] len bytes will be copied from the output side of the buffer string ByteStream::peek_output(const size_t len) const { string ans; size_t i = 0; for (auto it = buffer.begin(); it != buffer.end() \u0026\u0026 i \u003c len; ++it, ++i) { ans.push_back(*it); } return ans; } //! \\param[in] len bytes will be removed from the output side of the buffer void ByteStream::pop_output(const size_t len) { for (size_t i = 0; i \u003c len \u0026\u0026 !buffer.empty(); i++) { buffer.pop_front(); this-\u003eread_len++; } } //! Read (i.e., copy and then pop) the next \"len\" bytes of the stream //! \\param[in] len bytes will be popped and returned //! \\returns a string std::string ByteStream::read(const size_t len) { string ans; size_t i = 0; for (auto it = buffer.begin(); it != buffer.end() \u0026\u0026 i \u003c len \u0026\u0026 !buffer.empty(); ++it, ++i) { ans.push_back(*it); buffer.pop_front(); this-\u003eread_len++; } return ans; } void ByteStream::end_input() { input_end = true; } bool ByteStream::input_ended() const { return input_end; } size_t ByteStream::buffer_size() const { return buffer.size(); } bool ByteStream::buffer_empty() const { return buffer.empty(); } bool ByteStream::eof() const { return buffer.empty() \u0026\u0026 this-\u003einput_end; } size_t ByteStream::bytes_written() const { return this-\u003ewrite_len; } size_t ByteStream::bytes_read() const { return this-\u003eread_len; } size_t ByteStream::remaining_capacity() const { return this-\u003ecap - buffer.size(); } 完结证明： ","date":"2022-07-24","objectID":"/cs144-2021-lab0/:2:0","series":null,"tags":["cs144"],"title":"CS144-2021: lab0","uri":"/cs144-2021-lab0/#4-an-in-memory-reliable-byte-stream"},{"categories":["Internet","Lab"],"content":"小结lab0 其实花了我挺久的，大概3-4小时，主要是刚开始没反应过来先 make 一下测试代码编译是否正确 ","date":"2022-07-24","objectID":"/cs144-2021-lab0/:3:0","series":null,"tags":["cs144"],"title":"CS144-2021: lab0","uri":"/cs144-2021-lab0/#小结"},{"categories":["OS","Lab"],"content":"Uthread: switching between threads这个实验主要是让我们了解线程上下文切换需要做的哪些内容 大部分内容都可以参照内核态的进程进行上下文切换时保存的寄存器 首先在 uthread.c 中定义用户态线程的上下文（参考proc.h） struct context { uint64 ra; uint64 sp; // callee-saved uint64 s0; uint64 s1; uint64 s2; uint64 s3; uint64 s4; uint64 s5; uint64 s6; uint64 s7; uint64 s8; uint64 s9; uint64 s10; uint64 s11; }; 然后补充用户态线程 thread 的上下文内容 struct thread { char stack[STACK_SIZE]; /* the thread's stack */ int state; /* FREE, RUNNING, RUNNABLE */ struct context ucontext; /* ucontext */ }; user/uthread_switch.S中的 thread_switch 函数和 kernel/swtch.S 内容一致 /* YOUR CODE HERE */ sd ra, 0(a0) sd sp, 8(a0) sd s0, 16(a0) sd s1, 24(a0) sd s2, 32(a0) sd s3, 40(a0) sd s4, 48(a0) sd s5, 56(a0) sd s6, 64(a0) sd s7, 72(a0) sd s8, 80(a0) sd s9, 88(a0) sd s10, 96(a0) sd s11, 104(a0) ld ra, 0(a1) ld sp, 8(a1) ld s0, 16(a1) ld s1, 24(a1) ld s2, 32(a1) ld s3, 40(a1) ld s4, 48(a1) ld s5, 56(a1) ld s6, 64(a1) ld s7, 72(a1) ld s8, 80(a1) ld s9, 88(a1) ld s10, 96(a1) ld s11, 104(a1) ret /* return to ra */ 然后补充 thread_schedule 函数中保存被切换线程寄存器的内容 /* YOUR CODE HERE * Invoke thread_switch to switch from t to next_thread: * thread_switch(??, ??); */ thread_switch(\u0026t-\u003eucontext, \u0026next_thread-\u003eucontext); 注意我的 thread_switch 定义如下，不是原来的 uint64 extern void thread_switch(struct context*, struct context*); 最后就是创建一个线程的时候，在 thread_create 中要保存函数的返回地址和栈指针的内容即可 // YOUR CODE HERE t-\u003eucontext.ra = (uint64)func; // 保存函数返回地址 t-\u003eucontext.sp = (uint64)t-\u003estack + STACK_SIZE; // 保存栈指针 为什么两个线程都丢失了键，而不是一个线程？确定可能导致键丢失的具有2个线程的事件序列。在**answers-thread.txt**中提交您的序列和简短解释。 我的理解，两个线程同时插入的时候，insert 使用头插法，如果第一个线程还没返回，第二个线程就插入会导致第一个线程的数据丢失 ","date":"2022-07-24","objectID":"/mit6s.081-lab6-multithreading/:1:0","series":null,"tags":["xv6-lab-2021"],"title":"MIT6S.081-Lab6: Multithreading","uri":"/mit6s.081-lab6-multithreading/#uthread-switching-between-threads"},{"categories":["OS","Lab"],"content":"Barrier主要理解提示的意思： 你必须处理一系列的barrier调用，我们称每一连串的调用为一轮（round）。bstate.round记录当前轮数。每次当所有线程都到达屏障时，都应增加bstate.round。 这样的话相对于每次当 bstate.nthread 等于 nthread 的时候一轮结束，然后 bstate.round++，否则的话进行等待 您必须处理这样的情况：一个线程在其他线程退出barrier之前进入了下一轮循环。特别是，您在前后两轮中重复使用bstate.nthread变量。确保在前一轮仍在使用bstate.nthread时，离开barrier并循环运行的线程不会增加bstate.nthread。 这里意思对 bstate.nthread 的操作需要是原子的，所以需要在改变的时候上锁，这里直接使用 bstate 自带的互斥锁 barrier_mutex static void barrier() { // YOUR CODE HERE // // Block until all threads have called barrier() and // then increment bstate.round. // pthread_mutex_lock(\u0026bstate.barrier_mutex); // acquire lock ++bstate.nthread; if (bstate.nthread == nthread) { // 所有线程已到达 bstate.round++; bstate.nthread = 0; pthread_cond_broadcast(\u0026bstate.barrier_cond); } else { pthread_cond_wait(\u0026bstate.barrier_cond, \u0026bstate.barrier_mutex); } pthread_mutex_unlock(\u0026bstate.barrier_mutex); // release lock } 完结证明： 感觉这个实验不是特别的难，代码量也不多，最主要是让我们理解多线程中需要进行加锁等操作 ","date":"2022-07-24","objectID":"/mit6s.081-lab6-multithreading/:2:0","series":null,"tags":["xv6-lab-2021"],"title":"MIT6S.081-Lab6: Multithreading","uri":"/mit6s.081-lab6-multithreading/#barrier"},{"categories":["OS","Lab"],"content":"RISC-V assembly 哪些寄存器保存函数的参数？例如，在main对printf的调用中，哪个寄存器保存13？ a0-a7 中存放参数，a2 保存了 13 main的汇编代码中对函数f的调用在哪里？对g的调用在哪里(提示：编译器可能会将函数内联） 如果观看汇编的话，发现好像没有直接调用函数 f ，应该是做了内联优化操作 000000000000001c \u003cmain\u003e: void main(void) { 1c: 1141 addi sp,sp,-16 1e: e406 sd ra,8(sp) 20: e022 sd s0,0(sp) 22: 0800 addi s0,sp,16 printf(\"%d %d\\n\", f(8)+1, 13); 24: 4635 li a2,13 26: 45b1 li a1,12 //这里直接输出12了 28: 00000517 auipc a0,0x0 2c: 7b050513 addi a0,a0,1968 # 7d8 \u003cmalloc+0xea\u003e 30: 00000097 auipc ra,0x0 34: 600080e7 jalr 1536(ra) # 630 \u003cprintf\u003e exit(0); 38: 4501 li a0,0 3a: 00000097 auipc ra,0x0 3e: 27e080e7 jalr 638(ra) # 2b8 \u003cexit\u003e printf函数位于哪个地址？ 0x0000000000000630 在main中printf的jalr之后的寄存器ra中有什么值？ ra 中为0x30，因为 1536 写成16进制为 0x600，而 printf 的地址为 0x630，所以 ra 的值为 0x30 运行以下代码。 unsigned int i = 0x00646c72; printf(\"H%x Wo%s\", 57616, \u0026i); 程序的输出是什么？这是将字节映射到字符的ASCII码表。 输出为 He110 World -\u003e 注意中间是数字110 不是字母 llo 输出取决于RISC-V小端存储的事实。如果RISC-V是大端存储，为了得到相同的输出，你会把i设置成什么？是否需要将57616更改为其他值？ i 需要设置为 0x726c6400，57616 不需要更改 这里为什么输出是这样，首先对与%x 是输出 16 进制 57616 对应的16进制就是 0x110 也就不需要修改 而对于 i = 0x00646c72，如果将它根据ascii码表转化一下就是 \\0dlr ，\\0表示字符串的结尾，由于小端存储，最低有效位放在低地址上，读取的时候从低地址依次往高地址读，依次得到rld\\0，也就是输出 World 这个单词，如果是大端存储就需要反过来了 在下面的代码中，“y=”之后将打印什么(注：答案不是一个特定的值）？为什么会发生这种情况？ printf(\"x=%d y=%d\", 3); 我个人的理解：因为调用printf的时候只传入一个参数，另外一个参数没有设置，而调用的过程中会将寄存器的内容设置到对应的参数，因为少传入一个参数，但是在使用的过程中还是使用了两个寄存器，这就导致另外一个寄存器的值没有经过初始化，可能是在程序其他地方执行过程中保存在寄存器的一个值，所以最后打印输出的是一个不确定的值 ","date":"2022-07-20","objectID":"/mit6s.081-lab4-traps/:1:0","series":null,"tags":["xv6-lab-2021"],"title":"MIT6S.081-Lab4: traps","uri":"/mit6s.081-lab4-traps/#risc-v-assembly"},{"categories":["OS","Lab"],"content":"Backtrace这个实验是需要打印函数调用栈帧的情况，最主要是需要理解给的笔记上的那张栈帧布局图 根据提示： 返回地址位于栈帧帧指针的固定偏移(-8)位置 并且保存的帧指针位于帧指针的固定偏移(-16)位置 XV6在内核中以页面对齐的地址为每个栈分配一个页面 可以利用PGROUNDDOWN(fp)和PGROUNDUP(fp)（参见kernel/riscv.h）来计算栈页面的顶部和底部地址 依次根据栈帧地址，找到并打印输出返回地址，然后找到保存的栈指针地址进行继续循环判断 //kernel/printf.c void backtrace() { printf(\"backtrace:\\n\"); uint64 fp = r_fp(); uint64 up = PGROUNDUP(fp); while (fp != up) { printf(\"%p\\n\", *(uint64*)(fp - 8)); fp = *(uint64*)(fp - 16); } } ","date":"2022-07-20","objectID":"/mit6s.081-lab4-traps/:2:0","series":null,"tags":["xv6-lab-2021"],"title":"MIT6S.081-Lab4: traps","uri":"/mit6s.081-lab4-traps/#backtrace"},{"categories":["OS","Lab"],"content":"Alarm这个实验是要添加一个根据时间周期，CPU 进行中断的功能 ","date":"2022-07-20","objectID":"/mit6s.081-lab4-traps/:3:0","series":null,"tags":["xv6-lab-2021"],"title":"MIT6S.081-Lab4: traps","uri":"/mit6s.081-lab4-traps/#alarm"},{"categories":["OS","Lab"],"content":"test0: invoke handlertest0是根据进程滴答数达到间隔之后，产生中断 首先需要在 proc.h 中给进程定义报警间隔，报警之后处理程序的函数指针和距离上次报警已经经过了多少滴答数 //kernel/proc.h // Per-process state struct proc { int ticks; // 报警间隔 void (*handler) (); // 处理程序函数指针 int tick_cnt; // 据上一次报警已经经过了多少滴答 //... } 然后最主要就是在 trap 里面根据进程的报警滴答数来执行相应的中断操作，观察 usertrap 函数可以发现 p-\u003etrapframe-\u003eepc 保存的是用户的程序计数器，当产生报警的时候，将指令转移到报警处理函数，也就是将报警处理函数的地址设置到 epc 即可 //kernel/trap.c void usertrap(void) { //... // give up the CPU if this is a timer interrupt. if(which_dev == 2) { p-\u003etick_cnt++; if (p-\u003etick_cnt == p-\u003eticks \u0026\u0026 p-\u003eticks != 0 ) { p-\u003etrapframe-\u003eepc = (uint64)p-\u003ehandler; p-\u003etick_cnt = 0; } yield(); } //... } ","date":"2022-07-20","objectID":"/mit6s.081-lab4-traps/:3:1","series":null,"tags":["xv6-lab-2021"],"title":"MIT6S.081-Lab4: traps","uri":"/mit6s.081-lab4-traps/#test0-invoke-handler"},{"categories":["OS","Lab"],"content":"test1/test2(): resume interrupted codetest1和test2需要恢复中断之前的代码，这里中断产生警告之后需要返回到原来警告的地方，也就是需要恢复寄存器的内容，但是可以通过保存原陷入帧的内容，警告之后再恢复，就可以继续运行下去 首先在 proc 结构体中定义额外的 trapframe 和一个标记是否正在报警的变量，在一个变量报警处理程序返回之前，不应该重复调用 struct trapframe alarm_trapframe; // 报警后保存的陷阱帧 int is_alarming; // 是否正在报警 注意需要在 allocproc 和 freeproc 中将对应进程的类型初始化和清空 //allocproc p-\u003etick_cnt = 0; p-\u003einterval = 0; p-\u003ehandler = 0; //p-\u003eis_signal = 0; memset(\u0026p-\u003ealarm_trapframe, 0, sizeof(p-\u003ealarm_trapframe)); //freeproc p-\u003einterval = 0; p-\u003etick_cnt = 0; p-\u003ehandler = 0; //p-\u003eis_signal = 0; memset(\u0026p-\u003ealarm_trapframe, 0, sizeof(p-\u003ealarm_trapframe)); 然后是 sys_sigalarm 和 sys_sigreturn 函数的实现，这里注意sys_sigreturn 在警告处理函数执行完成之后将保存的陷入帧的内容都恢复 //kernel/sysproc.c uint64 sys_sigalarm(void) { int ticks; //报警间隔 uint64 fp; //函数指针的地址 if(argint(0, \u0026ticks) \u003c 0) return -1; if (argaddr(1, \u0026fp) \u003c 0) { return -1; } struct proc *p = myproc(); p-\u003einterval = ticks; p-\u003ehandler = (void(*)())fp; //p-\u003eis_signal = 1; return 0; } uint64 sys_sigreturn(void) { struct proc *p = myproc(); *(p-\u003etrapframe) = p-\u003ealarm_trapframe; p-\u003etick_cnt = 0; return 0; } 最后就是在 trap 中的实现，这里吧 tick_cnt 也用来判断处理程序是否返回，因为是在sys_sigreturn 里设置 的，所以在返回之前 tick_cnt 的值会一直增加也就不会进行if分支当中又一次调用处理程序（这个思路参考来自这里MIT 6.S081 Lab4: traps - 知乎） // give up the CPU if this is a timer interrupt. if(which_dev == 2) { if (p-\u003einterval != 0 ) { if (p-\u003etick_cnt == p-\u003einterval) { p-\u003ealarm_trapframe = *(p-\u003etrapframe); p-\u003etrapframe-\u003eepc = (uint64)p-\u003ehandler; // p-\u003etick_cnt = 0; // p-\u003eis_alarming = 1; } p-\u003etick_cnt++; } yield(); } 完结证明： 其实这里有一个问题，就是我的写的代码运行的很慢，我看了好几份其他人的代码，都尝试了下，不知道为什么就会一直超时（最后索性把测试用例时间改长了一点），包括这篇文章MIT 6.S081 2020 LAB4记录 - 知乎后面说的加上一个额外的变量来控制，也试了下还是超时，在 qemu 里面进行 usertests 都能通过，就不知道问题出在哪 ","date":"2022-07-20","objectID":"/mit6s.081-lab4-traps/:3:2","series":null,"tags":["xv6-lab-2021"],"title":"MIT6S.081-Lab4: traps","uri":"/mit6s.081-lab4-traps/#test1test2-resume-interrupted-code"},{"categories":["OS","Lab"],"content":"Speed up system calls最开始参考实验部分的是课程介绍 · 6.S081 All-In-One，做完打印页表实验后发现没法通过，然后反应过来这个中文翻译是基于xv6-lab-2020的，而我用的代码框架是2021年的，就有一点出入，仔细看了官网的Lab: page tables发现第三个实验页表有点不一样（可能因为20年页表比较难，21年降低了难度） 回到这个实验，这里需要添加的功能是增加一个内核态和用户态共享的一段数据区域，来加快某些系统调用 具体实现是在创建每个进程后，在 USYSCALL（定义在kernel/memlayout.h 中）上映射一个只读页面。在此页面的开头，存储一个结构 usyscall（也在 memlayout.h 中定义），并对其进行初始化以存储当前进程的 PID USYCALL 通过观察定义其实就是 (1L \u003c\u003c (9 + 9 + 9 + 12 - 1)) - 4096 - 4096 - 4096 ，相当于是在最大的地址空间往下分配的第三个大小为4096的页面，它和 TRAPFRAME 这块区域有很大共同之处 //kernel/memlayout.h // MAXVA = (1L \u003c\u003c (9 + 9 + 9 + 12 - 1)) // PGSIZE = 4096 #define TRAMPOLINE (MAXVA - PGSIZE) #define TRAPFRAME (TRAMPOLINE - PGSIZE) #ifdef LAB_PGTBL #define USYSCALL (TRAPFRAME - PGSIZE) struct usyscall { int pid; // Process ID }; #endif 首先由于是创建每个进程都会映射这样的一个页面，所以此时需要在 proc 进程的结构体上定义一个这样的指针，类似于trapframe 结构体 //kernel/proc.h struct proc { struct spinlock lock; //这里用了宏，因为usycall结构体定义的时候就在宏内部 //这里保持一致，下同 #ifdef LAB_PGTBL struct usyscall *usyscall; #endif pagetable_t pagetable; // User page table struct trapframe *trapframe; // data page for trampoline.S //... }; 然后就是在创建进程的时候需要分配这个页面，提示信息也给了：需要在 proc_pagetable() 中执行映射，这里需要用 mappages 来映射这个界面，通过观察函数原型可以发现，mappages 传入参数分别为 页表、起始的虚拟地址、大小、物理地址和标志位 int mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm); 页表和大小不用多说，就是上面已经定义的 pagetable 和 PGSIZE (4096)，对于起始的虚拟地址，由于是在 USYCALL 这里分配的4096个字节的页面，所以就是 USYCALL，物理地址则是进程中的 usyscall 结构体指针对于的地址（可以参照上面的写法），而标志位由于是只读的需要设为 PTE_R ，同时这里是用户态和内核态共享的页面需要设为 PTE_U，最后不难写出如下代码： //kernel/proc.c pagetable_t proc_pagetable(struct proc *p) { //... #ifdef LAB_PGTBL //分配一个用户态和内核态之间的可读区，加速系统调用 if(mappages(pagetable, USYSCALL, PGSIZE, (uint64)(p-\u003eusyscall), PTE_R | PTE_U) \u003c 0){ //下面是分配失败的同时释放已经分配过的页面 uvmunmap(pagetable, TRAMPOLINE, 1, 0); uvmunmap(pagetable, TRAPFRAME, 1, 0); uvmfree(pagetable, 0); return 0; } #endif return pagetable; } 执行映射创建好了就是需要到 allocproc() 中进行初始化和分配页面，主要是仿照上面给 trapframe 初始化和分配的写法，注意需要同时将进程 id 初始化 static struct proc* allocproc(void) { //... // Allocate a trapframe page. if((p-\u003etrapframe = (struct trapframe *)kalloc()) == 0){ freeproc(p); release(\u0026p-\u003elock); return 0; } #ifdef LAB_PGTBL // 分配一个加速系统调用页 if((p-\u003eusyscall = (struct usyscall *)kalloc()) == 0){ freeproc(p); release(\u0026p-\u003elock); return 0; } //进程id初始化 p-\u003eusyscall-\u003epid = p-\u003epid; #endif //... return p; } 既有初始化和分配，肯定也需要释放，在 freeproc() 中执行释放页面操作，仿写即可 static void freeproc(struct proc *p) { if(p-\u003etrapframe) kfree((void*)p-\u003etrapframe); p-\u003etrapframe = 0; //释放加速系统调用页 #ifdef LAB_PGTBL if(p-\u003eusyscall) kfree((void*)p-\u003eusyscall); p-\u003eusyscall = 0; #endif //... } 最后需要在 proc_freepagetable 释放进程的页表和已经映射的页面，不然会报 panic: freewalk: leaf 的错误 void proc_freepagetable(pagetable_t pagetable, uint64 sz) { uvmunmap(pagetable, TRAMPOLINE, 1, 0); uvmunmap(pagetable, TRAPFRAME, 1, 0); #ifdef LAB_PGTBL uvmunmap(pagetable, USYSCALL, 1, 0); #endif uvmfree(pagetable, sz); } ","date":"2022-07-19","objectID":"/mit6s.081-lab3-page-tables/:1:0","series":null,"tags":["xv6-lab-2021"],"title":"MIT6S.081-Lab3: page tables","uri":"/mit6s.081-lab3-page-tables/#speed-up-system-calls"},{"categories":["OS","Lab"],"content":"Print a page table这个实验是需要添加一个打印页表的功能，参考 freewalk 首先枚举512个页表项，对于每一项看是否有效，如果有效进行打印输出，同时判断是否为叶子节点（也就是判断PTE_R|PTE_W|PTE_X 是否都为0），然后就是需要一些递归深度的处理，这里用一个变量，比较容易想到 //kernel//vm.c void _vmprint(pagetable_t pagetable, int level) { // there are 2^9 = 512 PTEs in a page table. for(int i = 0; i \u003c 512; i++) { pte_t pte = pagetable[i]; if((pte \u0026 PTE_V)) { // this PTE points to a lower-level page table. for (int j = 0; j \u003c level; j++) { if (j == 0) { printf(\"..\"); } else { printf(\" ..\"); } } uint64 child = PTE2PA(pte); printf(\"%d: pte %p pa %p\\n\", i, pte, child); if ((pte \u0026 (PTE_R|PTE_W|PTE_X)) == 0) _vmprint((pagetable_t)child, level + 1); } } } void vmprint(pagetable_t pagetable) { printf(\"page table %p\\n\", pagetable); _vmprint(pagetable, 1); } ","date":"2022-07-19","objectID":"/mit6s.081-lab3-page-tables/:2:0","series":null,"tags":["xv6-lab-2021"],"title":"MIT6S.081-Lab3: page tables","uri":"/mit6s.081-lab3-page-tables/#print-a-page-table"},{"categories":["OS","Lab"],"content":"Detecting which pages have been accessed这个实验是检测进程对应的页表是否已经访问过，首先需要我们自己设置 PTE_A 位，通过查看xv6 book 可以发现，页表 A 位在第6号位，所以 PTE_A 就是 1L « 6 然后就是 sys_paaccess 系统调用的实现，首先根据提示获得三个参数，第一个参数为用户页表的起始地址，第二个参数为需要检查的页表数目，第三个参数为用户地址（用来返回数据信息的） 根据提示和之前的实验，可以知道通过 argaddr 能够获取地址，argint 能够获取整数变量，注意传入的参数要与之对应 然后就是根据 walk 函数来查找对应的页表，因为有了用户页表的起始地址，再加上每次循环的个数，就能够得到对应页表的地址，根据这个地址来判断 PET_ A 为是否为1，为1的话将掩码对应的位置置为1，最后根据 copyout 写回用户态即可 #ifdef LAB_PGTBL int sys_pgaccess(void) { // lab pgtbl: your code here. uint64 va; int n; uint64 addr; // user address if(argaddr(0, \u0026va) \u003c 0) return -1; if(argint(1, \u0026n) \u003c 0) return -1; if(argaddr(2, \u0026addr) \u003c 0) return -1; if(va \u003e= MAXVA) panic(\"walk\"); struct proc *p = myproc(); if (p == 0) return 1; pagetable_t pagetable = p-\u003epagetable; uint64 mask = 0; for(int i = 0; i \u003c n; i++) { pte_t *pte = walk(pagetable, (uint64)va + (uint64)PGSIZE * i, 0); if((pte != 0) \u0026\u0026 ((*pte) \u0026 PTE_A)) { mask |= 1 \u003c\u003c i; //清空 PTE_A 位 *pte \u0026= ~PTE_A; } } if (copyout(pagetable, addr, (char *)\u0026mask, sizeof(mask)) \u003c 0) { return -1; } return 0; } #endif 完结证明： lab3 让我对页表机制重新复习了一遍，之前做过南大的PA，页表这方面内容有所接触，不过感觉20年的lab3难一点，有时间可以做一下 参考资料： MIT 6.S081 2020 LAB3记录 - 知乎 ","date":"2022-07-19","objectID":"/mit6s.081-lab3-page-tables/:3:0","series":null,"tags":["xv6-lab-2021"],"title":"MIT6S.081-Lab3: page tables","uri":"/mit6s.081-lab3-page-tables/#detecting-which-pages-have-been-accessed"},{"categories":["OS","Lab"],"content":"System call tracingtrace 的功能就是根据提供的掩码 mask，来跟踪后续执行的系统调用情况，用户级的 trace 将传入的一个数字通过内核态的系统调用 sys_trace 来设置进程的掩码 mask，然后通过 exec 来执行后续的系统调用，通过对提供的 mask 进行判断，如果系统调用是需要跟踪的，则打印输出相关信息 首先根据提示添加系统调用 trace，这个不难 然后根据提示在kernel/sysproc.c中添加一个sys_trace()函数，这个函数将用户态传入的参数保存到 proc 结构体中，所以需要在 kernel/proc.h 中添加一个 int 型变量 mask，然后修改kernel/proc.c 中的 fork() 函数，将父进程的 mask 也拷贝到子进程中，对应代码如下： //kernel/proc.c 中的fork()函数 np-\u003emask = p-\u003emask; 接下来就是内核态的 sys_trace 的实现，通过观察其他函数，可以发现 argint() 这个函数的作用就是将用户态传入的参数拿到内核态来使用，不难写出 sys_trace 的实现，如下： uint64 sys_trace(void) { int n; if(argint(0, \u0026n) \u003c 0) return -1; myproc()-\u003emask = n; return 0; } 最后修改 kernel/syscall.c 中的syscall()函数，从这里可以看出根据这个系统调用的过程是根据提供的数字编号来通过查找static uint64 (*syscalls[])(void) 这个函数指针表来执行相应的系统调用，那么我们只需要在执行完看 num 这个数字对应的系统调用是否是我们需要追踪的即可，由于总共系统调用数量不超过32个，所以可以用一个 int 型变量 mask 来表示需要追踪的系统调用，代码如下 //系统调用名称数组 char *syscall_name[] = { \"\", //注意fork是从1开始的 \"fork\", \"exit\", \"wait\", \"pipe\", \"read\", \"kill\", \"exec\", \"fstat\", \"chdir\", \"dup\", \"getpid\", \"sbrk\", \"sleep\", \"uptime\", \"open\", \"write\", \"mknod\", \"unlink\", \"link\", \"mkdir\", \"close\", \"trace\", }; void syscall(void) { int num; struct proc *p = myproc(); num = p-\u003etrapframe-\u003ea7; if(num \u003e 0 \u0026\u0026 num \u003c NELEM(syscalls) \u0026\u0026 syscalls[num]) { p-\u003etrapframe-\u003ea0 = syscalls[num](); //打印输出syscall情况 if ((p-\u003emask \u003e\u003e num) \u0026 1) { printf(\"%d: syscall %s -\u003e %d\\n\", p-\u003epid, syscall_name[num], p-\u003etrapframe-\u003ea0); } } else { printf(\"%d %s: unknown sys call %d\\n\", p-\u003epid, p-\u003ename, num); p-\u003etrapframe-\u003ea0 = -1; } } ","date":"2022-07-18","objectID":"/mit6s.081-lab2-system-calls/:1:0","series":null,"tags":["xv6"],"title":"MIT6S.081-Lab2: system calls","uri":"/mit6s.081-lab2-system-calls/#system-call-tracing"},{"categories":["OS","Lab"],"content":"Sysinfo这个系统调用是将系统运行的信息返回给用户，前面的添加系统调用函数等等和上面类似 主要来看一下kenel/sysproc.c 中的 sys_sysinfo 这个函数的实现，根据提示先观察kenel/sysfile.c 中的 sys_fstat 这个函数，fstat 是将文件的信息从内核态返回给用户态，sysinfo 基本可以仿照 fstat 来完成 fstat 通过调用 argfd 和 argaddr 函数来初始化结构体 file 也就是文件描述符相关信息，st指的是用户态的指向struct stat的地址，这里用的是64位无符号数表示， argfd 和 argaddr 这两个函数根据提供的参数位置，从寄存器中得到相应的信息 通过观察系统调用int fstat(int fd, struct stat*); 可以发现第一个参数为文件描述符，第二个为 stat 结构体，所以对应 sys_fstat 中 argfd 第一个参数传入的为0，表示从第a0寄存器中获取值然后赋给f，同样的对于argaddr 第一个参数传入1，表示从第a1寄存器中获取值然后赋给st 当得到从用户态传入的参数数据之后，再调用 filestat 来拷贝信息，并且通过 copyout 传回用户态 //kernel/sysfile.c uint64 sys_fstat(void) { struct file *f; uint64 st; // user pointer to struct stat if(argfd(0, 0, \u0026f) \u003c 0 || argaddr(1, \u0026st) \u003c 0) return -1; return filestat(f, st); } //kernel/file.c // Get metadata about file f. // addr is a user virtual address, pointing to a struct stat. int filestat(struct file *f, uint64 addr) { struct proc *p = myproc(); struct stat st; if(f-\u003etype == FD_INODE || f-\u003etype == FD_DEVICE){ ilock(f-\u003eip); stati(f-\u003eip, \u0026st); iunlock(f-\u003eip); if(copyout(p-\u003epagetable, addr, (char *)\u0026st, sizeof(st)) \u003c 0) return -1; return 0; } return -1; } 所以对于 sysinfo 也是采取类似的操作，首先是初始化从用户态得到的参数信息，接着通过 getFreeMem 和 getEmptyProc 得到空闲内存的字节数和 state 字段不为 UNUSED 的进程数，最后利用 copyout 函数将获取的信息传回用户态中 uint64 sys_sysinfo(void) { struct sysinfo info; struct proc *p = myproc(); uint64 addr; //addr 表示从用户态传入的struct sysinfo结构体的地址 if(argaddr(0, \u0026addr) \u003c 0) return -1; info.freemem = getFreeMem(); info.nproc = getEmptyProc(); if(copyout(p-\u003epagetable, addr, (char *)\u0026info, sizeof(info)) \u003c 0) return -1; return 0; } 其中 getFreeMem 和 getEmptyProc 需要我们自己实现，通过观察对应文件其他函数，不难实现，代码如下： //kernel/proc.c uint64 getEmptyProc(void) { uint64 cnt = 0; //计数 struct proc *p; //指向proc进程的指针 //从第一个进程开始，到所有进程表结束，记录不为UNUSED的进程个数 for(p = proc; p \u003c \u0026proc[NPROC]; p++) { if(p-\u003estate != UNUSED) { cnt++; } } return cnt; } //kernel/kalloc.c uint64 getFreeMem(void) { struct run *r; uint64 cnt = 0; //记录空闲链表的个数 r = kmem.freelist; //空闲链表的起始地址 //依次遍历空闲链表 while(r) { r = r-\u003enext; cnt++; } return cnt * PGSIZE; //每个链表的大小为PGSIZE个字节 } 完结证明： lab2 让我对xv6中系统调用的过程更加熟悉，包括如何从用户态读取参数，如何将内核态的信息传回给用户态中，通过读源码的方式能够有效的理解其中的过程，继续加油 ","date":"2022-07-18","objectID":"/mit6s.081-lab2-system-calls/:2:0","series":null,"tags":["xv6"],"title":"MIT6S.081-Lab2: system calls","uri":"/mit6s.081-lab2-system-calls/#sysinfo"},{"categories":["OS","Lab"],"content":"sleep比较容易，主要是看系统调用的掌握，注意main函数传入的参数如何处理 #include \"kernel/types.h\"#include \"kernel/stat.h\"#include \"user/user.h\" int main(int argc, char *argv[]) { if (argc != 2) { printf(\"Usage: sleep time\\n\"); exit(1); } sleep(atoi(argv[1])); //直接调用sleep exit(0); } ","date":"2022-07-17","objectID":"/mit6s.081-lab1xv6-and-unix-utilities/:1:0","series":null,"tags":["xv6"],"title":"MIT6S.081-lab1:Xv6 and Unix utilities","uri":"/mit6s.081-lab1xv6-and-unix-utilities/#sleep"},{"categories":["OS","Lab"],"content":"pingpong这个考察管道和fork的应用，首先对于管道 pipe，它读入一个长度为2的数组，分别作为管道的读入端和写入端，p[0] 表示写入端，p[1]表示读入端，可以用一个宏来定义，避免01区分不清的情况 然后就是创建一个子进程，父进程向管道写入一个字节后，子进程打印输出\u003cpid\u003e: received ping，然后子进程向父进程写入一个字节，父进程打印输出\u003cpid\u003e: received pong，这里我用了 wait，表示父进程等待子进程结束之后再打印输出 //user/pingpong.c #include \"kernel/types.h\"#include \"kernel/stat.h\"#include \"user/user.h\" #define WRITE 0 #define READ 1 int main(int argc, char *argv[]) { if (argc \u003e= 2) { printf(\"Usage: pingpong\\n\"); exit(1); } char buf[2]; //一个缓冲区原来读写 int p[2]; //文件描述符 pipe(p); //创建一个管道 int pid = fork(); //创建一个子进程 if (pid == 0) { read(p[READ], buf, 1);//从管道读取一个字节 close(p[READ]); //关闭管道读端 printf(\"%d: received ping\\n\", getpid()); write(p[WRITE], buf, 1);//向管道写入一个字节 close(p[WRITE]); //关闭管道写端 } else { write(p[WRITE], buf, 1);//向管道写入一个字节 close(p[WRITE]); //关闭管道写端 wait(0); //这里是关键，要到达子进程结束后父进程才继续执行下去 read(p[READ], buf, 1); //从管道读取一个字节 printf(\"%d: received pong\\n\", getpid()); close(p[READ]); //关闭管道写端 } exit(0); } ","date":"2022-07-17","objectID":"/mit6s.081-lab1xv6-and-unix-utilities/:2:0","series":null,"tags":["xv6"],"title":"MIT6S.081-lab1:Xv6 and Unix utilities","uri":"/mit6s.081-lab1xv6-and-unix-utilities/#pingpong"},{"categories":["OS","Lab"],"content":"Primes相比前两个稍微复杂一点，重点是理解给的这张图： 这张图就是先创建一个主进程，然后将数字通过管道依次写入子进程中，由子进程读取来进行处理 子进程再创建一个新的进程，子进程处理时先读到的第一个数字first，然后将后续读到的数字是first倍数的都舍去，将不是first倍数的数字都写入管道中，由子子进程进行递归处理 值得注意的是递归终止的情况，详细见代码，理解了上面的过程就比较好解决了 //user/primes.c #include \"kernel/types.h\"#include \"kernel/stat.h\"#include \"user/user.h\" #define WRITE 1 #define READ 0 void primes(int p[]) { close(p[WRITE]); //关闭原管道的写端 int np[2]; pipe(np); //创建一个新的管道 //两个数分别表示从管道读取的第一个数字，以及接下来的数字 int first = 1, next = 0; //如果此时已经读取不到数字了，关闭管道并且退出 if (read(p[READ], \u0026first, 4) == 0) { close(p[READ]); exit(0); } //如果能读取到数字，打印输出 printf(\"prime %d\\n\", first); int pid = fork(); //创建一个子进程 if (pid == 0) { close(np[WRITE]); //关闭新管道的写端 primes(np); //进入下一层递归调用 close(np[READ]); //关闭新管道的读端 } else { close(np[READ]); //关闭新管道的读端 //从原管道中读取数字，read返回为0，表示已经读取完了 while (read(p[READ], \u0026next, 4) != 0) { //如果读取的数字不能整除读取第一个数字，写入下一层管道 if (next % first != 0) { write(np[WRITE], \u0026next, 4); } } close(p[READ]); //关闭原管道的读端 close(np[WRITE]);//关闭新管道的写端 wait((int*)0); //等待子进程结束 } exit(0); } int main(int argc, char *argv[]) { //参数不符合情况时候返回报错 if (argc \u003e= 2) { printf(\"Usage: primes\\n\"); exit(1); } int p[2]; pipe(p); //创建一个管道 int pid = fork(); //创建一个子进程 if (pid == 0) { close(p[WRITE]);//关闭管道的写端 primes(p); //进行递归调用 } else { close(p[READ]);//关闭管道的读端 //依次将2-35写入到管道中，由子进程进行进一步处理 for (int i = 2; i \u003c= 35; ++i) { write(p[WRITE], \u0026i, 4); } close(p[WRITE]);//关闭管道的写端 wait((int*)0); //等待子进程结束 } exit(0); } ","date":"2022-07-17","objectID":"/mit6s.081-lab1xv6-and-unix-utilities/:3:0","series":null,"tags":["xv6"],"title":"MIT6S.081-lab1:Xv6 and Unix utilities","uri":"/mit6s.081-lab1xv6-and-unix-utilities/#primes"},{"categories":["OS","Lab"],"content":"find基本上就是在 user/ls.c 基础上改过来的，要理解其中 char* fmtname(char *path) 函数的作用，它传入一个文件名（包括前面的目录），然后取最后一个 / 之后的文件名，例如a/b/c 最后取出来的是 c //user/find.c #include \"kernel/types.h\"#include \"kernel/stat.h\"#include \"user/user.h\"#include \"kernel/fs.h\" char* fmtname(char *path) { char *p; // Find first character after last slash. for(p=path+strlen(path); p \u003e= path \u0026\u0026 *p != '/'; p--) ; p++; return p; //直接返回/下一个字符，ls中在结尾添加了空格，这里不需要 } void find(char *path, char *filename) { char buf[512], *p; int fd; struct dirent de; struct stat st; //打开文件，如果失败直接报错 if((fd = open(path, 0)) \u003c 0){ fprintf(2, \"find: cannot open %s\\n\", path); return; } //查看文件的信息，失败则报错 if(fstat(fd, \u0026st) \u003c 0){ fprintf(2, \"find: cannot stat %s\\n\", path); close(fd); return; } //st.type为此时文件的类型 switch(st.type){ //当fd指向的是文件类型，进行比较 case T_FILE: //如果比较发现是要查找的文件名，打印输出 if (strcmp(fmtname(path), filename) == 0) { printf(\"%s\\n\", path); } break; //如果fd指向的是目录类型，需要进一步处理 case T_DIR: if(strlen(path) + 1 + DIRSIZ + 1 \u003e sizeof buf){ printf(\"find: path too long\\n\"); break; } strcpy(buf, path); //将此时路径拷贝到buf上 p = buf+strlen(buf);//p指向buf结尾的位置 *p++ = '/'; //在buf结尾加上/，并且p指向下一个位置，先*p = '/'，再p++ //读取目录中的每一个文件 while(read(fd, \u0026de, sizeof(de)) == sizeof(de)){ //de.inum是所有文件的根目录的情况，.是当前目录本身，..是当前目录的父目录，都需要特判 if(de.inum == 0 || strcmp(de.name, \".\") == 0 || strcmp(de.name, \"..\") == 0) continue; //将此时文件名拷贝到p指向的位置，也就是buf后面接上文件名 memmove(p, de.name, DIRSIZ); p[DIRSIZ] = 0; //字符串加上末端的0 //打开此时的绝对路径，如果失败则跳过 if(stat(buf, \u0026st) \u003c 0){ printf(\"find: cannot stat %s\\n\", buf); continue; } //将此时绝对路径buf，进入下一层递归查找 find(buf, filename); // printf(\"%s\\n\", fmtname(buf)); } break; } close(fd); } int main(int argc, char *argv[]) { if(argc == 2) { find(\".\", argv[1]); } else if (argc == 3) { find(argv[1], argv[2]); } else { fprintf(2, \"Usage: find path file\\n\"); exit(1); } exit(0); } ","date":"2022-07-17","objectID":"/mit6s.081-lab1xv6-and-unix-utilities/:4:0","series":null,"tags":["xv6"],"title":"MIT6S.081-lab1:Xv6 and Unix utilities","uri":"/mit6s.081-lab1xv6-and-unix-utilities/#find"},{"categories":["OS","Lab"],"content":"xargs这个命令在 Linux 详细用法参考xargs 命令教程 - 阮一峰的网络日志 这里不需要设置额外的参数，只需要将标准输入中的内容读取到参数列表的后面，然后创建一个子进程执行即可 //user/xargs.c #include \"kernel/types.h\"#include \"kernel/stat.h\"#include \"user/user.h\"#include \"kernel/param.h\" int main(int argc, char *argv[]) { if (argc \u003c 2) { fprintf(2, \"Usage: xargs cmd...\\n\"); exit(1); } char buf[1024]; char *argvs[MAXARG]; // memcpy(\u0026argvs[0], \u0026argv[1], sizeof(argv[0]) * (argc - 1)); for (int i = 1; i \u003c argc; ++i) { argvs[i - 1] = argv[i]; } while (1) { int size = 0; //表示从标准输入中读取的字节数目 //从标准输入中一个字节一个字节读取 while (read(0, \u0026buf[size], 1) != 0) { //遇见/n 跳出 if (buf[size] == '\\n') break; ++size; } //如果一个字节都没读取到，说明标准输入内容已经读取完了 if (size == 0) break; buf[size] = 0; //buf结尾置为0 //将从标准输入读取的一行内容放入到argvs末尾中 argvs[argc - 1] = buf; //创建一个子进程，利用exec执行 if (fork() == 0) { exec(argv[1], argvs); exit(0); } wait(0); //等待父进程结束 memset(buf, 0, 1024); //将buf清空 } exit(0); } 这应该是第三次做lab1了，前两次都止步于lab3，这次打算完成学（抄）一遍 完结证明： 参考资料： MIT 6.S081 2020 LAB1记录 - 知乎 ","date":"2022-07-17","objectID":"/mit6s.081-lab1xv6-and-unix-utilities/:5:0","series":null,"tags":["xv6"],"title":"MIT6S.081-lab1:Xv6 and Unix utilities","uri":"/mit6s.081-lab1xv6-and-unix-utilities/#xargs"},{"categories":["Lab"],"content":"前言PA3 存储管理，3-1对cache进行了简单的模拟，3-2开启了类似80386的保护机制，3-3实现了分页机制（虚拟地址转换） PA4-1是异常控制流，4-2是外设和IO的模拟 ","date":"2022-07-17","objectID":"/nju-ics2020-pa3-1-%E5%B0%8F%E7%BB%93/:1:0","series":null,"tags":["ICS","PA"],"title":"NJU-ICS2020 | PA3-1 小结","uri":"/nju-ics2020-pa3-1-%E5%B0%8F%E7%BB%93/#前言"},{"categories":["Lab"],"content":"PA 3-1 Cache的模拟cache原理部分可以看下Cache 的基本工作原理 具体实验要求如下： cache block存储空间的大小为64B cache存储空间的大小为64KB 8-way set associative 标志位只需要valid bit即可 替换算法采用随机方式 write through not write allocate 采用的是8路组相联，随机替换算法和回写法，回写分配法 由于 cache 大小 64KB，每个 cache block 大小是 64B，所以总共有 1024 个 cache 行，也就是可以定义一个1024大小的 CacheLine 数组 关于 CacheLine 的定义如下： typedef struct cacheLine { bool valid; // 1位 标志位 uint32_t tag; //tag 19位 32 - 6 - 7 uint8_t data[64]; //data 6位 64 = 2^6 }CacheLine; 关于主存块地址的分析： 数据大小是64B，而 64 = 2^6，所以对应主存块中的块内地址有6位 而cache总共2^10 = 1024 行，每组分成了 2^3 = 8行，总共也就有2^(10 - 3) = 128 组，则对应主存块中 cache 组号有 7 位 所以对于32位地址的主存来说，最后标志位有19位 详细有注释的实现代码如下：（注意cache读写跨行的情况） #include \"memory/memory.h\" #include \u003cstdlib.h\u003e#include \u003ctime.h\u003e CacheLine caches[1024]; // init the cache void init_cache() { // implement me in PA 3-1 // 1024 cache line for (int i = 0; i \u003c 1024; ++i) { caches[i].valid = false; caches[i].tag = 0; memset(caches[i].data, 0, 64); } } // write data to cache void cache_write(paddr_t paddr, size_t len, uint32_t data) { uint32_t addr = paddr \u0026 0x3f; // trancut lower 6 bit uint32_t line_id = (paddr \u003e\u003e 6) \u0026 0x7f; // cacheline group id uint32_t tag = paddr \u003e\u003e 13; //tag int k = line_id * 8; //record the hit caches for (int i = k; i \u003c k + 8; i++) { //如果命中 if (caches[i].valid == true \u0026\u0026 caches[i].tag == tag) { if (addr + len \u003c= 64) { //update block 将数据data写入主存中 memcpy(hw_mem + paddr, \u0026data, len); //update cache line 并且更新cache行中的数据 memcpy(caches[i].data + addr, \u0026data, len); caches[i].tag = tag; caches[i].valid = true; } else { int cur_len = 64 - addr; //当前行剩余长度 int next_len = len - cur_len;//下一行读取的长度 memcpy(hw_mem + paddr, \u0026data, len); cache_write(paddr, cur_len, data); cache_write(paddr + cur_len, next_len, data\u003e\u003e(cur_len * 8)); } return; } } //没有命中,只写入主存中，不在cache行中添加 memcpy(hw_mem + paddr, \u0026data, len); } // read data from cache uint32_t cache_read(paddr_t paddr, size_t len) { uint32_t addr = paddr \u0026 0x3f; // 块内地址，低 6 位 uint32_t line_id = (paddr \u003e\u003e 6) \u0026 0x7f; // cache组内号 uint32_t tag = paddr \u003e\u003e 13; //tag标志位 int cnt = 0, k = line_id * 8; //k是对于组的起始位置，由于8个一组，第line_id组个cache行对应的即为实际的第8*line_id个 uint32_t ret = 0; //返回地址 //枚举组内8个cache行 for (int i = k; i \u003c k + 8; i++) { //如果cache有效 if (caches[i].valid == true) { //cnt用来记录一组中cache行有效的个数 //cnt==8说明这组cache满了，需要采取替换策略 cnt++; //并且标志位也对应，也即是命中的情况 if (caches[i].tag == tag) { //没有跨行情况 if (addr + len \u003c= 64) { //从最后一个字往前读取 for (int t = len - 1; t \u003e= 0; t--) { if (t != len - 1) ret \u003c\u003c= 8; ret += caches[i].data[addr + t]; } break; } else { //跨行的情况 int cur_len = 64 - addr; //当前行剩余长度 int next_len = len - cur_len;//下一行读取的长度 //将这一行所有的地址都读取完 ret = cache_read(paddr, cur_len); //从下一行开始地址开始读取 next_len 个字节 uint32_t next_data = cache_read(paddr + cur_len, next_len); //移动8 * cur_len位，再加上上一行的数据 next_data \u003c\u003c= 8 * cur_len; ret += next_data; //printf(\"now 跨行, and ret = %u\\n\", ret); } return ret; } } } //cache group is full and not hit, random replace //cnt == 8 说明待读取的cache组已经满了，需要随机算法换出 if (cnt == 8) { //ret = hw_mem_read(paddr, len); //从主存块中读取内容，并设置到ret中 memcpy(\u0026ret, hw_mem + paddr, len); //printf(\"cache满了情况下 ret = %u\\n\", ret); srand((unsigned)time(NULL)); //设置随机数种子 int insert = k + (rand() % 8); //找到随机替换的位置 //将主存块中内容写入cache行中，注意是一整行64 memcpy(caches[insert].data, hw_mem + paddr - addr, 64); caches[insert].valid = true; caches[insert].tag = ret \u003e\u003e 13; } else { //cache缺失, 并且没有满 //从主存块中读取内容，并设置到ret中 memcpy(\u0026ret, hw_mem + paddr, len); //printf(\"cache缺失情况下 ret = %u\\n\", ret); //将主存块中内容写入cache行中，注意是一整行64 for (int i = k; i \u003c k + 8; i++) { if (caches[i].valid == false) { memcpy(caches[i].data, hw_mem + paddr - addr, 64); caches[i].valid = true; caches[i].tag = ret \u003e\u003e 13; } } } return ret; } ","date":"2022-07-17","objectID":"/nju-ics2020-pa3-1-%E5%B0%8F%E7%BB%93/:2:0","series":null,"tags":["ICS","PA"],"title":"NJU-ICS2020 | PA3-1 小结","uri":"/nju-ics2020-pa3-1-%E5%B0%8F%E7%BB%93/#pa-3-1-cache的模拟"},{"categories":["Lab"],"content":"小结PA3-1算是完整的完成了，对于后面的实验内容，发现PA3-2虽然能跑起来，但是好像实现的有问题（自己写的太简单了）。PA3-3之后的内容也没很认真的完成，到了3-3开启虚拟地址空间后，由于前面存在的一些指令的bug，导致PA3-3在运行的时候一直出现段错误，一时也没找到解决的办法，PA4就在别人代码基础上跑了一下 至此PA先告一段落了，后面有机会打算学习一下jyy版本的PA，顺便补一下计算机系统基础理论知识 ","date":"2022-07-17","objectID":"/nju-ics2020-pa3-1-%E5%B0%8F%E7%BB%93/:3:0","series":null,"tags":["ICS","PA"],"title":"NJU-ICS2020 | PA3-1 小结","uri":"/nju-ics2020-pa3-1-%E5%B0%8F%E7%BB%93/#小结"},{"categories":["计算机基础"],"content":"局部性原理时间局部性：指被访问的某个存储单元在一个较短的时间内很可能还会继续被访问 空间局部性：被访问的某个存储单元临近的单元在一个较短时间内很可能被访问 ","date":"2022-07-05","objectID":"/cache-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/:1:0","series":null,"tags":["cache"],"title":"Cache 的基本工作原理","uri":"/cache-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/#局部性原理"},{"categories":["计算机基础"],"content":"cache 基本工作原理cache 是一个小容量的高速缓冲存储器，在 CPU 和主存内部设置 cache 根据局部性原理，CPU访问指令和数据时可以直接从 cache 中读取，而不必到主存内部进行读取，cache 能减少不必要的访问主存，加快读取速度 cache 和主存空间被划分为相等的区域，便于 cache 和主存间交换信息 主存中按照一定的字节划分为一个区域（假定这里是 512 字节），这个区域称为主存块（简称块），而 cache 中存放这样的一个主存块的区域称为 cache 行（简称行） 有了 cache 之后 CPU 的访问过程： 先检查 cache 中有没有要访问的信息 如果有，直接在 cache 中读写 没有，从主存中读写，并且把当前访问的信息复制到 cache 中 在访问的过程中，如果 CPU 需要访问单元所在的主存 cache 中，则称之为 cache 命中，否则称为不命中 那么 CPU 在访问的过程中如何知道 cache 是否命中呢？ ","date":"2022-07-05","objectID":"/cache-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/:2:0","series":null,"tags":["cache"],"title":"Cache 的基本工作原理","uri":"/cache-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/#cache-基本工作原理"},{"categories":["计算机基础"],"content":"cache 行和主存块的映射想要知道 cache 是否命中，cache 和主存块之间需要有个对应的映射关系 主存块和 cache 行之间主要要三种映射关系： 直接映射：每个主存块映射到 cache 固定的行中 全相联：每个主存块映射到 cache 的任意行 组相联：每个主存块映射到 cache 的固定组的任意行中 ","date":"2022-07-05","objectID":"/cache-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/:3:0","series":null,"tags":["cache"],"title":"Cache 的基本工作原理","uri":"/cache-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/#cache-行和主存块的映射"},{"categories":["计算机基础"],"content":"直接映射基本思路是：把主存的每一块映射到固定的 cache 中，也称之为模映射，对应关系如下： cache 行号 = 主存块号 mod cache行数 假设 cache 有2^c 行，主存块有 2^m 块，主存块大小位 2^b 字节，则 cache 行占 c 位，主存块号占 m 位，块内地址有 b 位，m位的主存块号被分为标记字段和 cache 行号字段 下面是主存块和 cache 行之间的映射关系图： ","date":"2022-07-05","objectID":"/cache-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/:3:1","series":null,"tags":["cache"],"title":"Cache 的基本工作原理","uri":"/cache-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/#直接映射"},{"categories":["计算机基础"],"content":"全相联映射全相联映射是将主存块装入到 cache 的任意行中，查找过程中，需要比较所有 cache 行的标记，主存地址只有标记和块内地址两个字段 ","date":"2022-07-05","objectID":"/cache-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/:3:2","series":null,"tags":["cache"],"title":"Cache 的基本工作原理","uri":"/cache-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/#全相联映射"},{"categories":["计算机基础"],"content":"组相联映射组相联映射将 cache 分成大小相等的组，每个主存块被映射到 cache 固定组的任意一，映射关系如下： cache 组号 = 主存块号 mod cache 组数 假设 cache 有 2^c 行，分成 2^q 组，每组有 2^(c-q) 行，设 s = c - q，则cache 映射方式称为 2^s 路组相联映射 如果主存块有2^m 块，大小为 2^b 字节，按照字节编制则，块内地址有 b 位，cache 组号有 q 位，标记和 cache 组号共 m 位，标记 t = m - q位 例子：主存块和 cache 之间按照 2 路组相联映射，块大小512字，cache 数据区容量位 8K 字，主存地址空间为 1M字。问：主存地址如何划分？并说明CPU 对主存单元 01202H 的访问过程 解：cache 数据容量为 8K = 2^13 字 = 2^3组 * 2^1 行/组 * 512字/行 主存地址空间为 1M 字 = 2^20 字 = 2^11块 * 512字/块 = 2^8组群 * 2^3块/组群 * 512 字/块 主存地址位数 n为 20，组号位数 q = 3，标记位t = 8 位，块内地址 b = 9 位 主存地址01202H 二进制为 0000 0001 0010 0000 0010，主存地址划分为： 访问过程： 根据中间3位 001，找到 cache 第一组 将标记位 0000 0001 与第一组 cache 中的两行进行比较 如果相等并且有效位为 1，则命中，此时将低9位块内地址对应行中取出单元内容送到 CPU 中 如果都不相等，或有一个相等但有效位为0，则不命中，此时将01202H单元所在的主存第 0000 0001 001块复制到 cache 第001组中任意一个空闲行中，有效位设置为1，标记设为 0000 0001 ","date":"2022-07-05","objectID":"/cache-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/:3:3","series":null,"tags":["cache"],"title":"Cache 的基本工作原理","uri":"/cache-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/#组相联映射"},{"categories":["计算机基础"],"content":"cache 中主存块的替换算法cache 行数比主存块数小，多个主存块可能会映射到同一个 cache 行中，一旦cache 中对应的行满了，需要考虑淘汰掉一个cache 行中的主存块 如果说新的主存块可以放在多个cache 行中，具体需要调出哪一个块，就是淘汰策略问题，主要包括：先进先出（FIFO）、最近最少使用（LRU）、最不经常使用（LFU）和随机替换等 ","date":"2022-07-05","objectID":"/cache-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/:4:0","series":null,"tags":["cache"],"title":"Cache 的基本工作原理","uri":"/cache-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/#cache-中主存块的替换算法"},{"categories":["计算机基础"],"content":"先进先出算法基本思想是：选择最早装入 cache 的主存块替换掉 ","date":"2022-07-05","objectID":"/cache-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/:4:1","series":null,"tags":["cache"],"title":"Cache 的基本工作原理","uri":"/cache-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/#先进先出算法"},{"categories":["计算机基础"],"content":"最近最少使用算法基本思路是：选择近期最少使用的主存块被替换掉，这种算法能够正确反映访问的局部性，但是实现起来稍微复杂 ","date":"2022-07-05","objectID":"/cache-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/:4:2","series":null,"tags":["cache"],"title":"Cache 的基本工作原理","uri":"/cache-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/#最近最少使用算法"},{"categories":["计算机基础"],"content":"最不经常使用算法基本思路：替换掉 cache 中引用次数最少的块 ","date":"2022-07-05","objectID":"/cache-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/:4:3","series":null,"tags":["cache"],"title":"Cache 的基本工作原理","uri":"/cache-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/#最不经常使用算法"},{"categories":["计算机基础"],"content":"随机替换算法从候选的主存块中随机选取一个淘汰 ","date":"2022-07-05","objectID":"/cache-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/:4:4","series":null,"tags":["cache"],"title":"Cache 的基本工作原理","uri":"/cache-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/#随机替换算法"},{"categories":["计算机基础"],"content":"cache 一致性问题当 CPU 进行写操作时，需要对 cache 中的内容进行更新，此时 cache 和主存需要保持一致 通常两种写操作方式：1）全写法；2）回写法 ","date":"2022-07-05","objectID":"/cache-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/:5:0","series":null,"tags":["cache"],"title":"Cache 的基本工作原理","uri":"/cache-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/#cache-一致性问题"},{"categories":["计算机基础"],"content":"全写法全写法（write through）：基本做法是，当 CPU 执行写操作时，如写命中，则同时写 cache 和主存，如果没有命中，采用下面两种处理方式 写分配法：先在主存块中更新相应的存储单元，然后分配一个 cache 行，将更新后的主存块转入到分配的 cache 行中 非写分配法：仅更新主存单元而不转入 cache 行中 ","date":"2022-07-05","objectID":"/cache-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/:5:1","series":null,"tags":["cache"],"title":"Cache 的基本工作原理","uri":"/cache-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/#全写法"},{"categories":["计算机基础"],"content":"回写法回写法（write back）：当 CPU 执行写操作时，若命中 cache，则信息只写入 cache 而不写入主存；如果没有命中，则cache 中分配一行，将主存块调入改 cache 中并更新 cache 中相应单元的内容 当 CPU 执行写操作时，回写法不会更新主存单元，只有当 cache 行踪主存块被替换时，才将主存快内容一次性写回主存 这种做法能够减少写主存的次数，减少写回主存的开销，但是没有同步更新主存块和 cache，可能会由于两者不一致带来潜在隐患 ","date":"2022-07-05","objectID":"/cache-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/:5:2","series":null,"tags":["cache"],"title":"Cache 的基本工作原理","uri":"/cache-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/#回写法"},{"categories":["Lab"],"content":"前言PA2-1 需要实现每个指令的解码和执行，具体需要在项目根目录下先执行 make test_pa-2-1，查看当前缺少哪条指令，然后去实现对应指令即可，直到所有测试用例通过（除了最后一个test_float） ","date":"2022-06-28","objectID":"/nju-ics2021-pa2-1%E5%B0%8F%E7%BB%93/:1:0","series":null,"tags":["ICS","PA"],"title":"NJU-ICS2021 | PA2-1实验小结","uri":"/nju-ics2021-pa2-1%E5%B0%8F%E7%BB%93/#前言"},{"categories":["Lab"],"content":"指令的查阅过程下面是开始做实验时候，记录的查阅手册过程（仅供参考） 除了已经通过的 mov 测试用例，下一个 mov-cmp 的测试用例，make_test-pa-2-1 出现报错，然后定位到 0x83 f8 01 cmp $0x1, %eax 这条指令 下面查阅手册： 这条指令前面不是 0x66 说明 0x83 即为 opcode 查阅 i-386 手册附录 A，找到 0x83 对应的的指令为 Grp1 Ev, Iv 对应到 Nemu 中即为 Grp1 Iv, Ev 这里因为是一组Grp1 Iv, Ev，所以需要继续查表，先看一下下一位 0xf8 的寄存器对应的为111 反过来查找Grp1对应的 111位置，发现为 cmp ，也符合反汇编的结果 opcode 后面跟着的是 ModR/M 字节，则这里 0xf8 即为 ModR/M 字节，查阅i386手册第17.2.1节。其解析方式对应Table 17-3 ，0xf8这个ModR/M字节的对应的是 EAX/AX/AL 这里应该对应 %eax 寄存器（反汇编结果显示的也比较清楚） 最后 0x01 是个立即数，最后对应 AT\u0026T 格式为 cmp %eax, $0x1 接着查阅 cmp 指令对应的功能，可以看见对于 83这条指令主要是将一个==8 位==立即数存入寄存器或者地址中 这里强调一下 8 位立即数，因为在这里我弄错了，创建立即数时用的时全局的 data_size，导致卡了两三个小时一直没发现错误 此外我在返回长度的时候，返回的是 len + data_size / 8，也一直没发现问题，最开始给我报错的地方是将一个指令切分了，比如说这里报错的 eip = 0x30053 而这里根本不是对应一个指令地址的开始，而是 0x30050 中间的部分，如下图所示：（我还去查了以 0x00 为开始的指令，改了改 add 这条命令，结果发现根本就是 cmp 写错了，导致取地址的时候取的不是某条指令开头的位置！！！） 发现问题后，很快就解决了，cmp 的实现，这里可以使用PA-1 中实现的 alu_sub 函数，手册上说了 cmp 将源操作数减去目的操作数，但是并不保留结果，只改变标志位（CF、OF这些） 最后返回长度的时候，注意要将 len + 1 (因为还有一个8位的立即数) ","date":"2022-06-28","objectID":"/nju-ics2021-pa2-1%E5%B0%8F%E7%BB%93/:2:0","series":null,"tags":["ICS","PA"],"title":"NJU-ICS2021 | PA2-1实验小结","uri":"/nju-ics2021-pa2-1%E5%B0%8F%E7%BB%93/#指令的查阅过程"},{"categories":["Lab"],"content":"个人踩坑点下面是遇见的一些坑： 报错的地方在某条指令中间，很有可能是前面的指令返回地址没有写正确 有一些需要进行符号拓展，例如 cmp、sub这些 test 指令最后的结果需要丢弃，而不是写入 DEST 中，这里详细看一下手册，如果没看下面文字部分的话，就会以为需要写入 DEST 中 指令在实现的时候，尽可能的使用框架代码提供的宏，出错的概率会小很多，其次可以利用 PA1 中已经实现的整数运算 实现一条指令的同时，可以把类似的指令同时实现了，大部分指令都挺有规律的，另外感觉有一个小彩蛋，如果打开opcode_ref.c 这个文件，其实会发现大部分指令的格式已经写好了 ","date":"2022-06-28","objectID":"/nju-ics2021-pa2-1%E5%B0%8F%E7%BB%93/:3:0","series":null,"tags":["ICS","PA"],"title":"NJU-ICS2021 | PA2-1实验小结","uri":"/nju-ics2021-pa2-1%E5%B0%8F%E7%BB%93/#个人踩坑点"},{"categories":["Lab"],"content":"部分指令的实现个人感觉最难实现的是 call、ret、push 和 pop 这几个指令 首先看一下 push 指令的实现，push 指令是将一个寄存器/地址/立即数放入到栈中，看一下手册上的描述 push 指令，先需要将栈帧腾出来相应的位置（即ESP -= 2 或 4），然后将待写入的数据 SOURCE 写到栈帧对应的地址上，最开始我只是简单的先将 cpu.esp -= 2 或 4，然后将 source 赋值给 cpu.esp，后来发现不对，是需要写入到 cpu.esp 对应的地址中，这样的话需要额外创建一个 OPERAND 来进行操作，下面是主要的代码： 6 static void instr_execute_1op() { 7 operand_read(\u0026opr_src); 8 9 if (data_size == 16) { 10 cpu.esp -= 2; 11 } else if (data_size == 32) { 12 cpu.esp -= 4; 13 } 14 15 OPERAND esp; 16 esp.type = OPR_MEM; 17 esp.data_size = data_size; 18 esp.addr = cpu.esp; 19 esp.sreg = SREG_SS; 20 esp.val = sign_ext(opr_src.val, opr_src.data_size); 21 22 operand_write(\u0026esp); 23 } 其实如果弄清楚手册上 (SS:SP) 这种带括号的是写入到地址当中就不容易出错了，就类似是一个指针 int *p = \u0026a;，这里 p 类似于栈帧（ESP），然后我需要将数据写入到 p 所指的那个地址当中，也就是变量 a 的地址 目前我只实现了 E8 这条指令，也就是 call near，看一下这条指令的描述 可以看到首先需要将当前指令执行的位置（也就是 EIP）的下一个指令放入到栈中，然后 EIP 再加上一个立即数地址，Push EIP 前面已经提过思路，具体代码如下，其实很类似： //push(IP) 7 OPERAND esp; 8 esp.data_size = data_size; 9 esp.type = OPR_MEM; 10 11 cpu.esp -= data_size / 8; 12 13 esp.addr = cpu.esp; 14 esp.val = eip + 1 + data_size / 8; //注意这里是当前指令的下一个指令地址，所以需要额外加上 data_size/8 15 //printf(\"in call_near eip is %x\\n\", eip); 16 operand_write(\u0026esp); 然后是加上一个立即数，这里在 jmp_near 指令实现上已经给出类似的思路了 18 //EIP = EIP + rel16/32 19 OPERAND rel; 20 rel.type = OPR_IMM; 21 rel.sreg = SREG_CS; 22 rel.data_size = data_size; 23 rel.addr = eip + 1; 24 25 operand_read(\u0026rel); 26 27 int offset = sign_ext(rel.val, data_size);//符号拓展 28 cpu.eip += offset; //偏移量，加上立即数的值 29 return 1 + data_size / 8; ret 指令注意取出栈帧的值后赋给 eip，最后返回值不需要返回额外的长度，返回 0 即可 ","date":"2022-06-28","objectID":"/nju-ics2021-pa2-1%E5%B0%8F%E7%BB%93/:4:0","series":null,"tags":["ICS","PA"],"title":"NJU-ICS2021 | PA2-1实验小结","uri":"/nju-ics2021-pa2-1%E5%B0%8F%E7%BB%93/#部分指令的实现"},{"categories":["Lab"],"content":"小结PA2-1 总共花了约 35h，最开始折磨在每条指令实现上，后面慢慢发现框架代码提供的宏，比起自己写要准确的多，然后是一些指令的理解没有到位，尤其是后面说的 call、ret、push 和 pop 这几个，导致直接出现死循环的情况，也不知道是哪个地方实现错了，还有就是有的指令实现没有进行符号拓展，最后虽然通过了测试用例，但是感觉还是有很多细节部分没有做的很好，还需要继续加油~ ","date":"2022-06-28","objectID":"/nju-ics2021-pa2-1%E5%B0%8F%E7%BB%93/:5:0","series":null,"tags":["ICS","PA"],"title":"NJU-ICS2021 | PA2-1实验小结","uri":"/nju-ics2021-pa2-1%E5%B0%8F%E7%BB%93/#小结"},{"categories":["Lab"],"content":"前言这里简单记录一下自己做PA实验的体会，既是及时做个整理总结，也希望能够帮助到后续做PA实验的同学。 首先声明本人非南大学生，也并非科班学生，之前学过一点CSAPP，了解过部分汇编、计组相关内容，如果没学过相关课程的话，可以看一下中国大学 MOOC 上，南大的计算机系统基础课程，总共有 5 门课，前三门是基础知识，后面两门结合实践，我这里主要学了第 5 门课程，也就是计算机系统基础（五）：x86模拟器编程实践。 PA实验也是围绕这个课程开展的，不过这门课在中国大学 MOOC 上可能未开放（有时候因为学期结束了，不能上），所以另外推荐授课老师的B站：我是汪犬人的个人空间_哔哩哔哩_Bilibili，可以从老师主页看到相关录屏课程，然后就是PA实验代码和框架代码： Guide的仓库及其镜像地址： GitHub: http://github.com/ics-nju-wl/icspa-public-guide Gitee: https://gitee.com/wlicsnju/icspa-public-guide 实验框架代码及其镜像地址： GitHub: http://github.com/ics-nju-wl/icspa-public Gitee: https://gitee.com/wlicsnju/icspa-public ","date":"2022-06-26","objectID":"/nju-ics2021-pa0pa1%E5%B0%8F%E7%BB%93/:1:0","series":null,"tags":["ICS","PA"],"title":"NJU-ICS2021 | PA0\u0026PA1实验小结","uri":"/nju-ics2021-pa0pa1%E5%B0%8F%E7%BB%93/#前言"},{"categories":["Lab"],"content":"PA0 实验环境配置实验指导上写的很详细，过多内容就不赘述，这里主要记录下自己做实验遇见的一些坑和一些思考 课程推荐的是 Debian ，如果从官网上可以比较难找课程推荐的版本（我最开始就没有找到，也是看了MOOC上讨论区才找到），具体地址如下： https://www.debian.org/releases/buster/debian-installer/ 这是课程对应的Debian 10 buster版本，其他的环境配置跟着实验指导一步一步来就好，暂时没遇见什么问题 ","date":"2022-06-26","objectID":"/nju-ics2021-pa0pa1%E5%B0%8F%E7%BB%93/:2:0","series":null,"tags":["ICS","PA"],"title":"NJU-ICS2021 | PA0\u0026PA1实验小结","uri":"/nju-ics2021-pa0pa1%E5%B0%8F%E7%BB%93/#pa0-实验环境配置"},{"categories":["Lab"],"content":"PA1PA1主要是实现数据在 NEMU 模拟器上的表示和运算，包括整数和浮点数的表示、存储和运算 ","date":"2022-06-26","objectID":"/nju-ics2021-pa0pa1%E5%B0%8F%E7%BB%93/:3:0","series":null,"tags":["ICS","PA"],"title":"NJU-ICS2021 | PA0\u0026PA1实验小结","uri":"/nju-ics2021-pa0pa1%E5%B0%8F%E7%BB%93/#pa1"},{"categories":["Lab"],"content":"PA1-1 寄存器的模拟PA1-1 需要需要数据在计算机内部存储形式，也就是实现寄存器，这里框架代码已经给出来了，利用 C 语言中的 union ，看一下这个答案： typedef struct { union { union { union { uint32_t _32; uint16_t _16; uint8_t _8[2]; }; uint32_t val; } gpr[8]; struct { // do not change the order of the registers uint32_t eax, ecx, edx, ebx, esp, ebp, esi, edi; }; }; } CPU_STATE; 这里用到了 union 联合体，为什么用 union 就可以实现需求呢？ 具体需求如下： 我们希望以cpu.eax形式访问的和以cpu.gpr[0]._32形式访问的是同一个模拟寄存器，同时cpu.gpr[0]._16能够访问到cpu.eax的低16位也就是ax寄存器，cpu.gpr[0]._8[0]访问到cpu.eax的低8位也就是al寄存器等。 这里相当于是模拟了 i386 中寄存器的结构 要理解上面为什么可以实现，首先需要找到 union 联合体的在内存储存方式 union 相当于一个结构，它的所有成员相对于基地址的偏移量都为0，此结构空间要大到足够容纳最“宽”的成员 ——摘自K\u0026R C语言p130 我的理解，一个 union 宽度是它的成员中最大的那个，其他的成员和它存放在同一个地址，相对于起始地址偏移量都为0 举个例子：加入现在一个union 有两个成员，如下： union { char a; short b; int c; }u; 我们可以知道这个 union 所需要的字节数为一个 int 也就是4个字节，假设现在c = 0x12345615，并且存放在0x80000000这个地址开始位置，那么具体存放内容如下（假设这里为小端存放） 此时，对于 u.a = 0x15，而 u.b = 0x5615，相比较起始地址偏移量都为0，char 占用一个字节，则 a 即为 0x15，short 占用两个字节，b 即为 0x5615 了，下面是C程序验证我们的结论 #include \u003cstdio.h\u003e union { char a; short b; int c; }u; int main() { u.c = 0x12345615; printf(\"u.a = 0x%x\\n\", u.a); printf(\"u.b = 0x%x\\n\", u.b); printf(\"u.c = 0x%x\\n\", u.c); return 0; } /** silas@Silas-PC:~/ics4$ gcc -g -o union union.c \u0026\u0026 ./union u.a = 0x15 u.b = 0x5615 u.c = 0x12345615 **/ 上面提到一个小端存放，这个在实验指导书上提到： x86采用小端方式存储数据，它规定了超过一个字节的数据的存储规则：低有效字节放在低地址，高有效字节放在高地址。 这样就比较好理解，为什么下面 union 这个可以模拟出i386 对应寄存器的结构 union { uint32_t _32; uint16_t _16; uint8_t _8[2]; }; _32 在内存中宽度最大，也对应32位的寄存器，例如 eax，而_16 为16为，由于是小端存放，最低有效字节放在低地址，取出16位即为这个值的后16位，也就相当于是寄存器的后16位，同理可以理解 _8[2] 对应的过程 注意另外一点，这里将_32 放在了前面，而不是 _8[2] 根据前面的分析，这里应该也是可以的，但是 union 另外一个特点就是初始化的时候，只能用第一个成员类型的值进行初始化，所以将最宽的成员放在第一位，防止初始化时丢失了后面的精度 下面是代码验证： #include \u003cstdio.h\u003e union u_tag { char a; short b; int c; }u; int main() { u.c = 0x12345615; printf(\"u.a = 0x%x\\n\", u.a); printf(\"u.b = 0x%x\\n\", u.b); printf(\"u.c = 0x%x\\n\", u.c); union u_tag u2 = {0x12345615}; printf(\"u.a = 0x%x\\n\", u2.a); printf(\"u.b = 0x%x\\n\", u2.b); printf(\"u.c = 0x%x\\n\", u2.c); return 0; } /* silas@Silas-PC:~/ics4$ gcc -g -o union union.c \u0026\u0026 ./union union.c: In function ‘main’: union.c:16:20: warning: overflow in conversion from ‘int’ to ‘char’ changes value from ‘305419797’ to ‘21’ [-Woverflow] 16 | union u_tag u2 = {0x12345615}; | ^~~~~~~~~~ u.a = 0x15 u.b = 0x5615 u.c = 0x12345615 u.a = 0x15 u.b = 0x15 u.c = 0x15 */ 可以看到由于 union 第一个成员位 char a，只能存放 1 个字节，初始化后会损失精度 至此，差不多解释了为什么使用 union 可以实现模拟寄存器的功能 ","date":"2022-06-26","objectID":"/nju-ics2021-pa0pa1%E5%B0%8F%E7%BB%93/:3:1","series":null,"tags":["ICS","PA"],"title":"NJU-ICS2021 | PA0\u0026PA1实验小结","uri":"/nju-ics2021-pa0pa1%E5%B0%8F%E7%BB%93/#pa1-1-寄存器的模拟"},{"categories":["Lab"],"content":"PA1-2 ALU的模拟这里需要对整数的各个运算来进行模拟，其实实现中比较好实现，直接用 C 语言中对应操作即可，比如说 alu_add 的实现，结果 res = src + dest，包括后续的加减、移位、逻辑和乘除运算基本上都是可以这样来实现 但是最为关键的是需要对标志位进行设置，这就需要结合 i386 手册了（实验指导上给了相应链接 i386 手册: ） PA中需要设置的是CF、PF、ZF、SF 和 OF （AF不需要设置） CF：进位标志符，这个主要看运算结果是否超过了最高的有效位，相当于是进位了，或者是看运算是否向高位借位了 这里可以类比十进制，比如说89+83，相加的时候 3 + 9 = 12 \u003e 10 这里要进位，而CF标志位则是看最高位是否发生了进位，或者是两个数相减的时候 如91-87，个位上 1 - 7 不够减，所以需要向十位借位，这种情况 CF 会被设置为 1 PF：奇偶标志位，看结果中所有bit 位中 1 的个数是否为偶数，偶数 PF = 1，奇数 PF = 0 ZF：零标志位，看结果是否为 0，如果结果为0 则ZF = 1，否则 ZF = 0 SF：符号标志位，看结果是否为负，如果为负，SF = 1，否则 SF = 0 （PA中由于模拟的是无符号数，所以看最高有效位是否为 1 来判断结果是否为负数） OF：溢出标志位，计算中如果发生溢出则设置为1，溢出包括两种，一个是结果值太大，超过了能表示的最大范围就发生了溢出，另外一个是结果值太小，小于能表示的最小值就发生了溢出 这里注意 CF 和 OF 的区别： 在王爽汇编语言P218书中写到，CF 是针对无符号运算的标志位，OF 是针对有符号的标志位，同样位数情况下无符号的范围，这样就会在解释两个数值相加的时候，如果解释为无符号可能不会产生溢出，而解释为有符号会产生溢出 在PA中模拟的是无符号数，所以两者可能会有区别？其实我自己之前实现的时候，很多时候两个标志位实现逻辑就很类似 另外就是 PF、ZF 和 SF 这三个其实对于每个运算都是一样的，可以直接代码复用 ","date":"2022-06-26","objectID":"/nju-ics2021-pa0pa1%E5%B0%8F%E7%BB%93/:3:2","series":null,"tags":["ICS","PA"],"title":"NJU-ICS2021 | PA0\u0026PA1实验小结","uri":"/nju-ics2021-pa0pa1%E5%B0%8F%E7%BB%93/#pa1-2-alu的模拟"},{"categories":["Lab"],"content":"PA1-3 FPU的实现这个主要实现IEEE 754 单精度浮点数(float)的运算，框架代码已经给出大部分内容了，只需要根据实验手册进行补充即可，最重要的应该就是实现 internal_normalize() 规格化函数 其实这部分代码框架也都设计好了，不过开始没反应过来，自己花了不少时间没用在刀刃上，下面自己在做实验的时候遇见几个坑点： 第一个是粘位的处理 最开始我就是判断每次移位之前，判断(sig_grs » 1) 是否大于 1，开始看错了以为是舍入位左边有非零数字，粘位就为1，后来仔细看了代码框架，发现原来的粘位处理操作是 sticky = stickt | (sig_grs \u0026 0x1); 这才发现问题，另外就是注意粘位判断粘位是否为1，要在移位之前进行判断。 出现溢出或零的情况 最开始处理溢出或者零的时候，我把sig_grs 直接设置为 P_ZERO_F 或者 P_INF_F 等等这些，然后发现不对，这里应该直接返回，同时要根据符号位，判断正负的情况 处理舍入的时候 最开始没弄懂 GRS 位是怎么舍入的，直接将 sig_grs += 0x4 了，我以为只要 GRS 大于0x4 然后就直接进位，后面发现不是怎么回事，这里应该是浮点数默认的向偶数位舍入（这里参考了CSAPP p83)，其实就是我们经常听到的四舍六入五成双，举个例子： 对于十进制(这里保留一位)： 10.04 -\u003e 最后一位是4，直接丢弃，最后结果是 10.0 10.06 -\u003e 最后一位是6，大于5直接进位，结果是10.1 10.05 -\u003e 最后一位是5，要让进位的成为偶数，5前面的0已经是偶数了，所以这里直接丢弃5，结果是10.0 10.15 -\u003e 这里和上面就不一样了，5前面是奇数，所以要进位，结果是10.2 对于二进制，这里 GRS 是3位，所以取半即 0x4(0b100) 如果GRS 大于 0x4 直接进位 如果 GRS 小于 0x4 直接丢弃后面尾数 如果 GRS 等于 0x4，这里需要判断前面一位是否为偶数，偶数直接丢弃 GRS，奇数进行进位 舍入想清楚就基本上很容易解决了 （重新看了MOOC视频，发现老师这里讲的挺清楚的，不过自己最开始看了下视频，如何根据实验手册做的，就把视频内容给忘记了，看来还是需要好好看一下视频的内容） 阶码 exp == 0 \u0026\u0026 sig_grs » (23 + 3) == 1在规格化过程中，遇见这种情况，两个非规格化数运算后得到了一个规格化数，指数需要加 1，即 exp = exp + 1 简单分析下为什么要加1，首先 exp == 0，表示是两个非规格化数相加减（因为加减过程中会对阶，两个数应该同时为规格化或者非规格化数），非规格化数基本形式是 0.bbbb…(小数点后面26个位)，两个非规格化数相加为规格化数的情况就是相当于，第一位小数都为1，即 0.1bbb… 和 0.1bbb… 相加的情况，此时进位，结果为 1.bbbb…，结果上是一个规格化数，exp 应该等于 1，相当于是右规了一位 ","date":"2022-06-26","objectID":"/nju-ics2021-pa0pa1%E5%B0%8F%E7%BB%93/:3:3","series":null,"tags":["ICS","PA"],"title":"NJU-ICS2021 | PA0\u0026PA1实验小结","uri":"/nju-ics2021-pa0pa1%E5%B0%8F%E7%BB%93/#pa1-3-fpu的实现"},{"categories":["Lab"],"content":"PA1-3 FPU的实现这个主要实现IEEE 754 单精度浮点数(float)的运算，框架代码已经给出大部分内容了，只需要根据实验手册进行补充即可，最重要的应该就是实现 internal_normalize() 规格化函数 其实这部分代码框架也都设计好了，不过开始没反应过来，自己花了不少时间没用在刀刃上，下面自己在做实验的时候遇见几个坑点： 第一个是粘位的处理 最开始我就是判断每次移位之前，判断(sig_grs » 1) 是否大于 1，开始看错了以为是舍入位左边有非零数字，粘位就为1，后来仔细看了代码框架，发现原来的粘位处理操作是 sticky = stickt | (sig_grs \u0026 0x1); 这才发现问题，另外就是注意粘位判断粘位是否为1，要在移位之前进行判断。 出现溢出或零的情况 最开始处理溢出或者零的时候，我把sig_grs 直接设置为 P_ZERO_F 或者 P_INF_F 等等这些，然后发现不对，这里应该直接返回，同时要根据符号位，判断正负的情况 处理舍入的时候 最开始没弄懂 GRS 位是怎么舍入的，直接将 sig_grs += 0x4 了，我以为只要 GRS 大于0x4 然后就直接进位，后面发现不是怎么回事，这里应该是浮点数默认的向偶数位舍入（这里参考了CSAPP p83)，其实就是我们经常听到的四舍六入五成双，举个例子： 对于十进制(这里保留一位)： 10.04 - 最后一位是4，直接丢弃，最后结果是 10.0 10.06 - 最后一位是6，大于5直接进位，结果是10.1 10.05 - 最后一位是5，要让进位的成为偶数，5前面的0已经是偶数了，所以这里直接丢弃5，结果是10.0 10.15 - 这里和上面就不一样了，5前面是奇数，所以要进位，结果是10.2 对于二进制，这里 GRS 是3位，所以取半即 0x4(0b100) 如果GRS 大于 0x4 直接进位 如果 GRS 小于 0x4 直接丢弃后面尾数 如果 GRS 等于 0x4，这里需要判断前面一位是否为偶数，偶数直接丢弃 GRS，奇数进行进位 舍入想清楚就基本上很容易解决了 （重新看了MOOC视频，发现老师这里讲的挺清楚的，不过自己最开始看了下视频，如何根据实验手册做的，就把视频内容给忘记了，看来还是需要好好看一下视频的内容） 阶码 exp == 0 \u0026\u0026 sig_grs » (23 + 3) == 1在规格化过程中，遇见这种情况，两个非规格化数运算后得到了一个规格化数，指数需要加 1，即 exp = exp + 1 简单分析下为什么要加1，首先 exp == 0，表示是两个非规格化数相加减（因为加减过程中会对阶，两个数应该同时为规格化或者非规格化数），非规格化数基本形式是 0.bbbb…(小数点后面26个位)，两个非规格化数相加为规格化数的情况就是相当于，第一位小数都为1，即 0.1bbb… 和 0.1bbb… 相加的情况，此时进位，结果为 1.bbbb…，结果上是一个规格化数，exp 应该等于 1，相当于是右规了一位 ","date":"2022-06-26","objectID":"/nju-ics2021-pa0pa1%E5%B0%8F%E7%BB%93/:3:3","series":null,"tags":["ICS","PA"],"title":"NJU-ICS2021 | PA0\u0026PA1实验小结","uri":"/nju-ics2021-pa0pa1%E5%B0%8F%E7%BB%93/#阶码-exp--0--sig_grs--23--3--1"},{"categories":["Lab"],"content":"小结PA1的实验大概花了13.5h，感觉这部分内容在框架代码的基础上，查阅i386手册基本上都能实现相应的功能，最大的感受是在浮点数运算的实现时候，对浮点数规格化、舍入等有了更深入的了解 ","date":"2022-06-26","objectID":"/nju-ics2021-pa0pa1%E5%B0%8F%E7%BB%93/:4:0","series":null,"tags":["ICS","PA"],"title":"NJU-ICS2021 | PA0\u0026PA1实验小结","uri":"/nju-ics2021-pa0pa1%E5%B0%8F%E7%BB%93/#小结"},{"categories":["C++"],"content":"16.1 定义模板如果希望定义两个函数，来比较两个值，对于不同类型，可以通过定义多个重载函数来实现这样的功能 //如果两个值相等，返回0，v1小于v2返回-1，v2小于v1返回1 int compare(const string \u0026v1, const string \u0026v2) { if (v1 \u003c v2) return -1; if (v2 \u003c v1) return 1; return 0; } int compare(const double \u0026v1, const double \u0026v2) { if (v1 \u003c v2) return -1; if (v2 \u003c v1) return 1; return 0; } 这两个函数几乎相同，唯一的区别是参数的类型，函数体完全一样 如果还需要定义其他类型的比较函数，显然这样定义比较麻烦，可以用到下面介绍的函数模板进行简化 ","date":"2022-05-07","objectID":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/:1:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十六章 模板与泛型编程","uri":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/#161-定义模板"},{"categories":["C++"],"content":"16.1.1 函数模板 通过定义一个函数模板，而不需要为每个类型都定义一个新函数； 一个函数模板就是一个公式，可以用来生成针对特定类型的函数版本 template\u003ctypename T\u003e int compare(const T \u0026v1, const T \u0026v2) { if (v1 \u003c v2) return -1; if (v2 \u003c v1) return 1; return 0; } 模板定义以关键字 template 开始，后跟一个模板参数列表，这是一个逗号分隔的一个或多个模板参数的列表，用（\u003c\u003e）包围起来 模板定义中，模板参数列表不能为空 模板参数列表类似函数参数列表，在调用时为函数提供实参来初始化形参；模板参数列表中的类型，只有当调用时，通过显式或隐式指定模板实参，将其绑定到模板参数上，根据具体使用情况来确定 实例化函数模板当调用一个函数模板时，编译器用函数实参来推断模板实参 cout \u003c\u003c compare(1, 0) \u003c\u003c endl; //T为int //实参类型为int, 编译器推断出模板实参为int，将其绑定到模板参数T 编译器用推断出来的模板参数来实例化一个特定版本的函数，对于上面的调用，会实例化出 int compare(const int\u0026, const int\u0026); 函数 同样对于下面的调用： vector\u003cint\u003e vec1{1, 2, 3}, vec2{5, 6, 7}; cout \u003c\u003c compare(vec1, vec2) \u003c\u003c endl; //实例化出 int compare(const vector\u003cint\u003e\u0026, const vector\u003cint\u003e\u0026) 编译器会实例化另一个 compare 版本，其中 T 被替换为 vector\u003cint\u003e int compare(const vector\u003cint\u003e\u0026v1, const vector\u003cint\u003e\u0026v2) { if (v1 \u003c v2) return -1; if (v2 \u003c v1) return 1; return 0; } 这些编译器生成的版本通常称为模板的==实例== 模板类型参数上面定义的 compare 函数有一个模板类型参数，一般可以将类型参数看作类型说明符，就像内置类型或类类型说明符一样使用 类型参数可以用来指定返回类型，函数参数类型，以及函数体内用于变量声明或类型转换 template \u003ctypename T\u003e T foo(T* p) { T tmp = *p; //tmp类型将时指针p指向的类型 //... return tmp; } 类型参数前必须使用关键字 class 或 typename //错误：U前面需要加上关键字class或typename template \u003ctypename T, U\u003e T calc(const T\u0026, const U\u0026); 这两个关键字含义相同，可以互换使用 非类型模板参数 一个非类型参数表示一个值而非一个类型，通过一个特定的类型名而非关键字 class 或 typename 来指定非类型参数 一个模板被实例化时，非类型参数被用户提供或编译器推断出的值所替代，这些值必须是常量表达式 例如：编写一个 compare 版本处理字符串字面常量，这种字面常量是 const char 数组，用于不能拷贝一个数组，所以将自己的参数定义为数组的引用，由于希望比较不同长度的字符串字面值常量，模板定义了两个非类型的参数 template \u003cunsigned N, unsigned M\u003e int compare(const (\u0026p1)[N], const (\u0026p2)[M]) { return strcmp(p1, p2); } 调用这个版本时： compare(\"hi\", \"mom\"); //编译器会用字面值常量的大小代替N，M //编译器会在末尾插入一个空字符作为终结符 //编译器会实例出下面版本 int compare(const char (\u0026p1)[3], const char (\u0026p2)[4]); 一个非类型参数可以是一个整型、一个指向对象或函数类型的指针或（左值）引用 绑定到非类型整型参数的实参必须是一个常量表达式 绑定到指针或引用必须具有静态生存期，不能用普通（非static）局部变量或动态对象作为指针引用的实参 指针参数也可以用 nullptr 或值为 0 的常量表达式来实例化 inline 和 constexpr 的函数模板inline 和 constexpr 说明符放在模板参数列表后面，返回类型之前 //正确：inline说明符在模板参数列表之后 template\u003ctypename T\u003e inline T min(const T\u0026, const T\u0026); //错误：inline位置不正确 inline template\u003ctypename T\u003e T min(const T\u0026, const T\u0026); 编写类型无关的代码编写泛型代码两个重要原则： 模板中的函数参数是 const 的引用 函数体中的条件判断仅用 \u003c 比较运算 使用 const 的引用，保证了函数可以用于不能拷贝的类型，设为引用处理大对象时，函数运行速度会更快 只使用 \u003c 运算符，降低了函数对要处理类型的要求，这些类型必须支持 \u003c，而不必同时支持 \u003e 如果需要类型无关和可移植性，可以使用 less 函数对象来定义 template \u003ctypename T\u003e int compare(const T \u0026v1, const T \u0026v2) { if (less\u003cT\u003e()(v1, v2)) return -1; if (less\u003cT\u003e()(v2, v1)) return 1; return 0; } 模板编译编译器遇见一个模板定义时，并不生成代码，只有当实例化出模板的一个特定版本时，编译器才会生成代码 模板为了生成一个实例化版本，需要函数模板或类模板成员函数的定义，与非模板代码不同，模板的头文件通常即包括声明也包括定义 大多数编译错误在实例化期间报告模板直到实例化才会生成代码，通常编译器在三个阶段报告错误： 编译模板本身，基本的语法错误（忘记分号，变量名拼错等） 编译器遇到模板使用时，函数模板会检查实参数目是否正确，参数类型是否匹配，类模板是否提供了正确数目的模板实参 模板实例化时，只有这个阶段才会发现类型相关的错误 例如：之前的 compare 函数，如果传入一个类类型 Sales_data data1, data2; cout \u003c\u003c compare(data1, data2) \u003c\u003c endl; //错误：Sales_data未定义\u003c 这样的错误只有等到实例化 compare 才会发现 ","date":"2022-05-07","objectID":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/:1:1","series":null,"tags":["C++"],"title":"《C++Primer》| 第十六章 模板与泛型编程","uri":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/#1611-函数模板"},{"categories":["C++"],"content":"16.1.1 函数模板 通过定义一个函数模板，而不需要为每个类型都定义一个新函数； 一个函数模板就是一个公式，可以用来生成针对特定类型的函数版本 templateint compare(const T \u0026v1, const T \u0026v2) { if (v1 ）包围起来 模板定义中，模板参数列表不能为空 模板参数列表类似函数参数列表，在调用时为函数提供实参来初始化形参；模板参数列表中的类型，只有当调用时，通过显式或隐式指定模板实参，将其绑定到模板参数上，根据具体使用情况来确定 实例化函数模板当调用一个函数模板时，编译器用函数实参来推断模板实参 cout vec1{1, 2, 3}, vec2{5, 6, 7}; cout \u0026, const vector\u0026) 编译器会实例化另一个 compare 版本，其中 T 被替换为 vector int compare(const vector\u0026v1, const vector\u0026v2) { if (v1 T foo(T* p) { T tmp = *p; //tmp类型将时指针p指向的类型 //... return tmp; } 类型参数前必须使用关键字 class 或 typename //错误：U前面需要加上关键字class或typename template T calc(const T\u0026, const U\u0026); 这两个关键字含义相同，可以互换使用 非类型模板参数 一个非类型参数表示一个值而非一个类型，通过一个特定的类型名而非关键字 class 或 typename 来指定非类型参数 一个模板被实例化时，非类型参数被用户提供或编译器推断出的值所替代，这些值必须是常量表达式 例如：编写一个 compare 版本处理字符串字面常量，这种字面常量是 const char 数组，用于不能拷贝一个数组，所以将自己的参数定义为数组的引用，由于希望比较不同长度的字符串字面值常量，模板定义了两个非类型的参数 template int compare(const (\u0026p1)[N], const (\u0026p2)[M]) { return strcmp(p1, p2); } 调用这个版本时： compare(\"hi\", \"mom\"); //编译器会用字面值常量的大小代替N，M //编译器会在末尾插入一个空字符作为终结符 //编译器会实例出下面版本 int compare(const char (\u0026p1)[3], const char (\u0026p2)[4]); 一个非类型参数可以是一个整型、一个指向对象或函数类型的指针或（左值）引用 绑定到非类型整型参数的实参必须是一个常量表达式 绑定到指针或引用必须具有静态生存期，不能用普通（非static）局部变量或动态对象作为指针引用的实参 指针参数也可以用 nullptr 或值为 0 的常量表达式来实例化 inline 和 constexpr 的函数模板inline 和 constexpr 说明符放在模板参数列表后面，返回类型之前 //正确：inline说明符在模板参数列表之后 templateinline T min(const T\u0026, const T\u0026); //错误：inline位置不正确 inline templateT min(const T\u0026, const T\u0026); 编写类型无关的代码编写泛型代码两个重要原则： 模板中的函数参数是 const 的引用 函数体中的条件判断仅用 如果需要类型无关和可移植性，可以使用 less 函数对象来定义 template int compare(const T \u0026v1, const T \u0026v2) { if (less()(v1, v2)) return -1; if (less()(v2, v1)) return 1; return 0; } 模板编译编译器遇见一个模板定义时，并不生成代码，只有当实例化出模板的一个特定版本时，编译器才会生成代码 模板为了生成一个实例化版本，需要函数模板或类模板成员函数的定义，与非模板代码不同，模板的头文件通常即包括声明也包括定义 大多数编译错误在实例化期间报告模板直到实例化才会生成代码，通常编译器在三个阶段报告错误： 编译模板本身，基本的语法错误（忘记分号，变量名拼错等） 编译器遇到模板使用时，函数模板会检查实参数目是否正确，参数类型是否匹配，类模板是否提供了正确数目的模板实参 模板实例化时，只有这个阶段才会发现类型相关的错误 例如：之前的 compare 函数，如果传入一个类类型 Sales_data data1, data2; cout ","date":"2022-05-07","objectID":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/:1:1","series":null,"tags":["C++"],"title":"《C++Primer》| 第十六章 模板与泛型编程","uri":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/#实例化函数模板"},{"categories":["C++"],"content":"16.1.1 函数模板 通过定义一个函数模板，而不需要为每个类型都定义一个新函数； 一个函数模板就是一个公式，可以用来生成针对特定类型的函数版本 templateint compare(const T \u0026v1, const T \u0026v2) { if (v1 ）包围起来 模板定义中，模板参数列表不能为空 模板参数列表类似函数参数列表，在调用时为函数提供实参来初始化形参；模板参数列表中的类型，只有当调用时，通过显式或隐式指定模板实参，将其绑定到模板参数上，根据具体使用情况来确定 实例化函数模板当调用一个函数模板时，编译器用函数实参来推断模板实参 cout vec1{1, 2, 3}, vec2{5, 6, 7}; cout \u0026, const vector\u0026) 编译器会实例化另一个 compare 版本，其中 T 被替换为 vector int compare(const vector\u0026v1, const vector\u0026v2) { if (v1 T foo(T* p) { T tmp = *p; //tmp类型将时指针p指向的类型 //... return tmp; } 类型参数前必须使用关键字 class 或 typename //错误：U前面需要加上关键字class或typename template T calc(const T\u0026, const U\u0026); 这两个关键字含义相同，可以互换使用 非类型模板参数 一个非类型参数表示一个值而非一个类型，通过一个特定的类型名而非关键字 class 或 typename 来指定非类型参数 一个模板被实例化时，非类型参数被用户提供或编译器推断出的值所替代，这些值必须是常量表达式 例如：编写一个 compare 版本处理字符串字面常量，这种字面常量是 const char 数组，用于不能拷贝一个数组，所以将自己的参数定义为数组的引用，由于希望比较不同长度的字符串字面值常量，模板定义了两个非类型的参数 template int compare(const (\u0026p1)[N], const (\u0026p2)[M]) { return strcmp(p1, p2); } 调用这个版本时： compare(\"hi\", \"mom\"); //编译器会用字面值常量的大小代替N，M //编译器会在末尾插入一个空字符作为终结符 //编译器会实例出下面版本 int compare(const char (\u0026p1)[3], const char (\u0026p2)[4]); 一个非类型参数可以是一个整型、一个指向对象或函数类型的指针或（左值）引用 绑定到非类型整型参数的实参必须是一个常量表达式 绑定到指针或引用必须具有静态生存期，不能用普通（非static）局部变量或动态对象作为指针引用的实参 指针参数也可以用 nullptr 或值为 0 的常量表达式来实例化 inline 和 constexpr 的函数模板inline 和 constexpr 说明符放在模板参数列表后面，返回类型之前 //正确：inline说明符在模板参数列表之后 templateinline T min(const T\u0026, const T\u0026); //错误：inline位置不正确 inline templateT min(const T\u0026, const T\u0026); 编写类型无关的代码编写泛型代码两个重要原则： 模板中的函数参数是 const 的引用 函数体中的条件判断仅用 如果需要类型无关和可移植性，可以使用 less 函数对象来定义 template int compare(const T \u0026v1, const T \u0026v2) { if (less()(v1, v2)) return -1; if (less()(v2, v1)) return 1; return 0; } 模板编译编译器遇见一个模板定义时，并不生成代码，只有当实例化出模板的一个特定版本时，编译器才会生成代码 模板为了生成一个实例化版本，需要函数模板或类模板成员函数的定义，与非模板代码不同，模板的头文件通常即包括声明也包括定义 大多数编译错误在实例化期间报告模板直到实例化才会生成代码，通常编译器在三个阶段报告错误： 编译模板本身，基本的语法错误（忘记分号，变量名拼错等） 编译器遇到模板使用时，函数模板会检查实参数目是否正确，参数类型是否匹配，类模板是否提供了正确数目的模板实参 模板实例化时，只有这个阶段才会发现类型相关的错误 例如：之前的 compare 函数，如果传入一个类类型 Sales_data data1, data2; cout ","date":"2022-05-07","objectID":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/:1:1","series":null,"tags":["C++"],"title":"《C++Primer》| 第十六章 模板与泛型编程","uri":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/#模板类型参数"},{"categories":["C++"],"content":"16.1.1 函数模板 通过定义一个函数模板，而不需要为每个类型都定义一个新函数； 一个函数模板就是一个公式，可以用来生成针对特定类型的函数版本 templateint compare(const T \u0026v1, const T \u0026v2) { if (v1 ）包围起来 模板定义中，模板参数列表不能为空 模板参数列表类似函数参数列表，在调用时为函数提供实参来初始化形参；模板参数列表中的类型，只有当调用时，通过显式或隐式指定模板实参，将其绑定到模板参数上，根据具体使用情况来确定 实例化函数模板当调用一个函数模板时，编译器用函数实参来推断模板实参 cout vec1{1, 2, 3}, vec2{5, 6, 7}; cout \u0026, const vector\u0026) 编译器会实例化另一个 compare 版本，其中 T 被替换为 vector int compare(const vector\u0026v1, const vector\u0026v2) { if (v1 T foo(T* p) { T tmp = *p; //tmp类型将时指针p指向的类型 //... return tmp; } 类型参数前必须使用关键字 class 或 typename //错误：U前面需要加上关键字class或typename template T calc(const T\u0026, const U\u0026); 这两个关键字含义相同，可以互换使用 非类型模板参数 一个非类型参数表示一个值而非一个类型，通过一个特定的类型名而非关键字 class 或 typename 来指定非类型参数 一个模板被实例化时，非类型参数被用户提供或编译器推断出的值所替代，这些值必须是常量表达式 例如：编写一个 compare 版本处理字符串字面常量，这种字面常量是 const char 数组，用于不能拷贝一个数组，所以将自己的参数定义为数组的引用，由于希望比较不同长度的字符串字面值常量，模板定义了两个非类型的参数 template int compare(const (\u0026p1)[N], const (\u0026p2)[M]) { return strcmp(p1, p2); } 调用这个版本时： compare(\"hi\", \"mom\"); //编译器会用字面值常量的大小代替N，M //编译器会在末尾插入一个空字符作为终结符 //编译器会实例出下面版本 int compare(const char (\u0026p1)[3], const char (\u0026p2)[4]); 一个非类型参数可以是一个整型、一个指向对象或函数类型的指针或（左值）引用 绑定到非类型整型参数的实参必须是一个常量表达式 绑定到指针或引用必须具有静态生存期，不能用普通（非static）局部变量或动态对象作为指针引用的实参 指针参数也可以用 nullptr 或值为 0 的常量表达式来实例化 inline 和 constexpr 的函数模板inline 和 constexpr 说明符放在模板参数列表后面，返回类型之前 //正确：inline说明符在模板参数列表之后 templateinline T min(const T\u0026, const T\u0026); //错误：inline位置不正确 inline templateT min(const T\u0026, const T\u0026); 编写类型无关的代码编写泛型代码两个重要原则： 模板中的函数参数是 const 的引用 函数体中的条件判断仅用 如果需要类型无关和可移植性，可以使用 less 函数对象来定义 template int compare(const T \u0026v1, const T \u0026v2) { if (less()(v1, v2)) return -1; if (less()(v2, v1)) return 1; return 0; } 模板编译编译器遇见一个模板定义时，并不生成代码，只有当实例化出模板的一个特定版本时，编译器才会生成代码 模板为了生成一个实例化版本，需要函数模板或类模板成员函数的定义，与非模板代码不同，模板的头文件通常即包括声明也包括定义 大多数编译错误在实例化期间报告模板直到实例化才会生成代码，通常编译器在三个阶段报告错误： 编译模板本身，基本的语法错误（忘记分号，变量名拼错等） 编译器遇到模板使用时，函数模板会检查实参数目是否正确，参数类型是否匹配，类模板是否提供了正确数目的模板实参 模板实例化时，只有这个阶段才会发现类型相关的错误 例如：之前的 compare 函数，如果传入一个类类型 Sales_data data1, data2; cout ","date":"2022-05-07","objectID":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/:1:1","series":null,"tags":["C++"],"title":"《C++Primer》| 第十六章 模板与泛型编程","uri":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/#非类型模板参数"},{"categories":["C++"],"content":"16.1.1 函数模板 通过定义一个函数模板，而不需要为每个类型都定义一个新函数； 一个函数模板就是一个公式，可以用来生成针对特定类型的函数版本 templateint compare(const T \u0026v1, const T \u0026v2) { if (v1 ）包围起来 模板定义中，模板参数列表不能为空 模板参数列表类似函数参数列表，在调用时为函数提供实参来初始化形参；模板参数列表中的类型，只有当调用时，通过显式或隐式指定模板实参，将其绑定到模板参数上，根据具体使用情况来确定 实例化函数模板当调用一个函数模板时，编译器用函数实参来推断模板实参 cout vec1{1, 2, 3}, vec2{5, 6, 7}; cout \u0026, const vector\u0026) 编译器会实例化另一个 compare 版本，其中 T 被替换为 vector int compare(const vector\u0026v1, const vector\u0026v2) { if (v1 T foo(T* p) { T tmp = *p; //tmp类型将时指针p指向的类型 //... return tmp; } 类型参数前必须使用关键字 class 或 typename //错误：U前面需要加上关键字class或typename template T calc(const T\u0026, const U\u0026); 这两个关键字含义相同，可以互换使用 非类型模板参数 一个非类型参数表示一个值而非一个类型，通过一个特定的类型名而非关键字 class 或 typename 来指定非类型参数 一个模板被实例化时，非类型参数被用户提供或编译器推断出的值所替代，这些值必须是常量表达式 例如：编写一个 compare 版本处理字符串字面常量，这种字面常量是 const char 数组，用于不能拷贝一个数组，所以将自己的参数定义为数组的引用，由于希望比较不同长度的字符串字面值常量，模板定义了两个非类型的参数 template int compare(const (\u0026p1)[N], const (\u0026p2)[M]) { return strcmp(p1, p2); } 调用这个版本时： compare(\"hi\", \"mom\"); //编译器会用字面值常量的大小代替N，M //编译器会在末尾插入一个空字符作为终结符 //编译器会实例出下面版本 int compare(const char (\u0026p1)[3], const char (\u0026p2)[4]); 一个非类型参数可以是一个整型、一个指向对象或函数类型的指针或（左值）引用 绑定到非类型整型参数的实参必须是一个常量表达式 绑定到指针或引用必须具有静态生存期，不能用普通（非static）局部变量或动态对象作为指针引用的实参 指针参数也可以用 nullptr 或值为 0 的常量表达式来实例化 inline 和 constexpr 的函数模板inline 和 constexpr 说明符放在模板参数列表后面，返回类型之前 //正确：inline说明符在模板参数列表之后 templateinline T min(const T\u0026, const T\u0026); //错误：inline位置不正确 inline templateT min(const T\u0026, const T\u0026); 编写类型无关的代码编写泛型代码两个重要原则： 模板中的函数参数是 const 的引用 函数体中的条件判断仅用 如果需要类型无关和可移植性，可以使用 less 函数对象来定义 template int compare(const T \u0026v1, const T \u0026v2) { if (less()(v1, v2)) return -1; if (less()(v2, v1)) return 1; return 0; } 模板编译编译器遇见一个模板定义时，并不生成代码，只有当实例化出模板的一个特定版本时，编译器才会生成代码 模板为了生成一个实例化版本，需要函数模板或类模板成员函数的定义，与非模板代码不同，模板的头文件通常即包括声明也包括定义 大多数编译错误在实例化期间报告模板直到实例化才会生成代码，通常编译器在三个阶段报告错误： 编译模板本身，基本的语法错误（忘记分号，变量名拼错等） 编译器遇到模板使用时，函数模板会检查实参数目是否正确，参数类型是否匹配，类模板是否提供了正确数目的模板实参 模板实例化时，只有这个阶段才会发现类型相关的错误 例如：之前的 compare 函数，如果传入一个类类型 Sales_data data1, data2; cout ","date":"2022-05-07","objectID":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/:1:1","series":null,"tags":["C++"],"title":"《C++Primer》| 第十六章 模板与泛型编程","uri":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/#inline-和-constexpr-的函数模板"},{"categories":["C++"],"content":"16.1.1 函数模板 通过定义一个函数模板，而不需要为每个类型都定义一个新函数； 一个函数模板就是一个公式，可以用来生成针对特定类型的函数版本 templateint compare(const T \u0026v1, const T \u0026v2) { if (v1 ）包围起来 模板定义中，模板参数列表不能为空 模板参数列表类似函数参数列表，在调用时为函数提供实参来初始化形参；模板参数列表中的类型，只有当调用时，通过显式或隐式指定模板实参，将其绑定到模板参数上，根据具体使用情况来确定 实例化函数模板当调用一个函数模板时，编译器用函数实参来推断模板实参 cout vec1{1, 2, 3}, vec2{5, 6, 7}; cout \u0026, const vector\u0026) 编译器会实例化另一个 compare 版本，其中 T 被替换为 vector int compare(const vector\u0026v1, const vector\u0026v2) { if (v1 T foo(T* p) { T tmp = *p; //tmp类型将时指针p指向的类型 //... return tmp; } 类型参数前必须使用关键字 class 或 typename //错误：U前面需要加上关键字class或typename template T calc(const T\u0026, const U\u0026); 这两个关键字含义相同，可以互换使用 非类型模板参数 一个非类型参数表示一个值而非一个类型，通过一个特定的类型名而非关键字 class 或 typename 来指定非类型参数 一个模板被实例化时，非类型参数被用户提供或编译器推断出的值所替代，这些值必须是常量表达式 例如：编写一个 compare 版本处理字符串字面常量，这种字面常量是 const char 数组，用于不能拷贝一个数组，所以将自己的参数定义为数组的引用，由于希望比较不同长度的字符串字面值常量，模板定义了两个非类型的参数 template int compare(const (\u0026p1)[N], const (\u0026p2)[M]) { return strcmp(p1, p2); } 调用这个版本时： compare(\"hi\", \"mom\"); //编译器会用字面值常量的大小代替N，M //编译器会在末尾插入一个空字符作为终结符 //编译器会实例出下面版本 int compare(const char (\u0026p1)[3], const char (\u0026p2)[4]); 一个非类型参数可以是一个整型、一个指向对象或函数类型的指针或（左值）引用 绑定到非类型整型参数的实参必须是一个常量表达式 绑定到指针或引用必须具有静态生存期，不能用普通（非static）局部变量或动态对象作为指针引用的实参 指针参数也可以用 nullptr 或值为 0 的常量表达式来实例化 inline 和 constexpr 的函数模板inline 和 constexpr 说明符放在模板参数列表后面，返回类型之前 //正确：inline说明符在模板参数列表之后 templateinline T min(const T\u0026, const T\u0026); //错误：inline位置不正确 inline templateT min(const T\u0026, const T\u0026); 编写类型无关的代码编写泛型代码两个重要原则： 模板中的函数参数是 const 的引用 函数体中的条件判断仅用 如果需要类型无关和可移植性，可以使用 less 函数对象来定义 template int compare(const T \u0026v1, const T \u0026v2) { if (less()(v1, v2)) return -1; if (less()(v2, v1)) return 1; return 0; } 模板编译编译器遇见一个模板定义时，并不生成代码，只有当实例化出模板的一个特定版本时，编译器才会生成代码 模板为了生成一个实例化版本，需要函数模板或类模板成员函数的定义，与非模板代码不同，模板的头文件通常即包括声明也包括定义 大多数编译错误在实例化期间报告模板直到实例化才会生成代码，通常编译器在三个阶段报告错误： 编译模板本身，基本的语法错误（忘记分号，变量名拼错等） 编译器遇到模板使用时，函数模板会检查实参数目是否正确，参数类型是否匹配，类模板是否提供了正确数目的模板实参 模板实例化时，只有这个阶段才会发现类型相关的错误 例如：之前的 compare 函数，如果传入一个类类型 Sales_data data1, data2; cout ","date":"2022-05-07","objectID":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/:1:1","series":null,"tags":["C++"],"title":"《C++Primer》| 第十六章 模板与泛型编程","uri":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/#编写类型无关的代码"},{"categories":["C++"],"content":"16.1.1 函数模板 通过定义一个函数模板，而不需要为每个类型都定义一个新函数； 一个函数模板就是一个公式，可以用来生成针对特定类型的函数版本 templateint compare(const T \u0026v1, const T \u0026v2) { if (v1 ）包围起来 模板定义中，模板参数列表不能为空 模板参数列表类似函数参数列表，在调用时为函数提供实参来初始化形参；模板参数列表中的类型，只有当调用时，通过显式或隐式指定模板实参，将其绑定到模板参数上，根据具体使用情况来确定 实例化函数模板当调用一个函数模板时，编译器用函数实参来推断模板实参 cout vec1{1, 2, 3}, vec2{5, 6, 7}; cout \u0026, const vector\u0026) 编译器会实例化另一个 compare 版本，其中 T 被替换为 vector int compare(const vector\u0026v1, const vector\u0026v2) { if (v1 T foo(T* p) { T tmp = *p; //tmp类型将时指针p指向的类型 //... return tmp; } 类型参数前必须使用关键字 class 或 typename //错误：U前面需要加上关键字class或typename template T calc(const T\u0026, const U\u0026); 这两个关键字含义相同，可以互换使用 非类型模板参数 一个非类型参数表示一个值而非一个类型，通过一个特定的类型名而非关键字 class 或 typename 来指定非类型参数 一个模板被实例化时，非类型参数被用户提供或编译器推断出的值所替代，这些值必须是常量表达式 例如：编写一个 compare 版本处理字符串字面常量，这种字面常量是 const char 数组，用于不能拷贝一个数组，所以将自己的参数定义为数组的引用，由于希望比较不同长度的字符串字面值常量，模板定义了两个非类型的参数 template int compare(const (\u0026p1)[N], const (\u0026p2)[M]) { return strcmp(p1, p2); } 调用这个版本时： compare(\"hi\", \"mom\"); //编译器会用字面值常量的大小代替N，M //编译器会在末尾插入一个空字符作为终结符 //编译器会实例出下面版本 int compare(const char (\u0026p1)[3], const char (\u0026p2)[4]); 一个非类型参数可以是一个整型、一个指向对象或函数类型的指针或（左值）引用 绑定到非类型整型参数的实参必须是一个常量表达式 绑定到指针或引用必须具有静态生存期，不能用普通（非static）局部变量或动态对象作为指针引用的实参 指针参数也可以用 nullptr 或值为 0 的常量表达式来实例化 inline 和 constexpr 的函数模板inline 和 constexpr 说明符放在模板参数列表后面，返回类型之前 //正确：inline说明符在模板参数列表之后 templateinline T min(const T\u0026, const T\u0026); //错误：inline位置不正确 inline templateT min(const T\u0026, const T\u0026); 编写类型无关的代码编写泛型代码两个重要原则： 模板中的函数参数是 const 的引用 函数体中的条件判断仅用 如果需要类型无关和可移植性，可以使用 less 函数对象来定义 template int compare(const T \u0026v1, const T \u0026v2) { if (less()(v1, v2)) return -1; if (less()(v2, v1)) return 1; return 0; } 模板编译编译器遇见一个模板定义时，并不生成代码，只有当实例化出模板的一个特定版本时，编译器才会生成代码 模板为了生成一个实例化版本，需要函数模板或类模板成员函数的定义，与非模板代码不同，模板的头文件通常即包括声明也包括定义 大多数编译错误在实例化期间报告模板直到实例化才会生成代码，通常编译器在三个阶段报告错误： 编译模板本身，基本的语法错误（忘记分号，变量名拼错等） 编译器遇到模板使用时，函数模板会检查实参数目是否正确，参数类型是否匹配，类模板是否提供了正确数目的模板实参 模板实例化时，只有这个阶段才会发现类型相关的错误 例如：之前的 compare 函数，如果传入一个类类型 Sales_data data1, data2; cout ","date":"2022-05-07","objectID":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/:1:1","series":null,"tags":["C++"],"title":"《C++Primer》| 第十六章 模板与泛型编程","uri":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/#模板编译"},{"categories":["C++"],"content":"16.1.1 函数模板 通过定义一个函数模板，而不需要为每个类型都定义一个新函数； 一个函数模板就是一个公式，可以用来生成针对特定类型的函数版本 templateint compare(const T \u0026v1, const T \u0026v2) { if (v1 ）包围起来 模板定义中，模板参数列表不能为空 模板参数列表类似函数参数列表，在调用时为函数提供实参来初始化形参；模板参数列表中的类型，只有当调用时，通过显式或隐式指定模板实参，将其绑定到模板参数上，根据具体使用情况来确定 实例化函数模板当调用一个函数模板时，编译器用函数实参来推断模板实参 cout vec1{1, 2, 3}, vec2{5, 6, 7}; cout \u0026, const vector\u0026) 编译器会实例化另一个 compare 版本，其中 T 被替换为 vector int compare(const vector\u0026v1, const vector\u0026v2) { if (v1 T foo(T* p) { T tmp = *p; //tmp类型将时指针p指向的类型 //... return tmp; } 类型参数前必须使用关键字 class 或 typename //错误：U前面需要加上关键字class或typename template T calc(const T\u0026, const U\u0026); 这两个关键字含义相同，可以互换使用 非类型模板参数 一个非类型参数表示一个值而非一个类型，通过一个特定的类型名而非关键字 class 或 typename 来指定非类型参数 一个模板被实例化时，非类型参数被用户提供或编译器推断出的值所替代，这些值必须是常量表达式 例如：编写一个 compare 版本处理字符串字面常量，这种字面常量是 const char 数组，用于不能拷贝一个数组，所以将自己的参数定义为数组的引用，由于希望比较不同长度的字符串字面值常量，模板定义了两个非类型的参数 template int compare(const (\u0026p1)[N], const (\u0026p2)[M]) { return strcmp(p1, p2); } 调用这个版本时： compare(\"hi\", \"mom\"); //编译器会用字面值常量的大小代替N，M //编译器会在末尾插入一个空字符作为终结符 //编译器会实例出下面版本 int compare(const char (\u0026p1)[3], const char (\u0026p2)[4]); 一个非类型参数可以是一个整型、一个指向对象或函数类型的指针或（左值）引用 绑定到非类型整型参数的实参必须是一个常量表达式 绑定到指针或引用必须具有静态生存期，不能用普通（非static）局部变量或动态对象作为指针引用的实参 指针参数也可以用 nullptr 或值为 0 的常量表达式来实例化 inline 和 constexpr 的函数模板inline 和 constexpr 说明符放在模板参数列表后面，返回类型之前 //正确：inline说明符在模板参数列表之后 templateinline T min(const T\u0026, const T\u0026); //错误：inline位置不正确 inline templateT min(const T\u0026, const T\u0026); 编写类型无关的代码编写泛型代码两个重要原则： 模板中的函数参数是 const 的引用 函数体中的条件判断仅用 如果需要类型无关和可移植性，可以使用 less 函数对象来定义 template int compare(const T \u0026v1, const T \u0026v2) { if (less()(v1, v2)) return -1; if (less()(v2, v1)) return 1; return 0; } 模板编译编译器遇见一个模板定义时，并不生成代码，只有当实例化出模板的一个特定版本时，编译器才会生成代码 模板为了生成一个实例化版本，需要函数模板或类模板成员函数的定义，与非模板代码不同，模板的头文件通常即包括声明也包括定义 大多数编译错误在实例化期间报告模板直到实例化才会生成代码，通常编译器在三个阶段报告错误： 编译模板本身，基本的语法错误（忘记分号，变量名拼错等） 编译器遇到模板使用时，函数模板会检查实参数目是否正确，参数类型是否匹配，类模板是否提供了正确数目的模板实参 模板实例化时，只有这个阶段才会发现类型相关的错误 例如：之前的 compare 函数，如果传入一个类类型 Sales_data data1, data2; cout ","date":"2022-05-07","objectID":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/:1:1","series":null,"tags":["C++"],"title":"《C++Primer》| 第十六章 模板与泛型编程","uri":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/#大多数编译错误在实例化期间报告"},{"categories":["C++"],"content":"16.1.2 类模板类模板用来生成类的蓝图，类模板必须提供额外的信息，来确定模板的参数类型，一般在模板名后尖括号中提供实参 定义类模板 template \u003ctypename T\u003e class Blob { public: typedef T value_type; typedef typename std::vector\u003cT\u003e::size_type size_type; //构造函数 Blob(); Blob(std::initializer_list\u003cT\u003e il); //Blob中元素数目 size_type size() const { return data-\u003esize(); } bool empty() const { return data-\u003eempty(); } void push_back(const T\u0026 t) { return data-\u003epush_back(t);} void pop_back(); //元素访问 T\u0026 back(); T\u0026 operator[](size_type i); private: std::shared_ptr\u003cstd::vector\u003cT\u003e\u003e data; //若data[i]无效，抛出msg void check(size_type i, const std::string \u0026msg) const; }； 实例化类模板使用一个类模板时，需要提供额外信息，这些额外信息是显示模板实参列表，它们被绑定到模板参数 //使用类模板，必须提供元素类型 Blob\u003cint\u003e ia; Blob\u003cint\u003e ia2 = {0, 1, 2, 3}; ia 和 ia2会实例化以下特定版本的 Blob\u003cint\u003e ` template \u003c\u003e class Blob\u003cint\u003e { typedef typename std::vector\u003cint\u003e::size_type size_type; Blob(); Blob(std::initializer_list\u003cint\u003e il); //... } 当编译器从 Blob 模板中实例化一个类时，它会重写 Blob 模板，将参数 T 的每个实例替换成给定的模板实参 一个类模板的每个实例都形成一个独立的类，类型 Blob\u003cstring\u003e 与其他任何 Blob类型都没有关系，也不会对任何其他 Blob 类型的成员具有特殊的访问权限 类模板的成员函数与其他类一样，既可以在类模板内部，也可以在外部定义其成员函数，且定义在类模板内的成员函数被隐式声明为内联函数 类模板的成员函数本身是一个普通函数 每个类模板的实例都有自己版本的成员函数 类模板的成员函数具有和模板相同的模板参数 定义在类模板之外的成员函数就必须以关键字 template 开始，后接参数列表 简单说就是在类模板内部定义成员函数，可以直接使用参数 T，而在类模板外部定义成员函数，前面需要加上 template 等 template \u003ctypename T\u003e ret-type Blob\u003cT\u003e::member-name(parm-list) 这里必须加上 template 这行 类模板成员函数实例化默认情况下，类模板的成员函数只有当程序使用它的时候才进行实例化 // 实例化Blob\u003cint\u003e和接受initializer_list\u003cint\u003e的构造函数 Blob\u003cint\u003e squares = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; for (size_t i = 0; i != squares.size(); ++i) { squares[i] = i * i; //实例化Blob\u003cint\u003e::operator[](size_t) } 如果一个成员函数没有被使用，则它不会被实例化 类代码内简化模板类名的使用在使用一个类模板类型时必须提供模板实参，但是在类模板自己的作用域中，可以直接使用模板名而不提供实参 template \u003ctypename T\u003e class BlobPtr { public: BlobPtr() : curr(0) {} //其他构造函数 T\u0026 operator*() const { auto p = check(curr, \"derederence past edn\"); return (*p)[curr]; } //递增和递减 BlobPtr\u0026 operator++(); //求值运算符 BlobPtr\u0026 operator--(); private: //其他成员 std::size_t curr; //数组中的位置 } 这里前置递增和递减成员返回的时 BlobPtr\u0026，而不是 BlobPtr\u003cT\u003e\u0026，在类模板作用域中，编译器处理模板自身引用会自动提供模板匹配的实参 类模板外使用类模板名在类模板外定义成员时，此时不在类的作用域，直到遇见类名菜进入类的作用域 //后置++版本 template \u003ctypename T\u003e BlobPtr\u003cT\u003e BlobPtr\u003cT\u003e::operator++(int) { BlobPtr ret = *this; ++*this; return ret; } 返回类型位于类的作用域之外，所以必须指出返回类型是一个实例化的 BlobPtr，在函数体内已经进入类的作用域，则定义 ret 时无须重复提供模板实参，如果不通过模板实参，编译器假定使用的类型与成员实例化所用类型一致，等价于：BlobPtr\u003cT\u003e ret = *this; 类模板和友元 一个类包含一个友元声明，类与友元各自是否是模板是互相无关的 如果一个模板包括一个非模板友元，则友元可以访问所以模板实例 如果友元自身也是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例 一对一友好关系类模板与另一个（类或函数）模板间友好关系的最常见的形式是建立对应实例及其友元间的友好关系。例如，我们的 Blob 类应该将 BlobPtr 类和一个模板版本的 Blob template \u003ctypename\u003e class BlobPtr; //需要提前声明 template \u003ctypename\u003e class Blob; template \u003ctypename T\u003e bool operator==(const Blob\u003cT\u003e\u0026, const Blob\u003cT\u003e\u0026); template \u003ctypename T\u003e class Blob { friend class BlobPtr\u003cT\u003e; friend bool operator==\u003cT\u003e (const Blob\u003cT\u003e\u0026, const Blob\u003cT\u003e\u0026); //其他成员 } 友元的声明用 Blob 的模板形参作为自己的模板实参，友好关系被限定在相同类型实例化的 Blob 和 BlobPtr 相等运算符之间 //BlobPtr\u003cchar\u003e和operator==\u003cchar\u003e都是本对象的友元 Blob\u003cchar\u003e ca; //BlobPtr\u003cint\u003e和operator==\u003cint\u003e都是本对象的友元 Blob\u003cint\u003e ia; 上面例子中，ca 对 ia 或其他实例没有特殊访问权限 通用和特定模板的友好关系一个类也可以将另一个模板的每个实例都声明为自己的友元，或者限定特定的实例为友元 template \u003ctypename T\u003e class Pal; class C { //C是普通非模板类 friend class Pal\u003cC\u003e;//C实例化Pal是C的友元 //Pal2的所有实例都是C的友元，这种情况无须前置声明 template \u003ctypename T\u003e friend class Pal2; }; template \u003ctypename T\u003e class C2 {//C2是个模板类 //C2每个实例将相同实例的Pal声明为友元 friend class Pal\u003cT\u003e; //Pal2所有实例都是C2每个实例的友元，不需要前置声明 template \u003ctypename X\u003e friend class Pal2; //Pal3是一个非模板类，它是C2所有实例的友元 friend class Pal3; }; 为了让所有实例都成为友元，友元声明中必须使用与类模板不同的模板参数 令模板自己的类型参数成为友元在C++11新标准中，可以将模板类型参数声明为友元 template \u003ctypename Type\u003e class Bar { friend Type; //访问权限授予实例化Bar的类型 //... } 此时，对于某个类型 Foo，Foo 将称为 Bar\u003cFoo\u003e 的友元，Sales_data 将成为 Bar\u003cSales_data\u003e 的友元 模板类型别名类模板一个实例定义了一个类类型，我们可以定义一个 typedef 来引用实例化的类： typedef Blob\u003cstring\u003e StrBlob; 由于模板不是一个类型，我们不能定义一个 typedef 引用一个模板，即不能定义一个 typedef 引用 Blob\u003cT\u003e 但是新标准允许为类模板定义一个类型别名： template\u003ctypename T\u003e using twin = pair\u003cT, T\u003e; twin\u003cstring\u003e authors; //authors是一个pair\u003cstring, strin\u003e 使用别名时，也需要像模板那样指出特定类型的 twin 使用一个模板类型别名时，可以固定一个或多个模板参数 template \u003ctypename T\u003e using partNo = pair\u003cT, unsigned\u003e; partNo\u003cstring\u003e books; /","date":"2022-05-07","objectID":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/:1:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十六章 模板与泛型编程","uri":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/#1612-类模板"},{"categories":["C++"],"content":"16.1.2 类模板类模板用来生成类的蓝图，类模板必须提供额外的信息，来确定模板的参数类型，一般在模板名后尖括号中提供实参 定义类模板 template class Blob { public: typedef T value_type; typedef typename std::vector::size_type size_type; //构造函数 Blob(); Blob(std::initializer_list il); //Blob中元素数目 size_type size() const { return data-size(); } bool empty() const { return data-empty(); } void push_back(const T\u0026 t) { return data-push_back(t);} void pop_back(); //元素访问 T\u0026 back(); T\u0026 operator[](size_type i); private: std::shared_ptr data; //若data[i]无效，抛出msg void check(size_type i, const std::string \u0026msg) const; }； 实例化类模板使用一个类模板时，需要提供额外信息，这些额外信息是显示模板实参列表，它们被绑定到模板参数 //使用类模板，必须提供元素类型 Blob ia; Blob ia2 = {0, 1, 2, 3}; ia 和 ia2会实例化以下特定版本的 Blob ` template class Blob { typedef typename std::vector::size_type size_type; Blob(); Blob(std::initializer_list il); //... } 当编译器从 Blob 模板中实例化一个类时，它会重写 Blob 模板，将参数 T 的每个实例替换成给定的模板实参 一个类模板的每个实例都形成一个独立的类，类型 Blob 与其他任何 Blob类型都没有关系，也不会对任何其他 Blob 类型的成员具有特殊的访问权限 类模板的成员函数与其他类一样，既可以在类模板内部，也可以在外部定义其成员函数，且定义在类模板内的成员函数被隐式声明为内联函数 类模板的成员函数本身是一个普通函数 每个类模板的实例都有自己版本的成员函数 类模板的成员函数具有和模板相同的模板参数 定义在类模板之外的成员函数就必须以关键字 template 开始，后接参数列表 简单说就是在类模板内部定义成员函数，可以直接使用参数 T，而在类模板外部定义成员函数，前面需要加上 template 等 template ret-type Blob::member-name(parm-list) 这里必须加上 template 这行 类模板成员函数实例化默认情况下，类模板的成员函数只有当程序使用它的时候才进行实例化 // 实例化Blob和接受initializer_list的构造函数 Blob squares = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; for (size_t i = 0; i != squares.size(); ++i) { squares[i] = i * i; //实例化Blob::operator[](size_t) } 如果一个成员函数没有被使用，则它不会被实例化 类代码内简化模板类名的使用在使用一个类模板类型时必须提供模板实参，但是在类模板自己的作用域中，可以直接使用模板名而不提供实参 template class BlobPtr { public: BlobPtr() : curr(0) {} //其他构造函数 T\u0026 operator*() const { auto p = check(curr, \"derederence past edn\"); return (*p)[curr]; } //递增和递减 BlobPtr\u0026 operator++(); //求值运算符 BlobPtr\u0026 operator--(); private: //其他成员 std::size_t curr; //数组中的位置 } 这里前置递增和递减成员返回的时 BlobPtr\u0026，而不是 BlobPtr\u0026，在类模板作用域中，编译器处理模板自身引用会自动提供模板匹配的实参 类模板外使用类模板名在类模板外定义成员时，此时不在类的作用域，直到遇见类名菜进入类的作用域 //后置++版本 template BlobPtr BlobPtr::operator++(int) { BlobPtr ret = *this; ++*this; return ret; } 返回类型位于类的作用域之外，所以必须指出返回类型是一个实例化的 BlobPtr，在函数体内已经进入类的作用域，则定义 ret 时无须重复提供模板实参，如果不通过模板实参，编译器假定使用的类型与成员实例化所用类型一致，等价于：BlobPtr ret = *this; 类模板和友元 一个类包含一个友元声明，类与友元各自是否是模板是互相无关的 如果一个模板包括一个非模板友元，则友元可以访问所以模板实例 如果友元自身也是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例 一对一友好关系类模板与另一个（类或函数）模板间友好关系的最常见的形式是建立对应实例及其友元间的友好关系。例如，我们的 Blob 类应该将 BlobPtr 类和一个模板版本的 Blob template class BlobPtr; //需要提前声明 template class Blob; template bool operator==(const Blob\u0026, const Blob\u0026); template class Blob { friend class BlobPtr; friend bool operator== (const Blob\u0026, const Blob\u0026); //其他成员 } 友元的声明用 Blob 的模板形参作为自己的模板实参，友好关系被限定在相同类型实例化的 Blob 和 BlobPtr 相等运算符之间 //BlobPtr和operator==都是本对象的友元 Blob ca; //BlobPtr和operator==都是本对象的友元 Blob ia; 上面例子中，ca 对 ia 或其他实例没有特殊访问权限 通用和特定模板的友好关系一个类也可以将另一个模板的每个实例都声明为自己的友元，或者限定特定的实例为友元 template class Pal; class C { //C是普通非模板类 friend class Pal;//C实例化Pal是C的友元 //Pal2的所有实例都是C的友元，这种情况无须前置声明 template friend class Pal2; }; template class C2 {//C2是个模板类 //C2每个实例将相同实例的Pal声明为友元 friend class Pal; //Pal2所有实例都是C2每个实例的友元，不需要前置声明 template friend class Pal2; //Pal3是一个非模板类，它是C2所有实例的友元 friend class Pal3; }; 为了让所有实例都成为友元，友元声明中必须使用与类模板不同的模板参数 令模板自己的类型参数成为友元在C++11新标准中，可以将模板类型参数声明为友元 template class Bar { friend Type; //访问权限授予实例化Bar的类型 //... } 此时，对于某个类型 Foo，Foo 将称为 Bar 的友元，Sales_data 将成为 Bar 的友元 模板类型别名类模板一个实例定义了一个类类型，我们可以定义一个 typedef 来引用实例化的类： typedef Blob StrBlob; 由于模板不是一个类型，我们不能定义一个 typedef 引用一个模板，即不能定义一个 typedef 引用 Blob 但是新标准允许为类模板定义一个类型别名： templateusing twin = pair; twin authors; //authors是一个pair使用别名时，也需要像模板那样指出特定类型的 twin 使用一个模板类型别名时，可以固定一个或多个模板参数 template using partNo = pair; partNo books; /","date":"2022-05-07","objectID":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/:1:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十六章 模板与泛型编程","uri":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/#定义类模板"},{"categories":["C++"],"content":"16.1.2 类模板类模板用来生成类的蓝图，类模板必须提供额外的信息，来确定模板的参数类型，一般在模板名后尖括号中提供实参 定义类模板 template class Blob { public: typedef T value_type; typedef typename std::vector::size_type size_type; //构造函数 Blob(); Blob(std::initializer_list il); //Blob中元素数目 size_type size() const { return data-size(); } bool empty() const { return data-empty(); } void push_back(const T\u0026 t) { return data-push_back(t);} void pop_back(); //元素访问 T\u0026 back(); T\u0026 operator[](size_type i); private: std::shared_ptr data; //若data[i]无效，抛出msg void check(size_type i, const std::string \u0026msg) const; }； 实例化类模板使用一个类模板时，需要提供额外信息，这些额外信息是显示模板实参列表，它们被绑定到模板参数 //使用类模板，必须提供元素类型 Blob ia; Blob ia2 = {0, 1, 2, 3}; ia 和 ia2会实例化以下特定版本的 Blob ` template class Blob { typedef typename std::vector::size_type size_type; Blob(); Blob(std::initializer_list il); //... } 当编译器从 Blob 模板中实例化一个类时，它会重写 Blob 模板，将参数 T 的每个实例替换成给定的模板实参 一个类模板的每个实例都形成一个独立的类，类型 Blob 与其他任何 Blob类型都没有关系，也不会对任何其他 Blob 类型的成员具有特殊的访问权限 类模板的成员函数与其他类一样，既可以在类模板内部，也可以在外部定义其成员函数，且定义在类模板内的成员函数被隐式声明为内联函数 类模板的成员函数本身是一个普通函数 每个类模板的实例都有自己版本的成员函数 类模板的成员函数具有和模板相同的模板参数 定义在类模板之外的成员函数就必须以关键字 template 开始，后接参数列表 简单说就是在类模板内部定义成员函数，可以直接使用参数 T，而在类模板外部定义成员函数，前面需要加上 template 等 template ret-type Blob::member-name(parm-list) 这里必须加上 template 这行 类模板成员函数实例化默认情况下，类模板的成员函数只有当程序使用它的时候才进行实例化 // 实例化Blob和接受initializer_list的构造函数 Blob squares = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; for (size_t i = 0; i != squares.size(); ++i) { squares[i] = i * i; //实例化Blob::operator[](size_t) } 如果一个成员函数没有被使用，则它不会被实例化 类代码内简化模板类名的使用在使用一个类模板类型时必须提供模板实参，但是在类模板自己的作用域中，可以直接使用模板名而不提供实参 template class BlobPtr { public: BlobPtr() : curr(0) {} //其他构造函数 T\u0026 operator*() const { auto p = check(curr, \"derederence past edn\"); return (*p)[curr]; } //递增和递减 BlobPtr\u0026 operator++(); //求值运算符 BlobPtr\u0026 operator--(); private: //其他成员 std::size_t curr; //数组中的位置 } 这里前置递增和递减成员返回的时 BlobPtr\u0026，而不是 BlobPtr\u0026，在类模板作用域中，编译器处理模板自身引用会自动提供模板匹配的实参 类模板外使用类模板名在类模板外定义成员时，此时不在类的作用域，直到遇见类名菜进入类的作用域 //后置++版本 template BlobPtr BlobPtr::operator++(int) { BlobPtr ret = *this; ++*this; return ret; } 返回类型位于类的作用域之外，所以必须指出返回类型是一个实例化的 BlobPtr，在函数体内已经进入类的作用域，则定义 ret 时无须重复提供模板实参，如果不通过模板实参，编译器假定使用的类型与成员实例化所用类型一致，等价于：BlobPtr ret = *this; 类模板和友元 一个类包含一个友元声明，类与友元各自是否是模板是互相无关的 如果一个模板包括一个非模板友元，则友元可以访问所以模板实例 如果友元自身也是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例 一对一友好关系类模板与另一个（类或函数）模板间友好关系的最常见的形式是建立对应实例及其友元间的友好关系。例如，我们的 Blob 类应该将 BlobPtr 类和一个模板版本的 Blob template class BlobPtr; //需要提前声明 template class Blob; template bool operator==(const Blob\u0026, const Blob\u0026); template class Blob { friend class BlobPtr; friend bool operator== (const Blob\u0026, const Blob\u0026); //其他成员 } 友元的声明用 Blob 的模板形参作为自己的模板实参，友好关系被限定在相同类型实例化的 Blob 和 BlobPtr 相等运算符之间 //BlobPtr和operator==都是本对象的友元 Blob ca; //BlobPtr和operator==都是本对象的友元 Blob ia; 上面例子中，ca 对 ia 或其他实例没有特殊访问权限 通用和特定模板的友好关系一个类也可以将另一个模板的每个实例都声明为自己的友元，或者限定特定的实例为友元 template class Pal; class C { //C是普通非模板类 friend class Pal;//C实例化Pal是C的友元 //Pal2的所有实例都是C的友元，这种情况无须前置声明 template friend class Pal2; }; template class C2 {//C2是个模板类 //C2每个实例将相同实例的Pal声明为友元 friend class Pal; //Pal2所有实例都是C2每个实例的友元，不需要前置声明 template friend class Pal2; //Pal3是一个非模板类，它是C2所有实例的友元 friend class Pal3; }; 为了让所有实例都成为友元，友元声明中必须使用与类模板不同的模板参数 令模板自己的类型参数成为友元在C++11新标准中，可以将模板类型参数声明为友元 template class Bar { friend Type; //访问权限授予实例化Bar的类型 //... } 此时，对于某个类型 Foo，Foo 将称为 Bar 的友元，Sales_data 将成为 Bar 的友元 模板类型别名类模板一个实例定义了一个类类型，我们可以定义一个 typedef 来引用实例化的类： typedef Blob StrBlob; 由于模板不是一个类型，我们不能定义一个 typedef 引用一个模板，即不能定义一个 typedef 引用 Blob 但是新标准允许为类模板定义一个类型别名： templateusing twin = pair; twin authors; //authors是一个pair使用别名时，也需要像模板那样指出特定类型的 twin 使用一个模板类型别名时，可以固定一个或多个模板参数 template using partNo = pair; partNo books; /","date":"2022-05-07","objectID":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/:1:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十六章 模板与泛型编程","uri":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/#实例化类模板"},{"categories":["C++"],"content":"16.1.2 类模板类模板用来生成类的蓝图，类模板必须提供额外的信息，来确定模板的参数类型，一般在模板名后尖括号中提供实参 定义类模板 template class Blob { public: typedef T value_type; typedef typename std::vector::size_type size_type; //构造函数 Blob(); Blob(std::initializer_list il); //Blob中元素数目 size_type size() const { return data-size(); } bool empty() const { return data-empty(); } void push_back(const T\u0026 t) { return data-push_back(t);} void pop_back(); //元素访问 T\u0026 back(); T\u0026 operator[](size_type i); private: std::shared_ptr data; //若data[i]无效，抛出msg void check(size_type i, const std::string \u0026msg) const; }； 实例化类模板使用一个类模板时，需要提供额外信息，这些额外信息是显示模板实参列表，它们被绑定到模板参数 //使用类模板，必须提供元素类型 Blob ia; Blob ia2 = {0, 1, 2, 3}; ia 和 ia2会实例化以下特定版本的 Blob ` template class Blob { typedef typename std::vector::size_type size_type; Blob(); Blob(std::initializer_list il); //... } 当编译器从 Blob 模板中实例化一个类时，它会重写 Blob 模板，将参数 T 的每个实例替换成给定的模板实参 一个类模板的每个实例都形成一个独立的类，类型 Blob 与其他任何 Blob类型都没有关系，也不会对任何其他 Blob 类型的成员具有特殊的访问权限 类模板的成员函数与其他类一样，既可以在类模板内部，也可以在外部定义其成员函数，且定义在类模板内的成员函数被隐式声明为内联函数 类模板的成员函数本身是一个普通函数 每个类模板的实例都有自己版本的成员函数 类模板的成员函数具有和模板相同的模板参数 定义在类模板之外的成员函数就必须以关键字 template 开始，后接参数列表 简单说就是在类模板内部定义成员函数，可以直接使用参数 T，而在类模板外部定义成员函数，前面需要加上 template 等 template ret-type Blob::member-name(parm-list) 这里必须加上 template 这行 类模板成员函数实例化默认情况下，类模板的成员函数只有当程序使用它的时候才进行实例化 // 实例化Blob和接受initializer_list的构造函数 Blob squares = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; for (size_t i = 0; i != squares.size(); ++i) { squares[i] = i * i; //实例化Blob::operator[](size_t) } 如果一个成员函数没有被使用，则它不会被实例化 类代码内简化模板类名的使用在使用一个类模板类型时必须提供模板实参，但是在类模板自己的作用域中，可以直接使用模板名而不提供实参 template class BlobPtr { public: BlobPtr() : curr(0) {} //其他构造函数 T\u0026 operator*() const { auto p = check(curr, \"derederence past edn\"); return (*p)[curr]; } //递增和递减 BlobPtr\u0026 operator++(); //求值运算符 BlobPtr\u0026 operator--(); private: //其他成员 std::size_t curr; //数组中的位置 } 这里前置递增和递减成员返回的时 BlobPtr\u0026，而不是 BlobPtr\u0026，在类模板作用域中，编译器处理模板自身引用会自动提供模板匹配的实参 类模板外使用类模板名在类模板外定义成员时，此时不在类的作用域，直到遇见类名菜进入类的作用域 //后置++版本 template BlobPtr BlobPtr::operator++(int) { BlobPtr ret = *this; ++*this; return ret; } 返回类型位于类的作用域之外，所以必须指出返回类型是一个实例化的 BlobPtr，在函数体内已经进入类的作用域，则定义 ret 时无须重复提供模板实参，如果不通过模板实参，编译器假定使用的类型与成员实例化所用类型一致，等价于：BlobPtr ret = *this; 类模板和友元 一个类包含一个友元声明，类与友元各自是否是模板是互相无关的 如果一个模板包括一个非模板友元，则友元可以访问所以模板实例 如果友元自身也是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例 一对一友好关系类模板与另一个（类或函数）模板间友好关系的最常见的形式是建立对应实例及其友元间的友好关系。例如，我们的 Blob 类应该将 BlobPtr 类和一个模板版本的 Blob template class BlobPtr; //需要提前声明 template class Blob; template bool operator==(const Blob\u0026, const Blob\u0026); template class Blob { friend class BlobPtr; friend bool operator== (const Blob\u0026, const Blob\u0026); //其他成员 } 友元的声明用 Blob 的模板形参作为自己的模板实参，友好关系被限定在相同类型实例化的 Blob 和 BlobPtr 相等运算符之间 //BlobPtr和operator==都是本对象的友元 Blob ca; //BlobPtr和operator==都是本对象的友元 Blob ia; 上面例子中，ca 对 ia 或其他实例没有特殊访问权限 通用和特定模板的友好关系一个类也可以将另一个模板的每个实例都声明为自己的友元，或者限定特定的实例为友元 template class Pal; class C { //C是普通非模板类 friend class Pal;//C实例化Pal是C的友元 //Pal2的所有实例都是C的友元，这种情况无须前置声明 template friend class Pal2; }; template class C2 {//C2是个模板类 //C2每个实例将相同实例的Pal声明为友元 friend class Pal; //Pal2所有实例都是C2每个实例的友元，不需要前置声明 template friend class Pal2; //Pal3是一个非模板类，它是C2所有实例的友元 friend class Pal3; }; 为了让所有实例都成为友元，友元声明中必须使用与类模板不同的模板参数 令模板自己的类型参数成为友元在C++11新标准中，可以将模板类型参数声明为友元 template class Bar { friend Type; //访问权限授予实例化Bar的类型 //... } 此时，对于某个类型 Foo，Foo 将称为 Bar 的友元，Sales_data 将成为 Bar 的友元 模板类型别名类模板一个实例定义了一个类类型，我们可以定义一个 typedef 来引用实例化的类： typedef Blob StrBlob; 由于模板不是一个类型，我们不能定义一个 typedef 引用一个模板，即不能定义一个 typedef 引用 Blob 但是新标准允许为类模板定义一个类型别名： templateusing twin = pair; twin authors; //authors是一个pair使用别名时，也需要像模板那样指出特定类型的 twin 使用一个模板类型别名时，可以固定一个或多个模板参数 template using partNo = pair; partNo books; /","date":"2022-05-07","objectID":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/:1:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十六章 模板与泛型编程","uri":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/#类模板的成员函数"},{"categories":["C++"],"content":"16.1.2 类模板类模板用来生成类的蓝图，类模板必须提供额外的信息，来确定模板的参数类型，一般在模板名后尖括号中提供实参 定义类模板 template class Blob { public: typedef T value_type; typedef typename std::vector::size_type size_type; //构造函数 Blob(); Blob(std::initializer_list il); //Blob中元素数目 size_type size() const { return data-size(); } bool empty() const { return data-empty(); } void push_back(const T\u0026 t) { return data-push_back(t);} void pop_back(); //元素访问 T\u0026 back(); T\u0026 operator[](size_type i); private: std::shared_ptr data; //若data[i]无效，抛出msg void check(size_type i, const std::string \u0026msg) const; }； 实例化类模板使用一个类模板时，需要提供额外信息，这些额外信息是显示模板实参列表，它们被绑定到模板参数 //使用类模板，必须提供元素类型 Blob ia; Blob ia2 = {0, 1, 2, 3}; ia 和 ia2会实例化以下特定版本的 Blob ` template class Blob { typedef typename std::vector::size_type size_type; Blob(); Blob(std::initializer_list il); //... } 当编译器从 Blob 模板中实例化一个类时，它会重写 Blob 模板，将参数 T 的每个实例替换成给定的模板实参 一个类模板的每个实例都形成一个独立的类，类型 Blob 与其他任何 Blob类型都没有关系，也不会对任何其他 Blob 类型的成员具有特殊的访问权限 类模板的成员函数与其他类一样，既可以在类模板内部，也可以在外部定义其成员函数，且定义在类模板内的成员函数被隐式声明为内联函数 类模板的成员函数本身是一个普通函数 每个类模板的实例都有自己版本的成员函数 类模板的成员函数具有和模板相同的模板参数 定义在类模板之外的成员函数就必须以关键字 template 开始，后接参数列表 简单说就是在类模板内部定义成员函数，可以直接使用参数 T，而在类模板外部定义成员函数，前面需要加上 template 等 template ret-type Blob::member-name(parm-list) 这里必须加上 template 这行 类模板成员函数实例化默认情况下，类模板的成员函数只有当程序使用它的时候才进行实例化 // 实例化Blob和接受initializer_list的构造函数 Blob squares = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; for (size_t i = 0; i != squares.size(); ++i) { squares[i] = i * i; //实例化Blob::operator[](size_t) } 如果一个成员函数没有被使用，则它不会被实例化 类代码内简化模板类名的使用在使用一个类模板类型时必须提供模板实参，但是在类模板自己的作用域中，可以直接使用模板名而不提供实参 template class BlobPtr { public: BlobPtr() : curr(0) {} //其他构造函数 T\u0026 operator*() const { auto p = check(curr, \"derederence past edn\"); return (*p)[curr]; } //递增和递减 BlobPtr\u0026 operator++(); //求值运算符 BlobPtr\u0026 operator--(); private: //其他成员 std::size_t curr; //数组中的位置 } 这里前置递增和递减成员返回的时 BlobPtr\u0026，而不是 BlobPtr\u0026，在类模板作用域中，编译器处理模板自身引用会自动提供模板匹配的实参 类模板外使用类模板名在类模板外定义成员时，此时不在类的作用域，直到遇见类名菜进入类的作用域 //后置++版本 template BlobPtr BlobPtr::operator++(int) { BlobPtr ret = *this; ++*this; return ret; } 返回类型位于类的作用域之外，所以必须指出返回类型是一个实例化的 BlobPtr，在函数体内已经进入类的作用域，则定义 ret 时无须重复提供模板实参，如果不通过模板实参，编译器假定使用的类型与成员实例化所用类型一致，等价于：BlobPtr ret = *this; 类模板和友元 一个类包含一个友元声明，类与友元各自是否是模板是互相无关的 如果一个模板包括一个非模板友元，则友元可以访问所以模板实例 如果友元自身也是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例 一对一友好关系类模板与另一个（类或函数）模板间友好关系的最常见的形式是建立对应实例及其友元间的友好关系。例如，我们的 Blob 类应该将 BlobPtr 类和一个模板版本的 Blob template class BlobPtr; //需要提前声明 template class Blob; template bool operator==(const Blob\u0026, const Blob\u0026); template class Blob { friend class BlobPtr; friend bool operator== (const Blob\u0026, const Blob\u0026); //其他成员 } 友元的声明用 Blob 的模板形参作为自己的模板实参，友好关系被限定在相同类型实例化的 Blob 和 BlobPtr 相等运算符之间 //BlobPtr和operator==都是本对象的友元 Blob ca; //BlobPtr和operator==都是本对象的友元 Blob ia; 上面例子中，ca 对 ia 或其他实例没有特殊访问权限 通用和特定模板的友好关系一个类也可以将另一个模板的每个实例都声明为自己的友元，或者限定特定的实例为友元 template class Pal; class C { //C是普通非模板类 friend class Pal;//C实例化Pal是C的友元 //Pal2的所有实例都是C的友元，这种情况无须前置声明 template friend class Pal2; }; template class C2 {//C2是个模板类 //C2每个实例将相同实例的Pal声明为友元 friend class Pal; //Pal2所有实例都是C2每个实例的友元，不需要前置声明 template friend class Pal2; //Pal3是一个非模板类，它是C2所有实例的友元 friend class Pal3; }; 为了让所有实例都成为友元，友元声明中必须使用与类模板不同的模板参数 令模板自己的类型参数成为友元在C++11新标准中，可以将模板类型参数声明为友元 template class Bar { friend Type; //访问权限授予实例化Bar的类型 //... } 此时，对于某个类型 Foo，Foo 将称为 Bar 的友元，Sales_data 将成为 Bar 的友元 模板类型别名类模板一个实例定义了一个类类型，我们可以定义一个 typedef 来引用实例化的类： typedef Blob StrBlob; 由于模板不是一个类型，我们不能定义一个 typedef 引用一个模板，即不能定义一个 typedef 引用 Blob 但是新标准允许为类模板定义一个类型别名： templateusing twin = pair; twin authors; //authors是一个pair使用别名时，也需要像模板那样指出特定类型的 twin 使用一个模板类型别名时，可以固定一个或多个模板参数 template using partNo = pair; partNo books; /","date":"2022-05-07","objectID":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/:1:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十六章 模板与泛型编程","uri":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/#类模板成员函数实例化"},{"categories":["C++"],"content":"16.1.2 类模板类模板用来生成类的蓝图，类模板必须提供额外的信息，来确定模板的参数类型，一般在模板名后尖括号中提供实参 定义类模板 template class Blob { public: typedef T value_type; typedef typename std::vector::size_type size_type; //构造函数 Blob(); Blob(std::initializer_list il); //Blob中元素数目 size_type size() const { return data-size(); } bool empty() const { return data-empty(); } void push_back(const T\u0026 t) { return data-push_back(t);} void pop_back(); //元素访问 T\u0026 back(); T\u0026 operator[](size_type i); private: std::shared_ptr data; //若data[i]无效，抛出msg void check(size_type i, const std::string \u0026msg) const; }； 实例化类模板使用一个类模板时，需要提供额外信息，这些额外信息是显示模板实参列表，它们被绑定到模板参数 //使用类模板，必须提供元素类型 Blob ia; Blob ia2 = {0, 1, 2, 3}; ia 和 ia2会实例化以下特定版本的 Blob ` template class Blob { typedef typename std::vector::size_type size_type; Blob(); Blob(std::initializer_list il); //... } 当编译器从 Blob 模板中实例化一个类时，它会重写 Blob 模板，将参数 T 的每个实例替换成给定的模板实参 一个类模板的每个实例都形成一个独立的类，类型 Blob 与其他任何 Blob类型都没有关系，也不会对任何其他 Blob 类型的成员具有特殊的访问权限 类模板的成员函数与其他类一样，既可以在类模板内部，也可以在外部定义其成员函数，且定义在类模板内的成员函数被隐式声明为内联函数 类模板的成员函数本身是一个普通函数 每个类模板的实例都有自己版本的成员函数 类模板的成员函数具有和模板相同的模板参数 定义在类模板之外的成员函数就必须以关键字 template 开始，后接参数列表 简单说就是在类模板内部定义成员函数，可以直接使用参数 T，而在类模板外部定义成员函数，前面需要加上 template 等 template ret-type Blob::member-name(parm-list) 这里必须加上 template 这行 类模板成员函数实例化默认情况下，类模板的成员函数只有当程序使用它的时候才进行实例化 // 实例化Blob和接受initializer_list的构造函数 Blob squares = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; for (size_t i = 0; i != squares.size(); ++i) { squares[i] = i * i; //实例化Blob::operator[](size_t) } 如果一个成员函数没有被使用，则它不会被实例化 类代码内简化模板类名的使用在使用一个类模板类型时必须提供模板实参，但是在类模板自己的作用域中，可以直接使用模板名而不提供实参 template class BlobPtr { public: BlobPtr() : curr(0) {} //其他构造函数 T\u0026 operator*() const { auto p = check(curr, \"derederence past edn\"); return (*p)[curr]; } //递增和递减 BlobPtr\u0026 operator++(); //求值运算符 BlobPtr\u0026 operator--(); private: //其他成员 std::size_t curr; //数组中的位置 } 这里前置递增和递减成员返回的时 BlobPtr\u0026，而不是 BlobPtr\u0026，在类模板作用域中，编译器处理模板自身引用会自动提供模板匹配的实参 类模板外使用类模板名在类模板外定义成员时，此时不在类的作用域，直到遇见类名菜进入类的作用域 //后置++版本 template BlobPtr BlobPtr::operator++(int) { BlobPtr ret = *this; ++*this; return ret; } 返回类型位于类的作用域之外，所以必须指出返回类型是一个实例化的 BlobPtr，在函数体内已经进入类的作用域，则定义 ret 时无须重复提供模板实参，如果不通过模板实参，编译器假定使用的类型与成员实例化所用类型一致，等价于：BlobPtr ret = *this; 类模板和友元 一个类包含一个友元声明，类与友元各自是否是模板是互相无关的 如果一个模板包括一个非模板友元，则友元可以访问所以模板实例 如果友元自身也是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例 一对一友好关系类模板与另一个（类或函数）模板间友好关系的最常见的形式是建立对应实例及其友元间的友好关系。例如，我们的 Blob 类应该将 BlobPtr 类和一个模板版本的 Blob template class BlobPtr; //需要提前声明 template class Blob; template bool operator==(const Blob\u0026, const Blob\u0026); template class Blob { friend class BlobPtr; friend bool operator== (const Blob\u0026, const Blob\u0026); //其他成员 } 友元的声明用 Blob 的模板形参作为自己的模板实参，友好关系被限定在相同类型实例化的 Blob 和 BlobPtr 相等运算符之间 //BlobPtr和operator==都是本对象的友元 Blob ca; //BlobPtr和operator==都是本对象的友元 Blob ia; 上面例子中，ca 对 ia 或其他实例没有特殊访问权限 通用和特定模板的友好关系一个类也可以将另一个模板的每个实例都声明为自己的友元，或者限定特定的实例为友元 template class Pal; class C { //C是普通非模板类 friend class Pal;//C实例化Pal是C的友元 //Pal2的所有实例都是C的友元，这种情况无须前置声明 template friend class Pal2; }; template class C2 {//C2是个模板类 //C2每个实例将相同实例的Pal声明为友元 friend class Pal; //Pal2所有实例都是C2每个实例的友元，不需要前置声明 template friend class Pal2; //Pal3是一个非模板类，它是C2所有实例的友元 friend class Pal3; }; 为了让所有实例都成为友元，友元声明中必须使用与类模板不同的模板参数 令模板自己的类型参数成为友元在C++11新标准中，可以将模板类型参数声明为友元 template class Bar { friend Type; //访问权限授予实例化Bar的类型 //... } 此时，对于某个类型 Foo，Foo 将称为 Bar 的友元，Sales_data 将成为 Bar 的友元 模板类型别名类模板一个实例定义了一个类类型，我们可以定义一个 typedef 来引用实例化的类： typedef Blob StrBlob; 由于模板不是一个类型，我们不能定义一个 typedef 引用一个模板，即不能定义一个 typedef 引用 Blob 但是新标准允许为类模板定义一个类型别名： templateusing twin = pair; twin authors; //authors是一个pair使用别名时，也需要像模板那样指出特定类型的 twin 使用一个模板类型别名时，可以固定一个或多个模板参数 template using partNo = pair; partNo books; /","date":"2022-05-07","objectID":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/:1:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十六章 模板与泛型编程","uri":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/#类代码内简化模板类名的使用"},{"categories":["C++"],"content":"16.1.2 类模板类模板用来生成类的蓝图，类模板必须提供额外的信息，来确定模板的参数类型，一般在模板名后尖括号中提供实参 定义类模板 template class Blob { public: typedef T value_type; typedef typename std::vector::size_type size_type; //构造函数 Blob(); Blob(std::initializer_list il); //Blob中元素数目 size_type size() const { return data-size(); } bool empty() const { return data-empty(); } void push_back(const T\u0026 t) { return data-push_back(t);} void pop_back(); //元素访问 T\u0026 back(); T\u0026 operator[](size_type i); private: std::shared_ptr data; //若data[i]无效，抛出msg void check(size_type i, const std::string \u0026msg) const; }； 实例化类模板使用一个类模板时，需要提供额外信息，这些额外信息是显示模板实参列表，它们被绑定到模板参数 //使用类模板，必须提供元素类型 Blob ia; Blob ia2 = {0, 1, 2, 3}; ia 和 ia2会实例化以下特定版本的 Blob ` template class Blob { typedef typename std::vector::size_type size_type; Blob(); Blob(std::initializer_list il); //... } 当编译器从 Blob 模板中实例化一个类时，它会重写 Blob 模板，将参数 T 的每个实例替换成给定的模板实参 一个类模板的每个实例都形成一个独立的类，类型 Blob 与其他任何 Blob类型都没有关系，也不会对任何其他 Blob 类型的成员具有特殊的访问权限 类模板的成员函数与其他类一样，既可以在类模板内部，也可以在外部定义其成员函数，且定义在类模板内的成员函数被隐式声明为内联函数 类模板的成员函数本身是一个普通函数 每个类模板的实例都有自己版本的成员函数 类模板的成员函数具有和模板相同的模板参数 定义在类模板之外的成员函数就必须以关键字 template 开始，后接参数列表 简单说就是在类模板内部定义成员函数，可以直接使用参数 T，而在类模板外部定义成员函数，前面需要加上 template 等 template ret-type Blob::member-name(parm-list) 这里必须加上 template 这行 类模板成员函数实例化默认情况下，类模板的成员函数只有当程序使用它的时候才进行实例化 // 实例化Blob和接受initializer_list的构造函数 Blob squares = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; for (size_t i = 0; i != squares.size(); ++i) { squares[i] = i * i; //实例化Blob::operator[](size_t) } 如果一个成员函数没有被使用，则它不会被实例化 类代码内简化模板类名的使用在使用一个类模板类型时必须提供模板实参，但是在类模板自己的作用域中，可以直接使用模板名而不提供实参 template class BlobPtr { public: BlobPtr() : curr(0) {} //其他构造函数 T\u0026 operator*() const { auto p = check(curr, \"derederence past edn\"); return (*p)[curr]; } //递增和递减 BlobPtr\u0026 operator++(); //求值运算符 BlobPtr\u0026 operator--(); private: //其他成员 std::size_t curr; //数组中的位置 } 这里前置递增和递减成员返回的时 BlobPtr\u0026，而不是 BlobPtr\u0026，在类模板作用域中，编译器处理模板自身引用会自动提供模板匹配的实参 类模板外使用类模板名在类模板外定义成员时，此时不在类的作用域，直到遇见类名菜进入类的作用域 //后置++版本 template BlobPtr BlobPtr::operator++(int) { BlobPtr ret = *this; ++*this; return ret; } 返回类型位于类的作用域之外，所以必须指出返回类型是一个实例化的 BlobPtr，在函数体内已经进入类的作用域，则定义 ret 时无须重复提供模板实参，如果不通过模板实参，编译器假定使用的类型与成员实例化所用类型一致，等价于：BlobPtr ret = *this; 类模板和友元 一个类包含一个友元声明，类与友元各自是否是模板是互相无关的 如果一个模板包括一个非模板友元，则友元可以访问所以模板实例 如果友元自身也是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例 一对一友好关系类模板与另一个（类或函数）模板间友好关系的最常见的形式是建立对应实例及其友元间的友好关系。例如，我们的 Blob 类应该将 BlobPtr 类和一个模板版本的 Blob template class BlobPtr; //需要提前声明 template class Blob; template bool operator==(const Blob\u0026, const Blob\u0026); template class Blob { friend class BlobPtr; friend bool operator== (const Blob\u0026, const Blob\u0026); //其他成员 } 友元的声明用 Blob 的模板形参作为自己的模板实参，友好关系被限定在相同类型实例化的 Blob 和 BlobPtr 相等运算符之间 //BlobPtr和operator==都是本对象的友元 Blob ca; //BlobPtr和operator==都是本对象的友元 Blob ia; 上面例子中，ca 对 ia 或其他实例没有特殊访问权限 通用和特定模板的友好关系一个类也可以将另一个模板的每个实例都声明为自己的友元，或者限定特定的实例为友元 template class Pal; class C { //C是普通非模板类 friend class Pal;//C实例化Pal是C的友元 //Pal2的所有实例都是C的友元，这种情况无须前置声明 template friend class Pal2; }; template class C2 {//C2是个模板类 //C2每个实例将相同实例的Pal声明为友元 friend class Pal; //Pal2所有实例都是C2每个实例的友元，不需要前置声明 template friend class Pal2; //Pal3是一个非模板类，它是C2所有实例的友元 friend class Pal3; }; 为了让所有实例都成为友元，友元声明中必须使用与类模板不同的模板参数 令模板自己的类型参数成为友元在C++11新标准中，可以将模板类型参数声明为友元 template class Bar { friend Type; //访问权限授予实例化Bar的类型 //... } 此时，对于某个类型 Foo，Foo 将称为 Bar 的友元，Sales_data 将成为 Bar 的友元 模板类型别名类模板一个实例定义了一个类类型，我们可以定义一个 typedef 来引用实例化的类： typedef Blob StrBlob; 由于模板不是一个类型，我们不能定义一个 typedef 引用一个模板，即不能定义一个 typedef 引用 Blob 但是新标准允许为类模板定义一个类型别名： templateusing twin = pair; twin authors; //authors是一个pair使用别名时，也需要像模板那样指出特定类型的 twin 使用一个模板类型别名时，可以固定一个或多个模板参数 template using partNo = pair; partNo books; /","date":"2022-05-07","objectID":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/:1:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十六章 模板与泛型编程","uri":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/#类模板外使用类模板名"},{"categories":["C++"],"content":"16.1.2 类模板类模板用来生成类的蓝图，类模板必须提供额外的信息，来确定模板的参数类型，一般在模板名后尖括号中提供实参 定义类模板 template class Blob { public: typedef T value_type; typedef typename std::vector::size_type size_type; //构造函数 Blob(); Blob(std::initializer_list il); //Blob中元素数目 size_type size() const { return data-size(); } bool empty() const { return data-empty(); } void push_back(const T\u0026 t) { return data-push_back(t);} void pop_back(); //元素访问 T\u0026 back(); T\u0026 operator[](size_type i); private: std::shared_ptr data; //若data[i]无效，抛出msg void check(size_type i, const std::string \u0026msg) const; }； 实例化类模板使用一个类模板时，需要提供额外信息，这些额外信息是显示模板实参列表，它们被绑定到模板参数 //使用类模板，必须提供元素类型 Blob ia; Blob ia2 = {0, 1, 2, 3}; ia 和 ia2会实例化以下特定版本的 Blob ` template class Blob { typedef typename std::vector::size_type size_type; Blob(); Blob(std::initializer_list il); //... } 当编译器从 Blob 模板中实例化一个类时，它会重写 Blob 模板，将参数 T 的每个实例替换成给定的模板实参 一个类模板的每个实例都形成一个独立的类，类型 Blob 与其他任何 Blob类型都没有关系，也不会对任何其他 Blob 类型的成员具有特殊的访问权限 类模板的成员函数与其他类一样，既可以在类模板内部，也可以在外部定义其成员函数，且定义在类模板内的成员函数被隐式声明为内联函数 类模板的成员函数本身是一个普通函数 每个类模板的实例都有自己版本的成员函数 类模板的成员函数具有和模板相同的模板参数 定义在类模板之外的成员函数就必须以关键字 template 开始，后接参数列表 简单说就是在类模板内部定义成员函数，可以直接使用参数 T，而在类模板外部定义成员函数，前面需要加上 template 等 template ret-type Blob::member-name(parm-list) 这里必须加上 template 这行 类模板成员函数实例化默认情况下，类模板的成员函数只有当程序使用它的时候才进行实例化 // 实例化Blob和接受initializer_list的构造函数 Blob squares = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; for (size_t i = 0; i != squares.size(); ++i) { squares[i] = i * i; //实例化Blob::operator[](size_t) } 如果一个成员函数没有被使用，则它不会被实例化 类代码内简化模板类名的使用在使用一个类模板类型时必须提供模板实参，但是在类模板自己的作用域中，可以直接使用模板名而不提供实参 template class BlobPtr { public: BlobPtr() : curr(0) {} //其他构造函数 T\u0026 operator*() const { auto p = check(curr, \"derederence past edn\"); return (*p)[curr]; } //递增和递减 BlobPtr\u0026 operator++(); //求值运算符 BlobPtr\u0026 operator--(); private: //其他成员 std::size_t curr; //数组中的位置 } 这里前置递增和递减成员返回的时 BlobPtr\u0026，而不是 BlobPtr\u0026，在类模板作用域中，编译器处理模板自身引用会自动提供模板匹配的实参 类模板外使用类模板名在类模板外定义成员时，此时不在类的作用域，直到遇见类名菜进入类的作用域 //后置++版本 template BlobPtr BlobPtr::operator++(int) { BlobPtr ret = *this; ++*this; return ret; } 返回类型位于类的作用域之外，所以必须指出返回类型是一个实例化的 BlobPtr，在函数体内已经进入类的作用域，则定义 ret 时无须重复提供模板实参，如果不通过模板实参，编译器假定使用的类型与成员实例化所用类型一致，等价于：BlobPtr ret = *this; 类模板和友元 一个类包含一个友元声明，类与友元各自是否是模板是互相无关的 如果一个模板包括一个非模板友元，则友元可以访问所以模板实例 如果友元自身也是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例 一对一友好关系类模板与另一个（类或函数）模板间友好关系的最常见的形式是建立对应实例及其友元间的友好关系。例如，我们的 Blob 类应该将 BlobPtr 类和一个模板版本的 Blob template class BlobPtr; //需要提前声明 template class Blob; template bool operator==(const Blob\u0026, const Blob\u0026); template class Blob { friend class BlobPtr; friend bool operator== (const Blob\u0026, const Blob\u0026); //其他成员 } 友元的声明用 Blob 的模板形参作为自己的模板实参，友好关系被限定在相同类型实例化的 Blob 和 BlobPtr 相等运算符之间 //BlobPtr和operator==都是本对象的友元 Blob ca; //BlobPtr和operator==都是本对象的友元 Blob ia; 上面例子中，ca 对 ia 或其他实例没有特殊访问权限 通用和特定模板的友好关系一个类也可以将另一个模板的每个实例都声明为自己的友元，或者限定特定的实例为友元 template class Pal; class C { //C是普通非模板类 friend class Pal;//C实例化Pal是C的友元 //Pal2的所有实例都是C的友元，这种情况无须前置声明 template friend class Pal2; }; template class C2 {//C2是个模板类 //C2每个实例将相同实例的Pal声明为友元 friend class Pal; //Pal2所有实例都是C2每个实例的友元，不需要前置声明 template friend class Pal2; //Pal3是一个非模板类，它是C2所有实例的友元 friend class Pal3; }; 为了让所有实例都成为友元，友元声明中必须使用与类模板不同的模板参数 令模板自己的类型参数成为友元在C++11新标准中，可以将模板类型参数声明为友元 template class Bar { friend Type; //访问权限授予实例化Bar的类型 //... } 此时，对于某个类型 Foo，Foo 将称为 Bar 的友元，Sales_data 将成为 Bar 的友元 模板类型别名类模板一个实例定义了一个类类型，我们可以定义一个 typedef 来引用实例化的类： typedef Blob StrBlob; 由于模板不是一个类型，我们不能定义一个 typedef 引用一个模板，即不能定义一个 typedef 引用 Blob 但是新标准允许为类模板定义一个类型别名： templateusing twin = pair; twin authors; //authors是一个pair使用别名时，也需要像模板那样指出特定类型的 twin 使用一个模板类型别名时，可以固定一个或多个模板参数 template using partNo = pair; partNo books; /","date":"2022-05-07","objectID":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/:1:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十六章 模板与泛型编程","uri":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/#类模板和友元"},{"categories":["C++"],"content":"16.1.2 类模板类模板用来生成类的蓝图，类模板必须提供额外的信息，来确定模板的参数类型，一般在模板名后尖括号中提供实参 定义类模板 template class Blob { public: typedef T value_type; typedef typename std::vector::size_type size_type; //构造函数 Blob(); Blob(std::initializer_list il); //Blob中元素数目 size_type size() const { return data-size(); } bool empty() const { return data-empty(); } void push_back(const T\u0026 t) { return data-push_back(t);} void pop_back(); //元素访问 T\u0026 back(); T\u0026 operator[](size_type i); private: std::shared_ptr data; //若data[i]无效，抛出msg void check(size_type i, const std::string \u0026msg) const; }； 实例化类模板使用一个类模板时，需要提供额外信息，这些额外信息是显示模板实参列表，它们被绑定到模板参数 //使用类模板，必须提供元素类型 Blob ia; Blob ia2 = {0, 1, 2, 3}; ia 和 ia2会实例化以下特定版本的 Blob ` template class Blob { typedef typename std::vector::size_type size_type; Blob(); Blob(std::initializer_list il); //... } 当编译器从 Blob 模板中实例化一个类时，它会重写 Blob 模板，将参数 T 的每个实例替换成给定的模板实参 一个类模板的每个实例都形成一个独立的类，类型 Blob 与其他任何 Blob类型都没有关系，也不会对任何其他 Blob 类型的成员具有特殊的访问权限 类模板的成员函数与其他类一样，既可以在类模板内部，也可以在外部定义其成员函数，且定义在类模板内的成员函数被隐式声明为内联函数 类模板的成员函数本身是一个普通函数 每个类模板的实例都有自己版本的成员函数 类模板的成员函数具有和模板相同的模板参数 定义在类模板之外的成员函数就必须以关键字 template 开始，后接参数列表 简单说就是在类模板内部定义成员函数，可以直接使用参数 T，而在类模板外部定义成员函数，前面需要加上 template 等 template ret-type Blob::member-name(parm-list) 这里必须加上 template 这行 类模板成员函数实例化默认情况下，类模板的成员函数只有当程序使用它的时候才进行实例化 // 实例化Blob和接受initializer_list的构造函数 Blob squares = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; for (size_t i = 0; i != squares.size(); ++i) { squares[i] = i * i; //实例化Blob::operator[](size_t) } 如果一个成员函数没有被使用，则它不会被实例化 类代码内简化模板类名的使用在使用一个类模板类型时必须提供模板实参，但是在类模板自己的作用域中，可以直接使用模板名而不提供实参 template class BlobPtr { public: BlobPtr() : curr(0) {} //其他构造函数 T\u0026 operator*() const { auto p = check(curr, \"derederence past edn\"); return (*p)[curr]; } //递增和递减 BlobPtr\u0026 operator++(); //求值运算符 BlobPtr\u0026 operator--(); private: //其他成员 std::size_t curr; //数组中的位置 } 这里前置递增和递减成员返回的时 BlobPtr\u0026，而不是 BlobPtr\u0026，在类模板作用域中，编译器处理模板自身引用会自动提供模板匹配的实参 类模板外使用类模板名在类模板外定义成员时，此时不在类的作用域，直到遇见类名菜进入类的作用域 //后置++版本 template BlobPtr BlobPtr::operator++(int) { BlobPtr ret = *this; ++*this; return ret; } 返回类型位于类的作用域之外，所以必须指出返回类型是一个实例化的 BlobPtr，在函数体内已经进入类的作用域，则定义 ret 时无须重复提供模板实参，如果不通过模板实参，编译器假定使用的类型与成员实例化所用类型一致，等价于：BlobPtr ret = *this; 类模板和友元 一个类包含一个友元声明，类与友元各自是否是模板是互相无关的 如果一个模板包括一个非模板友元，则友元可以访问所以模板实例 如果友元自身也是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例 一对一友好关系类模板与另一个（类或函数）模板间友好关系的最常见的形式是建立对应实例及其友元间的友好关系。例如，我们的 Blob 类应该将 BlobPtr 类和一个模板版本的 Blob template class BlobPtr; //需要提前声明 template class Blob; template bool operator==(const Blob\u0026, const Blob\u0026); template class Blob { friend class BlobPtr; friend bool operator== (const Blob\u0026, const Blob\u0026); //其他成员 } 友元的声明用 Blob 的模板形参作为自己的模板实参，友好关系被限定在相同类型实例化的 Blob 和 BlobPtr 相等运算符之间 //BlobPtr和operator==都是本对象的友元 Blob ca; //BlobPtr和operator==都是本对象的友元 Blob ia; 上面例子中，ca 对 ia 或其他实例没有特殊访问权限 通用和特定模板的友好关系一个类也可以将另一个模板的每个实例都声明为自己的友元，或者限定特定的实例为友元 template class Pal; class C { //C是普通非模板类 friend class Pal;//C实例化Pal是C的友元 //Pal2的所有实例都是C的友元，这种情况无须前置声明 template friend class Pal2; }; template class C2 {//C2是个模板类 //C2每个实例将相同实例的Pal声明为友元 friend class Pal; //Pal2所有实例都是C2每个实例的友元，不需要前置声明 template friend class Pal2; //Pal3是一个非模板类，它是C2所有实例的友元 friend class Pal3; }; 为了让所有实例都成为友元，友元声明中必须使用与类模板不同的模板参数 令模板自己的类型参数成为友元在C++11新标准中，可以将模板类型参数声明为友元 template class Bar { friend Type; //访问权限授予实例化Bar的类型 //... } 此时，对于某个类型 Foo，Foo 将称为 Bar 的友元，Sales_data 将成为 Bar 的友元 模板类型别名类模板一个实例定义了一个类类型，我们可以定义一个 typedef 来引用实例化的类： typedef Blob StrBlob; 由于模板不是一个类型，我们不能定义一个 typedef 引用一个模板，即不能定义一个 typedef 引用 Blob 但是新标准允许为类模板定义一个类型别名： templateusing twin = pair; twin authors; //authors是一个pair使用别名时，也需要像模板那样指出特定类型的 twin 使用一个模板类型别名时，可以固定一个或多个模板参数 template using partNo = pair; partNo books; /","date":"2022-05-07","objectID":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/:1:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十六章 模板与泛型编程","uri":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/#一对一友好关系"},{"categories":["C++"],"content":"16.1.2 类模板类模板用来生成类的蓝图，类模板必须提供额外的信息，来确定模板的参数类型，一般在模板名后尖括号中提供实参 定义类模板 template class Blob { public: typedef T value_type; typedef typename std::vector::size_type size_type; //构造函数 Blob(); Blob(std::initializer_list il); //Blob中元素数目 size_type size() const { return data-size(); } bool empty() const { return data-empty(); } void push_back(const T\u0026 t) { return data-push_back(t);} void pop_back(); //元素访问 T\u0026 back(); T\u0026 operator[](size_type i); private: std::shared_ptr data; //若data[i]无效，抛出msg void check(size_type i, const std::string \u0026msg) const; }； 实例化类模板使用一个类模板时，需要提供额外信息，这些额外信息是显示模板实参列表，它们被绑定到模板参数 //使用类模板，必须提供元素类型 Blob ia; Blob ia2 = {0, 1, 2, 3}; ia 和 ia2会实例化以下特定版本的 Blob ` template class Blob { typedef typename std::vector::size_type size_type; Blob(); Blob(std::initializer_list il); //... } 当编译器从 Blob 模板中实例化一个类时，它会重写 Blob 模板，将参数 T 的每个实例替换成给定的模板实参 一个类模板的每个实例都形成一个独立的类，类型 Blob 与其他任何 Blob类型都没有关系，也不会对任何其他 Blob 类型的成员具有特殊的访问权限 类模板的成员函数与其他类一样，既可以在类模板内部，也可以在外部定义其成员函数，且定义在类模板内的成员函数被隐式声明为内联函数 类模板的成员函数本身是一个普通函数 每个类模板的实例都有自己版本的成员函数 类模板的成员函数具有和模板相同的模板参数 定义在类模板之外的成员函数就必须以关键字 template 开始，后接参数列表 简单说就是在类模板内部定义成员函数，可以直接使用参数 T，而在类模板外部定义成员函数，前面需要加上 template 等 template ret-type Blob::member-name(parm-list) 这里必须加上 template 这行 类模板成员函数实例化默认情况下，类模板的成员函数只有当程序使用它的时候才进行实例化 // 实例化Blob和接受initializer_list的构造函数 Blob squares = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; for (size_t i = 0; i != squares.size(); ++i) { squares[i] = i * i; //实例化Blob::operator[](size_t) } 如果一个成员函数没有被使用，则它不会被实例化 类代码内简化模板类名的使用在使用一个类模板类型时必须提供模板实参，但是在类模板自己的作用域中，可以直接使用模板名而不提供实参 template class BlobPtr { public: BlobPtr() : curr(0) {} //其他构造函数 T\u0026 operator*() const { auto p = check(curr, \"derederence past edn\"); return (*p)[curr]; } //递增和递减 BlobPtr\u0026 operator++(); //求值运算符 BlobPtr\u0026 operator--(); private: //其他成员 std::size_t curr; //数组中的位置 } 这里前置递增和递减成员返回的时 BlobPtr\u0026，而不是 BlobPtr\u0026，在类模板作用域中，编译器处理模板自身引用会自动提供模板匹配的实参 类模板外使用类模板名在类模板外定义成员时，此时不在类的作用域，直到遇见类名菜进入类的作用域 //后置++版本 template BlobPtr BlobPtr::operator++(int) { BlobPtr ret = *this; ++*this; return ret; } 返回类型位于类的作用域之外，所以必须指出返回类型是一个实例化的 BlobPtr，在函数体内已经进入类的作用域，则定义 ret 时无须重复提供模板实参，如果不通过模板实参，编译器假定使用的类型与成员实例化所用类型一致，等价于：BlobPtr ret = *this; 类模板和友元 一个类包含一个友元声明，类与友元各自是否是模板是互相无关的 如果一个模板包括一个非模板友元，则友元可以访问所以模板实例 如果友元自身也是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例 一对一友好关系类模板与另一个（类或函数）模板间友好关系的最常见的形式是建立对应实例及其友元间的友好关系。例如，我们的 Blob 类应该将 BlobPtr 类和一个模板版本的 Blob template class BlobPtr; //需要提前声明 template class Blob; template bool operator==(const Blob\u0026, const Blob\u0026); template class Blob { friend class BlobPtr; friend bool operator== (const Blob\u0026, const Blob\u0026); //其他成员 } 友元的声明用 Blob 的模板形参作为自己的模板实参，友好关系被限定在相同类型实例化的 Blob 和 BlobPtr 相等运算符之间 //BlobPtr和operator==都是本对象的友元 Blob ca; //BlobPtr和operator==都是本对象的友元 Blob ia; 上面例子中，ca 对 ia 或其他实例没有特殊访问权限 通用和特定模板的友好关系一个类也可以将另一个模板的每个实例都声明为自己的友元，或者限定特定的实例为友元 template class Pal; class C { //C是普通非模板类 friend class Pal;//C实例化Pal是C的友元 //Pal2的所有实例都是C的友元，这种情况无须前置声明 template friend class Pal2; }; template class C2 {//C2是个模板类 //C2每个实例将相同实例的Pal声明为友元 friend class Pal; //Pal2所有实例都是C2每个实例的友元，不需要前置声明 template friend class Pal2; //Pal3是一个非模板类，它是C2所有实例的友元 friend class Pal3; }; 为了让所有实例都成为友元，友元声明中必须使用与类模板不同的模板参数 令模板自己的类型参数成为友元在C++11新标准中，可以将模板类型参数声明为友元 template class Bar { friend Type; //访问权限授予实例化Bar的类型 //... } 此时，对于某个类型 Foo，Foo 将称为 Bar 的友元，Sales_data 将成为 Bar 的友元 模板类型别名类模板一个实例定义了一个类类型，我们可以定义一个 typedef 来引用实例化的类： typedef Blob StrBlob; 由于模板不是一个类型，我们不能定义一个 typedef 引用一个模板，即不能定义一个 typedef 引用 Blob 但是新标准允许为类模板定义一个类型别名： templateusing twin = pair; twin authors; //authors是一个pair使用别名时，也需要像模板那样指出特定类型的 twin 使用一个模板类型别名时，可以固定一个或多个模板参数 template using partNo = pair; partNo books; /","date":"2022-05-07","objectID":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/:1:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十六章 模板与泛型编程","uri":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/#通用和特定模板的友好关系"},{"categories":["C++"],"content":"16.1.2 类模板类模板用来生成类的蓝图，类模板必须提供额外的信息，来确定模板的参数类型，一般在模板名后尖括号中提供实参 定义类模板 template class Blob { public: typedef T value_type; typedef typename std::vector::size_type size_type; //构造函数 Blob(); Blob(std::initializer_list il); //Blob中元素数目 size_type size() const { return data-size(); } bool empty() const { return data-empty(); } void push_back(const T\u0026 t) { return data-push_back(t);} void pop_back(); //元素访问 T\u0026 back(); T\u0026 operator[](size_type i); private: std::shared_ptr data; //若data[i]无效，抛出msg void check(size_type i, const std::string \u0026msg) const; }； 实例化类模板使用一个类模板时，需要提供额外信息，这些额外信息是显示模板实参列表，它们被绑定到模板参数 //使用类模板，必须提供元素类型 Blob ia; Blob ia2 = {0, 1, 2, 3}; ia 和 ia2会实例化以下特定版本的 Blob ` template class Blob { typedef typename std::vector::size_type size_type; Blob(); Blob(std::initializer_list il); //... } 当编译器从 Blob 模板中实例化一个类时，它会重写 Blob 模板，将参数 T 的每个实例替换成给定的模板实参 一个类模板的每个实例都形成一个独立的类，类型 Blob 与其他任何 Blob类型都没有关系，也不会对任何其他 Blob 类型的成员具有特殊的访问权限 类模板的成员函数与其他类一样，既可以在类模板内部，也可以在外部定义其成员函数，且定义在类模板内的成员函数被隐式声明为内联函数 类模板的成员函数本身是一个普通函数 每个类模板的实例都有自己版本的成员函数 类模板的成员函数具有和模板相同的模板参数 定义在类模板之外的成员函数就必须以关键字 template 开始，后接参数列表 简单说就是在类模板内部定义成员函数，可以直接使用参数 T，而在类模板外部定义成员函数，前面需要加上 template 等 template ret-type Blob::member-name(parm-list) 这里必须加上 template 这行 类模板成员函数实例化默认情况下，类模板的成员函数只有当程序使用它的时候才进行实例化 // 实例化Blob和接受initializer_list的构造函数 Blob squares = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; for (size_t i = 0; i != squares.size(); ++i) { squares[i] = i * i; //实例化Blob::operator[](size_t) } 如果一个成员函数没有被使用，则它不会被实例化 类代码内简化模板类名的使用在使用一个类模板类型时必须提供模板实参，但是在类模板自己的作用域中，可以直接使用模板名而不提供实参 template class BlobPtr { public: BlobPtr() : curr(0) {} //其他构造函数 T\u0026 operator*() const { auto p = check(curr, \"derederence past edn\"); return (*p)[curr]; } //递增和递减 BlobPtr\u0026 operator++(); //求值运算符 BlobPtr\u0026 operator--(); private: //其他成员 std::size_t curr; //数组中的位置 } 这里前置递增和递减成员返回的时 BlobPtr\u0026，而不是 BlobPtr\u0026，在类模板作用域中，编译器处理模板自身引用会自动提供模板匹配的实参 类模板外使用类模板名在类模板外定义成员时，此时不在类的作用域，直到遇见类名菜进入类的作用域 //后置++版本 template BlobPtr BlobPtr::operator++(int) { BlobPtr ret = *this; ++*this; return ret; } 返回类型位于类的作用域之外，所以必须指出返回类型是一个实例化的 BlobPtr，在函数体内已经进入类的作用域，则定义 ret 时无须重复提供模板实参，如果不通过模板实参，编译器假定使用的类型与成员实例化所用类型一致，等价于：BlobPtr ret = *this; 类模板和友元 一个类包含一个友元声明，类与友元各自是否是模板是互相无关的 如果一个模板包括一个非模板友元，则友元可以访问所以模板实例 如果友元自身也是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例 一对一友好关系类模板与另一个（类或函数）模板间友好关系的最常见的形式是建立对应实例及其友元间的友好关系。例如，我们的 Blob 类应该将 BlobPtr 类和一个模板版本的 Blob template class BlobPtr; //需要提前声明 template class Blob; template bool operator==(const Blob\u0026, const Blob\u0026); template class Blob { friend class BlobPtr; friend bool operator== (const Blob\u0026, const Blob\u0026); //其他成员 } 友元的声明用 Blob 的模板形参作为自己的模板实参，友好关系被限定在相同类型实例化的 Blob 和 BlobPtr 相等运算符之间 //BlobPtr和operator==都是本对象的友元 Blob ca; //BlobPtr和operator==都是本对象的友元 Blob ia; 上面例子中，ca 对 ia 或其他实例没有特殊访问权限 通用和特定模板的友好关系一个类也可以将另一个模板的每个实例都声明为自己的友元，或者限定特定的实例为友元 template class Pal; class C { //C是普通非模板类 friend class Pal;//C实例化Pal是C的友元 //Pal2的所有实例都是C的友元，这种情况无须前置声明 template friend class Pal2; }; template class C2 {//C2是个模板类 //C2每个实例将相同实例的Pal声明为友元 friend class Pal; //Pal2所有实例都是C2每个实例的友元，不需要前置声明 template friend class Pal2; //Pal3是一个非模板类，它是C2所有实例的友元 friend class Pal3; }; 为了让所有实例都成为友元，友元声明中必须使用与类模板不同的模板参数 令模板自己的类型参数成为友元在C++11新标准中，可以将模板类型参数声明为友元 template class Bar { friend Type; //访问权限授予实例化Bar的类型 //... } 此时，对于某个类型 Foo，Foo 将称为 Bar 的友元，Sales_data 将成为 Bar 的友元 模板类型别名类模板一个实例定义了一个类类型，我们可以定义一个 typedef 来引用实例化的类： typedef Blob StrBlob; 由于模板不是一个类型，我们不能定义一个 typedef 引用一个模板，即不能定义一个 typedef 引用 Blob 但是新标准允许为类模板定义一个类型别名： templateusing twin = pair; twin authors; //authors是一个pair使用别名时，也需要像模板那样指出特定类型的 twin 使用一个模板类型别名时，可以固定一个或多个模板参数 template using partNo = pair; partNo books; /","date":"2022-05-07","objectID":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/:1:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十六章 模板与泛型编程","uri":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/#令模板自己的类型参数成为友元"},{"categories":["C++"],"content":"16.1.2 类模板类模板用来生成类的蓝图，类模板必须提供额外的信息，来确定模板的参数类型，一般在模板名后尖括号中提供实参 定义类模板 template class Blob { public: typedef T value_type; typedef typename std::vector::size_type size_type; //构造函数 Blob(); Blob(std::initializer_list il); //Blob中元素数目 size_type size() const { return data-size(); } bool empty() const { return data-empty(); } void push_back(const T\u0026 t) { return data-push_back(t);} void pop_back(); //元素访问 T\u0026 back(); T\u0026 operator[](size_type i); private: std::shared_ptr data; //若data[i]无效，抛出msg void check(size_type i, const std::string \u0026msg) const; }； 实例化类模板使用一个类模板时，需要提供额外信息，这些额外信息是显示模板实参列表，它们被绑定到模板参数 //使用类模板，必须提供元素类型 Blob ia; Blob ia2 = {0, 1, 2, 3}; ia 和 ia2会实例化以下特定版本的 Blob ` template class Blob { typedef typename std::vector::size_type size_type; Blob(); Blob(std::initializer_list il); //... } 当编译器从 Blob 模板中实例化一个类时，它会重写 Blob 模板，将参数 T 的每个实例替换成给定的模板实参 一个类模板的每个实例都形成一个独立的类，类型 Blob 与其他任何 Blob类型都没有关系，也不会对任何其他 Blob 类型的成员具有特殊的访问权限 类模板的成员函数与其他类一样，既可以在类模板内部，也可以在外部定义其成员函数，且定义在类模板内的成员函数被隐式声明为内联函数 类模板的成员函数本身是一个普通函数 每个类模板的实例都有自己版本的成员函数 类模板的成员函数具有和模板相同的模板参数 定义在类模板之外的成员函数就必须以关键字 template 开始，后接参数列表 简单说就是在类模板内部定义成员函数，可以直接使用参数 T，而在类模板外部定义成员函数，前面需要加上 template 等 template ret-type Blob::member-name(parm-list) 这里必须加上 template 这行 类模板成员函数实例化默认情况下，类模板的成员函数只有当程序使用它的时候才进行实例化 // 实例化Blob和接受initializer_list的构造函数 Blob squares = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; for (size_t i = 0; i != squares.size(); ++i) { squares[i] = i * i; //实例化Blob::operator[](size_t) } 如果一个成员函数没有被使用，则它不会被实例化 类代码内简化模板类名的使用在使用一个类模板类型时必须提供模板实参，但是在类模板自己的作用域中，可以直接使用模板名而不提供实参 template class BlobPtr { public: BlobPtr() : curr(0) {} //其他构造函数 T\u0026 operator*() const { auto p = check(curr, \"derederence past edn\"); return (*p)[curr]; } //递增和递减 BlobPtr\u0026 operator++(); //求值运算符 BlobPtr\u0026 operator--(); private: //其他成员 std::size_t curr; //数组中的位置 } 这里前置递增和递减成员返回的时 BlobPtr\u0026，而不是 BlobPtr\u0026，在类模板作用域中，编译器处理模板自身引用会自动提供模板匹配的实参 类模板外使用类模板名在类模板外定义成员时，此时不在类的作用域，直到遇见类名菜进入类的作用域 //后置++版本 template BlobPtr BlobPtr::operator++(int) { BlobPtr ret = *this; ++*this; return ret; } 返回类型位于类的作用域之外，所以必须指出返回类型是一个实例化的 BlobPtr，在函数体内已经进入类的作用域，则定义 ret 时无须重复提供模板实参，如果不通过模板实参，编译器假定使用的类型与成员实例化所用类型一致，等价于：BlobPtr ret = *this; 类模板和友元 一个类包含一个友元声明，类与友元各自是否是模板是互相无关的 如果一个模板包括一个非模板友元，则友元可以访问所以模板实例 如果友元自身也是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例 一对一友好关系类模板与另一个（类或函数）模板间友好关系的最常见的形式是建立对应实例及其友元间的友好关系。例如，我们的 Blob 类应该将 BlobPtr 类和一个模板版本的 Blob template class BlobPtr; //需要提前声明 template class Blob; template bool operator==(const Blob\u0026, const Blob\u0026); template class Blob { friend class BlobPtr; friend bool operator== (const Blob\u0026, const Blob\u0026); //其他成员 } 友元的声明用 Blob 的模板形参作为自己的模板实参，友好关系被限定在相同类型实例化的 Blob 和 BlobPtr 相等运算符之间 //BlobPtr和operator==都是本对象的友元 Blob ca; //BlobPtr和operator==都是本对象的友元 Blob ia; 上面例子中，ca 对 ia 或其他实例没有特殊访问权限 通用和特定模板的友好关系一个类也可以将另一个模板的每个实例都声明为自己的友元，或者限定特定的实例为友元 template class Pal; class C { //C是普通非模板类 friend class Pal;//C实例化Pal是C的友元 //Pal2的所有实例都是C的友元，这种情况无须前置声明 template friend class Pal2; }; template class C2 {//C2是个模板类 //C2每个实例将相同实例的Pal声明为友元 friend class Pal; //Pal2所有实例都是C2每个实例的友元，不需要前置声明 template friend class Pal2; //Pal3是一个非模板类，它是C2所有实例的友元 friend class Pal3; }; 为了让所有实例都成为友元，友元声明中必须使用与类模板不同的模板参数 令模板自己的类型参数成为友元在C++11新标准中，可以将模板类型参数声明为友元 template class Bar { friend Type; //访问权限授予实例化Bar的类型 //... } 此时，对于某个类型 Foo，Foo 将称为 Bar 的友元，Sales_data 将成为 Bar 的友元 模板类型别名类模板一个实例定义了一个类类型，我们可以定义一个 typedef 来引用实例化的类： typedef Blob StrBlob; 由于模板不是一个类型，我们不能定义一个 typedef 引用一个模板，即不能定义一个 typedef 引用 Blob 但是新标准允许为类模板定义一个类型别名： templateusing twin = pair; twin authors; //authors是一个pair使用别名时，也需要像模板那样指出特定类型的 twin 使用一个模板类型别名时，可以固定一个或多个模板参数 template using partNo = pair; partNo books; /","date":"2022-05-07","objectID":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/:1:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十六章 模板与泛型编程","uri":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/#模板类型别名"},{"categories":["C++"],"content":"16.1.2 类模板类模板用来生成类的蓝图，类模板必须提供额外的信息，来确定模板的参数类型，一般在模板名后尖括号中提供实参 定义类模板 template class Blob { public: typedef T value_type; typedef typename std::vector::size_type size_type; //构造函数 Blob(); Blob(std::initializer_list il); //Blob中元素数目 size_type size() const { return data-size(); } bool empty() const { return data-empty(); } void push_back(const T\u0026 t) { return data-push_back(t);} void pop_back(); //元素访问 T\u0026 back(); T\u0026 operator[](size_type i); private: std::shared_ptr data; //若data[i]无效，抛出msg void check(size_type i, const std::string \u0026msg) const; }； 实例化类模板使用一个类模板时，需要提供额外信息，这些额外信息是显示模板实参列表，它们被绑定到模板参数 //使用类模板，必须提供元素类型 Blob ia; Blob ia2 = {0, 1, 2, 3}; ia 和 ia2会实例化以下特定版本的 Blob ` template class Blob { typedef typename std::vector::size_type size_type; Blob(); Blob(std::initializer_list il); //... } 当编译器从 Blob 模板中实例化一个类时，它会重写 Blob 模板，将参数 T 的每个实例替换成给定的模板实参 一个类模板的每个实例都形成一个独立的类，类型 Blob 与其他任何 Blob类型都没有关系，也不会对任何其他 Blob 类型的成员具有特殊的访问权限 类模板的成员函数与其他类一样，既可以在类模板内部，也可以在外部定义其成员函数，且定义在类模板内的成员函数被隐式声明为内联函数 类模板的成员函数本身是一个普通函数 每个类模板的实例都有自己版本的成员函数 类模板的成员函数具有和模板相同的模板参数 定义在类模板之外的成员函数就必须以关键字 template 开始，后接参数列表 简单说就是在类模板内部定义成员函数，可以直接使用参数 T，而在类模板外部定义成员函数，前面需要加上 template 等 template ret-type Blob::member-name(parm-list) 这里必须加上 template 这行 类模板成员函数实例化默认情况下，类模板的成员函数只有当程序使用它的时候才进行实例化 // 实例化Blob和接受initializer_list的构造函数 Blob squares = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; for (size_t i = 0; i != squares.size(); ++i) { squares[i] = i * i; //实例化Blob::operator[](size_t) } 如果一个成员函数没有被使用，则它不会被实例化 类代码内简化模板类名的使用在使用一个类模板类型时必须提供模板实参，但是在类模板自己的作用域中，可以直接使用模板名而不提供实参 template class BlobPtr { public: BlobPtr() : curr(0) {} //其他构造函数 T\u0026 operator*() const { auto p = check(curr, \"derederence past edn\"); return (*p)[curr]; } //递增和递减 BlobPtr\u0026 operator++(); //求值运算符 BlobPtr\u0026 operator--(); private: //其他成员 std::size_t curr; //数组中的位置 } 这里前置递增和递减成员返回的时 BlobPtr\u0026，而不是 BlobPtr\u0026，在类模板作用域中，编译器处理模板自身引用会自动提供模板匹配的实参 类模板外使用类模板名在类模板外定义成员时，此时不在类的作用域，直到遇见类名菜进入类的作用域 //后置++版本 template BlobPtr BlobPtr::operator++(int) { BlobPtr ret = *this; ++*this; return ret; } 返回类型位于类的作用域之外，所以必须指出返回类型是一个实例化的 BlobPtr，在函数体内已经进入类的作用域，则定义 ret 时无须重复提供模板实参，如果不通过模板实参，编译器假定使用的类型与成员实例化所用类型一致，等价于：BlobPtr ret = *this; 类模板和友元 一个类包含一个友元声明，类与友元各自是否是模板是互相无关的 如果一个模板包括一个非模板友元，则友元可以访问所以模板实例 如果友元自身也是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例 一对一友好关系类模板与另一个（类或函数）模板间友好关系的最常见的形式是建立对应实例及其友元间的友好关系。例如，我们的 Blob 类应该将 BlobPtr 类和一个模板版本的 Blob template class BlobPtr; //需要提前声明 template class Blob; template bool operator==(const Blob\u0026, const Blob\u0026); template class Blob { friend class BlobPtr; friend bool operator== (const Blob\u0026, const Blob\u0026); //其他成员 } 友元的声明用 Blob 的模板形参作为自己的模板实参，友好关系被限定在相同类型实例化的 Blob 和 BlobPtr 相等运算符之间 //BlobPtr和operator==都是本对象的友元 Blob ca; //BlobPtr和operator==都是本对象的友元 Blob ia; 上面例子中，ca 对 ia 或其他实例没有特殊访问权限 通用和特定模板的友好关系一个类也可以将另一个模板的每个实例都声明为自己的友元，或者限定特定的实例为友元 template class Pal; class C { //C是普通非模板类 friend class Pal;//C实例化Pal是C的友元 //Pal2的所有实例都是C的友元，这种情况无须前置声明 template friend class Pal2; }; template class C2 {//C2是个模板类 //C2每个实例将相同实例的Pal声明为友元 friend class Pal; //Pal2所有实例都是C2每个实例的友元，不需要前置声明 template friend class Pal2; //Pal3是一个非模板类，它是C2所有实例的友元 friend class Pal3; }; 为了让所有实例都成为友元，友元声明中必须使用与类模板不同的模板参数 令模板自己的类型参数成为友元在C++11新标准中，可以将模板类型参数声明为友元 template class Bar { friend Type; //访问权限授予实例化Bar的类型 //... } 此时，对于某个类型 Foo，Foo 将称为 Bar 的友元，Sales_data 将成为 Bar 的友元 模板类型别名类模板一个实例定义了一个类类型，我们可以定义一个 typedef 来引用实例化的类： typedef Blob StrBlob; 由于模板不是一个类型，我们不能定义一个 typedef 引用一个模板，即不能定义一个 typedef 引用 Blob 但是新标准允许为类模板定义一个类型别名： templateusing twin = pair; twin authors; //authors是一个pair使用别名时，也需要像模板那样指出特定类型的 twin 使用一个模板类型别名时，可以固定一个或多个模板参数 template using partNo = pair; partNo books; /","date":"2022-05-07","objectID":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/:1:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十六章 模板与泛型编程","uri":"/chapter16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/#类模板的static成员"},{"categories":["C++"],"content":"15.1 OOP：概述面向对象程序设计：核心思想是数据抽象、继承和动态绑定 数据抽象：类的接口与实现进行分离 继承：定义相似的类型并对相似关系建模 动态绑定：一定程度上忽略相似类型的区别，用统一的方式使用它们的对象 继承通过继承联系在一起的类构成一种层次关系，这种层次关系的根部有一个基类，其他类直接或间接由基类继承而来，继承得到的类称为派生类，继承的关系满足 is a ，即派生类本身也是一种基类的类型 对于基类中的某些函数，如果派生类需要自定义适合自身的版本，可以在基类中将这些函数声明为虚函数，派生类必须在内部对所有的虚函数重新声明 动态绑定使用动态绑定，可以用同一段代码处理基类和派生类的对象 比如说定义一个函数参入的形参是基类类型，然后打印处基类的成员，此时如果传入一个派生类也同样可以打印派生类的成员，这时调用的函数会根据实际传入的类型进行调用 动态绑定过程是在函数运行时由实参决定，有时也可以称为运行时绑定 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:1:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#151-oop概述"},{"categories":["C++"],"content":"15.1 OOP：概述面向对象程序设计：核心思想是数据抽象、继承和动态绑定 数据抽象：类的接口与实现进行分离 继承：定义相似的类型并对相似关系建模 动态绑定：一定程度上忽略相似类型的区别，用统一的方式使用它们的对象 继承通过继承联系在一起的类构成一种层次关系，这种层次关系的根部有一个基类，其他类直接或间接由基类继承而来，继承得到的类称为派生类，继承的关系满足 is a ，即派生类本身也是一种基类的类型 对于基类中的某些函数，如果派生类需要自定义适合自身的版本，可以在基类中将这些函数声明为虚函数，派生类必须在内部对所有的虚函数重新声明 动态绑定使用动态绑定，可以用同一段代码处理基类和派生类的对象 比如说定义一个函数参入的形参是基类类型，然后打印处基类的成员，此时如果传入一个派生类也同样可以打印派生类的成员，这时调用的函数会根据实际传入的类型进行调用 动态绑定过程是在函数运行时由实参决定，有时也可以称为运行时绑定 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:1:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#继承"},{"categories":["C++"],"content":"15.1 OOP：概述面向对象程序设计：核心思想是数据抽象、继承和动态绑定 数据抽象：类的接口与实现进行分离 继承：定义相似的类型并对相似关系建模 动态绑定：一定程度上忽略相似类型的区别，用统一的方式使用它们的对象 继承通过继承联系在一起的类构成一种层次关系，这种层次关系的根部有一个基类，其他类直接或间接由基类继承而来，继承得到的类称为派生类，继承的关系满足 is a ，即派生类本身也是一种基类的类型 对于基类中的某些函数，如果派生类需要自定义适合自身的版本，可以在基类中将这些函数声明为虚函数，派生类必须在内部对所有的虚函数重新声明 动态绑定使用动态绑定，可以用同一段代码处理基类和派生类的对象 比如说定义一个函数参入的形参是基类类型，然后打印处基类的成员，此时如果传入一个派生类也同样可以打印派生类的成员，这时调用的函数会根据实际传入的类型进行调用 动态绑定过程是在函数运行时由实参决定，有时也可以称为运行时绑定 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:1:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#动态绑定"},{"categories":["C++"],"content":"15.2 定义基类和派生类","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#152-定义基类和派生类"},{"categories":["C++"],"content":"15.2.1 定义基类首先定义 Quote 类： class Quote { public: Quote() = default;//默认构造函数 Quote(const std::string \u0026book, double sales_price) : bookNo(book), price(sales_price) {} std::string isbn() const { return bookNo; } //返回给定数量书籍的销售总额 //派生类负责改写并使用不同的折算算法 virtual double net_price(std::size_t n) const { return n * price; } virtual ~Quote() = default;//对析构函数进行动态绑定 private: std::string bookNo; //书籍ISBN号 protected: double price = 0.0; //普通状态下不打折的价格 } 基类通常定义一个虚析构函数，即使不执行任何操作 成员函数和继承派生类可以继承基类的成员，遇见 net_price 这种与类型相关的操作，派生类需要对这些操作提供自己新定义以覆盖从基类继承而来的定义 通常将基类希望派生类进行覆盖的函数定义为虚函数，当使用指针或者引用调用虚函数时，该调用将被动态绑定 访问控制和继承 派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权访问从基类继承而来的成员 派生类可以访问公有成员，但是不能访问私有成员 如果希望基类的派生类有权访问该成员，同时禁止其他用户访问，可以定义为受保护的（protected） ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:1","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#1521-定义基类"},{"categories":["C++"],"content":"15.2.1 定义基类首先定义 Quote 类： class Quote { public: Quote() = default;//默认构造函数 Quote(const std::string \u0026book, double sales_price) : bookNo(book), price(sales_price) {} std::string isbn() const { return bookNo; } //返回给定数量书籍的销售总额 //派生类负责改写并使用不同的折算算法 virtual double net_price(std::size_t n) const { return n * price; } virtual ~Quote() = default;//对析构函数进行动态绑定 private: std::string bookNo; //书籍ISBN号 protected: double price = 0.0; //普通状态下不打折的价格 } 基类通常定义一个虚析构函数，即使不执行任何操作 成员函数和继承派生类可以继承基类的成员，遇见 net_price 这种与类型相关的操作，派生类需要对这些操作提供自己新定义以覆盖从基类继承而来的定义 通常将基类希望派生类进行覆盖的函数定义为虚函数，当使用指针或者引用调用虚函数时，该调用将被动态绑定 访问控制和继承 派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权访问从基类继承而来的成员 派生类可以访问公有成员，但是不能访问私有成员 如果希望基类的派生类有权访问该成员，同时禁止其他用户访问，可以定义为受保护的（protected） ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:1","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#成员函数和继承"},{"categories":["C++"],"content":"15.2.1 定义基类首先定义 Quote 类： class Quote { public: Quote() = default;//默认构造函数 Quote(const std::string \u0026book, double sales_price) : bookNo(book), price(sales_price) {} std::string isbn() const { return bookNo; } //返回给定数量书籍的销售总额 //派生类负责改写并使用不同的折算算法 virtual double net_price(std::size_t n) const { return n * price; } virtual ~Quote() = default;//对析构函数进行动态绑定 private: std::string bookNo; //书籍ISBN号 protected: double price = 0.0; //普通状态下不打折的价格 } 基类通常定义一个虚析构函数，即使不执行任何操作 成员函数和继承派生类可以继承基类的成员，遇见 net_price 这种与类型相关的操作，派生类需要对这些操作提供自己新定义以覆盖从基类继承而来的定义 通常将基类希望派生类进行覆盖的函数定义为虚函数，当使用指针或者引用调用虚函数时，该调用将被动态绑定 访问控制和继承 派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权访问从基类继承而来的成员 派生类可以访问公有成员，但是不能访问私有成员 如果希望基类的派生类有权访问该成员，同时禁止其他用户访问，可以定义为受保护的（protected） ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:1","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#访问控制和继承"},{"categories":["C++"],"content":"15.2.2 定义派生类派生类必须通过类派生列表来指明它是从哪个基类继承而来的，类派生列表形式是：首先一个冒号，后面紧跟以逗号分隔的基类列表，每个基类前面可以有以下三种访问说明符之一：public、protected和private 定义 Bulk_quote 类 class Bulk_quote : public Quote { //Bulk_quote继承自Quote public: Bulk_quote() = default; Bulk_quote(const std::string\u0026, double, std::size_t, double); //覆盖基类的函数版本以实现基于大量购买的折扣政策 double net_price(std::size_t) const override; private: std::size_t min_qty = 0;//适用折扣政策的最低购买量 double discount = 0.0; //以小数表示折扣额 } Bulk_quote 类从基类 Quote 继承了 isbn 函数和 bookNo、price等数据成员，此外还定义了 net_price 的新版本，同时增加了两个新的数据成员 派生类中的虚函数派生类如果没有覆盖基类的虚函数，则派生类会直接继承基类中的版本 C++11新标准允许派生类显示注明它使用某个成员函数覆盖了它继承的虚函数，具体做法是在函数定义后面加个关键字 override 派生类对象即派生类向基类的类型转换派生类对象含有基类对应的成员部分，我们可以将派生类对象当成基类对象来使用，也能将基类指针或引用绑定到派生类对象的基类部分上 Quote item; //基类对象 Bulk_quote bulk; //派生类对象 Quote *p = \u0026item;//p指向Quote对象 p = \u0026bulk; //p指向bulk的Quote部分 Quote \u0026r = bulk; //r绑定到bulk的Quote部分 这种转换称为派生类到基类的类型转换 派生类构造函数派生类对象中含有从基类继承的成员，但是派生类不能直接初始化这些成员，派生类必须使用基类的构造函数来初始化它的基类部分 派生类在初始化成员时，可以通过构造函数初始化列表将实参传给基类构造函数，如下： //Bulk_quote的构造函数 Bulk_quote(const std::string \u0026book, double p, std::size_t qyt, double disc) : Quote(book, p), min_qty(qty), discount(disc) {} 派生类首先初始化基类部分，然后按照声明顺序初始化派生类的成员 派生类使用基类的成员派生类可以访问基类的公用成员和受保护的成员，例如： //如果达到购买书籍某个最低限度值，就可以享受折扣价格 double Bulk_quote::net_price(size_t cnt) const { if (cnt \u003e= min_qty) return cnt * (1 - discount) * price; else return cnt * price; } 继承与静态成员如果基类定义了一个静态成员，则整个继承体系中只存在该成员的唯一定义，不能派生出来多个各类，每一个静态成员只存在唯一的实例 静态成员遵循通用的访问控制规则，如果基类中定义为 private 的，派生类无权进行访问；如果静态成员可访问，既可以通过基类使用它，也可以通过派生类使用 class Base { public: static void statemen(); }; class Derived : public Base { void f(const Derived\u0026); }; void Derived::f(const Derived \u0026derived_obj) { Base::statemem(); //通过基类访问 Derived::statemem(); //通过派生类访问 derived_obj.statemem(); //通过基类对象访问 statemem(); //通过this对象访问 } 派生类的声明派生类声明和其他类差别不大，声明中包含类名但是不包含它的派生列表： class Bulk_quote : public Quote;//错误，派生列表不能出现在这 class Bulk_quote; //正确：声明派生类的正确方式 被用作基类的类如果想用某个类作为基类，则这个类必须已经定义而非仅仅声明： class Quote;//声明但未定义 //错误：Quote必须被定义 class Bulk_quote : public Quote {...}; 一个类不可以派生它本身 防止继承的发生如果不希望某一个类派生出其他类，或者不考虑将它作为一个基类，C++11新标准提供了一种防止继承发生的方法，即在类名后面跟一个关键字 final： class NoDrived final { /***/ }; class Bad : Noderived { /***/ }; //错误：NoDrived是final的 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#1522-定义派生类"},{"categories":["C++"],"content":"15.2.2 定义派生类派生类必须通过类派生列表来指明它是从哪个基类继承而来的，类派生列表形式是：首先一个冒号，后面紧跟以逗号分隔的基类列表，每个基类前面可以有以下三种访问说明符之一：public、protected和private 定义 Bulk_quote 类 class Bulk_quote : public Quote { //Bulk_quote继承自Quote public: Bulk_quote() = default; Bulk_quote(const std::string\u0026, double, std::size_t, double); //覆盖基类的函数版本以实现基于大量购买的折扣政策 double net_price(std::size_t) const override; private: std::size_t min_qty = 0;//适用折扣政策的最低购买量 double discount = 0.0; //以小数表示折扣额 } Bulk_quote 类从基类 Quote 继承了 isbn 函数和 bookNo、price等数据成员，此外还定义了 net_price 的新版本，同时增加了两个新的数据成员 派生类中的虚函数派生类如果没有覆盖基类的虚函数，则派生类会直接继承基类中的版本 C++11新标准允许派生类显示注明它使用某个成员函数覆盖了它继承的虚函数，具体做法是在函数定义后面加个关键字 override 派生类对象即派生类向基类的类型转换派生类对象含有基类对应的成员部分，我们可以将派生类对象当成基类对象来使用，也能将基类指针或引用绑定到派生类对象的基类部分上 Quote item; //基类对象 Bulk_quote bulk; //派生类对象 Quote *p = \u0026item;//p指向Quote对象 p = \u0026bulk; //p指向bulk的Quote部分 Quote \u0026r = bulk; //r绑定到bulk的Quote部分 这种转换称为派生类到基类的类型转换 派生类构造函数派生类对象中含有从基类继承的成员，但是派生类不能直接初始化这些成员，派生类必须使用基类的构造函数来初始化它的基类部分 派生类在初始化成员时，可以通过构造函数初始化列表将实参传给基类构造函数，如下： //Bulk_quote的构造函数 Bulk_quote(const std::string \u0026book, double p, std::size_t qyt, double disc) : Quote(book, p), min_qty(qty), discount(disc) {} 派生类首先初始化基类部分，然后按照声明顺序初始化派生类的成员 派生类使用基类的成员派生类可以访问基类的公用成员和受保护的成员，例如： //如果达到购买书籍某个最低限度值，就可以享受折扣价格 double Bulk_quote::net_price(size_t cnt) const { if (cnt = min_qty) return cnt * (1 - discount) * price; else return cnt * price; } 继承与静态成员如果基类定义了一个静态成员，则整个继承体系中只存在该成员的唯一定义，不能派生出来多个各类，每一个静态成员只存在唯一的实例 静态成员遵循通用的访问控制规则，如果基类中定义为 private 的，派生类无权进行访问；如果静态成员可访问，既可以通过基类使用它，也可以通过派生类使用 class Base { public: static void statemen(); }; class Derived : public Base { void f(const Derived\u0026); }; void Derived::f(const Derived \u0026derived_obj) { Base::statemem(); //通过基类访问 Derived::statemem(); //通过派生类访问 derived_obj.statemem(); //通过基类对象访问 statemem(); //通过this对象访问 } 派生类的声明派生类声明和其他类差别不大，声明中包含类名但是不包含它的派生列表： class Bulk_quote : public Quote;//错误，派生列表不能出现在这 class Bulk_quote; //正确：声明派生类的正确方式 被用作基类的类如果想用某个类作为基类，则这个类必须已经定义而非仅仅声明： class Quote;//声明但未定义 //错误：Quote必须被定义 class Bulk_quote : public Quote {...}; 一个类不可以派生它本身 防止继承的发生如果不希望某一个类派生出其他类，或者不考虑将它作为一个基类，C++11新标准提供了一种防止继承发生的方法，即在类名后面跟一个关键字 final： class NoDrived final { /***/ }; class Bad : Noderived { /***/ }; //错误：NoDrived是final的 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#派生类中的虚函数"},{"categories":["C++"],"content":"15.2.2 定义派生类派生类必须通过类派生列表来指明它是从哪个基类继承而来的，类派生列表形式是：首先一个冒号，后面紧跟以逗号分隔的基类列表，每个基类前面可以有以下三种访问说明符之一：public、protected和private 定义 Bulk_quote 类 class Bulk_quote : public Quote { //Bulk_quote继承自Quote public: Bulk_quote() = default; Bulk_quote(const std::string\u0026, double, std::size_t, double); //覆盖基类的函数版本以实现基于大量购买的折扣政策 double net_price(std::size_t) const override; private: std::size_t min_qty = 0;//适用折扣政策的最低购买量 double discount = 0.0; //以小数表示折扣额 } Bulk_quote 类从基类 Quote 继承了 isbn 函数和 bookNo、price等数据成员，此外还定义了 net_price 的新版本，同时增加了两个新的数据成员 派生类中的虚函数派生类如果没有覆盖基类的虚函数，则派生类会直接继承基类中的版本 C++11新标准允许派生类显示注明它使用某个成员函数覆盖了它继承的虚函数，具体做法是在函数定义后面加个关键字 override 派生类对象即派生类向基类的类型转换派生类对象含有基类对应的成员部分，我们可以将派生类对象当成基类对象来使用，也能将基类指针或引用绑定到派生类对象的基类部分上 Quote item; //基类对象 Bulk_quote bulk; //派生类对象 Quote *p = \u0026item;//p指向Quote对象 p = \u0026bulk; //p指向bulk的Quote部分 Quote \u0026r = bulk; //r绑定到bulk的Quote部分 这种转换称为派生类到基类的类型转换 派生类构造函数派生类对象中含有从基类继承的成员，但是派生类不能直接初始化这些成员，派生类必须使用基类的构造函数来初始化它的基类部分 派生类在初始化成员时，可以通过构造函数初始化列表将实参传给基类构造函数，如下： //Bulk_quote的构造函数 Bulk_quote(const std::string \u0026book, double p, std::size_t qyt, double disc) : Quote(book, p), min_qty(qty), discount(disc) {} 派生类首先初始化基类部分，然后按照声明顺序初始化派生类的成员 派生类使用基类的成员派生类可以访问基类的公用成员和受保护的成员，例如： //如果达到购买书籍某个最低限度值，就可以享受折扣价格 double Bulk_quote::net_price(size_t cnt) const { if (cnt = min_qty) return cnt * (1 - discount) * price; else return cnt * price; } 继承与静态成员如果基类定义了一个静态成员，则整个继承体系中只存在该成员的唯一定义，不能派生出来多个各类，每一个静态成员只存在唯一的实例 静态成员遵循通用的访问控制规则，如果基类中定义为 private 的，派生类无权进行访问；如果静态成员可访问，既可以通过基类使用它，也可以通过派生类使用 class Base { public: static void statemen(); }; class Derived : public Base { void f(const Derived\u0026); }; void Derived::f(const Derived \u0026derived_obj) { Base::statemem(); //通过基类访问 Derived::statemem(); //通过派生类访问 derived_obj.statemem(); //通过基类对象访问 statemem(); //通过this对象访问 } 派生类的声明派生类声明和其他类差别不大，声明中包含类名但是不包含它的派生列表： class Bulk_quote : public Quote;//错误，派生列表不能出现在这 class Bulk_quote; //正确：声明派生类的正确方式 被用作基类的类如果想用某个类作为基类，则这个类必须已经定义而非仅仅声明： class Quote;//声明但未定义 //错误：Quote必须被定义 class Bulk_quote : public Quote {...}; 一个类不可以派生它本身 防止继承的发生如果不希望某一个类派生出其他类，或者不考虑将它作为一个基类，C++11新标准提供了一种防止继承发生的方法，即在类名后面跟一个关键字 final： class NoDrived final { /***/ }; class Bad : Noderived { /***/ }; //错误：NoDrived是final的 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#派生类对象即派生类向基类的类型转换"},{"categories":["C++"],"content":"15.2.2 定义派生类派生类必须通过类派生列表来指明它是从哪个基类继承而来的，类派生列表形式是：首先一个冒号，后面紧跟以逗号分隔的基类列表，每个基类前面可以有以下三种访问说明符之一：public、protected和private 定义 Bulk_quote 类 class Bulk_quote : public Quote { //Bulk_quote继承自Quote public: Bulk_quote() = default; Bulk_quote(const std::string\u0026, double, std::size_t, double); //覆盖基类的函数版本以实现基于大量购买的折扣政策 double net_price(std::size_t) const override; private: std::size_t min_qty = 0;//适用折扣政策的最低购买量 double discount = 0.0; //以小数表示折扣额 } Bulk_quote 类从基类 Quote 继承了 isbn 函数和 bookNo、price等数据成员，此外还定义了 net_price 的新版本，同时增加了两个新的数据成员 派生类中的虚函数派生类如果没有覆盖基类的虚函数，则派生类会直接继承基类中的版本 C++11新标准允许派生类显示注明它使用某个成员函数覆盖了它继承的虚函数，具体做法是在函数定义后面加个关键字 override 派生类对象即派生类向基类的类型转换派生类对象含有基类对应的成员部分，我们可以将派生类对象当成基类对象来使用，也能将基类指针或引用绑定到派生类对象的基类部分上 Quote item; //基类对象 Bulk_quote bulk; //派生类对象 Quote *p = \u0026item;//p指向Quote对象 p = \u0026bulk; //p指向bulk的Quote部分 Quote \u0026r = bulk; //r绑定到bulk的Quote部分 这种转换称为派生类到基类的类型转换 派生类构造函数派生类对象中含有从基类继承的成员，但是派生类不能直接初始化这些成员，派生类必须使用基类的构造函数来初始化它的基类部分 派生类在初始化成员时，可以通过构造函数初始化列表将实参传给基类构造函数，如下： //Bulk_quote的构造函数 Bulk_quote(const std::string \u0026book, double p, std::size_t qyt, double disc) : Quote(book, p), min_qty(qty), discount(disc) {} 派生类首先初始化基类部分，然后按照声明顺序初始化派生类的成员 派生类使用基类的成员派生类可以访问基类的公用成员和受保护的成员，例如： //如果达到购买书籍某个最低限度值，就可以享受折扣价格 double Bulk_quote::net_price(size_t cnt) const { if (cnt = min_qty) return cnt * (1 - discount) * price; else return cnt * price; } 继承与静态成员如果基类定义了一个静态成员，则整个继承体系中只存在该成员的唯一定义，不能派生出来多个各类，每一个静态成员只存在唯一的实例 静态成员遵循通用的访问控制规则，如果基类中定义为 private 的，派生类无权进行访问；如果静态成员可访问，既可以通过基类使用它，也可以通过派生类使用 class Base { public: static void statemen(); }; class Derived : public Base { void f(const Derived\u0026); }; void Derived::f(const Derived \u0026derived_obj) { Base::statemem(); //通过基类访问 Derived::statemem(); //通过派生类访问 derived_obj.statemem(); //通过基类对象访问 statemem(); //通过this对象访问 } 派生类的声明派生类声明和其他类差别不大，声明中包含类名但是不包含它的派生列表： class Bulk_quote : public Quote;//错误，派生列表不能出现在这 class Bulk_quote; //正确：声明派生类的正确方式 被用作基类的类如果想用某个类作为基类，则这个类必须已经定义而非仅仅声明： class Quote;//声明但未定义 //错误：Quote必须被定义 class Bulk_quote : public Quote {...}; 一个类不可以派生它本身 防止继承的发生如果不希望某一个类派生出其他类，或者不考虑将它作为一个基类，C++11新标准提供了一种防止继承发生的方法，即在类名后面跟一个关键字 final： class NoDrived final { /***/ }; class Bad : Noderived { /***/ }; //错误：NoDrived是final的 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#派生类构造函数"},{"categories":["C++"],"content":"15.2.2 定义派生类派生类必须通过类派生列表来指明它是从哪个基类继承而来的，类派生列表形式是：首先一个冒号，后面紧跟以逗号分隔的基类列表，每个基类前面可以有以下三种访问说明符之一：public、protected和private 定义 Bulk_quote 类 class Bulk_quote : public Quote { //Bulk_quote继承自Quote public: Bulk_quote() = default; Bulk_quote(const std::string\u0026, double, std::size_t, double); //覆盖基类的函数版本以实现基于大量购买的折扣政策 double net_price(std::size_t) const override; private: std::size_t min_qty = 0;//适用折扣政策的最低购买量 double discount = 0.0; //以小数表示折扣额 } Bulk_quote 类从基类 Quote 继承了 isbn 函数和 bookNo、price等数据成员，此外还定义了 net_price 的新版本，同时增加了两个新的数据成员 派生类中的虚函数派生类如果没有覆盖基类的虚函数，则派生类会直接继承基类中的版本 C++11新标准允许派生类显示注明它使用某个成员函数覆盖了它继承的虚函数，具体做法是在函数定义后面加个关键字 override 派生类对象即派生类向基类的类型转换派生类对象含有基类对应的成员部分，我们可以将派生类对象当成基类对象来使用，也能将基类指针或引用绑定到派生类对象的基类部分上 Quote item; //基类对象 Bulk_quote bulk; //派生类对象 Quote *p = \u0026item;//p指向Quote对象 p = \u0026bulk; //p指向bulk的Quote部分 Quote \u0026r = bulk; //r绑定到bulk的Quote部分 这种转换称为派生类到基类的类型转换 派生类构造函数派生类对象中含有从基类继承的成员，但是派生类不能直接初始化这些成员，派生类必须使用基类的构造函数来初始化它的基类部分 派生类在初始化成员时，可以通过构造函数初始化列表将实参传给基类构造函数，如下： //Bulk_quote的构造函数 Bulk_quote(const std::string \u0026book, double p, std::size_t qyt, double disc) : Quote(book, p), min_qty(qty), discount(disc) {} 派生类首先初始化基类部分，然后按照声明顺序初始化派生类的成员 派生类使用基类的成员派生类可以访问基类的公用成员和受保护的成员，例如： //如果达到购买书籍某个最低限度值，就可以享受折扣价格 double Bulk_quote::net_price(size_t cnt) const { if (cnt = min_qty) return cnt * (1 - discount) * price; else return cnt * price; } 继承与静态成员如果基类定义了一个静态成员，则整个继承体系中只存在该成员的唯一定义，不能派生出来多个各类，每一个静态成员只存在唯一的实例 静态成员遵循通用的访问控制规则，如果基类中定义为 private 的，派生类无权进行访问；如果静态成员可访问，既可以通过基类使用它，也可以通过派生类使用 class Base { public: static void statemen(); }; class Derived : public Base { void f(const Derived\u0026); }; void Derived::f(const Derived \u0026derived_obj) { Base::statemem(); //通过基类访问 Derived::statemem(); //通过派生类访问 derived_obj.statemem(); //通过基类对象访问 statemem(); //通过this对象访问 } 派生类的声明派生类声明和其他类差别不大，声明中包含类名但是不包含它的派生列表： class Bulk_quote : public Quote;//错误，派生列表不能出现在这 class Bulk_quote; //正确：声明派生类的正确方式 被用作基类的类如果想用某个类作为基类，则这个类必须已经定义而非仅仅声明： class Quote;//声明但未定义 //错误：Quote必须被定义 class Bulk_quote : public Quote {...}; 一个类不可以派生它本身 防止继承的发生如果不希望某一个类派生出其他类，或者不考虑将它作为一个基类，C++11新标准提供了一种防止继承发生的方法，即在类名后面跟一个关键字 final： class NoDrived final { /***/ }; class Bad : Noderived { /***/ }; //错误：NoDrived是final的 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#派生类使用基类的成员"},{"categories":["C++"],"content":"15.2.2 定义派生类派生类必须通过类派生列表来指明它是从哪个基类继承而来的，类派生列表形式是：首先一个冒号，后面紧跟以逗号分隔的基类列表，每个基类前面可以有以下三种访问说明符之一：public、protected和private 定义 Bulk_quote 类 class Bulk_quote : public Quote { //Bulk_quote继承自Quote public: Bulk_quote() = default; Bulk_quote(const std::string\u0026, double, std::size_t, double); //覆盖基类的函数版本以实现基于大量购买的折扣政策 double net_price(std::size_t) const override; private: std::size_t min_qty = 0;//适用折扣政策的最低购买量 double discount = 0.0; //以小数表示折扣额 } Bulk_quote 类从基类 Quote 继承了 isbn 函数和 bookNo、price等数据成员，此外还定义了 net_price 的新版本，同时增加了两个新的数据成员 派生类中的虚函数派生类如果没有覆盖基类的虚函数，则派生类会直接继承基类中的版本 C++11新标准允许派生类显示注明它使用某个成员函数覆盖了它继承的虚函数，具体做法是在函数定义后面加个关键字 override 派生类对象即派生类向基类的类型转换派生类对象含有基类对应的成员部分，我们可以将派生类对象当成基类对象来使用，也能将基类指针或引用绑定到派生类对象的基类部分上 Quote item; //基类对象 Bulk_quote bulk; //派生类对象 Quote *p = \u0026item;//p指向Quote对象 p = \u0026bulk; //p指向bulk的Quote部分 Quote \u0026r = bulk; //r绑定到bulk的Quote部分 这种转换称为派生类到基类的类型转换 派生类构造函数派生类对象中含有从基类继承的成员，但是派生类不能直接初始化这些成员，派生类必须使用基类的构造函数来初始化它的基类部分 派生类在初始化成员时，可以通过构造函数初始化列表将实参传给基类构造函数，如下： //Bulk_quote的构造函数 Bulk_quote(const std::string \u0026book, double p, std::size_t qyt, double disc) : Quote(book, p), min_qty(qty), discount(disc) {} 派生类首先初始化基类部分，然后按照声明顺序初始化派生类的成员 派生类使用基类的成员派生类可以访问基类的公用成员和受保护的成员，例如： //如果达到购买书籍某个最低限度值，就可以享受折扣价格 double Bulk_quote::net_price(size_t cnt) const { if (cnt = min_qty) return cnt * (1 - discount) * price; else return cnt * price; } 继承与静态成员如果基类定义了一个静态成员，则整个继承体系中只存在该成员的唯一定义，不能派生出来多个各类，每一个静态成员只存在唯一的实例 静态成员遵循通用的访问控制规则，如果基类中定义为 private 的，派生类无权进行访问；如果静态成员可访问，既可以通过基类使用它，也可以通过派生类使用 class Base { public: static void statemen(); }; class Derived : public Base { void f(const Derived\u0026); }; void Derived::f(const Derived \u0026derived_obj) { Base::statemem(); //通过基类访问 Derived::statemem(); //通过派生类访问 derived_obj.statemem(); //通过基类对象访问 statemem(); //通过this对象访问 } 派生类的声明派生类声明和其他类差别不大，声明中包含类名但是不包含它的派生列表： class Bulk_quote : public Quote;//错误，派生列表不能出现在这 class Bulk_quote; //正确：声明派生类的正确方式 被用作基类的类如果想用某个类作为基类，则这个类必须已经定义而非仅仅声明： class Quote;//声明但未定义 //错误：Quote必须被定义 class Bulk_quote : public Quote {...}; 一个类不可以派生它本身 防止继承的发生如果不希望某一个类派生出其他类，或者不考虑将它作为一个基类，C++11新标准提供了一种防止继承发生的方法，即在类名后面跟一个关键字 final： class NoDrived final { /***/ }; class Bad : Noderived { /***/ }; //错误：NoDrived是final的 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#继承与静态成员"},{"categories":["C++"],"content":"15.2.2 定义派生类派生类必须通过类派生列表来指明它是从哪个基类继承而来的，类派生列表形式是：首先一个冒号，后面紧跟以逗号分隔的基类列表，每个基类前面可以有以下三种访问说明符之一：public、protected和private 定义 Bulk_quote 类 class Bulk_quote : public Quote { //Bulk_quote继承自Quote public: Bulk_quote() = default; Bulk_quote(const std::string\u0026, double, std::size_t, double); //覆盖基类的函数版本以实现基于大量购买的折扣政策 double net_price(std::size_t) const override; private: std::size_t min_qty = 0;//适用折扣政策的最低购买量 double discount = 0.0; //以小数表示折扣额 } Bulk_quote 类从基类 Quote 继承了 isbn 函数和 bookNo、price等数据成员，此外还定义了 net_price 的新版本，同时增加了两个新的数据成员 派生类中的虚函数派生类如果没有覆盖基类的虚函数，则派生类会直接继承基类中的版本 C++11新标准允许派生类显示注明它使用某个成员函数覆盖了它继承的虚函数，具体做法是在函数定义后面加个关键字 override 派生类对象即派生类向基类的类型转换派生类对象含有基类对应的成员部分，我们可以将派生类对象当成基类对象来使用，也能将基类指针或引用绑定到派生类对象的基类部分上 Quote item; //基类对象 Bulk_quote bulk; //派生类对象 Quote *p = \u0026item;//p指向Quote对象 p = \u0026bulk; //p指向bulk的Quote部分 Quote \u0026r = bulk; //r绑定到bulk的Quote部分 这种转换称为派生类到基类的类型转换 派生类构造函数派生类对象中含有从基类继承的成员，但是派生类不能直接初始化这些成员，派生类必须使用基类的构造函数来初始化它的基类部分 派生类在初始化成员时，可以通过构造函数初始化列表将实参传给基类构造函数，如下： //Bulk_quote的构造函数 Bulk_quote(const std::string \u0026book, double p, std::size_t qyt, double disc) : Quote(book, p), min_qty(qty), discount(disc) {} 派生类首先初始化基类部分，然后按照声明顺序初始化派生类的成员 派生类使用基类的成员派生类可以访问基类的公用成员和受保护的成员，例如： //如果达到购买书籍某个最低限度值，就可以享受折扣价格 double Bulk_quote::net_price(size_t cnt) const { if (cnt = min_qty) return cnt * (1 - discount) * price; else return cnt * price; } 继承与静态成员如果基类定义了一个静态成员，则整个继承体系中只存在该成员的唯一定义，不能派生出来多个各类，每一个静态成员只存在唯一的实例 静态成员遵循通用的访问控制规则，如果基类中定义为 private 的，派生类无权进行访问；如果静态成员可访问，既可以通过基类使用它，也可以通过派生类使用 class Base { public: static void statemen(); }; class Derived : public Base { void f(const Derived\u0026); }; void Derived::f(const Derived \u0026derived_obj) { Base::statemem(); //通过基类访问 Derived::statemem(); //通过派生类访问 derived_obj.statemem(); //通过基类对象访问 statemem(); //通过this对象访问 } 派生类的声明派生类声明和其他类差别不大，声明中包含类名但是不包含它的派生列表： class Bulk_quote : public Quote;//错误，派生列表不能出现在这 class Bulk_quote; //正确：声明派生类的正确方式 被用作基类的类如果想用某个类作为基类，则这个类必须已经定义而非仅仅声明： class Quote;//声明但未定义 //错误：Quote必须被定义 class Bulk_quote : public Quote {...}; 一个类不可以派生它本身 防止继承的发生如果不希望某一个类派生出其他类，或者不考虑将它作为一个基类，C++11新标准提供了一种防止继承发生的方法，即在类名后面跟一个关键字 final： class NoDrived final { /***/ }; class Bad : Noderived { /***/ }; //错误：NoDrived是final的 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#派生类的声明"},{"categories":["C++"],"content":"15.2.2 定义派生类派生类必须通过类派生列表来指明它是从哪个基类继承而来的，类派生列表形式是：首先一个冒号，后面紧跟以逗号分隔的基类列表，每个基类前面可以有以下三种访问说明符之一：public、protected和private 定义 Bulk_quote 类 class Bulk_quote : public Quote { //Bulk_quote继承自Quote public: Bulk_quote() = default; Bulk_quote(const std::string\u0026, double, std::size_t, double); //覆盖基类的函数版本以实现基于大量购买的折扣政策 double net_price(std::size_t) const override; private: std::size_t min_qty = 0;//适用折扣政策的最低购买量 double discount = 0.0; //以小数表示折扣额 } Bulk_quote 类从基类 Quote 继承了 isbn 函数和 bookNo、price等数据成员，此外还定义了 net_price 的新版本，同时增加了两个新的数据成员 派生类中的虚函数派生类如果没有覆盖基类的虚函数，则派生类会直接继承基类中的版本 C++11新标准允许派生类显示注明它使用某个成员函数覆盖了它继承的虚函数，具体做法是在函数定义后面加个关键字 override 派生类对象即派生类向基类的类型转换派生类对象含有基类对应的成员部分，我们可以将派生类对象当成基类对象来使用，也能将基类指针或引用绑定到派生类对象的基类部分上 Quote item; //基类对象 Bulk_quote bulk; //派生类对象 Quote *p = \u0026item;//p指向Quote对象 p = \u0026bulk; //p指向bulk的Quote部分 Quote \u0026r = bulk; //r绑定到bulk的Quote部分 这种转换称为派生类到基类的类型转换 派生类构造函数派生类对象中含有从基类继承的成员，但是派生类不能直接初始化这些成员，派生类必须使用基类的构造函数来初始化它的基类部分 派生类在初始化成员时，可以通过构造函数初始化列表将实参传给基类构造函数，如下： //Bulk_quote的构造函数 Bulk_quote(const std::string \u0026book, double p, std::size_t qyt, double disc) : Quote(book, p), min_qty(qty), discount(disc) {} 派生类首先初始化基类部分，然后按照声明顺序初始化派生类的成员 派生类使用基类的成员派生类可以访问基类的公用成员和受保护的成员，例如： //如果达到购买书籍某个最低限度值，就可以享受折扣价格 double Bulk_quote::net_price(size_t cnt) const { if (cnt = min_qty) return cnt * (1 - discount) * price; else return cnt * price; } 继承与静态成员如果基类定义了一个静态成员，则整个继承体系中只存在该成员的唯一定义，不能派生出来多个各类，每一个静态成员只存在唯一的实例 静态成员遵循通用的访问控制规则，如果基类中定义为 private 的，派生类无权进行访问；如果静态成员可访问，既可以通过基类使用它，也可以通过派生类使用 class Base { public: static void statemen(); }; class Derived : public Base { void f(const Derived\u0026); }; void Derived::f(const Derived \u0026derived_obj) { Base::statemem(); //通过基类访问 Derived::statemem(); //通过派生类访问 derived_obj.statemem(); //通过基类对象访问 statemem(); //通过this对象访问 } 派生类的声明派生类声明和其他类差别不大，声明中包含类名但是不包含它的派生列表： class Bulk_quote : public Quote;//错误，派生列表不能出现在这 class Bulk_quote; //正确：声明派生类的正确方式 被用作基类的类如果想用某个类作为基类，则这个类必须已经定义而非仅仅声明： class Quote;//声明但未定义 //错误：Quote必须被定义 class Bulk_quote : public Quote {...}; 一个类不可以派生它本身 防止继承的发生如果不希望某一个类派生出其他类，或者不考虑将它作为一个基类，C++11新标准提供了一种防止继承发生的方法，即在类名后面跟一个关键字 final： class NoDrived final { /***/ }; class Bad : Noderived { /***/ }; //错误：NoDrived是final的 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#被用作基类的类"},{"categories":["C++"],"content":"15.2.2 定义派生类派生类必须通过类派生列表来指明它是从哪个基类继承而来的，类派生列表形式是：首先一个冒号，后面紧跟以逗号分隔的基类列表，每个基类前面可以有以下三种访问说明符之一：public、protected和private 定义 Bulk_quote 类 class Bulk_quote : public Quote { //Bulk_quote继承自Quote public: Bulk_quote() = default; Bulk_quote(const std::string\u0026, double, std::size_t, double); //覆盖基类的函数版本以实现基于大量购买的折扣政策 double net_price(std::size_t) const override; private: std::size_t min_qty = 0;//适用折扣政策的最低购买量 double discount = 0.0; //以小数表示折扣额 } Bulk_quote 类从基类 Quote 继承了 isbn 函数和 bookNo、price等数据成员，此外还定义了 net_price 的新版本，同时增加了两个新的数据成员 派生类中的虚函数派生类如果没有覆盖基类的虚函数，则派生类会直接继承基类中的版本 C++11新标准允许派生类显示注明它使用某个成员函数覆盖了它继承的虚函数，具体做法是在函数定义后面加个关键字 override 派生类对象即派生类向基类的类型转换派生类对象含有基类对应的成员部分，我们可以将派生类对象当成基类对象来使用，也能将基类指针或引用绑定到派生类对象的基类部分上 Quote item; //基类对象 Bulk_quote bulk; //派生类对象 Quote *p = \u0026item;//p指向Quote对象 p = \u0026bulk; //p指向bulk的Quote部分 Quote \u0026r = bulk; //r绑定到bulk的Quote部分 这种转换称为派生类到基类的类型转换 派生类构造函数派生类对象中含有从基类继承的成员，但是派生类不能直接初始化这些成员，派生类必须使用基类的构造函数来初始化它的基类部分 派生类在初始化成员时，可以通过构造函数初始化列表将实参传给基类构造函数，如下： //Bulk_quote的构造函数 Bulk_quote(const std::string \u0026book, double p, std::size_t qyt, double disc) : Quote(book, p), min_qty(qty), discount(disc) {} 派生类首先初始化基类部分，然后按照声明顺序初始化派生类的成员 派生类使用基类的成员派生类可以访问基类的公用成员和受保护的成员，例如： //如果达到购买书籍某个最低限度值，就可以享受折扣价格 double Bulk_quote::net_price(size_t cnt) const { if (cnt = min_qty) return cnt * (1 - discount) * price; else return cnt * price; } 继承与静态成员如果基类定义了一个静态成员，则整个继承体系中只存在该成员的唯一定义，不能派生出来多个各类，每一个静态成员只存在唯一的实例 静态成员遵循通用的访问控制规则，如果基类中定义为 private 的，派生类无权进行访问；如果静态成员可访问，既可以通过基类使用它，也可以通过派生类使用 class Base { public: static void statemen(); }; class Derived : public Base { void f(const Derived\u0026); }; void Derived::f(const Derived \u0026derived_obj) { Base::statemem(); //通过基类访问 Derived::statemem(); //通过派生类访问 derived_obj.statemem(); //通过基类对象访问 statemem(); //通过this对象访问 } 派生类的声明派生类声明和其他类差别不大，声明中包含类名但是不包含它的派生列表： class Bulk_quote : public Quote;//错误，派生列表不能出现在这 class Bulk_quote; //正确：声明派生类的正确方式 被用作基类的类如果想用某个类作为基类，则这个类必须已经定义而非仅仅声明： class Quote;//声明但未定义 //错误：Quote必须被定义 class Bulk_quote : public Quote {...}; 一个类不可以派生它本身 防止继承的发生如果不希望某一个类派生出其他类，或者不考虑将它作为一个基类，C++11新标准提供了一种防止继承发生的方法，即在类名后面跟一个关键字 final： class NoDrived final { /***/ }; class Bad : Noderived { /***/ }; //错误：NoDrived是final的 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#防止继承的发生"},{"categories":["C++"],"content":"15.2.3 类型转换与继承我们可以将基类的指针或引用绑定到派生类对象上，例如：可以用 Quote\u0026 指向一个 Bulk_quote 对象 ==当使用基类的引用（或指针）时，我们并不清楚该引用（指针）所绑定对象的真实类型==，可能该对象时基类的对象，也可能时派生类的对象 智能指针类也支持派生类向基类的类型转换 静态类型和动态类型 使用存在继承关系的类型时，需要区分一个变量或者表达式的静态类型和动态类型 静态类型编译时总是已知的，它是变量声明时的类型或者表达式生成的类型 动态类型则是变量或表达式表示内存中的对象的类型，运行时才可以确定 如果表达式既不是引用也不是指针，则它的动态类型和静态类型永远一致 不存在基类向派生类的隐式转换 派生类可以向基类转换是因为派生类中含有基类的成员，基类的引用或指针可以绑定到该基类部分上 而基类对象中可能存在派生类对象中的成员，也可能不存在，所以不能从基类向派生类自动类型转换 Quote base; Bulk_quote* bulkPtr = \u0026base; //错误：基类不能转换为派生类 Bulk_quote\u0026 bulkRef = base; //错误：基类不能转换为派生类 ==即使一个基类指针或者引用类型绑定在派生类对象上，我们也不能执行从基类向派生类的转换== Bulk_quote bulk; Quote *itemPtr = \u0026bulk; //正确：动态类型是Bulk_quote Bulk_quote *bulkPtr = itemPtr; //错误：不能将基类转换为派生类 编译器在编译时候无法确定上述转换过程在运行时是否安全，编译器只能检查静态类型来判断是否合法 对象之间不存在类型转换派生类向基类的自动类型转换只能对指针和引用有效，在派生类和基类类型之间不存在这样的转换。 当对基类进行初始化或者拷贝赋值时，如果传入的是派生类的对象，通常只会将派生类中含有基类的部分进行拷贝复制，而派生类多的部分会被忽略 Bulk_quote bulk; //派生类对象 Quote item(bulk); //使用Quote::Quote(const Quote\u0026)构造函数 item = bulk; //调用Quote::operator=(const Quote\u0026) 当构造 item 时，只会处理 Quote 类中的 bookNo 和 price 两个部分，同时忽略了 bulk 中其他成员 当使用一个派生类对象为基类对象初始化或赋值时，只有派生类对象中基类部分会被拷贝、移动或赋值，它的派生类部分会被忽略 问：给出静态类型和动态类型的定义 静态类型在编译时就己经确定了，它是变量声明时的类型或表达式生成的类型； 而动态类型则是变量或表达式表示的内存中的对象的类型，动态类型直到运行时才能知道； 如果一个变量非指针也非引用，则它的静态类型和动态类型永远一致。但基类的指针或引用的动态类型可能与其动态类型不一致 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:3","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#1523-类型转换与继承"},{"categories":["C++"],"content":"15.2.3 类型转换与继承我们可以将基类的指针或引用绑定到派生类对象上，例如：可以用 Quote\u0026 指向一个 Bulk_quote 对象 ==当使用基类的引用（或指针）时，我们并不清楚该引用（指针）所绑定对象的真实类型==，可能该对象时基类的对象，也可能时派生类的对象 智能指针类也支持派生类向基类的类型转换 静态类型和动态类型 使用存在继承关系的类型时，需要区分一个变量或者表达式的静态类型和动态类型 静态类型编译时总是已知的，它是变量声明时的类型或者表达式生成的类型 动态类型则是变量或表达式表示内存中的对象的类型，运行时才可以确定 如果表达式既不是引用也不是指针，则它的动态类型和静态类型永远一致 不存在基类向派生类的隐式转换 派生类可以向基类转换是因为派生类中含有基类的成员，基类的引用或指针可以绑定到该基类部分上 而基类对象中可能存在派生类对象中的成员，也可能不存在，所以不能从基类向派生类自动类型转换 Quote base; Bulk_quote* bulkPtr = \u0026base; //错误：基类不能转换为派生类 Bulk_quote\u0026 bulkRef = base; //错误：基类不能转换为派生类 ==即使一个基类指针或者引用类型绑定在派生类对象上，我们也不能执行从基类向派生类的转换== Bulk_quote bulk; Quote *itemPtr = \u0026bulk; //正确：动态类型是Bulk_quote Bulk_quote *bulkPtr = itemPtr; //错误：不能将基类转换为派生类 编译器在编译时候无法确定上述转换过程在运行时是否安全，编译器只能检查静态类型来判断是否合法 对象之间不存在类型转换派生类向基类的自动类型转换只能对指针和引用有效，在派生类和基类类型之间不存在这样的转换。 当对基类进行初始化或者拷贝赋值时，如果传入的是派生类的对象，通常只会将派生类中含有基类的部分进行拷贝复制，而派生类多的部分会被忽略 Bulk_quote bulk; //派生类对象 Quote item(bulk); //使用Quote::Quote(const Quote\u0026)构造函数 item = bulk; //调用Quote::operator=(const Quote\u0026) 当构造 item 时，只会处理 Quote 类中的 bookNo 和 price 两个部分，同时忽略了 bulk 中其他成员 当使用一个派生类对象为基类对象初始化或赋值时，只有派生类对象中基类部分会被拷贝、移动或赋值，它的派生类部分会被忽略 问：给出静态类型和动态类型的定义 静态类型在编译时就己经确定了，它是变量声明时的类型或表达式生成的类型； 而动态类型则是变量或表达式表示的内存中的对象的类型，动态类型直到运行时才能知道； 如果一个变量非指针也非引用，则它的静态类型和动态类型永远一致。但基类的指针或引用的动态类型可能与其动态类型不一致 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:3","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#静态类型和动态类型"},{"categories":["C++"],"content":"15.2.3 类型转换与继承我们可以将基类的指针或引用绑定到派生类对象上，例如：可以用 Quote\u0026 指向一个 Bulk_quote 对象 ==当使用基类的引用（或指针）时，我们并不清楚该引用（指针）所绑定对象的真实类型==，可能该对象时基类的对象，也可能时派生类的对象 智能指针类也支持派生类向基类的类型转换 静态类型和动态类型 使用存在继承关系的类型时，需要区分一个变量或者表达式的静态类型和动态类型 静态类型编译时总是已知的，它是变量声明时的类型或者表达式生成的类型 动态类型则是变量或表达式表示内存中的对象的类型，运行时才可以确定 如果表达式既不是引用也不是指针，则它的动态类型和静态类型永远一致 不存在基类向派生类的隐式转换 派生类可以向基类转换是因为派生类中含有基类的成员，基类的引用或指针可以绑定到该基类部分上 而基类对象中可能存在派生类对象中的成员，也可能不存在，所以不能从基类向派生类自动类型转换 Quote base; Bulk_quote* bulkPtr = \u0026base; //错误：基类不能转换为派生类 Bulk_quote\u0026 bulkRef = base; //错误：基类不能转换为派生类 ==即使一个基类指针或者引用类型绑定在派生类对象上，我们也不能执行从基类向派生类的转换== Bulk_quote bulk; Quote *itemPtr = \u0026bulk; //正确：动态类型是Bulk_quote Bulk_quote *bulkPtr = itemPtr; //错误：不能将基类转换为派生类 编译器在编译时候无法确定上述转换过程在运行时是否安全，编译器只能检查静态类型来判断是否合法 对象之间不存在类型转换派生类向基类的自动类型转换只能对指针和引用有效，在派生类和基类类型之间不存在这样的转换。 当对基类进行初始化或者拷贝赋值时，如果传入的是派生类的对象，通常只会将派生类中含有基类的部分进行拷贝复制，而派生类多的部分会被忽略 Bulk_quote bulk; //派生类对象 Quote item(bulk); //使用Quote::Quote(const Quote\u0026)构造函数 item = bulk; //调用Quote::operator=(const Quote\u0026) 当构造 item 时，只会处理 Quote 类中的 bookNo 和 price 两个部分，同时忽略了 bulk 中其他成员 当使用一个派生类对象为基类对象初始化或赋值时，只有派生类对象中基类部分会被拷贝、移动或赋值，它的派生类部分会被忽略 问：给出静态类型和动态类型的定义 静态类型在编译时就己经确定了，它是变量声明时的类型或表达式生成的类型； 而动态类型则是变量或表达式表示的内存中的对象的类型，动态类型直到运行时才能知道； 如果一个变量非指针也非引用，则它的静态类型和动态类型永远一致。但基类的指针或引用的动态类型可能与其动态类型不一致 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:3","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#不存在基类向派生类的隐式转换"},{"categories":["C++"],"content":"15.2.3 类型转换与继承我们可以将基类的指针或引用绑定到派生类对象上，例如：可以用 Quote\u0026 指向一个 Bulk_quote 对象 ==当使用基类的引用（或指针）时，我们并不清楚该引用（指针）所绑定对象的真实类型==，可能该对象时基类的对象，也可能时派生类的对象 智能指针类也支持派生类向基类的类型转换 静态类型和动态类型 使用存在继承关系的类型时，需要区分一个变量或者表达式的静态类型和动态类型 静态类型编译时总是已知的，它是变量声明时的类型或者表达式生成的类型 动态类型则是变量或表达式表示内存中的对象的类型，运行时才可以确定 如果表达式既不是引用也不是指针，则它的动态类型和静态类型永远一致 不存在基类向派生类的隐式转换 派生类可以向基类转换是因为派生类中含有基类的成员，基类的引用或指针可以绑定到该基类部分上 而基类对象中可能存在派生类对象中的成员，也可能不存在，所以不能从基类向派生类自动类型转换 Quote base; Bulk_quote* bulkPtr = \u0026base; //错误：基类不能转换为派生类 Bulk_quote\u0026 bulkRef = base; //错误：基类不能转换为派生类 ==即使一个基类指针或者引用类型绑定在派生类对象上，我们也不能执行从基类向派生类的转换== Bulk_quote bulk; Quote *itemPtr = \u0026bulk; //正确：动态类型是Bulk_quote Bulk_quote *bulkPtr = itemPtr; //错误：不能将基类转换为派生类 编译器在编译时候无法确定上述转换过程在运行时是否安全，编译器只能检查静态类型来判断是否合法 对象之间不存在类型转换派生类向基类的自动类型转换只能对指针和引用有效，在派生类和基类类型之间不存在这样的转换。 当对基类进行初始化或者拷贝赋值时，如果传入的是派生类的对象，通常只会将派生类中含有基类的部分进行拷贝复制，而派生类多的部分会被忽略 Bulk_quote bulk; //派生类对象 Quote item(bulk); //使用Quote::Quote(const Quote\u0026)构造函数 item = bulk; //调用Quote::operator=(const Quote\u0026) 当构造 item 时，只会处理 Quote 类中的 bookNo 和 price 两个部分，同时忽略了 bulk 中其他成员 当使用一个派生类对象为基类对象初始化或赋值时，只有派生类对象中基类部分会被拷贝、移动或赋值，它的派生类部分会被忽略 问：给出静态类型和动态类型的定义 静态类型在编译时就己经确定了，它是变量声明时的类型或表达式生成的类型； 而动态类型则是变量或表达式表示的内存中的对象的类型，动态类型直到运行时才能知道； 如果一个变量非指针也非引用，则它的静态类型和动态类型永远一致。但基类的指针或引用的动态类型可能与其动态类型不一致 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:3","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#对象之间不存在类型转换"},{"categories":["C++"],"content":"15.3 虚函数我们使用基类的引用或指针调用一个虚函数的成员函数时，会执行动态绑定，直到运行时我们才能知道到底调用了哪个版本的虚函数，所以所有的虚函数都必须被定义 虚函数的调用可能在运行时才被解析下面是个例子： Quote base(\"0-201-824-1\", 50); print_total(cout, base, 10); //Quote::net_price Bulk_quote derived(\"021-82470-1\", 50); print_total(cout, derived, 10); //Bulk_quote::net_price 第一次调用 print_total 时，base 绑定到 Quote 上，运行的是 Quote 定义的版本 第二次调用时，derived 绑定的 Bulk_quote 版本上，调用的会是 Bulk_quote 定义的版本 动态绑定只有当通过引用或指针调用虚函数时才会发生 base = derived; //把derived中Quote部分拷贝给base base.net_price(20); //调用Quote::net_price 使用普通类型（非指针非引用）的表达式调用虚函数时，在编译阶段就已经确定下来调用的版本了 派生类中的虚函数 派生类如果覆盖继承而来的虚函数，它的形参类型和返回类型必须和基类函数一致 当派生类返回类型是指针或引用时，返回类型存在例外，如果 D 由 B 派生而来，则派生类的返回类型可以时 B* ，而基类返回类型为 D* final 和 override 说明符派生类如果定义了一个函数和虚函数名字相同但是形参列表不同，编译器会认为这个函数和原有函数相互独立，这样的话就不符合我们的想法，派生类没有覆盖基类中的虚函数。或者是在派生类定义函数时因为疏忽打错了函数名，也会出现上述情况 C++11新标准提供 override 关键字来说明派生类中的虚函数，这样使得程序员意图更清晰同时编译器也可以发现错误 struct B { virtual void f1(int) const; virtual void f2(); void f3(); }; struct D1 : B { void f1(int) const override; //正确：f1与基类f1匹配 void f2(int) override; //错误：形参不匹配 void f3() override; //错误：f3不是虚函数 void f4() override; //错误：基类没有名为f4函数 } 如果我们使用 final 关键字，则之后尝试覆盖该函数操作都会失败 struct D2 : B { //从B继承f2()和f3()，覆盖f1(int) void f1(int) const final;//不允许后续其他类覆盖f1(int) }; struct D3 : D2 { void f2(); //正确：覆盖从基类B间接继承来的f2() void f1(int) const; //错误：D2将f1声明为final } final 和 override 说明符出现在形参列表（包括任何const和引用修饰符）以及尾置返回类型之后 虚函数和默认实参虚函数也可以像其他函数一样拥有默认实参，基类和派生类定义的默认实参最好相同 回避虚函数的机制如果希望对虚函数的调用不要进行动态绑定，而是强迫执行虚函数的特定版本，可以使用作用域运算符实现这一目的 double undiscounted = basePtr-\u003eQuote::net_price(42); 通常情况下，只有成员函数（或友元）中代码才需要使用作用域运算符回避虚函数机制 通常当一个派生类的虚函数想调用基类中虚函数版本时，需要回避虚函数的机制 如果派生类虚函数中没有使用作用域运算符，运行时被解析成调用自身版本，导致无限循环 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:3:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#153-虚函数"},{"categories":["C++"],"content":"15.3 虚函数我们使用基类的引用或指针调用一个虚函数的成员函数时，会执行动态绑定，直到运行时我们才能知道到底调用了哪个版本的虚函数，所以所有的虚函数都必须被定义 虚函数的调用可能在运行时才被解析下面是个例子： Quote base(\"0-201-824-1\", 50); print_total(cout, base, 10); //Quote::net_price Bulk_quote derived(\"021-82470-1\", 50); print_total(cout, derived, 10); //Bulk_quote::net_price 第一次调用 print_total 时，base 绑定到 Quote 上，运行的是 Quote 定义的版本 第二次调用时，derived 绑定的 Bulk_quote 版本上，调用的会是 Bulk_quote 定义的版本 动态绑定只有当通过引用或指针调用虚函数时才会发生 base = derived; //把derived中Quote部分拷贝给base base.net_price(20); //调用Quote::net_price 使用普通类型（非指针非引用）的表达式调用虚函数时，在编译阶段就已经确定下来调用的版本了 派生类中的虚函数 派生类如果覆盖继承而来的虚函数，它的形参类型和返回类型必须和基类函数一致 当派生类返回类型是指针或引用时，返回类型存在例外，如果 D 由 B 派生而来，则派生类的返回类型可以时 B* ，而基类返回类型为 D* final 和 override 说明符派生类如果定义了一个函数和虚函数名字相同但是形参列表不同，编译器会认为这个函数和原有函数相互独立，这样的话就不符合我们的想法，派生类没有覆盖基类中的虚函数。或者是在派生类定义函数时因为疏忽打错了函数名，也会出现上述情况 C++11新标准提供 override 关键字来说明派生类中的虚函数，这样使得程序员意图更清晰同时编译器也可以发现错误 struct B { virtual void f1(int) const; virtual void f2(); void f3(); }; struct D1 : B { void f1(int) const override; //正确：f1与基类f1匹配 void f2(int) override; //错误：形参不匹配 void f3() override; //错误：f3不是虚函数 void f4() override; //错误：基类没有名为f4函数 } 如果我们使用 final 关键字，则之后尝试覆盖该函数操作都会失败 struct D2 : B { //从B继承f2()和f3()，覆盖f1(int) void f1(int) const final;//不允许后续其他类覆盖f1(int) }; struct D3 : D2 { void f2(); //正确：覆盖从基类B间接继承来的f2() void f1(int) const; //错误：D2将f1声明为final } final 和 override 说明符出现在形参列表（包括任何const和引用修饰符）以及尾置返回类型之后 虚函数和默认实参虚函数也可以像其他函数一样拥有默认实参，基类和派生类定义的默认实参最好相同 回避虚函数的机制如果希望对虚函数的调用不要进行动态绑定，而是强迫执行虚函数的特定版本，可以使用作用域运算符实现这一目的 double undiscounted = basePtr-Quote::net_price(42); 通常情况下，只有成员函数（或友元）中代码才需要使用作用域运算符回避虚函数机制 通常当一个派生类的虚函数想调用基类中虚函数版本时，需要回避虚函数的机制 如果派生类虚函数中没有使用作用域运算符，运行时被解析成调用自身版本，导致无限循环 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:3:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#虚函数的调用可能在运行时才被解析"},{"categories":["C++"],"content":"15.3 虚函数我们使用基类的引用或指针调用一个虚函数的成员函数时，会执行动态绑定，直到运行时我们才能知道到底调用了哪个版本的虚函数，所以所有的虚函数都必须被定义 虚函数的调用可能在运行时才被解析下面是个例子： Quote base(\"0-201-824-1\", 50); print_total(cout, base, 10); //Quote::net_price Bulk_quote derived(\"021-82470-1\", 50); print_total(cout, derived, 10); //Bulk_quote::net_price 第一次调用 print_total 时，base 绑定到 Quote 上，运行的是 Quote 定义的版本 第二次调用时，derived 绑定的 Bulk_quote 版本上，调用的会是 Bulk_quote 定义的版本 动态绑定只有当通过引用或指针调用虚函数时才会发生 base = derived; //把derived中Quote部分拷贝给base base.net_price(20); //调用Quote::net_price 使用普通类型（非指针非引用）的表达式调用虚函数时，在编译阶段就已经确定下来调用的版本了 派生类中的虚函数 派生类如果覆盖继承而来的虚函数，它的形参类型和返回类型必须和基类函数一致 当派生类返回类型是指针或引用时，返回类型存在例外，如果 D 由 B 派生而来，则派生类的返回类型可以时 B* ，而基类返回类型为 D* final 和 override 说明符派生类如果定义了一个函数和虚函数名字相同但是形参列表不同，编译器会认为这个函数和原有函数相互独立，这样的话就不符合我们的想法，派生类没有覆盖基类中的虚函数。或者是在派生类定义函数时因为疏忽打错了函数名，也会出现上述情况 C++11新标准提供 override 关键字来说明派生类中的虚函数，这样使得程序员意图更清晰同时编译器也可以发现错误 struct B { virtual void f1(int) const; virtual void f2(); void f3(); }; struct D1 : B { void f1(int) const override; //正确：f1与基类f1匹配 void f2(int) override; //错误：形参不匹配 void f3() override; //错误：f3不是虚函数 void f4() override; //错误：基类没有名为f4函数 } 如果我们使用 final 关键字，则之后尝试覆盖该函数操作都会失败 struct D2 : B { //从B继承f2()和f3()，覆盖f1(int) void f1(int) const final;//不允许后续其他类覆盖f1(int) }; struct D3 : D2 { void f2(); //正确：覆盖从基类B间接继承来的f2() void f1(int) const; //错误：D2将f1声明为final } final 和 override 说明符出现在形参列表（包括任何const和引用修饰符）以及尾置返回类型之后 虚函数和默认实参虚函数也可以像其他函数一样拥有默认实参，基类和派生类定义的默认实参最好相同 回避虚函数的机制如果希望对虚函数的调用不要进行动态绑定，而是强迫执行虚函数的特定版本，可以使用作用域运算符实现这一目的 double undiscounted = basePtr-Quote::net_price(42); 通常情况下，只有成员函数（或友元）中代码才需要使用作用域运算符回避虚函数机制 通常当一个派生类的虚函数想调用基类中虚函数版本时，需要回避虚函数的机制 如果派生类虚函数中没有使用作用域运算符，运行时被解析成调用自身版本，导致无限循环 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:3:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#派生类中的虚函数-1"},{"categories":["C++"],"content":"15.3 虚函数我们使用基类的引用或指针调用一个虚函数的成员函数时，会执行动态绑定，直到运行时我们才能知道到底调用了哪个版本的虚函数，所以所有的虚函数都必须被定义 虚函数的调用可能在运行时才被解析下面是个例子： Quote base(\"0-201-824-1\", 50); print_total(cout, base, 10); //Quote::net_price Bulk_quote derived(\"021-82470-1\", 50); print_total(cout, derived, 10); //Bulk_quote::net_price 第一次调用 print_total 时，base 绑定到 Quote 上，运行的是 Quote 定义的版本 第二次调用时，derived 绑定的 Bulk_quote 版本上，调用的会是 Bulk_quote 定义的版本 动态绑定只有当通过引用或指针调用虚函数时才会发生 base = derived; //把derived中Quote部分拷贝给base base.net_price(20); //调用Quote::net_price 使用普通类型（非指针非引用）的表达式调用虚函数时，在编译阶段就已经确定下来调用的版本了 派生类中的虚函数 派生类如果覆盖继承而来的虚函数，它的形参类型和返回类型必须和基类函数一致 当派生类返回类型是指针或引用时，返回类型存在例外，如果 D 由 B 派生而来，则派生类的返回类型可以时 B* ，而基类返回类型为 D* final 和 override 说明符派生类如果定义了一个函数和虚函数名字相同但是形参列表不同，编译器会认为这个函数和原有函数相互独立，这样的话就不符合我们的想法，派生类没有覆盖基类中的虚函数。或者是在派生类定义函数时因为疏忽打错了函数名，也会出现上述情况 C++11新标准提供 override 关键字来说明派生类中的虚函数，这样使得程序员意图更清晰同时编译器也可以发现错误 struct B { virtual void f1(int) const; virtual void f2(); void f3(); }; struct D1 : B { void f1(int) const override; //正确：f1与基类f1匹配 void f2(int) override; //错误：形参不匹配 void f3() override; //错误：f3不是虚函数 void f4() override; //错误：基类没有名为f4函数 } 如果我们使用 final 关键字，则之后尝试覆盖该函数操作都会失败 struct D2 : B { //从B继承f2()和f3()，覆盖f1(int) void f1(int) const final;//不允许后续其他类覆盖f1(int) }; struct D3 : D2 { void f2(); //正确：覆盖从基类B间接继承来的f2() void f1(int) const; //错误：D2将f1声明为final } final 和 override 说明符出现在形参列表（包括任何const和引用修饰符）以及尾置返回类型之后 虚函数和默认实参虚函数也可以像其他函数一样拥有默认实参，基类和派生类定义的默认实参最好相同 回避虚函数的机制如果希望对虚函数的调用不要进行动态绑定，而是强迫执行虚函数的特定版本，可以使用作用域运算符实现这一目的 double undiscounted = basePtr-Quote::net_price(42); 通常情况下，只有成员函数（或友元）中代码才需要使用作用域运算符回避虚函数机制 通常当一个派生类的虚函数想调用基类中虚函数版本时，需要回避虚函数的机制 如果派生类虚函数中没有使用作用域运算符，运行时被解析成调用自身版本，导致无限循环 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:3:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#final-和-override-说明符"},{"categories":["C++"],"content":"15.3 虚函数我们使用基类的引用或指针调用一个虚函数的成员函数时，会执行动态绑定，直到运行时我们才能知道到底调用了哪个版本的虚函数，所以所有的虚函数都必须被定义 虚函数的调用可能在运行时才被解析下面是个例子： Quote base(\"0-201-824-1\", 50); print_total(cout, base, 10); //Quote::net_price Bulk_quote derived(\"021-82470-1\", 50); print_total(cout, derived, 10); //Bulk_quote::net_price 第一次调用 print_total 时，base 绑定到 Quote 上，运行的是 Quote 定义的版本 第二次调用时，derived 绑定的 Bulk_quote 版本上，调用的会是 Bulk_quote 定义的版本 动态绑定只有当通过引用或指针调用虚函数时才会发生 base = derived; //把derived中Quote部分拷贝给base base.net_price(20); //调用Quote::net_price 使用普通类型（非指针非引用）的表达式调用虚函数时，在编译阶段就已经确定下来调用的版本了 派生类中的虚函数 派生类如果覆盖继承而来的虚函数，它的形参类型和返回类型必须和基类函数一致 当派生类返回类型是指针或引用时，返回类型存在例外，如果 D 由 B 派生而来，则派生类的返回类型可以时 B* ，而基类返回类型为 D* final 和 override 说明符派生类如果定义了一个函数和虚函数名字相同但是形参列表不同，编译器会认为这个函数和原有函数相互独立，这样的话就不符合我们的想法，派生类没有覆盖基类中的虚函数。或者是在派生类定义函数时因为疏忽打错了函数名，也会出现上述情况 C++11新标准提供 override 关键字来说明派生类中的虚函数，这样使得程序员意图更清晰同时编译器也可以发现错误 struct B { virtual void f1(int) const; virtual void f2(); void f3(); }; struct D1 : B { void f1(int) const override; //正确：f1与基类f1匹配 void f2(int) override; //错误：形参不匹配 void f3() override; //错误：f3不是虚函数 void f4() override; //错误：基类没有名为f4函数 } 如果我们使用 final 关键字，则之后尝试覆盖该函数操作都会失败 struct D2 : B { //从B继承f2()和f3()，覆盖f1(int) void f1(int) const final;//不允许后续其他类覆盖f1(int) }; struct D3 : D2 { void f2(); //正确：覆盖从基类B间接继承来的f2() void f1(int) const; //错误：D2将f1声明为final } final 和 override 说明符出现在形参列表（包括任何const和引用修饰符）以及尾置返回类型之后 虚函数和默认实参虚函数也可以像其他函数一样拥有默认实参，基类和派生类定义的默认实参最好相同 回避虚函数的机制如果希望对虚函数的调用不要进行动态绑定，而是强迫执行虚函数的特定版本，可以使用作用域运算符实现这一目的 double undiscounted = basePtr-Quote::net_price(42); 通常情况下，只有成员函数（或友元）中代码才需要使用作用域运算符回避虚函数机制 通常当一个派生类的虚函数想调用基类中虚函数版本时，需要回避虚函数的机制 如果派生类虚函数中没有使用作用域运算符，运行时被解析成调用自身版本，导致无限循环 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:3:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#虚函数和默认实参"},{"categories":["C++"],"content":"15.3 虚函数我们使用基类的引用或指针调用一个虚函数的成员函数时，会执行动态绑定，直到运行时我们才能知道到底调用了哪个版本的虚函数，所以所有的虚函数都必须被定义 虚函数的调用可能在运行时才被解析下面是个例子： Quote base(\"0-201-824-1\", 50); print_total(cout, base, 10); //Quote::net_price Bulk_quote derived(\"021-82470-1\", 50); print_total(cout, derived, 10); //Bulk_quote::net_price 第一次调用 print_total 时，base 绑定到 Quote 上，运行的是 Quote 定义的版本 第二次调用时，derived 绑定的 Bulk_quote 版本上，调用的会是 Bulk_quote 定义的版本 动态绑定只有当通过引用或指针调用虚函数时才会发生 base = derived; //把derived中Quote部分拷贝给base base.net_price(20); //调用Quote::net_price 使用普通类型（非指针非引用）的表达式调用虚函数时，在编译阶段就已经确定下来调用的版本了 派生类中的虚函数 派生类如果覆盖继承而来的虚函数，它的形参类型和返回类型必须和基类函数一致 当派生类返回类型是指针或引用时，返回类型存在例外，如果 D 由 B 派生而来，则派生类的返回类型可以时 B* ，而基类返回类型为 D* final 和 override 说明符派生类如果定义了一个函数和虚函数名字相同但是形参列表不同，编译器会认为这个函数和原有函数相互独立，这样的话就不符合我们的想法，派生类没有覆盖基类中的虚函数。或者是在派生类定义函数时因为疏忽打错了函数名，也会出现上述情况 C++11新标准提供 override 关键字来说明派生类中的虚函数，这样使得程序员意图更清晰同时编译器也可以发现错误 struct B { virtual void f1(int) const; virtual void f2(); void f3(); }; struct D1 : B { void f1(int) const override; //正确：f1与基类f1匹配 void f2(int) override; //错误：形参不匹配 void f3() override; //错误：f3不是虚函数 void f4() override; //错误：基类没有名为f4函数 } 如果我们使用 final 关键字，则之后尝试覆盖该函数操作都会失败 struct D2 : B { //从B继承f2()和f3()，覆盖f1(int) void f1(int) const final;//不允许后续其他类覆盖f1(int) }; struct D3 : D2 { void f2(); //正确：覆盖从基类B间接继承来的f2() void f1(int) const; //错误：D2将f1声明为final } final 和 override 说明符出现在形参列表（包括任何const和引用修饰符）以及尾置返回类型之后 虚函数和默认实参虚函数也可以像其他函数一样拥有默认实参，基类和派生类定义的默认实参最好相同 回避虚函数的机制如果希望对虚函数的调用不要进行动态绑定，而是强迫执行虚函数的特定版本，可以使用作用域运算符实现这一目的 double undiscounted = basePtr-Quote::net_price(42); 通常情况下，只有成员函数（或友元）中代码才需要使用作用域运算符回避虚函数机制 通常当一个派生类的虚函数想调用基类中虚函数版本时，需要回避虚函数的机制 如果派生类虚函数中没有使用作用域运算符，运行时被解析成调用自身版本，导致无限循环 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:3:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#回避虚函数的机制"},{"categories":["C++"],"content":"15.4 抽象基类纯虚函数我们如果将虚函数定义为纯虚函数，含有该函数的类是抽象基类，抽象基类负责定义接口，而后续其他类可以覆盖该接口 我们在函数体的位置（即分号前面）书写 =0 就可以将一个虚函数说明为纯虚函数 class Disc_quote : public Quote { public: Disc_quote() = default; Disc_quote(const std::string\u0026 book, double price, std::size_t qty, double price) : Quote(book, price), quantity(qty), discount(dis) {} double net_price(std::size_t) const = 0; protected: std::size_t quantity = 0; double discount = 0.0; } 纯虚函数无须定义，我们也可以为其定义，但函数体必须写在类的外部，即我们不能在类的内部为一个 =0 的函数提供函数体 我们不能直接创建一个抽象基类的对象 派生类构造函数只初始化它的直接基类下面重新实现 Bulk_quote class Bulk_quote : public Disc_quote { public: Bulk_quote() = default; Bulk_quote(const std::string\u0026 book, double price, std::size_t qty, double price) : Disc_quote(book, price, qty, disc) {} double net_price(std::size_t) const override; }; 每个类各自控制其对象的初始化过程，即使 Bulk_quote 中没有任何数据成员，也需要提供一个构造函数，初始化它的直接基类，也就是 Disc_quote ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:4:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#154-抽象基类"},{"categories":["C++"],"content":"15.4 抽象基类纯虚函数我们如果将虚函数定义为纯虚函数，含有该函数的类是抽象基类，抽象基类负责定义接口，而后续其他类可以覆盖该接口 我们在函数体的位置（即分号前面）书写 =0 就可以将一个虚函数说明为纯虚函数 class Disc_quote : public Quote { public: Disc_quote() = default; Disc_quote(const std::string\u0026 book, double price, std::size_t qty, double price) : Quote(book, price), quantity(qty), discount(dis) {} double net_price(std::size_t) const = 0; protected: std::size_t quantity = 0; double discount = 0.0; } 纯虚函数无须定义，我们也可以为其定义，但函数体必须写在类的外部，即我们不能在类的内部为一个 =0 的函数提供函数体 我们不能直接创建一个抽象基类的对象 派生类构造函数只初始化它的直接基类下面重新实现 Bulk_quote class Bulk_quote : public Disc_quote { public: Bulk_quote() = default; Bulk_quote(const std::string\u0026 book, double price, std::size_t qty, double price) : Disc_quote(book, price, qty, disc) {} double net_price(std::size_t) const override; }; 每个类各自控制其对象的初始化过程，即使 Bulk_quote 中没有任何数据成员，也需要提供一个构造函数，初始化它的直接基类，也就是 Disc_quote ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:4:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#纯虚函数"},{"categories":["C++"],"content":"15.4 抽象基类纯虚函数我们如果将虚函数定义为纯虚函数，含有该函数的类是抽象基类，抽象基类负责定义接口，而后续其他类可以覆盖该接口 我们在函数体的位置（即分号前面）书写 =0 就可以将一个虚函数说明为纯虚函数 class Disc_quote : public Quote { public: Disc_quote() = default; Disc_quote(const std::string\u0026 book, double price, std::size_t qty, double price) : Quote(book, price), quantity(qty), discount(dis) {} double net_price(std::size_t) const = 0; protected: std::size_t quantity = 0; double discount = 0.0; } 纯虚函数无须定义，我们也可以为其定义，但函数体必须写在类的外部，即我们不能在类的内部为一个 =0 的函数提供函数体 我们不能直接创建一个抽象基类的对象 派生类构造函数只初始化它的直接基类下面重新实现 Bulk_quote class Bulk_quote : public Disc_quote { public: Bulk_quote() = default; Bulk_quote(const std::string\u0026 book, double price, std::size_t qty, double price) : Disc_quote(book, price, qty, disc) {} double net_price(std::size_t) const override; }; 每个类各自控制其对象的初始化过程，即使 Bulk_quote 中没有任何数据成员，也需要提供一个构造函数，初始化它的直接基类，也就是 Disc_quote ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:4:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#派生类构造函数只初始化它的直接基类"},{"categories":["C++"],"content":"15.5 访问控制与继承每个类分别控制自己成员初始化过程，每个类还控制着其成员对于派生类来说是否可访问 受保护的成员protected 关键字可以控制那些它希望与派生类分享但是不想和其他公共访问使用的成员 和私有成员类似，受保护的成员对于类的用户是不可访问的 和公有成员类型，受保护的成员对于派生类和友元是可访问的 派生类的成员或友元只能通过派生类对象来访问基类中受保护的成员 派生类对于基类对象中受保护成员没有任何访问权限 class Base { protected: int prot_mem; }; class Sneaky : public Base { friend void clobber(Sneaky\u0026);//能访问Sneaky::prot_mem friend void clobber(Base\u0026*); //不能访问Base::prot_mem int j; //默认为private }; //正确：可以访问Sneaky对象的private和protected成员 void clobber(Sneaky \u0026s) { s.j = s.prot_mem = 0; } //错误：不能访问Base中的protected成员 void clobber(Base \u0026b) { b.prot_mem = 0; } 上面的最后一条的含义是一个派生类成员和友元只能访问派生类继承过来属于基类那部分的受保护成员（这些成员，派生类自己本身也有，成员和友元可以访问自己本身的受保护的成员），而不能直接访问基类对象中的受保护成员 公共、私有和受保护继承类对继承而来的成员的访问权限受到两个因素影响：一是基类在该成员的访问说明符，二是派生类的派生列表中的访问说明符 class Base { public: void pub_mem(); protected: int prot_mem; private: char priv_mem; }; struct Pub_Derv : public Base { //正确：派生类能访问protected成员 int f() { return prot_mem; } //错误：派生类不能访问private成员 char g() { return priv_mem; } }; struct Priv_Derv : private Base { //private不影响派生类访问权限 int f1() const { return prot_mem; } }; 派生类访问说明符对于派生类的成员能否访问直接基类的成员没有什么影响，如上 Pub_Derv 和 Priv_Derv 都可以访问基类 Base 中的 prot_mem 派生类访问说明符是控制派生类用户（包括派生类的派生类）对于基类成员的访问权限，相当于将基类成员定义为相应的访问说明符 Pub_Derv d1; Priv_Derv d2; d1.pub_mem(); //正确：pub_mem在派生类中是public的 d2.pub_mem(); //错误：pub_mem在派生类中是protected的 此时在 Priv_Derv 中基类的成员被定义为 private 的了，这样它创建的对象就不可以直接访问 派生类向基类转换的可访问性派生类向基类的转换是否可访问由使用该转换的代码决定，同时派牛类的派生访问说明符也会有影响。假定D 继承自B :· 只有当 D 公有地继承 B 时，用户代码才能使用派生类向基类的转换；如果 D 继承 B 的方式是受保护的或者私有的，则用户代码不能使用该转换。 不论 D 以什么方式继承B , D 的成员函数和友元都能使用派生类向基类的转换： 派生类向其直接基类的类型转换对千派牛类的成员和友元来说水远是可访问的。 如果 D 继承 B 的方式是公有的或者受保护的，则 D 的派生类的成员和友元可以使用 D 向 B 的类型转换； 反之，如果 D 继承 B 的方式是私有的，则不能使用。 友元和继承友元关系不能传递，也不能继承，基类的友元在访问派生类成员时不具有特殊性 class Base { friend class Pal; protected: int prot_mem; }; class Sneaky : public Base { friend void clobber(Sneaky\u0026);//能访问Sneaky::prot_mem friend void clobber(Base\u0026*); //不能访问Base::prot_mem int j; //默认为private }; class Pal { public: int f(Base b) { return b.prot_mem; } //正确：Pal是Base友元 int f(Sneaky s) { return s.j; } //错误：Pal不是Sneaky友元 int f3(Sneaky s) { return s.prot_mem; }//正确：Pal是Base友元 } f3 访问了派生类中基类部分的成员，Pal 是基类的友元，Pal 能够访问 Base 对象的成员 友元只对做出声明的类有效，而友元的基类或派生类不具有特殊访问能力 class D2 : public Pal { public: int mem(Base b) { return b.prot_mem; } //错误友元不能继承 } 改变个别成员的可访问性如果需要改变派生类继承的某个名字的访问性，可以使用 using 声明达到这个目的 class Base { public: std::size_t size() cont { return n; } protected: std::size_t n; }; class Dervied : private Base { public: using Base::size; protected: using Base::n; }; Derived 为私有继承，继承的size 和 n 默认情况下是 Derived 的私有成员，使用 using 声明语句，可以改变这个成员的可访问性，此时的 Derived 用户都可以使用 size，而只有 Derived 的派生类才可以使用 n using 声明控制的访问权限仅由声明语句前面的访问说明符决定 默认的继承保护级别默认情况下，class 关键字的派生类是私有继承的，struct 关键字的派生类是公有继承的 class Base { /**/ }; struct D1 : Base { /**/ }; //默认public继承 class D2 : Base { /**/ }; //默认private继承 struct 和 class 关键字唯一区别就是默认成员访问说明符默认派生访问说明符的区别 一个私有派生的类最好显示的声明 private，不要仅仅依赖默认设置 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:5:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#155-访问控制与继承"},{"categories":["C++"],"content":"15.5 访问控制与继承每个类分别控制自己成员初始化过程，每个类还控制着其成员对于派生类来说是否可访问 受保护的成员protected 关键字可以控制那些它希望与派生类分享但是不想和其他公共访问使用的成员 和私有成员类似，受保护的成员对于类的用户是不可访问的 和公有成员类型，受保护的成员对于派生类和友元是可访问的 派生类的成员或友元只能通过派生类对象来访问基类中受保护的成员 派生类对于基类对象中受保护成员没有任何访问权限 class Base { protected: int prot_mem; }; class Sneaky : public Base { friend void clobber(Sneaky\u0026);//能访问Sneaky::prot_mem friend void clobber(Base\u0026*); //不能访问Base::prot_mem int j; //默认为private }; //正确：可以访问Sneaky对象的private和protected成员 void clobber(Sneaky \u0026s) { s.j = s.prot_mem = 0; } //错误：不能访问Base中的protected成员 void clobber(Base \u0026b) { b.prot_mem = 0; } 上面的最后一条的含义是一个派生类成员和友元只能访问派生类继承过来属于基类那部分的受保护成员（这些成员，派生类自己本身也有，成员和友元可以访问自己本身的受保护的成员），而不能直接访问基类对象中的受保护成员 公共、私有和受保护继承类对继承而来的成员的访问权限受到两个因素影响：一是基类在该成员的访问说明符，二是派生类的派生列表中的访问说明符 class Base { public: void pub_mem(); protected: int prot_mem; private: char priv_mem; }; struct Pub_Derv : public Base { //正确：派生类能访问protected成员 int f() { return prot_mem; } //错误：派生类不能访问private成员 char g() { return priv_mem; } }; struct Priv_Derv : private Base { //private不影响派生类访问权限 int f1() const { return prot_mem; } }; 派生类访问说明符对于派生类的成员能否访问直接基类的成员没有什么影响，如上 Pub_Derv 和 Priv_Derv 都可以访问基类 Base 中的 prot_mem 派生类访问说明符是控制派生类用户（包括派生类的派生类）对于基类成员的访问权限，相当于将基类成员定义为相应的访问说明符 Pub_Derv d1; Priv_Derv d2; d1.pub_mem(); //正确：pub_mem在派生类中是public的 d2.pub_mem(); //错误：pub_mem在派生类中是protected的 此时在 Priv_Derv 中基类的成员被定义为 private 的了，这样它创建的对象就不可以直接访问 派生类向基类转换的可访问性派生类向基类的转换是否可访问由使用该转换的代码决定，同时派牛类的派生访问说明符也会有影响。假定D 继承自B :· 只有当 D 公有地继承 B 时，用户代码才能使用派生类向基类的转换；如果 D 继承 B 的方式是受保护的或者私有的，则用户代码不能使用该转换。 不论 D 以什么方式继承B , D 的成员函数和友元都能使用派生类向基类的转换： 派生类向其直接基类的类型转换对千派牛类的成员和友元来说水远是可访问的。 如果 D 继承 B 的方式是公有的或者受保护的，则 D 的派生类的成员和友元可以使用 D 向 B 的类型转换； 反之，如果 D 继承 B 的方式是私有的，则不能使用。 友元和继承友元关系不能传递，也不能继承，基类的友元在访问派生类成员时不具有特殊性 class Base { friend class Pal; protected: int prot_mem; }; class Sneaky : public Base { friend void clobber(Sneaky\u0026);//能访问Sneaky::prot_mem friend void clobber(Base\u0026*); //不能访问Base::prot_mem int j; //默认为private }; class Pal { public: int f(Base b) { return b.prot_mem; } //正确：Pal是Base友元 int f(Sneaky s) { return s.j; } //错误：Pal不是Sneaky友元 int f3(Sneaky s) { return s.prot_mem; }//正确：Pal是Base友元 } f3 访问了派生类中基类部分的成员，Pal 是基类的友元，Pal 能够访问 Base 对象的成员 友元只对做出声明的类有效，而友元的基类或派生类不具有特殊访问能力 class D2 : public Pal { public: int mem(Base b) { return b.prot_mem; } //错误友元不能继承 } 改变个别成员的可访问性如果需要改变派生类继承的某个名字的访问性，可以使用 using 声明达到这个目的 class Base { public: std::size_t size() cont { return n; } protected: std::size_t n; }; class Dervied : private Base { public: using Base::size; protected: using Base::n; }; Derived 为私有继承，继承的size 和 n 默认情况下是 Derived 的私有成员，使用 using 声明语句，可以改变这个成员的可访问性，此时的 Derived 用户都可以使用 size，而只有 Derived 的派生类才可以使用 n using 声明控制的访问权限仅由声明语句前面的访问说明符决定 默认的继承保护级别默认情况下，class 关键字的派生类是私有继承的，struct 关键字的派生类是公有继承的 class Base { /**/ }; struct D1 : Base { /**/ }; //默认public继承 class D2 : Base { /**/ }; //默认private继承 struct 和 class 关键字唯一区别就是默认成员访问说明符默认派生访问说明符的区别 一个私有派生的类最好显示的声明 private，不要仅仅依赖默认设置 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:5:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#受保护的成员"},{"categories":["C++"],"content":"15.5 访问控制与继承每个类分别控制自己成员初始化过程，每个类还控制着其成员对于派生类来说是否可访问 受保护的成员protected 关键字可以控制那些它希望与派生类分享但是不想和其他公共访问使用的成员 和私有成员类似，受保护的成员对于类的用户是不可访问的 和公有成员类型，受保护的成员对于派生类和友元是可访问的 派生类的成员或友元只能通过派生类对象来访问基类中受保护的成员 派生类对于基类对象中受保护成员没有任何访问权限 class Base { protected: int prot_mem; }; class Sneaky : public Base { friend void clobber(Sneaky\u0026);//能访问Sneaky::prot_mem friend void clobber(Base\u0026*); //不能访问Base::prot_mem int j; //默认为private }; //正确：可以访问Sneaky对象的private和protected成员 void clobber(Sneaky \u0026s) { s.j = s.prot_mem = 0; } //错误：不能访问Base中的protected成员 void clobber(Base \u0026b) { b.prot_mem = 0; } 上面的最后一条的含义是一个派生类成员和友元只能访问派生类继承过来属于基类那部分的受保护成员（这些成员，派生类自己本身也有，成员和友元可以访问自己本身的受保护的成员），而不能直接访问基类对象中的受保护成员 公共、私有和受保护继承类对继承而来的成员的访问权限受到两个因素影响：一是基类在该成员的访问说明符，二是派生类的派生列表中的访问说明符 class Base { public: void pub_mem(); protected: int prot_mem; private: char priv_mem; }; struct Pub_Derv : public Base { //正确：派生类能访问protected成员 int f() { return prot_mem; } //错误：派生类不能访问private成员 char g() { return priv_mem; } }; struct Priv_Derv : private Base { //private不影响派生类访问权限 int f1() const { return prot_mem; } }; 派生类访问说明符对于派生类的成员能否访问直接基类的成员没有什么影响，如上 Pub_Derv 和 Priv_Derv 都可以访问基类 Base 中的 prot_mem 派生类访问说明符是控制派生类用户（包括派生类的派生类）对于基类成员的访问权限，相当于将基类成员定义为相应的访问说明符 Pub_Derv d1; Priv_Derv d2; d1.pub_mem(); //正确：pub_mem在派生类中是public的 d2.pub_mem(); //错误：pub_mem在派生类中是protected的 此时在 Priv_Derv 中基类的成员被定义为 private 的了，这样它创建的对象就不可以直接访问 派生类向基类转换的可访问性派生类向基类的转换是否可访问由使用该转换的代码决定，同时派牛类的派生访问说明符也会有影响。假定D 继承自B :· 只有当 D 公有地继承 B 时，用户代码才能使用派生类向基类的转换；如果 D 继承 B 的方式是受保护的或者私有的，则用户代码不能使用该转换。 不论 D 以什么方式继承B , D 的成员函数和友元都能使用派生类向基类的转换： 派生类向其直接基类的类型转换对千派牛类的成员和友元来说水远是可访问的。 如果 D 继承 B 的方式是公有的或者受保护的，则 D 的派生类的成员和友元可以使用 D 向 B 的类型转换； 反之，如果 D 继承 B 的方式是私有的，则不能使用。 友元和继承友元关系不能传递，也不能继承，基类的友元在访问派生类成员时不具有特殊性 class Base { friend class Pal; protected: int prot_mem; }; class Sneaky : public Base { friend void clobber(Sneaky\u0026);//能访问Sneaky::prot_mem friend void clobber(Base\u0026*); //不能访问Base::prot_mem int j; //默认为private }; class Pal { public: int f(Base b) { return b.prot_mem; } //正确：Pal是Base友元 int f(Sneaky s) { return s.j; } //错误：Pal不是Sneaky友元 int f3(Sneaky s) { return s.prot_mem; }//正确：Pal是Base友元 } f3 访问了派生类中基类部分的成员，Pal 是基类的友元，Pal 能够访问 Base 对象的成员 友元只对做出声明的类有效，而友元的基类或派生类不具有特殊访问能力 class D2 : public Pal { public: int mem(Base b) { return b.prot_mem; } //错误友元不能继承 } 改变个别成员的可访问性如果需要改变派生类继承的某个名字的访问性，可以使用 using 声明达到这个目的 class Base { public: std::size_t size() cont { return n; } protected: std::size_t n; }; class Dervied : private Base { public: using Base::size; protected: using Base::n; }; Derived 为私有继承，继承的size 和 n 默认情况下是 Derived 的私有成员，使用 using 声明语句，可以改变这个成员的可访问性，此时的 Derived 用户都可以使用 size，而只有 Derived 的派生类才可以使用 n using 声明控制的访问权限仅由声明语句前面的访问说明符决定 默认的继承保护级别默认情况下，class 关键字的派生类是私有继承的，struct 关键字的派生类是公有继承的 class Base { /**/ }; struct D1 : Base { /**/ }; //默认public继承 class D2 : Base { /**/ }; //默认private继承 struct 和 class 关键字唯一区别就是默认成员访问说明符默认派生访问说明符的区别 一个私有派生的类最好显示的声明 private，不要仅仅依赖默认设置 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:5:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#公共私有和受保护继承"},{"categories":["C++"],"content":"15.5 访问控制与继承每个类分别控制自己成员初始化过程，每个类还控制着其成员对于派生类来说是否可访问 受保护的成员protected 关键字可以控制那些它希望与派生类分享但是不想和其他公共访问使用的成员 和私有成员类似，受保护的成员对于类的用户是不可访问的 和公有成员类型，受保护的成员对于派生类和友元是可访问的 派生类的成员或友元只能通过派生类对象来访问基类中受保护的成员 派生类对于基类对象中受保护成员没有任何访问权限 class Base { protected: int prot_mem; }; class Sneaky : public Base { friend void clobber(Sneaky\u0026);//能访问Sneaky::prot_mem friend void clobber(Base\u0026*); //不能访问Base::prot_mem int j; //默认为private }; //正确：可以访问Sneaky对象的private和protected成员 void clobber(Sneaky \u0026s) { s.j = s.prot_mem = 0; } //错误：不能访问Base中的protected成员 void clobber(Base \u0026b) { b.prot_mem = 0; } 上面的最后一条的含义是一个派生类成员和友元只能访问派生类继承过来属于基类那部分的受保护成员（这些成员，派生类自己本身也有，成员和友元可以访问自己本身的受保护的成员），而不能直接访问基类对象中的受保护成员 公共、私有和受保护继承类对继承而来的成员的访问权限受到两个因素影响：一是基类在该成员的访问说明符，二是派生类的派生列表中的访问说明符 class Base { public: void pub_mem(); protected: int prot_mem; private: char priv_mem; }; struct Pub_Derv : public Base { //正确：派生类能访问protected成员 int f() { return prot_mem; } //错误：派生类不能访问private成员 char g() { return priv_mem; } }; struct Priv_Derv : private Base { //private不影响派生类访问权限 int f1() const { return prot_mem; } }; 派生类访问说明符对于派生类的成员能否访问直接基类的成员没有什么影响，如上 Pub_Derv 和 Priv_Derv 都可以访问基类 Base 中的 prot_mem 派生类访问说明符是控制派生类用户（包括派生类的派生类）对于基类成员的访问权限，相当于将基类成员定义为相应的访问说明符 Pub_Derv d1; Priv_Derv d2; d1.pub_mem(); //正确：pub_mem在派生类中是public的 d2.pub_mem(); //错误：pub_mem在派生类中是protected的 此时在 Priv_Derv 中基类的成员被定义为 private 的了，这样它创建的对象就不可以直接访问 派生类向基类转换的可访问性派生类向基类的转换是否可访问由使用该转换的代码决定，同时派牛类的派生访问说明符也会有影响。假定D 继承自B :· 只有当 D 公有地继承 B 时，用户代码才能使用派生类向基类的转换；如果 D 继承 B 的方式是受保护的或者私有的，则用户代码不能使用该转换。 不论 D 以什么方式继承B , D 的成员函数和友元都能使用派生类向基类的转换： 派生类向其直接基类的类型转换对千派牛类的成员和友元来说水远是可访问的。 如果 D 继承 B 的方式是公有的或者受保护的，则 D 的派生类的成员和友元可以使用 D 向 B 的类型转换； 反之，如果 D 继承 B 的方式是私有的，则不能使用。 友元和继承友元关系不能传递，也不能继承，基类的友元在访问派生类成员时不具有特殊性 class Base { friend class Pal; protected: int prot_mem; }; class Sneaky : public Base { friend void clobber(Sneaky\u0026);//能访问Sneaky::prot_mem friend void clobber(Base\u0026*); //不能访问Base::prot_mem int j; //默认为private }; class Pal { public: int f(Base b) { return b.prot_mem; } //正确：Pal是Base友元 int f(Sneaky s) { return s.j; } //错误：Pal不是Sneaky友元 int f3(Sneaky s) { return s.prot_mem; }//正确：Pal是Base友元 } f3 访问了派生类中基类部分的成员，Pal 是基类的友元，Pal 能够访问 Base 对象的成员 友元只对做出声明的类有效，而友元的基类或派生类不具有特殊访问能力 class D2 : public Pal { public: int mem(Base b) { return b.prot_mem; } //错误友元不能继承 } 改变个别成员的可访问性如果需要改变派生类继承的某个名字的访问性，可以使用 using 声明达到这个目的 class Base { public: std::size_t size() cont { return n; } protected: std::size_t n; }; class Dervied : private Base { public: using Base::size; protected: using Base::n; }; Derived 为私有继承，继承的size 和 n 默认情况下是 Derived 的私有成员，使用 using 声明语句，可以改变这个成员的可访问性，此时的 Derived 用户都可以使用 size，而只有 Derived 的派生类才可以使用 n using 声明控制的访问权限仅由声明语句前面的访问说明符决定 默认的继承保护级别默认情况下，class 关键字的派生类是私有继承的，struct 关键字的派生类是公有继承的 class Base { /**/ }; struct D1 : Base { /**/ }; //默认public继承 class D2 : Base { /**/ }; //默认private继承 struct 和 class 关键字唯一区别就是默认成员访问说明符默认派生访问说明符的区别 一个私有派生的类最好显示的声明 private，不要仅仅依赖默认设置 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:5:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#派生类向基类转换的可访问性"},{"categories":["C++"],"content":"15.5 访问控制与继承每个类分别控制自己成员初始化过程，每个类还控制着其成员对于派生类来说是否可访问 受保护的成员protected 关键字可以控制那些它希望与派生类分享但是不想和其他公共访问使用的成员 和私有成员类似，受保护的成员对于类的用户是不可访问的 和公有成员类型，受保护的成员对于派生类和友元是可访问的 派生类的成员或友元只能通过派生类对象来访问基类中受保护的成员 派生类对于基类对象中受保护成员没有任何访问权限 class Base { protected: int prot_mem; }; class Sneaky : public Base { friend void clobber(Sneaky\u0026);//能访问Sneaky::prot_mem friend void clobber(Base\u0026*); //不能访问Base::prot_mem int j; //默认为private }; //正确：可以访问Sneaky对象的private和protected成员 void clobber(Sneaky \u0026s) { s.j = s.prot_mem = 0; } //错误：不能访问Base中的protected成员 void clobber(Base \u0026b) { b.prot_mem = 0; } 上面的最后一条的含义是一个派生类成员和友元只能访问派生类继承过来属于基类那部分的受保护成员（这些成员，派生类自己本身也有，成员和友元可以访问自己本身的受保护的成员），而不能直接访问基类对象中的受保护成员 公共、私有和受保护继承类对继承而来的成员的访问权限受到两个因素影响：一是基类在该成员的访问说明符，二是派生类的派生列表中的访问说明符 class Base { public: void pub_mem(); protected: int prot_mem; private: char priv_mem; }; struct Pub_Derv : public Base { //正确：派生类能访问protected成员 int f() { return prot_mem; } //错误：派生类不能访问private成员 char g() { return priv_mem; } }; struct Priv_Derv : private Base { //private不影响派生类访问权限 int f1() const { return prot_mem; } }; 派生类访问说明符对于派生类的成员能否访问直接基类的成员没有什么影响，如上 Pub_Derv 和 Priv_Derv 都可以访问基类 Base 中的 prot_mem 派生类访问说明符是控制派生类用户（包括派生类的派生类）对于基类成员的访问权限，相当于将基类成员定义为相应的访问说明符 Pub_Derv d1; Priv_Derv d2; d1.pub_mem(); //正确：pub_mem在派生类中是public的 d2.pub_mem(); //错误：pub_mem在派生类中是protected的 此时在 Priv_Derv 中基类的成员被定义为 private 的了，这样它创建的对象就不可以直接访问 派生类向基类转换的可访问性派生类向基类的转换是否可访问由使用该转换的代码决定，同时派牛类的派生访问说明符也会有影响。假定D 继承自B :· 只有当 D 公有地继承 B 时，用户代码才能使用派生类向基类的转换；如果 D 继承 B 的方式是受保护的或者私有的，则用户代码不能使用该转换。 不论 D 以什么方式继承B , D 的成员函数和友元都能使用派生类向基类的转换： 派生类向其直接基类的类型转换对千派牛类的成员和友元来说水远是可访问的。 如果 D 继承 B 的方式是公有的或者受保护的，则 D 的派生类的成员和友元可以使用 D 向 B 的类型转换； 反之，如果 D 继承 B 的方式是私有的，则不能使用。 友元和继承友元关系不能传递，也不能继承，基类的友元在访问派生类成员时不具有特殊性 class Base { friend class Pal; protected: int prot_mem; }; class Sneaky : public Base { friend void clobber(Sneaky\u0026);//能访问Sneaky::prot_mem friend void clobber(Base\u0026*); //不能访问Base::prot_mem int j; //默认为private }; class Pal { public: int f(Base b) { return b.prot_mem; } //正确：Pal是Base友元 int f(Sneaky s) { return s.j; } //错误：Pal不是Sneaky友元 int f3(Sneaky s) { return s.prot_mem; }//正确：Pal是Base友元 } f3 访问了派生类中基类部分的成员，Pal 是基类的友元，Pal 能够访问 Base 对象的成员 友元只对做出声明的类有效，而友元的基类或派生类不具有特殊访问能力 class D2 : public Pal { public: int mem(Base b) { return b.prot_mem; } //错误友元不能继承 } 改变个别成员的可访问性如果需要改变派生类继承的某个名字的访问性，可以使用 using 声明达到这个目的 class Base { public: std::size_t size() cont { return n; } protected: std::size_t n; }; class Dervied : private Base { public: using Base::size; protected: using Base::n; }; Derived 为私有继承，继承的size 和 n 默认情况下是 Derived 的私有成员，使用 using 声明语句，可以改变这个成员的可访问性，此时的 Derived 用户都可以使用 size，而只有 Derived 的派生类才可以使用 n using 声明控制的访问权限仅由声明语句前面的访问说明符决定 默认的继承保护级别默认情况下，class 关键字的派生类是私有继承的，struct 关键字的派生类是公有继承的 class Base { /**/ }; struct D1 : Base { /**/ }; //默认public继承 class D2 : Base { /**/ }; //默认private继承 struct 和 class 关键字唯一区别就是默认成员访问说明符默认派生访问说明符的区别 一个私有派生的类最好显示的声明 private，不要仅仅依赖默认设置 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:5:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#友元和继承"},{"categories":["C++"],"content":"15.5 访问控制与继承每个类分别控制自己成员初始化过程，每个类还控制着其成员对于派生类来说是否可访问 受保护的成员protected 关键字可以控制那些它希望与派生类分享但是不想和其他公共访问使用的成员 和私有成员类似，受保护的成员对于类的用户是不可访问的 和公有成员类型，受保护的成员对于派生类和友元是可访问的 派生类的成员或友元只能通过派生类对象来访问基类中受保护的成员 派生类对于基类对象中受保护成员没有任何访问权限 class Base { protected: int prot_mem; }; class Sneaky : public Base { friend void clobber(Sneaky\u0026);//能访问Sneaky::prot_mem friend void clobber(Base\u0026*); //不能访问Base::prot_mem int j; //默认为private }; //正确：可以访问Sneaky对象的private和protected成员 void clobber(Sneaky \u0026s) { s.j = s.prot_mem = 0; } //错误：不能访问Base中的protected成员 void clobber(Base \u0026b) { b.prot_mem = 0; } 上面的最后一条的含义是一个派生类成员和友元只能访问派生类继承过来属于基类那部分的受保护成员（这些成员，派生类自己本身也有，成员和友元可以访问自己本身的受保护的成员），而不能直接访问基类对象中的受保护成员 公共、私有和受保护继承类对继承而来的成员的访问权限受到两个因素影响：一是基类在该成员的访问说明符，二是派生类的派生列表中的访问说明符 class Base { public: void pub_mem(); protected: int prot_mem; private: char priv_mem; }; struct Pub_Derv : public Base { //正确：派生类能访问protected成员 int f() { return prot_mem; } //错误：派生类不能访问private成员 char g() { return priv_mem; } }; struct Priv_Derv : private Base { //private不影响派生类访问权限 int f1() const { return prot_mem; } }; 派生类访问说明符对于派生类的成员能否访问直接基类的成员没有什么影响，如上 Pub_Derv 和 Priv_Derv 都可以访问基类 Base 中的 prot_mem 派生类访问说明符是控制派生类用户（包括派生类的派生类）对于基类成员的访问权限，相当于将基类成员定义为相应的访问说明符 Pub_Derv d1; Priv_Derv d2; d1.pub_mem(); //正确：pub_mem在派生类中是public的 d2.pub_mem(); //错误：pub_mem在派生类中是protected的 此时在 Priv_Derv 中基类的成员被定义为 private 的了，这样它创建的对象就不可以直接访问 派生类向基类转换的可访问性派生类向基类的转换是否可访问由使用该转换的代码决定，同时派牛类的派生访问说明符也会有影响。假定D 继承自B :· 只有当 D 公有地继承 B 时，用户代码才能使用派生类向基类的转换；如果 D 继承 B 的方式是受保护的或者私有的，则用户代码不能使用该转换。 不论 D 以什么方式继承B , D 的成员函数和友元都能使用派生类向基类的转换： 派生类向其直接基类的类型转换对千派牛类的成员和友元来说水远是可访问的。 如果 D 继承 B 的方式是公有的或者受保护的，则 D 的派生类的成员和友元可以使用 D 向 B 的类型转换； 反之，如果 D 继承 B 的方式是私有的，则不能使用。 友元和继承友元关系不能传递，也不能继承，基类的友元在访问派生类成员时不具有特殊性 class Base { friend class Pal; protected: int prot_mem; }; class Sneaky : public Base { friend void clobber(Sneaky\u0026);//能访问Sneaky::prot_mem friend void clobber(Base\u0026*); //不能访问Base::prot_mem int j; //默认为private }; class Pal { public: int f(Base b) { return b.prot_mem; } //正确：Pal是Base友元 int f(Sneaky s) { return s.j; } //错误：Pal不是Sneaky友元 int f3(Sneaky s) { return s.prot_mem; }//正确：Pal是Base友元 } f3 访问了派生类中基类部分的成员，Pal 是基类的友元，Pal 能够访问 Base 对象的成员 友元只对做出声明的类有效，而友元的基类或派生类不具有特殊访问能力 class D2 : public Pal { public: int mem(Base b) { return b.prot_mem; } //错误友元不能继承 } 改变个别成员的可访问性如果需要改变派生类继承的某个名字的访问性，可以使用 using 声明达到这个目的 class Base { public: std::size_t size() cont { return n; } protected: std::size_t n; }; class Dervied : private Base { public: using Base::size; protected: using Base::n; }; Derived 为私有继承，继承的size 和 n 默认情况下是 Derived 的私有成员，使用 using 声明语句，可以改变这个成员的可访问性，此时的 Derived 用户都可以使用 size，而只有 Derived 的派生类才可以使用 n using 声明控制的访问权限仅由声明语句前面的访问说明符决定 默认的继承保护级别默认情况下，class 关键字的派生类是私有继承的，struct 关键字的派生类是公有继承的 class Base { /**/ }; struct D1 : Base { /**/ }; //默认public继承 class D2 : Base { /**/ }; //默认private继承 struct 和 class 关键字唯一区别就是默认成员访问说明符默认派生访问说明符的区别 一个私有派生的类最好显示的声明 private，不要仅仅依赖默认设置 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:5:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#改变个别成员的可访问性"},{"categories":["C++"],"content":"15.5 访问控制与继承每个类分别控制自己成员初始化过程，每个类还控制着其成员对于派生类来说是否可访问 受保护的成员protected 关键字可以控制那些它希望与派生类分享但是不想和其他公共访问使用的成员 和私有成员类似，受保护的成员对于类的用户是不可访问的 和公有成员类型，受保护的成员对于派生类和友元是可访问的 派生类的成员或友元只能通过派生类对象来访问基类中受保护的成员 派生类对于基类对象中受保护成员没有任何访问权限 class Base { protected: int prot_mem; }; class Sneaky : public Base { friend void clobber(Sneaky\u0026);//能访问Sneaky::prot_mem friend void clobber(Base\u0026*); //不能访问Base::prot_mem int j; //默认为private }; //正确：可以访问Sneaky对象的private和protected成员 void clobber(Sneaky \u0026s) { s.j = s.prot_mem = 0; } //错误：不能访问Base中的protected成员 void clobber(Base \u0026b) { b.prot_mem = 0; } 上面的最后一条的含义是一个派生类成员和友元只能访问派生类继承过来属于基类那部分的受保护成员（这些成员，派生类自己本身也有，成员和友元可以访问自己本身的受保护的成员），而不能直接访问基类对象中的受保护成员 公共、私有和受保护继承类对继承而来的成员的访问权限受到两个因素影响：一是基类在该成员的访问说明符，二是派生类的派生列表中的访问说明符 class Base { public: void pub_mem(); protected: int prot_mem; private: char priv_mem; }; struct Pub_Derv : public Base { //正确：派生类能访问protected成员 int f() { return prot_mem; } //错误：派生类不能访问private成员 char g() { return priv_mem; } }; struct Priv_Derv : private Base { //private不影响派生类访问权限 int f1() const { return prot_mem; } }; 派生类访问说明符对于派生类的成员能否访问直接基类的成员没有什么影响，如上 Pub_Derv 和 Priv_Derv 都可以访问基类 Base 中的 prot_mem 派生类访问说明符是控制派生类用户（包括派生类的派生类）对于基类成员的访问权限，相当于将基类成员定义为相应的访问说明符 Pub_Derv d1; Priv_Derv d2; d1.pub_mem(); //正确：pub_mem在派生类中是public的 d2.pub_mem(); //错误：pub_mem在派生类中是protected的 此时在 Priv_Derv 中基类的成员被定义为 private 的了，这样它创建的对象就不可以直接访问 派生类向基类转换的可访问性派生类向基类的转换是否可访问由使用该转换的代码决定，同时派牛类的派生访问说明符也会有影响。假定D 继承自B :· 只有当 D 公有地继承 B 时，用户代码才能使用派生类向基类的转换；如果 D 继承 B 的方式是受保护的或者私有的，则用户代码不能使用该转换。 不论 D 以什么方式继承B , D 的成员函数和友元都能使用派生类向基类的转换： 派生类向其直接基类的类型转换对千派牛类的成员和友元来说水远是可访问的。 如果 D 继承 B 的方式是公有的或者受保护的，则 D 的派生类的成员和友元可以使用 D 向 B 的类型转换； 反之，如果 D 继承 B 的方式是私有的，则不能使用。 友元和继承友元关系不能传递，也不能继承，基类的友元在访问派生类成员时不具有特殊性 class Base { friend class Pal; protected: int prot_mem; }; class Sneaky : public Base { friend void clobber(Sneaky\u0026);//能访问Sneaky::prot_mem friend void clobber(Base\u0026*); //不能访问Base::prot_mem int j; //默认为private }; class Pal { public: int f(Base b) { return b.prot_mem; } //正确：Pal是Base友元 int f(Sneaky s) { return s.j; } //错误：Pal不是Sneaky友元 int f3(Sneaky s) { return s.prot_mem; }//正确：Pal是Base友元 } f3 访问了派生类中基类部分的成员，Pal 是基类的友元，Pal 能够访问 Base 对象的成员 友元只对做出声明的类有效，而友元的基类或派生类不具有特殊访问能力 class D2 : public Pal { public: int mem(Base b) { return b.prot_mem; } //错误友元不能继承 } 改变个别成员的可访问性如果需要改变派生类继承的某个名字的访问性，可以使用 using 声明达到这个目的 class Base { public: std::size_t size() cont { return n; } protected: std::size_t n; }; class Dervied : private Base { public: using Base::size; protected: using Base::n; }; Derived 为私有继承，继承的size 和 n 默认情况下是 Derived 的私有成员，使用 using 声明语句，可以改变这个成员的可访问性，此时的 Derived 用户都可以使用 size，而只有 Derived 的派生类才可以使用 n using 声明控制的访问权限仅由声明语句前面的访问说明符决定 默认的继承保护级别默认情况下，class 关键字的派生类是私有继承的，struct 关键字的派生类是公有继承的 class Base { /**/ }; struct D1 : Base { /**/ }; //默认public继承 class D2 : Base { /**/ }; //默认private继承 struct 和 class 关键字唯一区别就是默认成员访问说明符默认派生访问说明符的区别 一个私有派生的类最好显示的声明 private，不要仅仅依赖默认设置 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:5:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#默认的继承保护级别"},{"categories":["C++"],"content":"15.6 继承中的类作用域每个类定义自己的作用域，在这个作用域类定义类的成员 存在继承关系时，派生类的作用域嵌套在基类作用域之内，当一个名字在派生类的作用域无法解析，编译器会继续在外层的基类作用域中寻找改名字的含义 Bulk_quote bulk; cout \u003c\u003c bulk.isbn(); 名字 isbn 解析过程如下： 我们通过 Bulk_quote 对象调用 isbn 的，首先在 Bulk_quote 中查找，没有找到 isbn Bulk_quote 由 Disc_quote 派生而来，记下来在 Disc_quote 中查找，仍然找不到 Disc_quote 由 Quote 派生而来，接着在 Quote 中查找，此时找到了 isbn，最终被解析为 Quote 中的 isbn 在编译时进行名字查找一个对象、引用或指针的静态类型决定了对象哪些成员是可见的，静态类型和动态类型可能不一样，但是能使用哪些成员依然由静态类型决定 我们在 Disc_quote 中添加一个新成员 class Disc_quote : public Quote { public: std::pair\u003csize_t, double\u003e discount_policy() const { return {quantity, discount}; } //其他成员与前面一致 } 我们只能通过 Disc_quote 及派生类对象、引用或指针使用 discount_policy Bulk_quote bulk; Bulk_quote *bulkPtr = \u0026bulk; Quote *itemPtr = \u0026bulk; bulkPtr-\u003ediscount_policy();//正确：bulkPtr类型为Bulk_quote* itemPtr-\u003ediscount_policy();//错误：itemPtr类型为Quote* 名字冲突与继承和其他作用域一样，派生类也能重用定义在基类中的名字，此时定义在内层作用域（即派生类）的名字将隐藏定义在外层作用域（即基类）的名字 可以通过作用域运算符来使用一个被隐藏的基类成员 名字查找先于类型检查声明在内层作用域的函数并不会重载声明在外层作用域的函数，定义在派生类中的函数也不会重载基类中的成员 如果派生类和基类某个成员同名，派生类将在其作用域内隐藏该基类成员，即使形参列表不一样，基类成员仍然会被隐藏 struct Base { int memfcn(); }; struct Derived : Base { int memfcn(int);//隐藏基类的memfcn }; Derived d; Base b; b.memfcn(); //调用 Base::memfcn d.memfcn(10); //调用 Derived::memfcn d.memfcn(); //错误：基类memfcn被隐藏了 d.Base::memfcn(); //正确：调用Base::memfcn 虚函数和作用域15.3说到基类和派生类的虚函数必须有相同的形参列表，如果基类和派生类虚函数接受实参不一样，无法通过基类的引用或指针调用派生类的虚函数 class Base { public: virtual int fcn(); }; class D1 : public Base { public: //隐藏了基类的fcn，这个fcn不是虚函数 //D1继承了Base::fcn()定义 int fcn(int); virtual void f2(); }； class D2 : public D1 { public: int fcn(int);//非虚函数，隐藏了D1::fcn(int) int fcn(); //覆盖了Base的虚函数fcn void f2(); //覆盖了D1虚函数f2 } 下面是使用几种函数的方法 Base bobj; D1 d1obj; D2 d2obj; Base *bp1 = \u0026bobj, *bp2 = \u0026d1obj, *bp3 = \u0026d2obj; bp1-\u003efcn(); //虚调用，运行时调用Base::fcn bp2-\u003efcn(); //虚调用，运行时调用Base::fcn bp3-\u003efcn(); //需调用，运行时调用D2::fcn D1 *d1p = \u0026d1obj; D2 *d2p = \u0026d2obj; bp2-\u003ef2(); //错误：Base没有名为f2成员 d1p-\u003ef2(); //虚调用，运行时调用D1::f2() d2p-\u003ef2(); //虚调用，运行时调用D2::f2() Base *p1 = \u0026d2obj; D1 *p2 = \u0026d2obj; D2 *p3 = \u0026d2obj; p1-\u003efcn(42); //错误，Base中没有fcn(int)函数 p2-\u003efcn(42); //静态绑定，调用D1::fcn(int) p3-\u003efcn(42); //静态绑定，调用D2::fcn(int) 覆盖重载的函数成员函数无论是否为虚函数都能被重载，如果派生类希望所有的重载版本对于它都是可见的，那么它就需要覆盖所有的版本，或者一个都不覆盖 如果只需要覆盖其中一些函数，但是不得不自己重新定义覆盖基类的每一个版本，否则未重新定义的函数会被隐藏 通过使用 using 声明，就无须覆盖所有版本。using 声明语句指定一个名字而不指定形参列表，所有一条基类成员函数的 using 声明语句就可以把该函数所有重载实例添加到派生类作用域中。此时派生类只需要定义特有的函数就行了 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:6:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#156-继承中的类作用域"},{"categories":["C++"],"content":"15.6 继承中的类作用域每个类定义自己的作用域，在这个作用域类定义类的成员 存在继承关系时，派生类的作用域嵌套在基类作用域之内，当一个名字在派生类的作用域无法解析，编译器会继续在外层的基类作用域中寻找改名字的含义 Bulk_quote bulk; cout discount_policy() const { return {quantity, discount}; } //其他成员与前面一致 } 我们只能通过 Disc_quote 及派生类对象、引用或指针使用 discount_policy Bulk_quote bulk; Bulk_quote *bulkPtr = \u0026bulk; Quote *itemPtr = \u0026bulk; bulkPtr-discount_policy();//正确：bulkPtr类型为Bulk_quote* itemPtr-discount_policy();//错误：itemPtr类型为Quote* 名字冲突与继承和其他作用域一样，派生类也能重用定义在基类中的名字，此时定义在内层作用域（即派生类）的名字将隐藏定义在外层作用域（即基类）的名字 可以通过作用域运算符来使用一个被隐藏的基类成员 名字查找先于类型检查声明在内层作用域的函数并不会重载声明在外层作用域的函数，定义在派生类中的函数也不会重载基类中的成员 如果派生类和基类某个成员同名，派生类将在其作用域内隐藏该基类成员，即使形参列表不一样，基类成员仍然会被隐藏 struct Base { int memfcn(); }; struct Derived : Base { int memfcn(int);//隐藏基类的memfcn }; Derived d; Base b; b.memfcn(); //调用 Base::memfcn d.memfcn(10); //调用 Derived::memfcn d.memfcn(); //错误：基类memfcn被隐藏了 d.Base::memfcn(); //正确：调用Base::memfcn 虚函数和作用域15.3说到基类和派生类的虚函数必须有相同的形参列表，如果基类和派生类虚函数接受实参不一样，无法通过基类的引用或指针调用派生类的虚函数 class Base { public: virtual int fcn(); }; class D1 : public Base { public: //隐藏了基类的fcn，这个fcn不是虚函数 //D1继承了Base::fcn()定义 int fcn(int); virtual void f2(); }； class D2 : public D1 { public: int fcn(int);//非虚函数，隐藏了D1::fcn(int) int fcn(); //覆盖了Base的虚函数fcn void f2(); //覆盖了D1虚函数f2 } 下面是使用几种函数的方法 Base bobj; D1 d1obj; D2 d2obj; Base *bp1 = \u0026bobj, *bp2 = \u0026d1obj, *bp3 = \u0026d2obj; bp1-fcn(); //虚调用，运行时调用Base::fcn bp2-fcn(); //虚调用，运行时调用Base::fcn bp3-fcn(); //需调用，运行时调用D2::fcn D1 *d1p = \u0026d1obj; D2 *d2p = \u0026d2obj; bp2-f2(); //错误：Base没有名为f2成员 d1p-f2(); //虚调用，运行时调用D1::f2() d2p-f2(); //虚调用，运行时调用D2::f2() Base *p1 = \u0026d2obj; D1 *p2 = \u0026d2obj; D2 *p3 = \u0026d2obj; p1-fcn(42); //错误，Base中没有fcn(int)函数 p2-fcn(42); //静态绑定，调用D1::fcn(int) p3-fcn(42); //静态绑定，调用D2::fcn(int) 覆盖重载的函数成员函数无论是否为虚函数都能被重载，如果派生类希望所有的重载版本对于它都是可见的，那么它就需要覆盖所有的版本，或者一个都不覆盖 如果只需要覆盖其中一些函数，但是不得不自己重新定义覆盖基类的每一个版本，否则未重新定义的函数会被隐藏 通过使用 using 声明，就无须覆盖所有版本。using 声明语句指定一个名字而不指定形参列表，所有一条基类成员函数的 using 声明语句就可以把该函数所有重载实例添加到派生类作用域中。此时派生类只需要定义特有的函数就行了 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:6:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#在编译时进行名字查找"},{"categories":["C++"],"content":"15.6 继承中的类作用域每个类定义自己的作用域，在这个作用域类定义类的成员 存在继承关系时，派生类的作用域嵌套在基类作用域之内，当一个名字在派生类的作用域无法解析，编译器会继续在外层的基类作用域中寻找改名字的含义 Bulk_quote bulk; cout discount_policy() const { return {quantity, discount}; } //其他成员与前面一致 } 我们只能通过 Disc_quote 及派生类对象、引用或指针使用 discount_policy Bulk_quote bulk; Bulk_quote *bulkPtr = \u0026bulk; Quote *itemPtr = \u0026bulk; bulkPtr-discount_policy();//正确：bulkPtr类型为Bulk_quote* itemPtr-discount_policy();//错误：itemPtr类型为Quote* 名字冲突与继承和其他作用域一样，派生类也能重用定义在基类中的名字，此时定义在内层作用域（即派生类）的名字将隐藏定义在外层作用域（即基类）的名字 可以通过作用域运算符来使用一个被隐藏的基类成员 名字查找先于类型检查声明在内层作用域的函数并不会重载声明在外层作用域的函数，定义在派生类中的函数也不会重载基类中的成员 如果派生类和基类某个成员同名，派生类将在其作用域内隐藏该基类成员，即使形参列表不一样，基类成员仍然会被隐藏 struct Base { int memfcn(); }; struct Derived : Base { int memfcn(int);//隐藏基类的memfcn }; Derived d; Base b; b.memfcn(); //调用 Base::memfcn d.memfcn(10); //调用 Derived::memfcn d.memfcn(); //错误：基类memfcn被隐藏了 d.Base::memfcn(); //正确：调用Base::memfcn 虚函数和作用域15.3说到基类和派生类的虚函数必须有相同的形参列表，如果基类和派生类虚函数接受实参不一样，无法通过基类的引用或指针调用派生类的虚函数 class Base { public: virtual int fcn(); }; class D1 : public Base { public: //隐藏了基类的fcn，这个fcn不是虚函数 //D1继承了Base::fcn()定义 int fcn(int); virtual void f2(); }； class D2 : public D1 { public: int fcn(int);//非虚函数，隐藏了D1::fcn(int) int fcn(); //覆盖了Base的虚函数fcn void f2(); //覆盖了D1虚函数f2 } 下面是使用几种函数的方法 Base bobj; D1 d1obj; D2 d2obj; Base *bp1 = \u0026bobj, *bp2 = \u0026d1obj, *bp3 = \u0026d2obj; bp1-fcn(); //虚调用，运行时调用Base::fcn bp2-fcn(); //虚调用，运行时调用Base::fcn bp3-fcn(); //需调用，运行时调用D2::fcn D1 *d1p = \u0026d1obj; D2 *d2p = \u0026d2obj; bp2-f2(); //错误：Base没有名为f2成员 d1p-f2(); //虚调用，运行时调用D1::f2() d2p-f2(); //虚调用，运行时调用D2::f2() Base *p1 = \u0026d2obj; D1 *p2 = \u0026d2obj; D2 *p3 = \u0026d2obj; p1-fcn(42); //错误，Base中没有fcn(int)函数 p2-fcn(42); //静态绑定，调用D1::fcn(int) p3-fcn(42); //静态绑定，调用D2::fcn(int) 覆盖重载的函数成员函数无论是否为虚函数都能被重载，如果派生类希望所有的重载版本对于它都是可见的，那么它就需要覆盖所有的版本，或者一个都不覆盖 如果只需要覆盖其中一些函数，但是不得不自己重新定义覆盖基类的每一个版本，否则未重新定义的函数会被隐藏 通过使用 using 声明，就无须覆盖所有版本。using 声明语句指定一个名字而不指定形参列表，所有一条基类成员函数的 using 声明语句就可以把该函数所有重载实例添加到派生类作用域中。此时派生类只需要定义特有的函数就行了 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:6:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#名字冲突与继承"},{"categories":["C++"],"content":"15.6 继承中的类作用域每个类定义自己的作用域，在这个作用域类定义类的成员 存在继承关系时，派生类的作用域嵌套在基类作用域之内，当一个名字在派生类的作用域无法解析，编译器会继续在外层的基类作用域中寻找改名字的含义 Bulk_quote bulk; cout discount_policy() const { return {quantity, discount}; } //其他成员与前面一致 } 我们只能通过 Disc_quote 及派生类对象、引用或指针使用 discount_policy Bulk_quote bulk; Bulk_quote *bulkPtr = \u0026bulk; Quote *itemPtr = \u0026bulk; bulkPtr-discount_policy();//正确：bulkPtr类型为Bulk_quote* itemPtr-discount_policy();//错误：itemPtr类型为Quote* 名字冲突与继承和其他作用域一样，派生类也能重用定义在基类中的名字，此时定义在内层作用域（即派生类）的名字将隐藏定义在外层作用域（即基类）的名字 可以通过作用域运算符来使用一个被隐藏的基类成员 名字查找先于类型检查声明在内层作用域的函数并不会重载声明在外层作用域的函数，定义在派生类中的函数也不会重载基类中的成员 如果派生类和基类某个成员同名，派生类将在其作用域内隐藏该基类成员，即使形参列表不一样，基类成员仍然会被隐藏 struct Base { int memfcn(); }; struct Derived : Base { int memfcn(int);//隐藏基类的memfcn }; Derived d; Base b; b.memfcn(); //调用 Base::memfcn d.memfcn(10); //调用 Derived::memfcn d.memfcn(); //错误：基类memfcn被隐藏了 d.Base::memfcn(); //正确：调用Base::memfcn 虚函数和作用域15.3说到基类和派生类的虚函数必须有相同的形参列表，如果基类和派生类虚函数接受实参不一样，无法通过基类的引用或指针调用派生类的虚函数 class Base { public: virtual int fcn(); }; class D1 : public Base { public: //隐藏了基类的fcn，这个fcn不是虚函数 //D1继承了Base::fcn()定义 int fcn(int); virtual void f2(); }； class D2 : public D1 { public: int fcn(int);//非虚函数，隐藏了D1::fcn(int) int fcn(); //覆盖了Base的虚函数fcn void f2(); //覆盖了D1虚函数f2 } 下面是使用几种函数的方法 Base bobj; D1 d1obj; D2 d2obj; Base *bp1 = \u0026bobj, *bp2 = \u0026d1obj, *bp3 = \u0026d2obj; bp1-fcn(); //虚调用，运行时调用Base::fcn bp2-fcn(); //虚调用，运行时调用Base::fcn bp3-fcn(); //需调用，运行时调用D2::fcn D1 *d1p = \u0026d1obj; D2 *d2p = \u0026d2obj; bp2-f2(); //错误：Base没有名为f2成员 d1p-f2(); //虚调用，运行时调用D1::f2() d2p-f2(); //虚调用，运行时调用D2::f2() Base *p1 = \u0026d2obj; D1 *p2 = \u0026d2obj; D2 *p3 = \u0026d2obj; p1-fcn(42); //错误，Base中没有fcn(int)函数 p2-fcn(42); //静态绑定，调用D1::fcn(int) p3-fcn(42); //静态绑定，调用D2::fcn(int) 覆盖重载的函数成员函数无论是否为虚函数都能被重载，如果派生类希望所有的重载版本对于它都是可见的，那么它就需要覆盖所有的版本，或者一个都不覆盖 如果只需要覆盖其中一些函数，但是不得不自己重新定义覆盖基类的每一个版本，否则未重新定义的函数会被隐藏 通过使用 using 声明，就无须覆盖所有版本。using 声明语句指定一个名字而不指定形参列表，所有一条基类成员函数的 using 声明语句就可以把该函数所有重载实例添加到派生类作用域中。此时派生类只需要定义特有的函数就行了 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:6:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#名字查找先于类型检查"},{"categories":["C++"],"content":"15.6 继承中的类作用域每个类定义自己的作用域，在这个作用域类定义类的成员 存在继承关系时，派生类的作用域嵌套在基类作用域之内，当一个名字在派生类的作用域无法解析，编译器会继续在外层的基类作用域中寻找改名字的含义 Bulk_quote bulk; cout discount_policy() const { return {quantity, discount}; } //其他成员与前面一致 } 我们只能通过 Disc_quote 及派生类对象、引用或指针使用 discount_policy Bulk_quote bulk; Bulk_quote *bulkPtr = \u0026bulk; Quote *itemPtr = \u0026bulk; bulkPtr-discount_policy();//正确：bulkPtr类型为Bulk_quote* itemPtr-discount_policy();//错误：itemPtr类型为Quote* 名字冲突与继承和其他作用域一样，派生类也能重用定义在基类中的名字，此时定义在内层作用域（即派生类）的名字将隐藏定义在外层作用域（即基类）的名字 可以通过作用域运算符来使用一个被隐藏的基类成员 名字查找先于类型检查声明在内层作用域的函数并不会重载声明在外层作用域的函数，定义在派生类中的函数也不会重载基类中的成员 如果派生类和基类某个成员同名，派生类将在其作用域内隐藏该基类成员，即使形参列表不一样，基类成员仍然会被隐藏 struct Base { int memfcn(); }; struct Derived : Base { int memfcn(int);//隐藏基类的memfcn }; Derived d; Base b; b.memfcn(); //调用 Base::memfcn d.memfcn(10); //调用 Derived::memfcn d.memfcn(); //错误：基类memfcn被隐藏了 d.Base::memfcn(); //正确：调用Base::memfcn 虚函数和作用域15.3说到基类和派生类的虚函数必须有相同的形参列表，如果基类和派生类虚函数接受实参不一样，无法通过基类的引用或指针调用派生类的虚函数 class Base { public: virtual int fcn(); }; class D1 : public Base { public: //隐藏了基类的fcn，这个fcn不是虚函数 //D1继承了Base::fcn()定义 int fcn(int); virtual void f2(); }； class D2 : public D1 { public: int fcn(int);//非虚函数，隐藏了D1::fcn(int) int fcn(); //覆盖了Base的虚函数fcn void f2(); //覆盖了D1虚函数f2 } 下面是使用几种函数的方法 Base bobj; D1 d1obj; D2 d2obj; Base *bp1 = \u0026bobj, *bp2 = \u0026d1obj, *bp3 = \u0026d2obj; bp1-fcn(); //虚调用，运行时调用Base::fcn bp2-fcn(); //虚调用，运行时调用Base::fcn bp3-fcn(); //需调用，运行时调用D2::fcn D1 *d1p = \u0026d1obj; D2 *d2p = \u0026d2obj; bp2-f2(); //错误：Base没有名为f2成员 d1p-f2(); //虚调用，运行时调用D1::f2() d2p-f2(); //虚调用，运行时调用D2::f2() Base *p1 = \u0026d2obj; D1 *p2 = \u0026d2obj; D2 *p3 = \u0026d2obj; p1-fcn(42); //错误，Base中没有fcn(int)函数 p2-fcn(42); //静态绑定，调用D1::fcn(int) p3-fcn(42); //静态绑定，调用D2::fcn(int) 覆盖重载的函数成员函数无论是否为虚函数都能被重载，如果派生类希望所有的重载版本对于它都是可见的，那么它就需要覆盖所有的版本，或者一个都不覆盖 如果只需要覆盖其中一些函数，但是不得不自己重新定义覆盖基类的每一个版本，否则未重新定义的函数会被隐藏 通过使用 using 声明，就无须覆盖所有版本。using 声明语句指定一个名字而不指定形参列表，所有一条基类成员函数的 using 声明语句就可以把该函数所有重载实例添加到派生类作用域中。此时派生类只需要定义特有的函数就行了 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:6:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#虚函数和作用域"},{"categories":["C++"],"content":"15.6 继承中的类作用域每个类定义自己的作用域，在这个作用域类定义类的成员 存在继承关系时，派生类的作用域嵌套在基类作用域之内，当一个名字在派生类的作用域无法解析，编译器会继续在外层的基类作用域中寻找改名字的含义 Bulk_quote bulk; cout discount_policy() const { return {quantity, discount}; } //其他成员与前面一致 } 我们只能通过 Disc_quote 及派生类对象、引用或指针使用 discount_policy Bulk_quote bulk; Bulk_quote *bulkPtr = \u0026bulk; Quote *itemPtr = \u0026bulk; bulkPtr-discount_policy();//正确：bulkPtr类型为Bulk_quote* itemPtr-discount_policy();//错误：itemPtr类型为Quote* 名字冲突与继承和其他作用域一样，派生类也能重用定义在基类中的名字，此时定义在内层作用域（即派生类）的名字将隐藏定义在外层作用域（即基类）的名字 可以通过作用域运算符来使用一个被隐藏的基类成员 名字查找先于类型检查声明在内层作用域的函数并不会重载声明在外层作用域的函数，定义在派生类中的函数也不会重载基类中的成员 如果派生类和基类某个成员同名，派生类将在其作用域内隐藏该基类成员，即使形参列表不一样，基类成员仍然会被隐藏 struct Base { int memfcn(); }; struct Derived : Base { int memfcn(int);//隐藏基类的memfcn }; Derived d; Base b; b.memfcn(); //调用 Base::memfcn d.memfcn(10); //调用 Derived::memfcn d.memfcn(); //错误：基类memfcn被隐藏了 d.Base::memfcn(); //正确：调用Base::memfcn 虚函数和作用域15.3说到基类和派生类的虚函数必须有相同的形参列表，如果基类和派生类虚函数接受实参不一样，无法通过基类的引用或指针调用派生类的虚函数 class Base { public: virtual int fcn(); }; class D1 : public Base { public: //隐藏了基类的fcn，这个fcn不是虚函数 //D1继承了Base::fcn()定义 int fcn(int); virtual void f2(); }； class D2 : public D1 { public: int fcn(int);//非虚函数，隐藏了D1::fcn(int) int fcn(); //覆盖了Base的虚函数fcn void f2(); //覆盖了D1虚函数f2 } 下面是使用几种函数的方法 Base bobj; D1 d1obj; D2 d2obj; Base *bp1 = \u0026bobj, *bp2 = \u0026d1obj, *bp3 = \u0026d2obj; bp1-fcn(); //虚调用，运行时调用Base::fcn bp2-fcn(); //虚调用，运行时调用Base::fcn bp3-fcn(); //需调用，运行时调用D2::fcn D1 *d1p = \u0026d1obj; D2 *d2p = \u0026d2obj; bp2-f2(); //错误：Base没有名为f2成员 d1p-f2(); //虚调用，运行时调用D1::f2() d2p-f2(); //虚调用，运行时调用D2::f2() Base *p1 = \u0026d2obj; D1 *p2 = \u0026d2obj; D2 *p3 = \u0026d2obj; p1-fcn(42); //错误，Base中没有fcn(int)函数 p2-fcn(42); //静态绑定，调用D1::fcn(int) p3-fcn(42); //静态绑定，调用D2::fcn(int) 覆盖重载的函数成员函数无论是否为虚函数都能被重载，如果派生类希望所有的重载版本对于它都是可见的，那么它就需要覆盖所有的版本，或者一个都不覆盖 如果只需要覆盖其中一些函数，但是不得不自己重新定义覆盖基类的每一个版本，否则未重新定义的函数会被隐藏 通过使用 using 声明，就无须覆盖所有版本。using 声明语句指定一个名字而不指定形参列表，所有一条基类成员函数的 using 声明语句就可以把该函数所有重载实例添加到派生类作用域中。此时派生类只需要定义特有的函数就行了 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:6:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#覆盖重载的函数"},{"categories":["C++"],"content":"15.7 构造函数与拷贝控制","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:7:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#157-构造函数与拷贝控制"},{"categories":["C++"],"content":"15.7.1 虚析构函数当我们 delete 一个动态分配的对象指针时，将执行析构函数，如果指向继承体系中的某个类型，则有可能出现指针的静态类型与被删除对象动态类型不符合的情况，这样的话编译器必须确保执行正确的析构函数 通过将基类中的析构函数定义为虚函数来确保执行正确的析构函数版本 class Quote { public: //如果我们删除指向派生类对象的基类指针，需要虚析构函数 virtual ~Quote() = default; //动态绑定析构函数 } 析构函数的虚属性也会继承，基类的析构函数为虚函数就可以确保 delete 基类指针时能够调用正确的析构函数版本 Quote *itemPtr = new Quote; //静态类型与动态类型一致 delete itemPtr; //调用Quote的析构函数 itemPtr = new Bulk_Quote; //静态类型与动态类型一致 delete itemPtr; //调用Bulk_quote析构函数 如果基类的析构函数不是虚函数，则 delete 一个指向派生类对象的基类函数将产生未定义的行为 虚函数将阻止合成移动操作如果一个类定义了一个析构函数，即使通过=default 的形式使用了合成版本，编译器也不会为这个类合成移动操作 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:7:1","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#1571-虚析构函数"},{"categories":["C++"],"content":"15.7.1 虚析构函数当我们 delete 一个动态分配的对象指针时，将执行析构函数，如果指向继承体系中的某个类型，则有可能出现指针的静态类型与被删除对象动态类型不符合的情况，这样的话编译器必须确保执行正确的析构函数 通过将基类中的析构函数定义为虚函数来确保执行正确的析构函数版本 class Quote { public: //如果我们删除指向派生类对象的基类指针，需要虚析构函数 virtual ~Quote() = default; //动态绑定析构函数 } 析构函数的虚属性也会继承，基类的析构函数为虚函数就可以确保 delete 基类指针时能够调用正确的析构函数版本 Quote *itemPtr = new Quote; //静态类型与动态类型一致 delete itemPtr; //调用Quote的析构函数 itemPtr = new Bulk_Quote; //静态类型与动态类型一致 delete itemPtr; //调用Bulk_quote析构函数 如果基类的析构函数不是虚函数，则 delete 一个指向派生类对象的基类函数将产生未定义的行为 虚函数将阻止合成移动操作如果一个类定义了一个析构函数，即使通过=default 的形式使用了合成版本，编译器也不会为这个类合成移动操作 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:7:1","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#虚函数将阻止合成移动操作"},{"categories":["C++"],"content":"15.7.2 合成拷贝控制与继承基类和派生类的合成拷贝控制成员的行为与其他合成的构造函数、赋值运算符或析构函数类似，它们对类本身成员依次进行初始化、赋值和销毁操作，此外还负责对直接基类部分进行初始化、赋值、销毁的操作 这里需要注意的就是顺序问题： 对于构造函数，派生类使用合成的构造函数时，会自动先调用直接基类的构造函数，然后再初始化自己的成员，直接基类又会进一步调用基类的构造函数 构造函数整体的表现为，先初始化基类成员-\u003e初始化直接基类-\u003e派生类 对于析构函数，合成的析构函数体是空的，隐式的析构部分负责销毁类的成员，对于派生类的析构函数来说，除了销毁自己的成员外，还负责销毁派生类的直接基类，依次进行 整体表现为，先调用派生类析构函数-\u003e直接基类析构函数-\u003e基类析构函数 派生类中删除的拷贝控制和基类的关系 如果基类拷贝控制成员是被删除的或者不可访问，派生类中对于的成员也是被删除的 如果基类中有一个不可访问或删除的析构函数，派生类中合成的默认和拷贝构造函数是删除的，因为编译器无法销毁派生类对象中基类部分 class B { public: B() {} B(const B\u0026) = delete; //其他成员，无移动构造函数 }; class D : public B { //没有声明任何构造函数 }; D d; //正确：D合成默认构造函数使用B默认构造函数 D d2(d); //错误：D合成拷贝构造函数是删除的 D d3(std::move(d)); //错误：隐式使用D被删除的拷贝构造函数 如果基类中没有默认、拷贝或移动构造函数，一般情况下派生类也不会定义相应的操作 移动操作和继承大多数基类会定义一个虚析构函数，默认情况下，基类不含有合成的移动操作，派生类也没有 如果需要移动操作，首先应该在基类中进行定义，可以使用合成的版本，但是要显示的定义，一旦定义移动操作，还有同时定义拷贝操作（3/5准则） class Quote { public: Quote() = default; Quote(const Quote\u0026) = default; Quote(Quote\u0026\u0026) = default; Quote\u0026 operator=(const Quote\u0026) = default; Quote\u0026 operator=(Quote\u0026\u0026) = default; virtual ~Quote() = default; }; ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:8:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#1572-合成拷贝控制与继承"},{"categories":["C++"],"content":"15.7.2 合成拷贝控制与继承基类和派生类的合成拷贝控制成员的行为与其他合成的构造函数、赋值运算符或析构函数类似，它们对类本身成员依次进行初始化、赋值和销毁操作，此外还负责对直接基类部分进行初始化、赋值、销毁的操作 这里需要注意的就是顺序问题： 对于构造函数，派生类使用合成的构造函数时，会自动先调用直接基类的构造函数，然后再初始化自己的成员，直接基类又会进一步调用基类的构造函数 构造函数整体的表现为，先初始化基类成员-初始化直接基类-派生类 对于析构函数，合成的析构函数体是空的，隐式的析构部分负责销毁类的成员，对于派生类的析构函数来说，除了销毁自己的成员外，还负责销毁派生类的直接基类，依次进行 整体表现为，先调用派生类析构函数-直接基类析构函数-基类析构函数 派生类中删除的拷贝控制和基类的关系 如果基类拷贝控制成员是被删除的或者不可访问，派生类中对于的成员也是被删除的 如果基类中有一个不可访问或删除的析构函数，派生类中合成的默认和拷贝构造函数是删除的，因为编译器无法销毁派生类对象中基类部分 class B { public: B() {} B(const B\u0026) = delete; //其他成员，无移动构造函数 }; class D : public B { //没有声明任何构造函数 }; D d; //正确：D合成默认构造函数使用B默认构造函数 D d2(d); //错误：D合成拷贝构造函数是删除的 D d3(std::move(d)); //错误：隐式使用D被删除的拷贝构造函数 如果基类中没有默认、拷贝或移动构造函数，一般情况下派生类也不会定义相应的操作 移动操作和继承大多数基类会定义一个虚析构函数，默认情况下，基类不含有合成的移动操作，派生类也没有 如果需要移动操作，首先应该在基类中进行定义，可以使用合成的版本，但是要显示的定义，一旦定义移动操作，还有同时定义拷贝操作（3/5准则） class Quote { public: Quote() = default; Quote(const Quote\u0026) = default; Quote(Quote\u0026\u0026) = default; Quote\u0026 operator=(const Quote\u0026) = default; Quote\u0026 operator=(Quote\u0026\u0026) = default; virtual ~Quote() = default; }; ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:8:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#派生类中删除的拷贝控制和基类的关系"},{"categories":["C++"],"content":"15.7.2 合成拷贝控制与继承基类和派生类的合成拷贝控制成员的行为与其他合成的构造函数、赋值运算符或析构函数类似，它们对类本身成员依次进行初始化、赋值和销毁操作，此外还负责对直接基类部分进行初始化、赋值、销毁的操作 这里需要注意的就是顺序问题： 对于构造函数，派生类使用合成的构造函数时，会自动先调用直接基类的构造函数，然后再初始化自己的成员，直接基类又会进一步调用基类的构造函数 构造函数整体的表现为，先初始化基类成员-初始化直接基类-派生类 对于析构函数，合成的析构函数体是空的，隐式的析构部分负责销毁类的成员，对于派生类的析构函数来说，除了销毁自己的成员外，还负责销毁派生类的直接基类，依次进行 整体表现为，先调用派生类析构函数-直接基类析构函数-基类析构函数 派生类中删除的拷贝控制和基类的关系 如果基类拷贝控制成员是被删除的或者不可访问，派生类中对于的成员也是被删除的 如果基类中有一个不可访问或删除的析构函数，派生类中合成的默认和拷贝构造函数是删除的，因为编译器无法销毁派生类对象中基类部分 class B { public: B() {} B(const B\u0026) = delete; //其他成员，无移动构造函数 }; class D : public B { //没有声明任何构造函数 }; D d; //正确：D合成默认构造函数使用B默认构造函数 D d2(d); //错误：D合成拷贝构造函数是删除的 D d3(std::move(d)); //错误：隐式使用D被删除的拷贝构造函数 如果基类中没有默认、拷贝或移动构造函数，一般情况下派生类也不会定义相应的操作 移动操作和继承大多数基类会定义一个虚析构函数，默认情况下，基类不含有合成的移动操作，派生类也没有 如果需要移动操作，首先应该在基类中进行定义，可以使用合成的版本，但是要显示的定义，一旦定义移动操作，还有同时定义拷贝操作（3/5准则） class Quote { public: Quote() = default; Quote(const Quote\u0026) = default; Quote(Quote\u0026\u0026) = default; Quote\u0026 operator=(const Quote\u0026) = default; Quote\u0026 operator=(Quote\u0026\u0026) = default; virtual ~Quote() = default; }; ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:8:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#移动操作和继承"},{"categories":["C++"],"content":"15.7.3 派生类的拷贝控制成员 派生类构造函数初始化阶段不仅需要初始化派生类自己的成员，还负责初始化派生类对象中基类部分 派生类的拷贝、移动构造函数、赋值运算符也类似，拷贝移动赋值派生类成员的同时，也要对基类部分进行相同的操作 而析构函数只负责销毁派生类自己分配的资源，派生类中基类部分是自动销毁的 定义派生类的拷贝或移动构造函数 class Base { /***/ }; class D : public Base { public: D(const D\u0026 d) : Base(d) //拷贝基类成员 /*D的成员初始值*/ {/**/} D(D\u0026\u0026 d) : Base(std::move(d)) //移动基类成员 /*D的成员初始值*/ {/**/} }; 初始值 Base(d) 将一个 D 对象传递给基类构造函数，值得注意的是，这里传给基类拷贝构造函数是一个 D 对象，它会自动匹配 Base 中的拷贝构造函数 如果没有提供基类初始值的话，基类部分被默认初始化，而不是从其他对象拷贝而来 //D这个拷贝构造函数很可能是不正确的定义 //基类部分被默认初始化，而非拷贝 D(const D\u0026 d) /*成员初始值，但是没有提供基类初始值*/ {/**/} 派生类赋值运算符和拷贝移动构造函数一样，赋值运算符也必须显示为基类部分进行赋值 D \u0026D::operator=(const D \u0026rhs) { Base::operator=(rhs); //D的其他成员赋值 //酌情使用自赋值和释放已有资源 return *this; } 派生类析构函数派生类析构函数只负责销毁派生类自己分配的资源 class D : public B { public: //Base::~Base()被自动执行 ~D() { /*销毁D分配的资源*/} } 构造函数和析构函数中调用虚函数书上这里写的有点绕，我的理解就是： 在基类的构造或析构函数中调用虚函数时，执行的版本时基类的虚函数版本 在派生类的构造或析构函数中调用虚函数时，执行的是派生类的虚函数版本 我自己也写了下面的代码进行了测试，确实是这样： #include \u003ciostream\u003eusing namespace std; class Base { public: Base() { cout \u003c\u003c \"Base default constructor\" \u003c\u003c endl; } Base(int n) : num(n) { cout \u003c\u003c \"Base constructor\" \u003c\u003c endl; print_num(); } virtual void print_num() { cout \u003c\u003c \"this is a base virtual, num = \"; cout \u003c\u003c num \u003c\u003c endl; } ~Base() { cout \u003c\u003c \"this is a Base destructor\" \u003c\u003c endl; print_num(); } protected: int num; }; class Derived : public Base { public: Derived(int n) :Base(n) { print_num(); cnt = n / 2; } void print_num() override { cout \u003c\u003c \"this is a derived virtual, num = \" \u003c\u003c num \u003c\u003c endl; cout \u003c\u003c \"cnt is \" \u003c\u003c cnt \u003c\u003c endl; } ~Derived() { cout \u003c\u003c \"this is a Derived destructor\" \u003c\u003c endl; print_num(); } private: int cnt; }; int main() { Derived *p = new Derived(10); cout \u003c\u003c \"===========\" \u003c\u003c endl; delete p; return 0; } /*打印结果，先执行了构造函数的调用，然后是析构函数的调用 silas@Silas-PC:~/cpp$ g++ construct_virtual.cpp \u0026\u0026 ./a.out Base constructor this is a base virtual, num = 10 this is a derived virtual, num = 10 cnt is 0 =========== this is a Derived destructor this is a derived virtual, num = 10 cnt is 5 this is a Base destructor this is a base virtual, num = 10 */ ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:8:1","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#1573-派生类的拷贝控制成员"},{"categories":["C++"],"content":"15.7.3 派生类的拷贝控制成员 派生类构造函数初始化阶段不仅需要初始化派生类自己的成员，还负责初始化派生类对象中基类部分 派生类的拷贝、移动构造函数、赋值运算符也类似，拷贝移动赋值派生类成员的同时，也要对基类部分进行相同的操作 而析构函数只负责销毁派生类自己分配的资源，派生类中基类部分是自动销毁的 定义派生类的拷贝或移动构造函数 class Base { /***/ }; class D : public Base { public: D(const D\u0026 d) : Base(d) //拷贝基类成员 /*D的成员初始值*/ {/**/} D(D\u0026\u0026 d) : Base(std::move(d)) //移动基类成员 /*D的成员初始值*/ {/**/} }; 初始值 Base(d) 将一个 D 对象传递给基类构造函数，值得注意的是，这里传给基类拷贝构造函数是一个 D 对象，它会自动匹配 Base 中的拷贝构造函数 如果没有提供基类初始值的话，基类部分被默认初始化，而不是从其他对象拷贝而来 //D这个拷贝构造函数很可能是不正确的定义 //基类部分被默认初始化，而非拷贝 D(const D\u0026 d) /*成员初始值，但是没有提供基类初始值*/ {/**/} 派生类赋值运算符和拷贝移动构造函数一样，赋值运算符也必须显示为基类部分进行赋值 D \u0026D::operator=(const D \u0026rhs) { Base::operator=(rhs); //D的其他成员赋值 //酌情使用自赋值和释放已有资源 return *this; } 派生类析构函数派生类析构函数只负责销毁派生类自己分配的资源 class D : public B { public: //Base::~Base()被自动执行 ~D() { /*销毁D分配的资源*/} } 构造函数和析构函数中调用虚函数书上这里写的有点绕，我的理解就是： 在基类的构造或析构函数中调用虚函数时，执行的版本时基类的虚函数版本 在派生类的构造或析构函数中调用虚函数时，执行的是派生类的虚函数版本 我自己也写了下面的代码进行了测试，确实是这样： #include using namespace std; class Base { public: Base() { cout ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:8:1","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#定义派生类的拷贝或移动构造函数"},{"categories":["C++"],"content":"15.7.3 派生类的拷贝控制成员 派生类构造函数初始化阶段不仅需要初始化派生类自己的成员，还负责初始化派生类对象中基类部分 派生类的拷贝、移动构造函数、赋值运算符也类似，拷贝移动赋值派生类成员的同时，也要对基类部分进行相同的操作 而析构函数只负责销毁派生类自己分配的资源，派生类中基类部分是自动销毁的 定义派生类的拷贝或移动构造函数 class Base { /***/ }; class D : public Base { public: D(const D\u0026 d) : Base(d) //拷贝基类成员 /*D的成员初始值*/ {/**/} D(D\u0026\u0026 d) : Base(std::move(d)) //移动基类成员 /*D的成员初始值*/ {/**/} }; 初始值 Base(d) 将一个 D 对象传递给基类构造函数，值得注意的是，这里传给基类拷贝构造函数是一个 D 对象，它会自动匹配 Base 中的拷贝构造函数 如果没有提供基类初始值的话，基类部分被默认初始化，而不是从其他对象拷贝而来 //D这个拷贝构造函数很可能是不正确的定义 //基类部分被默认初始化，而非拷贝 D(const D\u0026 d) /*成员初始值，但是没有提供基类初始值*/ {/**/} 派生类赋值运算符和拷贝移动构造函数一样，赋值运算符也必须显示为基类部分进行赋值 D \u0026D::operator=(const D \u0026rhs) { Base::operator=(rhs); //D的其他成员赋值 //酌情使用自赋值和释放已有资源 return *this; } 派生类析构函数派生类析构函数只负责销毁派生类自己分配的资源 class D : public B { public: //Base::~Base()被自动执行 ~D() { /*销毁D分配的资源*/} } 构造函数和析构函数中调用虚函数书上这里写的有点绕，我的理解就是： 在基类的构造或析构函数中调用虚函数时，执行的版本时基类的虚函数版本 在派生类的构造或析构函数中调用虚函数时，执行的是派生类的虚函数版本 我自己也写了下面的代码进行了测试，确实是这样： #include using namespace std; class Base { public: Base() { cout ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:8:1","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#派生类赋值运算符"},{"categories":["C++"],"content":"15.7.3 派生类的拷贝控制成员 派生类构造函数初始化阶段不仅需要初始化派生类自己的成员，还负责初始化派生类对象中基类部分 派生类的拷贝、移动构造函数、赋值运算符也类似，拷贝移动赋值派生类成员的同时，也要对基类部分进行相同的操作 而析构函数只负责销毁派生类自己分配的资源，派生类中基类部分是自动销毁的 定义派生类的拷贝或移动构造函数 class Base { /***/ }; class D : public Base { public: D(const D\u0026 d) : Base(d) //拷贝基类成员 /*D的成员初始值*/ {/**/} D(D\u0026\u0026 d) : Base(std::move(d)) //移动基类成员 /*D的成员初始值*/ {/**/} }; 初始值 Base(d) 将一个 D 对象传递给基类构造函数，值得注意的是，这里传给基类拷贝构造函数是一个 D 对象，它会自动匹配 Base 中的拷贝构造函数 如果没有提供基类初始值的话，基类部分被默认初始化，而不是从其他对象拷贝而来 //D这个拷贝构造函数很可能是不正确的定义 //基类部分被默认初始化，而非拷贝 D(const D\u0026 d) /*成员初始值，但是没有提供基类初始值*/ {/**/} 派生类赋值运算符和拷贝移动构造函数一样，赋值运算符也必须显示为基类部分进行赋值 D \u0026D::operator=(const D \u0026rhs) { Base::operator=(rhs); //D的其他成员赋值 //酌情使用自赋值和释放已有资源 return *this; } 派生类析构函数派生类析构函数只负责销毁派生类自己分配的资源 class D : public B { public: //Base::~Base()被自动执行 ~D() { /*销毁D分配的资源*/} } 构造函数和析构函数中调用虚函数书上这里写的有点绕，我的理解就是： 在基类的构造或析构函数中调用虚函数时，执行的版本时基类的虚函数版本 在派生类的构造或析构函数中调用虚函数时，执行的是派生类的虚函数版本 我自己也写了下面的代码进行了测试，确实是这样： #include using namespace std; class Base { public: Base() { cout ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:8:1","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#派生类析构函数"},{"categories":["C++"],"content":"15.7.3 派生类的拷贝控制成员 派生类构造函数初始化阶段不仅需要初始化派生类自己的成员，还负责初始化派生类对象中基类部分 派生类的拷贝、移动构造函数、赋值运算符也类似，拷贝移动赋值派生类成员的同时，也要对基类部分进行相同的操作 而析构函数只负责销毁派生类自己分配的资源，派生类中基类部分是自动销毁的 定义派生类的拷贝或移动构造函数 class Base { /***/ }; class D : public Base { public: D(const D\u0026 d) : Base(d) //拷贝基类成员 /*D的成员初始值*/ {/**/} D(D\u0026\u0026 d) : Base(std::move(d)) //移动基类成员 /*D的成员初始值*/ {/**/} }; 初始值 Base(d) 将一个 D 对象传递给基类构造函数，值得注意的是，这里传给基类拷贝构造函数是一个 D 对象，它会自动匹配 Base 中的拷贝构造函数 如果没有提供基类初始值的话，基类部分被默认初始化，而不是从其他对象拷贝而来 //D这个拷贝构造函数很可能是不正确的定义 //基类部分被默认初始化，而非拷贝 D(const D\u0026 d) /*成员初始值，但是没有提供基类初始值*/ {/**/} 派生类赋值运算符和拷贝移动构造函数一样，赋值运算符也必须显示为基类部分进行赋值 D \u0026D::operator=(const D \u0026rhs) { Base::operator=(rhs); //D的其他成员赋值 //酌情使用自赋值和释放已有资源 return *this; } 派生类析构函数派生类析构函数只负责销毁派生类自己分配的资源 class D : public B { public: //Base::~Base()被自动执行 ~D() { /*销毁D分配的资源*/} } 构造函数和析构函数中调用虚函数书上这里写的有点绕，我的理解就是： 在基类的构造或析构函数中调用虚函数时，执行的版本时基类的虚函数版本 在派生类的构造或析构函数中调用虚函数时，执行的是派生类的虚函数版本 我自己也写了下面的代码进行了测试，确实是这样： #include using namespace std; class Base { public: Base() { cout ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:8:1","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#构造函数和析构函数中调用虚函数"},{"categories":["C++"],"content":"15.7.4 继承的构造函数C++11新标准下，派生类可以重用直接基类定义的构造函数，一个类只负责初始化它的直接基类，也只继承直接基类的构造函数。 类不能继承默认、拷贝和移动构造函数，如果派生类没有直接定义这些构造函数，编译器将为派生类合成它们 派生类继承基类构造函数的方式是提供一条注明了直接基类名的 using 声明语句 class Bulk_quote : public Disc_quote { public: using Disc_quote::Disc_quote;//继承了Disc_quote构造函数 double net_price(std::size_t) const; }; using 声明语句作用在构造函数时，将令编译器产生代码，对于基类的每个构造函数，在派生类都会生成一个与之对应的构造函数，形如：derived(parms) : base(args) {} 在上面Bulk_quote 中，继承的构造函数等价于： Bulk_quote(const std::string \u0026book, double price, std::size_t qty, double disc) : Disc_quote(book, price, qty, disc) {} 如果派生类有自己的成员，这些成员将会被默认初始化 继承的构造函数特点 和普通成员 using 声明不一样，using 不会改变构造函数的访问级别，如，基类的私有构造函数在派生类中还是一个私有的构造函数 using 声明不能指定 explicit 或 constexpr，基类构造函数是 explicit 或 constexpr，派生类也是如此 基类构造函数中的默认实参不会被继承，派生类会获得多个继承的构造函数，其中每个构造函数分别省略掉一个含义默认实参的形参 如果派生类定义的构造函数和基类构造函数有相同形参列表，这些构造函数不会被继承 默认、 拷贝和移动构造函数不会被继承，这些按照正常合成规则被合成 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:8:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#1574-继承的构造函数"},{"categories":["C++"],"content":"15.7.4 继承的构造函数C++11新标准下，派生类可以重用直接基类定义的构造函数，一个类只负责初始化它的直接基类，也只继承直接基类的构造函数。 类不能继承默认、拷贝和移动构造函数，如果派生类没有直接定义这些构造函数，编译器将为派生类合成它们 派生类继承基类构造函数的方式是提供一条注明了直接基类名的 using 声明语句 class Bulk_quote : public Disc_quote { public: using Disc_quote::Disc_quote;//继承了Disc_quote构造函数 double net_price(std::size_t) const; }; using 声明语句作用在构造函数时，将令编译器产生代码，对于基类的每个构造函数，在派生类都会生成一个与之对应的构造函数，形如：derived(parms) : base(args) {} 在上面Bulk_quote 中，继承的构造函数等价于： Bulk_quote(const std::string \u0026book, double price, std::size_t qty, double disc) : Disc_quote(book, price, qty, disc) {} 如果派生类有自己的成员，这些成员将会被默认初始化 继承的构造函数特点 和普通成员 using 声明不一样，using 不会改变构造函数的访问级别，如，基类的私有构造函数在派生类中还是一个私有的构造函数 using 声明不能指定 explicit 或 constexpr，基类构造函数是 explicit 或 constexpr，派生类也是如此 基类构造函数中的默认实参不会被继承，派生类会获得多个继承的构造函数，其中每个构造函数分别省略掉一个含义默认实参的形参 如果派生类定义的构造函数和基类构造函数有相同形参列表，这些构造函数不会被继承 默认、 拷贝和移动构造函数不会被继承，这些按照正常合成规则被合成 ","date":"2022-04-28","objectID":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:8:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十五章 面向对象程序设计","uri":"/chapter15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/#继承的构造函数特点"},{"categories":["C++"],"content":"第14章 重载运算与类型转换","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:0:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#第14章-重载运算与类型转换"},{"categories":["C++"],"content":"14.1 基本概念重载的运算符是具有特殊名字的函数：它们的名字由关键字 operator 和其后要定义的运算符号共同组成。和其他函数一样，重载的运算符也包含返回类型、参数列表以及函数体。 重载运算符函数的参数数量与该作用的运算对象数量一样多，一元运算符有一个参数，二元运算符有两个参数； 二元运算符左侧运算对象传递给第一个参数，右侧对象传递给第二个对象 除了 operator() 外，其他重载运算符不能含有默认实参 如果一个重载运算符是类的成员函数时，this 会绑定到左侧运算对象，参数数量会比运算对象少一个 重载运算符函数只能是一个类的成员，或者至少有一个类类型的参数，不能对内置类型定义重载运算符 int operator+(int, int);//错误，不能重定义int的运算符 以下是可以重载或者不能重载的运算符： 重载运算符的几种调用形式： 可以间接的用运算符调用重载的运算符函数 也可以像普通函数那样直接调用 //一个非成员运算符函数的等价调用 data1 + data2; //普通表达式 operator+(data1, data2); //等价的函数调用 也可以像调用其他成员函数一样显示的调用成员运算符 data1 += data2; //基于调用的表达式 data1.operator+=(data2); //对成员运算符函数的等价调用 某些运算符不应该被重载 某些运算符会指定运算对象的求值顺序，而关于这些运算对象求值顺序的规则无法应用到重载的运算符上 像逻辑与运算符、逻辑或运算符、逗号运算符的运算对象求值顺序无法保留下来，而 \u0026\u0026 和 || 短路求值属性也无法保留 对于逗号和取地址运算符，用于类类型对象时已经定义了特殊的含义，所以不应该被重载 使用内置类型一致的含义设计一个类时，要考虑这个类提供哪些操作，然后再考虑这些操作设为普通函数还是重载的运算符。如果某些类逻辑上和运算符相关，它们适合定义成重载的运算符 如果类执行 IO 操作，定义移位运算符和内置类型的 IO 保存一致 类检查相等性操作，定义 operator=，同时也应该定义 operator!= 如果类有比较操作，例如 operator\u003c，也该也定义其他关系的操作 返回类型通常情况下要和内置返回类型兼容： 逻辑和关系运算符应该返回 bool 算术运算符应该返回类类型的值 赋值和复合运算符应该返回左侧对象的引用 选择作为成员或者非成员定义重载运算符时，首先要觉得声明为类的成员函数，还是一个普通的非成员函数，下面准则可以帮助判断： 赋值（=），下标（[]），调用（()）和成员访问箭头（-\u003e）必须时成员 复合类型一般为成员，但非必须 改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减、解引用通常为成员 具有对称性的运算符可以转换任意一端的运算对象，如算术、相等性、关系和位运算，通常位普通的非成员函数 string s = \"world\"; string t = s + \"!\"; string u = \"hi \" + s;//如果+是string成员函数，这里会报错 实际上，string 将 + 定义为了普通成员函数，\"hi \" + s 等价于 operator+=(\"hi \", s)，就没有出现问题 ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:1:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#141-基本概念"},{"categories":["C++"],"content":"14.1 基本概念重载的运算符是具有特殊名字的函数：它们的名字由关键字 operator 和其后要定义的运算符号共同组成。和其他函数一样，重载的运算符也包含返回类型、参数列表以及函数体。 重载运算符函数的参数数量与该作用的运算对象数量一样多，一元运算符有一个参数，二元运算符有两个参数； 二元运算符左侧运算对象传递给第一个参数，右侧对象传递给第二个对象 除了 operator() 外，其他重载运算符不能含有默认实参 如果一个重载运算符是类的成员函数时，this 会绑定到左侧运算对象，参数数量会比运算对象少一个 重载运算符函数只能是一个类的成员，或者至少有一个类类型的参数，不能对内置类型定义重载运算符 int operator+(int, int);//错误，不能重定义int的运算符 以下是可以重载或者不能重载的运算符： 重载运算符的几种调用形式： 可以间接的用运算符调用重载的运算符函数 也可以像普通函数那样直接调用 //一个非成员运算符函数的等价调用 data1 + data2; //普通表达式 operator+(data1, data2); //等价的函数调用 也可以像调用其他成员函数一样显示的调用成员运算符 data1 += data2; //基于调用的表达式 data1.operator+=(data2); //对成员运算符函数的等价调用 某些运算符不应该被重载 某些运算符会指定运算对象的求值顺序，而关于这些运算对象求值顺序的规则无法应用到重载的运算符上 像逻辑与运算符、逻辑或运算符、逗号运算符的运算对象求值顺序无法保留下来，而 \u0026\u0026 和 || 短路求值属性也无法保留 对于逗号和取地址运算符，用于类类型对象时已经定义了特殊的含义，所以不应该被重载 使用内置类型一致的含义设计一个类时，要考虑这个类提供哪些操作，然后再考虑这些操作设为普通函数还是重载的运算符。如果某些类逻辑上和运算符相关，它们适合定义成重载的运算符 如果类执行 IO 操作，定义移位运算符和内置类型的 IO 保存一致 类检查相等性操作，定义 operator=，同时也应该定义 operator!= 如果类有比较操作，例如 operator）必须时成员 复合类型一般为成员，但非必须 改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减、解引用通常为成员 具有对称性的运算符可以转换任意一端的运算对象，如算术、相等性、关系和位运算，通常位普通的非成员函数 string s = \"world\"; string t = s + \"!\"; string u = \"hi \" + s;//如果+是string成员函数，这里会报错 实际上，string 将 + 定义为了普通成员函数，\"hi \" + s 等价于 operator+=(\"hi \", s)，就没有出现问题 ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:1:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#重载运算符的几种调用形式"},{"categories":["C++"],"content":"14.1 基本概念重载的运算符是具有特殊名字的函数：它们的名字由关键字 operator 和其后要定义的运算符号共同组成。和其他函数一样，重载的运算符也包含返回类型、参数列表以及函数体。 重载运算符函数的参数数量与该作用的运算对象数量一样多，一元运算符有一个参数，二元运算符有两个参数； 二元运算符左侧运算对象传递给第一个参数，右侧对象传递给第二个对象 除了 operator() 外，其他重载运算符不能含有默认实参 如果一个重载运算符是类的成员函数时，this 会绑定到左侧运算对象，参数数量会比运算对象少一个 重载运算符函数只能是一个类的成员，或者至少有一个类类型的参数，不能对内置类型定义重载运算符 int operator+(int, int);//错误，不能重定义int的运算符 以下是可以重载或者不能重载的运算符： 重载运算符的几种调用形式： 可以间接的用运算符调用重载的运算符函数 也可以像普通函数那样直接调用 //一个非成员运算符函数的等价调用 data1 + data2; //普通表达式 operator+(data1, data2); //等价的函数调用 也可以像调用其他成员函数一样显示的调用成员运算符 data1 += data2; //基于调用的表达式 data1.operator+=(data2); //对成员运算符函数的等价调用 某些运算符不应该被重载 某些运算符会指定运算对象的求值顺序，而关于这些运算对象求值顺序的规则无法应用到重载的运算符上 像逻辑与运算符、逻辑或运算符、逗号运算符的运算对象求值顺序无法保留下来，而 \u0026\u0026 和 || 短路求值属性也无法保留 对于逗号和取地址运算符，用于类类型对象时已经定义了特殊的含义，所以不应该被重载 使用内置类型一致的含义设计一个类时，要考虑这个类提供哪些操作，然后再考虑这些操作设为普通函数还是重载的运算符。如果某些类逻辑上和运算符相关，它们适合定义成重载的运算符 如果类执行 IO 操作，定义移位运算符和内置类型的 IO 保存一致 类检查相等性操作，定义 operator=，同时也应该定义 operator!= 如果类有比较操作，例如 operator）必须时成员 复合类型一般为成员，但非必须 改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减、解引用通常为成员 具有对称性的运算符可以转换任意一端的运算对象，如算术、相等性、关系和位运算，通常位普通的非成员函数 string s = \"world\"; string t = s + \"!\"; string u = \"hi \" + s;//如果+是string成员函数，这里会报错 实际上，string 将 + 定义为了普通成员函数，\"hi \" + s 等价于 operator+=(\"hi \", s)，就没有出现问题 ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:1:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#某些运算符不应该被重载"},{"categories":["C++"],"content":"14.1 基本概念重载的运算符是具有特殊名字的函数：它们的名字由关键字 operator 和其后要定义的运算符号共同组成。和其他函数一样，重载的运算符也包含返回类型、参数列表以及函数体。 重载运算符函数的参数数量与该作用的运算对象数量一样多，一元运算符有一个参数，二元运算符有两个参数； 二元运算符左侧运算对象传递给第一个参数，右侧对象传递给第二个对象 除了 operator() 外，其他重载运算符不能含有默认实参 如果一个重载运算符是类的成员函数时，this 会绑定到左侧运算对象，参数数量会比运算对象少一个 重载运算符函数只能是一个类的成员，或者至少有一个类类型的参数，不能对内置类型定义重载运算符 int operator+(int, int);//错误，不能重定义int的运算符 以下是可以重载或者不能重载的运算符： 重载运算符的几种调用形式： 可以间接的用运算符调用重载的运算符函数 也可以像普通函数那样直接调用 //一个非成员运算符函数的等价调用 data1 + data2; //普通表达式 operator+(data1, data2); //等价的函数调用 也可以像调用其他成员函数一样显示的调用成员运算符 data1 += data2; //基于调用的表达式 data1.operator+=(data2); //对成员运算符函数的等价调用 某些运算符不应该被重载 某些运算符会指定运算对象的求值顺序，而关于这些运算对象求值顺序的规则无法应用到重载的运算符上 像逻辑与运算符、逻辑或运算符、逗号运算符的运算对象求值顺序无法保留下来，而 \u0026\u0026 和 || 短路求值属性也无法保留 对于逗号和取地址运算符，用于类类型对象时已经定义了特殊的含义，所以不应该被重载 使用内置类型一致的含义设计一个类时，要考虑这个类提供哪些操作，然后再考虑这些操作设为普通函数还是重载的运算符。如果某些类逻辑上和运算符相关，它们适合定义成重载的运算符 如果类执行 IO 操作，定义移位运算符和内置类型的 IO 保存一致 类检查相等性操作，定义 operator=，同时也应该定义 operator!= 如果类有比较操作，例如 operator）必须时成员 复合类型一般为成员，但非必须 改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减、解引用通常为成员 具有对称性的运算符可以转换任意一端的运算对象，如算术、相等性、关系和位运算，通常位普通的非成员函数 string s = \"world\"; string t = s + \"!\"; string u = \"hi \" + s;//如果+是string成员函数，这里会报错 实际上，string 将 + 定义为了普通成员函数，\"hi \" + s 等价于 operator+=(\"hi \", s)，就没有出现问题 ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:1:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#使用内置类型一致的含义"},{"categories":["C++"],"content":"14.1 基本概念重载的运算符是具有特殊名字的函数：它们的名字由关键字 operator 和其后要定义的运算符号共同组成。和其他函数一样，重载的运算符也包含返回类型、参数列表以及函数体。 重载运算符函数的参数数量与该作用的运算对象数量一样多，一元运算符有一个参数，二元运算符有两个参数； 二元运算符左侧运算对象传递给第一个参数，右侧对象传递给第二个对象 除了 operator() 外，其他重载运算符不能含有默认实参 如果一个重载运算符是类的成员函数时，this 会绑定到左侧运算对象，参数数量会比运算对象少一个 重载运算符函数只能是一个类的成员，或者至少有一个类类型的参数，不能对内置类型定义重载运算符 int operator+(int, int);//错误，不能重定义int的运算符 以下是可以重载或者不能重载的运算符： 重载运算符的几种调用形式： 可以间接的用运算符调用重载的运算符函数 也可以像普通函数那样直接调用 //一个非成员运算符函数的等价调用 data1 + data2; //普通表达式 operator+(data1, data2); //等价的函数调用 也可以像调用其他成员函数一样显示的调用成员运算符 data1 += data2; //基于调用的表达式 data1.operator+=(data2); //对成员运算符函数的等价调用 某些运算符不应该被重载 某些运算符会指定运算对象的求值顺序，而关于这些运算对象求值顺序的规则无法应用到重载的运算符上 像逻辑与运算符、逻辑或运算符、逗号运算符的运算对象求值顺序无法保留下来，而 \u0026\u0026 和 || 短路求值属性也无法保留 对于逗号和取地址运算符，用于类类型对象时已经定义了特殊的含义，所以不应该被重载 使用内置类型一致的含义设计一个类时，要考虑这个类提供哪些操作，然后再考虑这些操作设为普通函数还是重载的运算符。如果某些类逻辑上和运算符相关，它们适合定义成重载的运算符 如果类执行 IO 操作，定义移位运算符和内置类型的 IO 保存一致 类检查相等性操作，定义 operator=，同时也应该定义 operator!= 如果类有比较操作，例如 operator）必须时成员 复合类型一般为成员，但非必须 改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减、解引用通常为成员 具有对称性的运算符可以转换任意一端的运算对象，如算术、相等性、关系和位运算，通常位普通的非成员函数 string s = \"world\"; string t = s + \"!\"; string u = \"hi \" + s;//如果+是string成员函数，这里会报错 实际上，string 将 + 定义为了普通成员函数，\"hi \" + s 等价于 operator+=(\"hi \", s)，就没有出现问题 ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:1:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#选择作为成员或者非成员"},{"categories":["C++"],"content":"14.2 输入输出运算符","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:2:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#142-输入输出运算符"},{"categories":["C++"],"content":"14.2.1 重载输出运算符«通常情况下，输出运算符第一个形参是一个非常量 ostream 对象的引用，非常量是因为像流写入内容会改变其状态，引用类型是因为无法直接复制一个 ostream 对象（注：拷贝构造函数为 delete） 第二个形参是一个常量的引用，这个常量是需要打印出来的类类型，引用为了避免复制，常量是因为打印不会改变对象的内容 举个例子： ostream \u0026operator(ostream \u0026os, const \u0026Sales_data \u0026item) { os \u003c\u003c item.isbn() \u003c\u003c \" \" \u003c\u003c item.units_sold \u003c\u003c \" \" \u003c\u003c item.revenue \u003c\u003c \" \" \u003c\u003c item.avg_price();//末尾不需要再加换行符 return os; } 通常输出运算符主要负责打印对象内容而不是控制格式，所以一般不打印换行符 输入输出运算符必须是非成员函数输入输出函数必须为非成员函数，不能是类成员函数，否则左侧运算对象将是类的一个对象 Sales_data data; data \u003c\u003c cout; //如果opeator\u003c\u003c是Sales_data的对象 如果输入输出运算符是Sales_data 的成员，它们也必须为 istream 或 ostream 的成员，当然我们不能为标准库定义成员 注：其实这里感觉没看懂，如果像书上写的这样，data « cout 感觉是不是也可以输出？我自己也试了代码，确实可以输出，就是看着有点怪，要是深究起来，感觉书上写的话不够严谨 ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:2:1","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#1421-重载输出运算符"},{"categories":["C++"],"content":"14.2.1 重载输出运算符«通常情况下，输出运算符第一个形参是一个非常量 ostream 对象的引用，非常量是因为像流写入内容会改变其状态，引用类型是因为无法直接复制一个 ostream 对象（注：拷贝构造函数为 delete） 第二个形参是一个常量的引用，这个常量是需要打印出来的类类型，引用为了避免复制，常量是因为打印不会改变对象的内容 举个例子： ostream \u0026operator(ostream \u0026os, const \u0026Sales_data \u0026item) { os ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:2:1","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#输入输出运算符必须是非成员函数"},{"categories":["C++"],"content":"14.2.2 重载输入运算符»输入运算符第一个形参是读取流的引用，第二个形参是读入到对象的引用 例如： istream \u0026operator\u003e\u003e(istream \u0026is, Sales_data \u0026item) { double price; is \u003e\u003e item.bookNo \u003e\u003e item.untis_sold \u003e\u003e price; if (is) {//检查是否输入成功 item.revenue = item.units_sold * price; } else { item = Sales_data();//输入失败，对象初始为默认情况 } return is; } 输入时的错误执行输入运算符时可能发生以下错误： 当流读取到错误类型的数据，后续操作都会失败 当读取操作未达到文件末尾或者遇到输入流其他错误时也会失败 所以使用输入操作符时，需要判断是否有错误的情况发生，因为如果出现错误的情况可能发生在中间，这样的话前面的成员时正确的，而发生读取错误的地方后面的成员就和前面不匹配了 ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:2:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#1422-重载输入运算符"},{"categories":["C++"],"content":"14.2.2 重载输入运算符»输入运算符第一个形参是读取流的引用，第二个形参是读入到对象的引用 例如： istream \u0026operator(istream \u0026is, Sales_data \u0026item) { double price; is item.bookNo item.untis_sold price; if (is) {//检查是否输入成功 item.revenue = item.units_sold * price; } else { item = Sales_data();//输入失败，对象初始为默认情况 } return is; } 输入时的错误执行输入运算符时可能发生以下错误： 当流读取到错误类型的数据，后续操作都会失败 当读取操作未达到文件末尾或者遇到输入流其他错误时也会失败 所以使用输入操作符时，需要判断是否有错误的情况发生，因为如果出现错误的情况可能发生在中间，这样的话前面的成员时正确的，而发生读取错误的地方后面的成员就和前面不匹配了 ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:2:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#输入时的错误"},{"categories":["C++"],"content":"14.3 算术和关系运算符通常情况下，算术和关系运算符定义为非成员函数允许左侧和右侧运算对象进行转换，形参都是常量的引用 算术运算符通常会计算两个对象并得到一个新值，这个值区别于任何一个运算对象，常常位于一个局部变量中，返回值应该为局部变量的副本作为结果，通常也会定义复合赋值运算符 Book operator+(const Book \u0026lhs, const Book \u0026rhs) { Book sum = lhs; sum += rhs; //复合赋值运算符 return sum; } ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:3:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#143-算术和关系运算符"},{"categories":["C++"],"content":"14.3.1 相等运算符一般情况下只有当两个对象每一个数据成员都相等时，才认为他们时相等的 下面是个具体例子： bool operator==(const Book \u0026lhs, const Book \u0026rhs) { return lhs.price == rhs.price \u0026\u0026 lhs.name == rhs.name; } bool operator!=(const Book \u0026lhs, const Book \u0026rhs) { return !(lhs == rhs); } 设计相等运算符函数基本准则如下： 设计一个类判断两个对象是否相等的操作时，通常定义为 operator== 而非其他的像（equl等等）普通的命名函数 如果类定义了 operator== ，则该运算符应该能判断一组给定对象是否含义重复数据 相等运算符应该具有传递性，如 a == b 和 b == c 都为真，那么 a == c 也为真 定义了 operator== 通常也要定义 operator!= 相等和不相等运算符，通常具体写一个即可，另一个进行调用即可 ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:3:1","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#1431-相等运算符"},{"categories":["C++"],"content":"14.3.2 关系运算符对于关联容器和一些算法会用到小于运算符，此时可以定义 operator\u003c 但是一般情况下，关系运算符可能没有那么有必要，比如说上面的 Book 类，如果说定义小于关系的，具体内容如何比较，是先根据书名然后根据价格进行比较？还是说仅仅根据书名比较 一般情况下，对于不相等的对象，一个对象应该小于另一个对象，这样的话，定义关系运算符的时候，逻辑上就不是很清楚了 如果存在唯一一种逻辑可靠的 \u003c 定义，应该考虑定义 \u003c 运算符，但是如果类还包括 == ，仅当\u003c 的定义和 == 结果一致时才定义 \u003c 运算符 ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:3:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#1432-关系运算符"},{"categories":["C++"],"content":"14.4 赋值运算符13章时已经介绍过拷贝赋值和移动赋值运算符，它们把一个对象赋值给另一个对象。我们还可以定义其他的赋值运算符，以使用别的类型作为右侧对象 复合赋值运算符通常把复合赋值运算符等赋值运算符都定义在类的内部，复合赋值运算符也应该返回左侧对象的引用 Book \u0026Book::operator+=(const Book \u0026rhs) { price += rhs.price;//这里因为自己写的例子，语义上可能有些问题 return *this; } ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:4:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#144-赋值运算符"},{"categories":["C++"],"content":"14.4 赋值运算符13章时已经介绍过拷贝赋值和移动赋值运算符，它们把一个对象赋值给另一个对象。我们还可以定义其他的赋值运算符，以使用别的类型作为右侧对象 复合赋值运算符通常把复合赋值运算符等赋值运算符都定义在类的内部，复合赋值运算符也应该返回左侧对象的引用 Book \u0026Book::operator+=(const Book \u0026rhs) { price += rhs.price;//这里因为自己写的例子，语义上可能有些问题 return *this; } ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:4:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#复合赋值运算符"},{"categories":["C++"],"content":"14.5 下标运算符下标运算符通常在一些容器中，可以让我们像访问数组那样的形式进行访问，一般会定义为 operator[] 下标运算符必须时成员函数 通常返回值为访问元素的引用，确保下标可以出现在赋值运算符任意一端 如果一个类包含下标运算符，通常会定义两个版本： 一个返回普通引用 另一个是类的常量成员并且返回常量引用 class StrVec { std::string\u0026 operator[](std::size_t n) {return elements[n];} const std::string\u0026 operator[](std::size_t) const {return elements[n];} private: std::string *elements;//指向数组首元素的指针 } 当 StrVec 是非常量时，可以给元素赋值 当对常量对象取小标时，不能为其赋值 const StrVec cvec = svec; if (svec.size() \u0026\u0026 svec[0].empty()) { svec[0] = \"zero\";//正确：下标运算符返回string的引用 cvec[0] = \"zip\"; //错误：cvec取下标返回的为常量引用 } ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:5:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#145-下标运算符"},{"categories":["C++"],"content":"14.6递增和递减运算符一般迭代器类会实现递增运算符（++）和递减运算符（–），使得迭代器可以在元素序列中进行移动，因为它们改变了操作对象的状态，通常设为成员函数 定义递增和递减运算符的类要同时定义前置版本和后置版本，且都为类的成员函数 定义前置递增/递减运算符==为了和内置版本保持一致，前置运算符应该返回递增或递减后对象的引用== 递增和递减运算符工作机理： 首先调用check 函数检查是否有效 如果有效，接着检查给定索引值是否有效 check 函数没有发生异常，返回运算对象的引用 下面时具体例子： class StrBlobPtr { public: //递增和递减运算符 StrBlobPtr\u0026 operator++();//前置版本 StrBlobPtr\u0026 operator--(); //其他成员 } StrBlobPtr\u0026 StrBlobPtr::operator++() { check(curr, \"已经越界\"); ++curr; //curr向前移动一个元素 return *this; } StrBlobPtr\u0026 StrBlobPtr::operator--() { --curr; //curr向后移动一个元素 check(curr, \"已经越界\"); return *this; } 区分前置和后置运算符因为前置和后置版本使用的是同一个符号，重载版本的名字也是相同的，运算对象的数量和类型也是相同的 所以为了解决这个问题，后置版本接受一个额外的但是不使用的 int 类型的参数，编译器会为这个形参提供一个值为 0 的实参 class StrBlobPtr { public: //递增和递减运算符 StrBlobPtr\u0026 operator++(int);//后置版本 StrBlobPtr\u0026 operator--(int); //其他成员 } StrBlobPtr StrBlobPtr::operator++(int) { //这里无须检查有效性，调用前置版本的时候会检查 StrBlobPtr ret = *this;//记录当前的值 ++*this; //向前移动一个元素，前置++会检查有效性 return ret; //返回之前记录的状态 } StrBlobPtr\u0026 StrBlobPtr::operator--(int) { //这里无须检查有效性，调用前置版本的时候会检查 StrBlobPtr ret = *this;//记录当前的值 --*this; //向前移动一个元素，前置++会检查有效性 return ret; //返回之前记录的状态 } 这里主要需要理解内置类型前置版本和后置版本的区别（以int类型为例） ++i 首先会对 i 的值进行递增，然后返回 i 的值 i++ 首先会返回 i 的值，然后再进行运算 int sum = 0, i = 1; sum = ++i; //此时sum的值为2 sum = i++; //此时sum的值为1 显示调用后置运算符如果要显示调用运算符的话，像之前那样利用函数调用的形式进行调用，但是注意必须传入一个整型参数 StrBlobPtr p(a1); //p指向a1的vector p.operator++(0); //调用后置版本的operator++ p.operator++(); //调用前置版本的operator++ ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:6:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#146递增和递减运算符"},{"categories":["C++"],"content":"14.6递增和递减运算符一般迭代器类会实现递增运算符（++）和递减运算符（–），使得迭代器可以在元素序列中进行移动，因为它们改变了操作对象的状态，通常设为成员函数 定义递增和递减运算符的类要同时定义前置版本和后置版本，且都为类的成员函数 定义前置递增/递减运算符==为了和内置版本保持一致，前置运算符应该返回递增或递减后对象的引用== 递增和递减运算符工作机理： 首先调用check 函数检查是否有效 如果有效，接着检查给定索引值是否有效 check 函数没有发生异常，返回运算对象的引用 下面时具体例子： class StrBlobPtr { public: //递增和递减运算符 StrBlobPtr\u0026 operator++();//前置版本 StrBlobPtr\u0026 operator--(); //其他成员 } StrBlobPtr\u0026 StrBlobPtr::operator++() { check(curr, \"已经越界\"); ++curr; //curr向前移动一个元素 return *this; } StrBlobPtr\u0026 StrBlobPtr::operator--() { --curr; //curr向后移动一个元素 check(curr, \"已经越界\"); return *this; } 区分前置和后置运算符因为前置和后置版本使用的是同一个符号，重载版本的名字也是相同的，运算对象的数量和类型也是相同的 所以为了解决这个问题，后置版本接受一个额外的但是不使用的 int 类型的参数，编译器会为这个形参提供一个值为 0 的实参 class StrBlobPtr { public: //递增和递减运算符 StrBlobPtr\u0026 operator++(int);//后置版本 StrBlobPtr\u0026 operator--(int); //其他成员 } StrBlobPtr StrBlobPtr::operator++(int) { //这里无须检查有效性，调用前置版本的时候会检查 StrBlobPtr ret = *this;//记录当前的值 ++*this; //向前移动一个元素，前置++会检查有效性 return ret; //返回之前记录的状态 } StrBlobPtr\u0026 StrBlobPtr::operator--(int) { //这里无须检查有效性，调用前置版本的时候会检查 StrBlobPtr ret = *this;//记录当前的值 --*this; //向前移动一个元素，前置++会检查有效性 return ret; //返回之前记录的状态 } 这里主要需要理解内置类型前置版本和后置版本的区别（以int类型为例） ++i 首先会对 i 的值进行递增，然后返回 i 的值 i++ 首先会返回 i 的值，然后再进行运算 int sum = 0, i = 1; sum = ++i; //此时sum的值为2 sum = i++; //此时sum的值为1 显示调用后置运算符如果要显示调用运算符的话，像之前那样利用函数调用的形式进行调用，但是注意必须传入一个整型参数 StrBlobPtr p(a1); //p指向a1的vector p.operator++(0); //调用后置版本的operator++ p.operator++(); //调用前置版本的operator++ ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:6:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#定义前置递增递减运算符"},{"categories":["C++"],"content":"14.6递增和递减运算符一般迭代器类会实现递增运算符（++）和递减运算符（–），使得迭代器可以在元素序列中进行移动，因为它们改变了操作对象的状态，通常设为成员函数 定义递增和递减运算符的类要同时定义前置版本和后置版本，且都为类的成员函数 定义前置递增/递减运算符==为了和内置版本保持一致，前置运算符应该返回递增或递减后对象的引用== 递增和递减运算符工作机理： 首先调用check 函数检查是否有效 如果有效，接着检查给定索引值是否有效 check 函数没有发生异常，返回运算对象的引用 下面时具体例子： class StrBlobPtr { public: //递增和递减运算符 StrBlobPtr\u0026 operator++();//前置版本 StrBlobPtr\u0026 operator--(); //其他成员 } StrBlobPtr\u0026 StrBlobPtr::operator++() { check(curr, \"已经越界\"); ++curr; //curr向前移动一个元素 return *this; } StrBlobPtr\u0026 StrBlobPtr::operator--() { --curr; //curr向后移动一个元素 check(curr, \"已经越界\"); return *this; } 区分前置和后置运算符因为前置和后置版本使用的是同一个符号，重载版本的名字也是相同的，运算对象的数量和类型也是相同的 所以为了解决这个问题，后置版本接受一个额外的但是不使用的 int 类型的参数，编译器会为这个形参提供一个值为 0 的实参 class StrBlobPtr { public: //递增和递减运算符 StrBlobPtr\u0026 operator++(int);//后置版本 StrBlobPtr\u0026 operator--(int); //其他成员 } StrBlobPtr StrBlobPtr::operator++(int) { //这里无须检查有效性，调用前置版本的时候会检查 StrBlobPtr ret = *this;//记录当前的值 ++*this; //向前移动一个元素，前置++会检查有效性 return ret; //返回之前记录的状态 } StrBlobPtr\u0026 StrBlobPtr::operator--(int) { //这里无须检查有效性，调用前置版本的时候会检查 StrBlobPtr ret = *this;//记录当前的值 --*this; //向前移动一个元素，前置++会检查有效性 return ret; //返回之前记录的状态 } 这里主要需要理解内置类型前置版本和后置版本的区别（以int类型为例） ++i 首先会对 i 的值进行递增，然后返回 i 的值 i++ 首先会返回 i 的值，然后再进行运算 int sum = 0, i = 1; sum = ++i; //此时sum的值为2 sum = i++; //此时sum的值为1 显示调用后置运算符如果要显示调用运算符的话，像之前那样利用函数调用的形式进行调用，但是注意必须传入一个整型参数 StrBlobPtr p(a1); //p指向a1的vector p.operator++(0); //调用后置版本的operator++ p.operator++(); //调用前置版本的operator++ ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:6:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#区分前置和后置运算符"},{"categories":["C++"],"content":"14.6递增和递减运算符一般迭代器类会实现递增运算符（++）和递减运算符（–），使得迭代器可以在元素序列中进行移动，因为它们改变了操作对象的状态，通常设为成员函数 定义递增和递减运算符的类要同时定义前置版本和后置版本，且都为类的成员函数 定义前置递增/递减运算符==为了和内置版本保持一致，前置运算符应该返回递增或递减后对象的引用== 递增和递减运算符工作机理： 首先调用check 函数检查是否有效 如果有效，接着检查给定索引值是否有效 check 函数没有发生异常，返回运算对象的引用 下面时具体例子： class StrBlobPtr { public: //递增和递减运算符 StrBlobPtr\u0026 operator++();//前置版本 StrBlobPtr\u0026 operator--(); //其他成员 } StrBlobPtr\u0026 StrBlobPtr::operator++() { check(curr, \"已经越界\"); ++curr; //curr向前移动一个元素 return *this; } StrBlobPtr\u0026 StrBlobPtr::operator--() { --curr; //curr向后移动一个元素 check(curr, \"已经越界\"); return *this; } 区分前置和后置运算符因为前置和后置版本使用的是同一个符号，重载版本的名字也是相同的，运算对象的数量和类型也是相同的 所以为了解决这个问题，后置版本接受一个额外的但是不使用的 int 类型的参数，编译器会为这个形参提供一个值为 0 的实参 class StrBlobPtr { public: //递增和递减运算符 StrBlobPtr\u0026 operator++(int);//后置版本 StrBlobPtr\u0026 operator--(int); //其他成员 } StrBlobPtr StrBlobPtr::operator++(int) { //这里无须检查有效性，调用前置版本的时候会检查 StrBlobPtr ret = *this;//记录当前的值 ++*this; //向前移动一个元素，前置++会检查有效性 return ret; //返回之前记录的状态 } StrBlobPtr\u0026 StrBlobPtr::operator--(int) { //这里无须检查有效性，调用前置版本的时候会检查 StrBlobPtr ret = *this;//记录当前的值 --*this; //向前移动一个元素，前置++会检查有效性 return ret; //返回之前记录的状态 } 这里主要需要理解内置类型前置版本和后置版本的区别（以int类型为例） ++i 首先会对 i 的值进行递增，然后返回 i 的值 i++ 首先会返回 i 的值，然后再进行运算 int sum = 0, i = 1; sum = ++i; //此时sum的值为2 sum = i++; //此时sum的值为1 显示调用后置运算符如果要显示调用运算符的话，像之前那样利用函数调用的形式进行调用，但是注意必须传入一个整型参数 StrBlobPtr p(a1); //p指向a1的vector p.operator++(0); //调用后置版本的operator++ p.operator++(); //调用前置版本的operator++ ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:6:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#显示调用后置运算符"},{"categories":["C++"],"content":"14.7 成员访问运算符迭代器和智能指针类中常常用到解引用运算符（*）和箭头运算符（-\u003e），例如： class StrBlobPtr { public: std::string \u0026operator*() const { auto p = check(curr, \"dereference past end\"); return (*p)[curr]; //(*p)是对象所指的vector } std::string \u0026operator-\u003e() const { return \u0026 this-\u003eoperator*();//实际工作委托给解引用运算符 } //其他成员 } 解引用运算符首先检查curr是否在作用范围内，如果是返回curr所指元素的引用，箭头运算符返回解引用结果元素的地址 对箭头运算符返回值的限定形如point-\u003emem 的表达式，point必须是指向类对象的指针或者是重载了 operator-\u003e 的类的对象 (*point).mem; //point是一个内置指针类型 point.operator()-\u003emem;//point是一个类的对象 如果 point 是指针，则会应用内置箭头运算符，等价于 (*point).mem 如果 point 是一个定义了 operator-\u003e的类的一个对象，则使用 point.operator-\u003e() 的结果来获取 mem ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:7:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#147-成员访问运算符"},{"categories":["C++"],"content":"14.7 成员访问运算符迭代器和智能指针类中常常用到解引用运算符（*）和箭头运算符（-），例如： class StrBlobPtr { public: std::string \u0026operator*() const { auto p = check(curr, \"dereference past end\"); return (*p)[curr]; //(*p)是对象所指的vector } std::string \u0026operator-() const { return \u0026 this-operator*();//实际工作委托给解引用运算符 } //其他成员 } 解引用运算符首先检查curr是否在作用范围内，如果是返回curr所指元素的引用，箭头运算符返回解引用结果元素的地址 对箭头运算符返回值的限定形如point-mem 的表达式，point必须是指向类对象的指针或者是重载了 operator- 的类的对象 (*point).mem; //point是一个内置指针类型 point.operator()-mem;//point是一个类的对象 如果 point 是指针，则会应用内置箭头运算符，等价于 (*point).mem 如果 point 是一个定义了 operator-的类的一个对象，则使用 point.operator-() 的结果来获取 mem ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:7:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#对箭头运算符返回值的限定"},{"categories":["C++"],"content":"14.8 函数调用运算符如果一个类重载了函数调用运算符（就是()），则可以像调用函数一样使用该类的对象，下面是一个例子： struct absInt { int operator()(int val) const { return val \u003c 0 ? -val : val; } } int i = -42; absInt absObj; //含有函数调用运算符的对象 int ui = absObj(i);//将i传递给absObj.operator() 函数调用运算符必须是成员函数，一个类可以定义多个不同版本的调用运算符 如果类定义了调用运算符，则该类的对象称为函数对象，这些对象的行为像函数一样 含有状态的函数对象类函数对象类除了 operator() 之外也可以包含其他成员，这些成员被用于定制调用运算符中的操作，下面是个例子： class PrintString { public: PrintString(ostream \u0026o = cout, char c = ' ') : os(o), sep(c) {} void operator()(const string \u0026s) const {os \u003c\u003c s \u003c\u003c sep;} private: ostream \u0026os;//用于写入的目的流 char step; //用于将不同输出隔开的字符 } PrintString printer; printer(s); PrintString errors(cerr, '\\n'); errors(s); 函数对象常常作为泛型算法的实参，例如可以用for_each 算法和 PrintString 类来打印容器的内容： for_each(vec.beign(), vec.end(), PrintString(cerr, '\\n')); for_each 第三个实参是类型 PrintString 的一个临时对象，我们用 cerr 和 换行符初始化了改对象，程序调用 for_each 时，会把 vec 每个元素打印到 cerr 中，元素之间以换行符分割 ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:8:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#148-函数调用运算符"},{"categories":["C++"],"content":"14.8 函数调用运算符如果一个类重载了函数调用运算符（就是()），则可以像调用函数一样使用该类的对象，下面是一个例子： struct absInt { int operator()(int val) const { return val ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:8:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#含有状态的函数对象类"},{"categories":["C++"],"content":"14.8.1 lambda 是函数对象使用 PrintString 对象作为 for_each 的实参，类似于使用 lambda 表达式，编译器会将 lambda 表达式 翻译成一个未命名类的未命名对象，举例如下： //根据单词长度进行排序，长度相同的会按照字典序排序 stable_sort(word.begin(), word.end(), [](const string \u0026a, const string \u0026b) { return a.size() \u003c b.size();}); 上面 lambda 表达式类似下面的一个未命名对象 class ShorterString { public: bool operator()(const string \u0026s1, string \u0026s2) const { return s1.size() \u003c s2.size(); } } //替换上面的lambda表达式 stable_sort(word.begin(), word.end(), ShorterString()); 表示 lambda 及相应捕获行为的类 使用一个 lambda 表达式通过引用捕获变量时，程序确保 lambda 执行时引用所引的对象确实存在，编译器可以直接引用而无须在 lambda 产生的类中将其存储为数据成员 使用值捕获的变量会拷贝到 lambda 表达式中，这种 lambda 表达式产生的类必须为每个值捕获的变量建立对应的数据成员，同时创建构造函数，用捕获的变量进行初始化 //获得第一个指向满足条件元素的迭代器，该元素满足size() \u003e= sz auto wc = find_if(word.begin(), word.end(), [sz](const string \u0026a) { return a.size() \u003e= sz;}); //上面的lambda表达式产生的类像下面这样 class SizeComp { SizeComp(size_t n) : sz(n) {} bool operator()(const string \u0026s) const { return s.size() \u003e= sz; } private: size_t sz;//该数据成员对应通过值捕获的变量 } //使用像上面的函数对象时，必须提供一个实参 auto wc = find_if(word.begin(), word.end(), SizeCopm(sz)); lambda 表达式产生的类不含默认构造函数、赋值运算符和默认析构函数；它是否含有默认的拷贝/移动构造函数通常视捕获的数据成员类型而定 ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:8:1","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#1481-lambda-是函数对象"},{"categories":["C++"],"content":"14.8.1 lambda 是函数对象使用 PrintString 对象作为 for_each 的实参，类似于使用 lambda 表达式，编译器会将 lambda 表达式 翻译成一个未命名类的未命名对象，举例如下： //根据单词长度进行排序，长度相同的会按照字典序排序 stable_sort(word.begin(), word.end(), [](const string \u0026a, const string \u0026b) { return a.size() = sz auto wc = find_if(word.begin(), word.end(), [sz](const string \u0026a) { return a.size() = sz;}); //上面的lambda表达式产生的类像下面这样 class SizeComp { SizeComp(size_t n) : sz(n) {} bool operator()(const string \u0026s) const { return s.size() = sz; } private: size_t sz;//该数据成员对应通过值捕获的变量 } //使用像上面的函数对象时，必须提供一个实参 auto wc = find_if(word.begin(), word.end(), SizeCopm(sz)); lambda 表达式产生的类不含默认构造函数、赋值运算符和默认析构函数；它是否含有默认的拷贝/移动构造函数通常视捕获的数据成员类型而定 ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:8:1","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#表示-lambda-及相应捕获行为的类"},{"categories":["C++"],"content":"14.8.2 标准库定义的函数对象标准库定义了一组表示算术运算符、关系运算符和逻辑运算符的类，每个类分别定义了一个执行与类名对应的调用运算符。 如puls 类定义了一个函数调用运算符用于执行 + 操作，modulus类定义了一个调用运算符执行二元 % 的操作 这些类都是模板形式，可以指定具体的应用类型，即对应调用运算符的形参类型 plus\u003cint\u003e intAdd; //执行int加法的函数对象 negate\u003cint\u003e intNegate; //执行int取反的函数对象 int sum = intAdd(10, 20); //sum = 30 sum = intNegate(intAdd(10, 20));//sum = -30 sum = intAdd(10, intNegate(10));//sum = 0 下面时标准库定义的函数对象： 算术 关系 逻辑 plus\u003cType\u003e equal_to\u003cType\u003e logical_and\u003c minus\u003cType not_equal_to\u003cType\u003e logical_or\u003cType\u003e multiplies\u003cType\u003e greater\u003cType\u003e logical_not\u003cType\u003e divides\u003cType\u003e greater_equal\u003cType\u003e modulus\u003cType\u003e less\u003cType\u003e negate\u003cType\u003e less_equal\u003cType\u003e 算法中使用标准库函数对象默认情况下排序算法使用 operator\u003c 将序列按照升序进行排列，如果想执行降序的话，可以用 greater类型的对象 sort(svec.begin(), sec.end(), greater\u003cstring\u003e()); 注意：标准库规定的函数对象对于指针同样适用，如果比较两个无关指针会产生未定义的行为，而我们如果想比较指针内存地址来 sort 指针的 vector。直接比较会产生未定义的行为，而标准库函数对象则可实现这个目的 vector\u003cstring*\u003e nameTable; //错误：nameTable中指针彼此之间没有关系，所以 \u003c 将产生未定义行为 sort(nameTable.begin(), nameTable.end(), [](string *a, string *b) { return a \u003c b;}); // 正确：标准库规定指针的less是定义良好的 sort(nameTable.begin(), nameTable.end(), less\u003cstring*\u003e()); ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:8:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#1482-标准库定义的函数对象"},{"categories":["C++"],"content":"14.8.2 标准库定义的函数对象标准库定义了一组表示算术运算符、关系运算符和逻辑运算符的类，每个类分别定义了一个执行与类名对应的调用运算符。 如puls 类定义了一个函数调用运算符用于执行 + 操作，modulus类定义了一个调用运算符执行二元 % 的操作 这些类都是模板形式，可以指定具体的应用类型，即对应调用运算符的形参类型 plus intAdd; //执行int加法的函数对象 negate intNegate; //执行int取反的函数对象 int sum = intAdd(10, 20); //sum = 30 sum = intNegate(intAdd(10, 20));//sum = -30 sum = intAdd(10, intNegate(10));//sum = 0 下面时标准库定义的函数对象： 算术 关系 逻辑 plus equal_to logical_andlogical_or multiplies greater logical_not divides greater_equal modulus less negate less_equal 算法中使用标准库函数对象默认情况下排序算法使用 operator()); 注意：标准库规定的函数对象对于指针同样适用，如果比较两个无关指针会产生未定义的行为，而我们如果想比较指针内存地址来 sort 指针的 vector。直接比较会产生未定义的行为，而标准库函数对象则可实现这个目的 vector nameTable; //错误：nameTable中指针彼此之间没有关系，所以 ()); ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:8:2","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#算法中使用标准库函数对象"},{"categories":["C++"],"content":"14.8.3 可调用对象与 functionC++中有几种可调用的对象：函数、函数指针、lambda 表达式、bind 创建的对象以及重载了函数调用运算符的类 这些不同类型的可调用对象可能共享一种调用形式，调用形式指明了返回类型以及实参类型，下面是个例子： //普通函数 int add(int i, int j) { return i + j; } //lambda 表达式 auto mod = [](int i, int j) { return i % j; } //函数对象类 struct divide { int operator()(int denominator, int divisor) { return denominator / divisor; } } 上面的几种可调用对象对参数执行了不同的算术运算，它们类型不相同，但是共享同一种调用形式 int(int, int) 我们如果用这些可调用对象构建一个简单的计算器，可以定义一个函数表用于储存这些可调用对象的指针。 可以通过 map 来实现，用运算符符号的string对象作为关键字，实现运算符函数作为值 //构建运算符到函数指针的映射关系，函数接受两个int，返回一个int map\u003cstring, int(*)(int, int)\u003e binops; //正确：add是一个指向正确类型的函数指针 binops.insert({\"+\", add}); //错误：mod不是一个函数指针 binops.insert({\"%\", mod}); 上面的问题在于 mod 是一个 lambda 表达式，与 binops 的值类型不匹配 标准库 function 类型标准库中一个新的类型 function 可以解决上述问题，下面是 function 定义的操作： function 是一个模板，创建一个具体 function 类型时需要指定 function 表示的对象的调用形式，如 function\u003cint(int, int)\u003e ，这里声明了一个 function 类型，它可以接受两个 int，返回一个 int 类型的可调用对象 function\u003cint(int, int)\u003e f1 = add; //函数指针 function\u003cint(int, int)\u003e f1 = divide();//函数对象类的对象 function\u003cint(int, int)\u003e f1 = [](int i, int j) //lambda { return i * j; }; cout \u003c\u003c f1(4, 2) \u003c\u003c endl; // 6 cout \u003c\u003c f2(4, 2) \u003c\u003c endl; // 2 cout \u003c\u003c f3(4, 2) \u003c\u003c endl; // 8 使用这个 function 类型可以重新定义 map： map\u003cstring, function\u003cint(int, int)\u003e\u003e binops = { {\"+\", add}, //函数指针 {\"-\", std::minus\u003cint\u003e()}, //标准库定义函数对象 {\"/\", divide()}, //用户定义函数对象 {\"*\", [](int i, int j) { return i * j; }},//未命名lambda表达式 {\"%\", mod} //命名的lambda } map 包含5 个元素，虽然可调用对象类型各不相同，但是仍可以存储在同一个 function\u003cint(int, int)\u003e 类型中，这时可以通过索引 map 得到function 对象的引用 binops[\"+\"](10, 5);//add(10, 5); binops[\"-\"](10, 5);//minus\u003cint\u003e(10, 5) binops[\"/\"](10, 5);//divide对象调用运算符 binops[\"*\"](10, 5);//调用lambda函数对象 binops[\"%\"](10, 5);//调用lambda函数对象 重载的函数与 function我们变不能将重载函数名字存入 function 类型的对象中： int add(int i, int j); Sales_data add(const Sales_data\u0026, const Sales_data\u0026); map\u003cstring, function\u003cint(int, int)\u003e\u003e binops; binops.insert({\"+\", add}); //错误：哪个add？ 解决上述二义性问题，可以通过一个函数指针，以及 lambda 表达式进行区分 int (*fp)(int, int) = add; binops.insert({\"+\", fp});//正确：fp指向一个正确的add版本 //正确：使用lambda来指定我们希望使用的add版本 binops.insert({\"+\", [](int a, int b) {return add(a, b);}}); ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:8:3","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#1483-可调用对象与-function"},{"categories":["C++"],"content":"14.8.3 可调用对象与 functionC++中有几种可调用的对象：函数、函数指针、lambda 表达式、bind 创建的对象以及重载了函数调用运算符的类 这些不同类型的可调用对象可能共享一种调用形式，调用形式指明了返回类型以及实参类型，下面是个例子： //普通函数 int add(int i, int j) { return i + j; } //lambda 表达式 auto mod = [](int i, int j) { return i % j; } //函数对象类 struct divide { int operator()(int denominator, int divisor) { return denominator / divisor; } } 上面的几种可调用对象对参数执行了不同的算术运算，它们类型不相同，但是共享同一种调用形式 int(int, int) 我们如果用这些可调用对象构建一个简单的计算器，可以定义一个函数表用于储存这些可调用对象的指针。 可以通过 map 来实现，用运算符符号的string对象作为关键字，实现运算符函数作为值 //构建运算符到函数指针的映射关系，函数接受两个int，返回一个int mapbinops; //正确：add是一个指向正确类型的函数指针 binops.insert({\"+\", add}); //错误：mod不是一个函数指针 binops.insert({\"%\", mod}); 上面的问题在于 mod 是一个 lambda 表达式，与 binops 的值类型不匹配 标准库 function 类型标准库中一个新的类型 function 可以解决上述问题，下面是 function 定义的操作： function 是一个模板，创建一个具体 function 类型时需要指定 function 表示的对象的调用形式，如 function，这里声明了一个 function 类型，它可以接受两个 int，返回一个 int 类型的可调用对象 functionf1 = add; //函数指针 functionf1 = divide();//函数对象类的对象 functionf1 = [](int i, int j) //lambda { return i * j; }; cout binops = { {\"+\", add}, //函数指针 {\"-\", std::minus()}, //标准库定义函数对象 {\"/\", divide()}, //用户定义函数对象 {\"*\", [](int i, int j) { return i * j; }},//未命名lambda表达式 {\"%\", mod} //命名的lambda } map 包含5 个元素，虽然可调用对象类型各不相同，但是仍可以存储在同一个 function类型中，这时可以通过索引 map 得到function 对象的引用 binops[\"+\"](10, 5);//add(10, 5); binops[\"-\"](10, 5);//minus(10, 5) binops[\"/\"](10, 5);//divide对象调用运算符 binops[\"*\"](10, 5);//调用lambda函数对象 binops[\"%\"](10, 5);//调用lambda函数对象 重载的函数与 function我们变不能将重载函数名字存入 function 类型的对象中： int add(int i, int j); Sales_data add(const Sales_data\u0026, const Sales_data\u0026); map binops; binops.insert({\"+\", add}); //错误：哪个add？ 解决上述二义性问题，可以通过一个函数指针，以及 lambda 表达式进行区分 int (*fp)(int, int) = add; binops.insert({\"+\", fp});//正确：fp指向一个正确的add版本 //正确：使用lambda来指定我们希望使用的add版本 binops.insert({\"+\", [](int a, int b) {return add(a, b);}}); ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:8:3","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#标准库-function-类型"},{"categories":["C++"],"content":"14.8.3 可调用对象与 functionC++中有几种可调用的对象：函数、函数指针、lambda 表达式、bind 创建的对象以及重载了函数调用运算符的类 这些不同类型的可调用对象可能共享一种调用形式，调用形式指明了返回类型以及实参类型，下面是个例子： //普通函数 int add(int i, int j) { return i + j; } //lambda 表达式 auto mod = [](int i, int j) { return i % j; } //函数对象类 struct divide { int operator()(int denominator, int divisor) { return denominator / divisor; } } 上面的几种可调用对象对参数执行了不同的算术运算，它们类型不相同，但是共享同一种调用形式 int(int, int) 我们如果用这些可调用对象构建一个简单的计算器，可以定义一个函数表用于储存这些可调用对象的指针。 可以通过 map 来实现，用运算符符号的string对象作为关键字，实现运算符函数作为值 //构建运算符到函数指针的映射关系，函数接受两个int，返回一个int mapbinops; //正确：add是一个指向正确类型的函数指针 binops.insert({\"+\", add}); //错误：mod不是一个函数指针 binops.insert({\"%\", mod}); 上面的问题在于 mod 是一个 lambda 表达式，与 binops 的值类型不匹配 标准库 function 类型标准库中一个新的类型 function 可以解决上述问题，下面是 function 定义的操作： function 是一个模板，创建一个具体 function 类型时需要指定 function 表示的对象的调用形式，如 function，这里声明了一个 function 类型，它可以接受两个 int，返回一个 int 类型的可调用对象 functionf1 = add; //函数指针 functionf1 = divide();//函数对象类的对象 functionf1 = [](int i, int j) //lambda { return i * j; }; cout binops = { {\"+\", add}, //函数指针 {\"-\", std::minus()}, //标准库定义函数对象 {\"/\", divide()}, //用户定义函数对象 {\"*\", [](int i, int j) { return i * j; }},//未命名lambda表达式 {\"%\", mod} //命名的lambda } map 包含5 个元素，虽然可调用对象类型各不相同，但是仍可以存储在同一个 function类型中，这时可以通过索引 map 得到function 对象的引用 binops[\"+\"](10, 5);//add(10, 5); binops[\"-\"](10, 5);//minus(10, 5) binops[\"/\"](10, 5);//divide对象调用运算符 binops[\"*\"](10, 5);//调用lambda函数对象 binops[\"%\"](10, 5);//调用lambda函数对象 重载的函数与 function我们变不能将重载函数名字存入 function 类型的对象中： int add(int i, int j); Sales_data add(const Sales_data\u0026, const Sales_data\u0026); map binops; binops.insert({\"+\", add}); //错误：哪个add？ 解决上述二义性问题，可以通过一个函数指针，以及 lambda 表达式进行区分 int (*fp)(int, int) = add; binops.insert({\"+\", fp});//正确：fp指向一个正确的add版本 //正确：使用lambda来指定我们希望使用的add版本 binops.insert({\"+\", [](int a, int b) {return add(a, b);}}); ","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:8:3","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#重载的函数与-function"},{"categories":["C++"],"content":"14.9 重载、类型转换和运算符","date":"2022-04-25","objectID":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:9:0","series":null,"tags":["C++"],"title":"《C++Primer》| 第十四章 重载运算与类型转换","uri":"/chapter14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#149-重载类型转换和运算符"},{"categories":[],"content":"博客搭建初衷半路转行选手，大学走了很多弯路，兜兜转转最后还是选择计算机，目前软工方向研究生在读，目标是中大厂后端开发，现在仍处于入门阶段，基础知识较为薄弱。 搭建这个博客初衷是为了记录自己学习过程中的笔记，我并不是那种特别善于总结的人，很多内容可能也表述不够清楚，但是我觉得如果学习过程中没有记录相关的笔记，尤其是计算机相关课程，时间一久很容易就忘记之前学过的内容，记录笔记的过程亦是一种思考的过程。 ","date":"2022-04-19","objectID":"/about/:0:1","series":null,"tags":[],"title":"关于我","uri":"/about/#博客搭建初衷"},{"categories":[],"content":"这是一条树洞测试 ","date":"2022-04-19","objectID":"/life/%E6%9D%82%E8%AE%B0/:0:0","series":null,"tags":[],"title":"树洞测试","uri":"/life/%E6%9D%82%E8%AE%B0/#"}]